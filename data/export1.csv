"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"Is an Athletic Approach the Future of Software Engineering Education?","E. Hill; P. M. Johnson; D. Port",Drew University; University of Hawaii at Manoa; University of Hawaii at Manoa,"IEEE Software","29 Dec 2015","2016","33","1","97","100","Traditional software engineering education approaches--in-class lectures, unsupervised homework assignments, and occasional projects--create many opportunities for distraction. To address this problem, the authors have employed an approach that treats software engineering education more like athletic training.","1937-4194","","10.1109/MS.2016.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367991","software engineering education;athletic software engineering;education;software development;unit testing;software engineering","Software engineering;Programming profession;Training;Computer science education;Software development","computer science education;educational institutions;software engineering;training","software engineering education;in-class lectures;unsupervised homework assignments;occasional projects;athletic training","","5","","1","","29 Dec 2015","","","IEEE","IEEE Magazines"
"What Do We Know about Knowledge Management? Practical Implications for Software Engineering","T. Dingsøyr; F. O. Bjørnson; F. Shull",SINTEF Information and Communication Technology; SINTEF Fisheries and Aquaculture; Fraunhofer Center for Experimental Software Engineering,"IEEE Software","17 Apr 2009","2009","26","3","100","103","There have been many claims about knowledge management's benefits in software engineering, such as decreased time and cost for development, increased quality, and better decision-making abilities. Although we can find some success stories illustrating these claims, particularly on aspects related to the systems and engineering schools, more research is necessary to explore the intersection between each school and the software engineering field. Researchers should continue to emphasize the need for a broad focus across multiple KM schools to suceed in improving KM's practical application in software engineering.","1937-4194","","10.1109/MS.2009.82","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814968","software engineering;knowledge management;learning software organization;software process improvement;systematic review","Knowledge management;Software engineering;Educational institutions;Systems engineering and theory;Knowledge engineering;Guidelines;Software development management;Programming;Social network services;Space technology","knowledge management;software engineering","knowledge management;software engineering;decision making;software development","","28","","7","","17 Apr 2009","","","IEEE","IEEE Magazines"
"Global Software Engineering: An Industry Perspective","C. Ebert; M. Kuhrmann; R. Prikladnicki",Vector Consulting Services; University of Southern Denmark; Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS),"IEEE Software","29 Dec 2015","2016","33","1","105","108","Professional software products and IT systems and services today are developed mostly by globally distributed teams, projects, and companies. This issue's column summarizes experiences and guidance from industry to facilitate knowledge and technology transfer. It's based on industry feedback from the annual IEEE International Conference on Global Software Engineering.","1937-4194","","10.1109/MS.2016.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367984","global software engineering;agile software development;agile;outsourcing;IEEE International Conference on Global Software Engineering;ICGSE;software engineering;software development","Software engineering;Industries;Globalization;Outsourcing;Software development","software engineering;software houses;technology transfer","global software engineering;industry perspective;professional software products;IT systems;IT services;globally distributed teams;technology transfer","","11","","7","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Advancing Software Engineering Professional Education","M. Ardis; P. Bourque; T. Hilburn; K. Lasfer; S. Lucero; J. McDonald; A. Pyster; M. Shaw",Stevens Institute of Technology; École de Technologie Supérieure; Embry-Riddle Aeronautical University; Stevens Institute of Technology; US Department of Defense; Monmouth University; Stevens Institute of Technology; Carnegie Mellon University,"IEEE Software","23 Jun 2011","2011","28","4","58","63","The paper mentions that a reference curriculum for master's programs helps ensure software engineers possess the appropriate skills, knowledge, and experience to develop, maintain, and acquire complex systems.","1937-4194","","10.1109/MS.2010.133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5590235","software engineering;computer and information science education;graduate programs;curriculum architecture;core body of knowledge;SWEBOK","Software engineering;Computer science education;Engineering education;Engineering profession;Career development","computer science education;software engineering","software engineering professional education;masters program;software engineering skill;software engineering knowledge;software engineering experience;complex systems development;complex systems maintenance;complex systems acquisition","","11","","15","","30 Sep 2010","","","IEEE","IEEE Magazines"
"Improving the State of Automotive Software Engineering","A. Haghighatkhah; M. Oivo; A. Banijamali; P. Kuvaja",University of Oulu; University of Oulu; University of Oulu; University of Oulu,"IEEE Software","26 Sep 2017","2017","34","5","82","86","The automotive industry is fundamentally changing by becoming software intensive, rather than mechanically intensive. To stay ahead of the game, automakers must continuously improve their software engineering. For this article, the authors studied the existing literature on the subject and made practitioner-oriented recommendations.","1937-4194","","10.1109/MS.2017.3571571","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8050198","automotive software engineering;ASE;AUTOSAR;standards;testing;search-based testing;requirements engineering;model-based development;agile development;system integration;continuous integration;regression testing;software reliability growth models;SRGM;variability;software engineering;software development","Software;Automotive engineering;Industries;Testing;Tools;Software engineering;Biological system modeling","production engineering computing;software engineering","automotive software engineering;automotive industry;practitioner-oriented recommendations","","4","","18","","26 Sep 2017","","","IEEE","IEEE Magazines"
"Putting Human Aspects of Software Engineering in University Curricula","O. Hazzan",Technion–Israel Institute of Technology,"IEEE Software","14 Jun 2010","2010","27","4","90","91","Although people-related issues are central factors in determining the success of software projects, they do not receive sufficient attention in the software industry to improve project results. This essay describes two barriers to their getting more attention: barriers that originate in the academic status and positioning of software engineering. The essay also proposes several suggestions regarding the professional development of software practitioners.","1937-4194","","10.1109/MS.2010.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484115","human aspects of software engineering;software engineering education;computer science education;software projects;software industry;professional development of software engineers","Humans;Software engineering;Computer industry","computer science education;DP industry;software engineering","software engineering;university curricula;software projects;software industry","","3","","7","","14 Jun 2010","","","IEEE","IEEE Magazines"
"Where's the Theory for Software Engineering?","P. Johnson; M. Ekstedt; I. Jacobson",KTH Royal Institute of Technology; KTH Royal Institute of Technology; Peking University,"IEEE Software","21 Aug 2012","2012","29","5","96","96","Darwin's theory of natural selection, Maxwell's equations, the theory of demand and supply; almost all established academic disciplines place great emphasis on what their core theory is. This is not, however, the case in software engineering. What is the reason behind the software engineering community's apparent indifference to a concept that is so important to so many others?","1937-4194","","10.1109/MS.2012.127","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6276302","software engineering theory;theory;explanation;prediction;science;engineering","Software engineering;Predictive models","software engineering","software engineering theory;software engineering community","","17","","","","21 Aug 2012","","","IEEE","IEEE Magazines"
"Software Engineering for Spreadsheets","M. Erwig",Oregon State University,"IEEE Software","25 Aug 2009","2009","26","5","25","30","The idiosyncratic structure of spreadsheets allows the adaptation of proven software engineering principles to an end-user domain and thus makes software engineering accessible to many users.","1937-4194","","10.1109/MS.2009.140","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222790","spreadsheets;software engineering;type checking;debugging;spatial analysis","Software engineering;Labeling;Embedded software;Software tools;Embedded computing;Application software;Runtime","software engineering;spreadsheet programs","software engineering;spreadsheets;idiosyncratic structure;end-user domain","","20","","15","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Regress or Progress? Seeing Good Software Engineering Ideas Through","H. Erdogmus",Kalemun Research,"IEEE Software","25 Feb 2010","2010","27","2","4","7","In the last edition of From the Editor (""Deja Vu: The Life of Software Engineering Ideas,"" January/February 2010), I wrote about how modern software engineering ideas evolve. I represented an idea's maturation life cycle from conception to streaming in terms of nine states, interactions with the life cycle of other related ideas, and regressive loops that preempt an idea's normal progression and revert it to a previous state. In this edition, I discuss the levers that help prevent reversion, or at least premature reversion, and push a worthwhile idea forward toward the streamed state. These levers work only for good ideas, or those that have genuine merit, and before the idea reaches the streamed state. Once an idea reaches that point, we don't have much control; short attention spans are inevitably diverted elsewhere.","1937-4194","","10.1109/MS.2010.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420787","software engineering innovation;diffusion of software innovations;adoptability of software innovations","Software engineering","software engineering","software engineering;maturation software life cycle","","","","","","25 Feb 2010","","","IEEE","IEEE Magazines"
"Collaboration Tools for Global Software Engineering","F. Lanubile; C. Ebert; R. Prikladnicki; A. Vizcaíno",University of Bari; Vector Consulting Services; Pontifícia Universidade do Rio Grande do Sul; University of Castilla-La Mancha,"IEEE Software","25 Feb 2010","2010","27","2","52","55","Software engineering involves people collaborating to develop better software. Collaboration is challenging, especially across time zones and without face-to-face meetings. We therefore use collaboration tools all along the product life cycle to let us work together, stay together, and achieve results together. This article summarizes experiences and trends chosen from recent IEEE International Conference on Global Software Engineering (IGSCE) conferences.","1937-4194","","10.1109/MS.2010.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420797","software engineering;collaboration;global software development","Collaborative tools;Collaborative software;International collaboration;Software engineering;Collaborative work;Meetings","groupware;product life cycle management;software engineering","collaboration tools;global software engineering;product life cycle;IEEE international conference","","101","3","10","","25 Feb 2010","","","IEEE","IEEE Magazines"
"A Whisper of Evidence in Global Software Engineering","D. Èmite; C. Wohlin",NA; NA,"IEEE Software","23 Jun 2011","2011","28","4","15","18","A systematic review of global software engineering (GSE) literature from 2000 to 2007 shows the field to be immature. Studies report many challenges but little evidence regarding specific GSE practices directly related to project success or failure. There is evidence that distance matters and, furthermore, that GSE--although driven by cost-reduction goals--seldom brings immediate cost savings.","1937-4194","","10.1109/MS.2011.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929523","software engineering;systematic literature review","Software engineering;Globalization;Cost benefit analysis;Research initiatives","cost reduction;software engineering","global software engineering;GSE practices;cost-reduction goals;cost savings","","23","","10","","23 Jun 2011","","","IEEE","IEEE Magazines"
"Maturing Software Engineering Knowledge through Classifications: A Case Study on Unit Testing Techniques","S. Vegas; N. Juristo; V. R. Basili","Universidad Politecnica de Madrid, Madrid; Universidad Politecnica de Madrid, Madrid; University of Maryland, College Park and Fraunhofer Center for Experimental Software Engineering, Maryland","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","551","565","Classification makes a significant contribution to advancing knowledge in both science and engineering. It is a way of investigating the relationships between the objects to be classified and identifies gaps in knowledge. Classification in engineering also has a practical application; it supports object selection. They can help mature software engineering knowledge, as classifications constitute an organized structure of knowledge items. Till date, there have been few attempts at classifying in software engineering. In this research, we examine how useful classifications in software engineering are for advancing knowledge by trying to classify testing techniques. The paper presents a preliminary classification of a set of unit testing techniques. To obtain this classification, we enacted a generic process for developing useful software engineering classifications. The proposed classification has been proven useful for maturing knowledge about testing techniques, and therefore, SE, as it helps to: 1) provide a systematic description of the techniques, 2) understand testing techniques by studying the relationships among techniques (measured in terms of differences and similarities), 3) identify potentially useful techniques that do not yet exist by analyzing gaps in the classification, and 4) support practitioners in testing technique selection by matching technique characteristics to project characteristics.","1939-3520","","10.1109/TSE.2009.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4775907","Classification;software engineering;software testing;test design techniques;testing techniques;unit testing techniques.","Software engineering;Software testing;Diseases;Knowledge engineering;System testing;Chemical elements;Application software;Software design;Chemistry;Civil engineering","program testing;software engineering","software engineering knowledge;unit testing techniques;engineering classification;matching technique characteristic;project characteristic;software testing","","29","","31","","6 Feb 2009","","","IEEE","IEEE Journals"
"Toward Evidence-Based Software Engineering: Lessons Learned in Healthcare Application Development","A. Nowak; H. J. Schünemann",Evidence Prime; McMaster University,"IEEE Software","22 Sep 2017","2017","34","5","67","71","The authors look back at their journey of implementing, rolling out, and evolving a collaboration tool to support evidence-based healthcare and reflect on how software engineers could benefit from similar methods.","1937-4194","","10.1109/MS.2017.3571572","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048641","architectural decisions;evidence;guidelines;healthcare;web application development;GRADEpro Guideline Development Tool;GRADEpro GDT;software development;software engineering","Medical services;Software engineering;Decision making;Guidelines;Stakeholders;Collaboration","health care;software engineering","software engineering;healthcare application development","","","","15","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Investigating Country Differences in Mobile App User Behavior and Challenges for Software Engineering","S. L. Lim; P. J. Bentley; N. Kanakam; F. Ishikawa; S. Honiden","Department of Computer Science, University College, London; Department of Computer Science, University College London; Department of Clinical, Education and Health Psychology, University College, London; Digital Content and Media Sciences Research Division, National Institute of Informatics, Japan; National Institute of Informatics, Japan","IEEE Transactions on Software Engineering","7 Jan 2015","2015","41","1","40","64","Mobile applications (apps) are software developed for use on mobile devices and made available through app stores. App stores are highly competitive markets where developers need to cater to a large number of users spanning multiple countries. This work hypothesizes that there exist country differences in mobile app user behavior and conducts one of the largest surveys to date of app users across the world, in order to identify the precise nature of those differences. The survey investigated user adoption of the app store concept, app needs, and rationale for selecting or abandoning an app. We collected data from more than 15 countries, including USA, China, Japan, Germany, France, Brazil, United Kingdom, Italy, Russia, India, Canada, Spain, Australia, Mexico, and South Korea. Analysis of data provided by 4,824 participants showed significant differences in app user behaviors across countries, for example users from USA are more likely to download medical apps, users from the United Kingdom and Canada are more likely to be influenced by price, users from Japan and Australia are less likely to rate apps. Analysis of the results revealed new challenges to market-driven software engineering related to packaging requirements, feature space, quality expectations, app store dependency, price sensitivity, and ecosystem effect.","1939-3520","","10.1109/TSE.2014.2360674","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6913003","Requirements/specifications;market-driven software engineering;mobile application development;user requirements;survey research;app user behavior;software product lines;software ecosystems;Requirements/specifications;market-driven software engineering;mobile application development;user requirements;survey research;app user behavior;software product lines;software ecosystems","Mobile communication;Software;Smart phones;Software engineering;Data mining;Educational institutions","consumer behaviour;mobile computing;smart phones;software engineering","market-driven software engineering;medical applications;data analysis;South Korea;South;Mexico;Australia;Spain;Canada;India;Russia;Italy;United Kingdom;Brazil;France;Germany;Japan;China;USA;applications stores;mobile devices;user behavior;mobile application","","79","","65","","29 Sep 2014","","","IEEE","IEEE Journals"
"Master's Degrees in Software Engineering: An Analysis of 28 University Programs","A. Pyster; R. Turner; D. Henry; K. Lasfer; L. Bernstein",Stevens Institute of Technology; Stevens Institute of Technology; Stevens Institute of Technology; Stevens Institute of Technology; Stevens Institute of Technology,"IEEE Software","25 Aug 2009","2009","26","5","94","101","The software engineering institute published the last reference curriculum for a master's in software engineering in 1991. In 2007, a coalition from academia, industry, and government began creating a new reference curriculum. An early step was to establish a baseline of graduate education by surveying 28 master's programs in software engineering. The survey was largely limited to US schools. Key findings showed that the universities viewed software engineering largely as a specialization of computer science, that faculty size is generally small with few dedicated professors, and that new master's programs continue to start despite the decrease in computer science majors over the past few years. We used the IEEE Computer Society's Software Engineering Body of Knowledge (SWEBOK) to structure our analysis of the 28 curricula, focusing primarily on courses and topics required or semirequired of all students. (A course is semirequired if there is at least a 50 percent chance a student must take it.) Major findings show wide variation in the depth and breadth of SWEBOK coverage in required and semirequired courses, less than 40 percent of all programs requiring an introductory course on software engineering, and many universities having required and semirequired courses that are peripheral to SWEBOK.","1937-4194","","10.1109/MS.2009.133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222804","software engineering;curriculum;Software Engineering Body of Knowledge;SWEBOK;computer science education","Software engineering;Taxonomy;Computer science;Aerospace engineering;Automotive engineering;Systems engineering and theory;Educational institutions;Educational programs;Radio access networks;Collaboration","computer science education;educational courses;software engineering","master degree;software engineering;university program;graduate education;computer science specialization;educational course","","11","","8","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Cost Savings in Global Software Engineering: Where's the Evidence?","D. Smite; F. Calefato; C. Wohlin",Blekinge Institute of Technology; University of Bari; Blekinge Institute of Technology,"IEEE Software","30 Jun 2015","2015","32","4","26","32","Researchers examined published studies of global software engineering to determine whether offshoring actually yielded cost savings. Not enough evidence existed to reach the verdict that offshoring reduced costs.","1937-4194","","10.1109/MS.2015.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140692","global software engineering;software engineering;offshoring;outsourcing;evidence profile","Software engineering;Outsourcing;Globalization;Economics;Employment","outsourcing;software cost estimation","global software engineering;software offshoring;cost saving;cost reduction","","9","","19","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Group Awareness in Global Software Engineering","F. Lanubile; F. Calefato; C. Ebert",University of Bari; University of Bari; Vector Consulting Services,"IEEE Software","25 Feb 2013","2013","30","2","18","23","Insufficient team collaboration often challenges global software engineering projects. Group awareness can improve teams' trust, relationships, and efficiency. This article surveys the key technologies and tools that support group awareness and collaboration. The insights on technologies derive from discussions and presentations at related conferences, including the IEEE-sponsored International Conference on Global Software Engineering (ICGSE).","1937-4194","","10.1109/MS.2013.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6470588","global software;group awareness;software engineering;collaboration;teams","Software engineering;Globalization;Visualization;Licenses;Collaboration;Ports (Computers);Software development","project management;software management;team working","group awareness;global software engineering projects;insufficient team collaboration;group collaboration;IEEE-sponsored International Conference on Global Software Engineering;ICGSE","","14","","5","","25 Feb 2013","","","IEEE","IEEE Magazines"
"To Game or Not to Game?","C. G. von Wangenheim; F. Shull","Universidade do Vale do Itajaí; Fraunhofer Center for Experimental Software Engineering, Maryland","IEEE Software","24 Feb 2009","2009","26","2","92","94","One challenge in software engineering education is to give students sufficient hands-on experience in actually building software. This is necessary so that students can understand which practices and techniques are useful in various situations. Some researchers have advocated alternative teaching methods to help in this regard. If successful, such methods could give students some experience with different approaches' effects in a shorter, more constrained time period. We examine one such approach, game-based learning, here.","1937-4194","","10.1109/MS.2009.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786960","Software engineering education;game-based learning;software management;software simulation","Project management;Computational modeling;Computer simulation;Engineering education;Software engineering;Computer science education;Software libraries;Databases;Search methods;World Wide Web","computer aided instruction;computer games;software engineering;teaching","software engineering education;hands-on experience;alternative teaching methods;game-based learning","","52","","7","","24 Feb 2009","","","IEEE","IEEE Magazines"
"The Role of Ethnographic Studies in Empirical Software Engineering","H. Sharp; Y. Dittrich; C. R. B. de Souza","Open University, Walton Hall, Milton Keynes, UK; Software and Systems Section, IT University of Copenhagen, Rued Langgaards Vej 7, Copenhagen S, Denmark; Vale Institute of Technology and the Federal University of Pará, Tv. Boaventura da Silva, 955, Belém, PA, Brazil","IEEE Transactions on Software Engineering","11 Aug 2016","2016","42","8","786","804","Ethnography is a qualitative research method used to study people and cultures. It is largely adopted in disciplines outside software engineering, including different areas of computer science. Ethnography can provide an in-depth understanding of the socio-technological realities surrounding everyday software development practice, i.e., it can help to uncover not only what practitioners do, but also why they do it. Despite its potential, ethnography has not been widely adopted by empirical software engineering researchers, and receives little attention in the related literature. The main goal of this paper is to explain how empirical software engineering researchers would benefit from adopting ethnography. This is achieved by explicating four roles that ethnography can play in furthering the goals of empirical software engineering: to strengthen investigations into the social and human aspects of software engineering; to inform the design of software engineering tools; to improve method and process development; and to inform research programmes. This article introduces ethnography, explains its origin, context, strengths and weaknesses, and presents a set of dimensions that position ethnography as a useful and usable approach to empirical software engineering research. Throughout the paper, relevant examples of ethnographic studies of software practice are used to illustrate the points being made.","1939-3520","","10.1109/TSE.2016.2519887","CNPq; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7387744","Design tools and techniques;human factors in software design;software engineering process;computer-supported collaborative work","Software engineering;Software;Context;Sociology;Electronic mail;Computer science;Guidelines","cultural aspects;human factors;software process improvement","sociotechnological realities;software development practice;ethnography;empirical software engineering;human aspects;social aspects;software process development;software engineering tools","","30","","135","","20 Jan 2016","","","IEEE","IEEE Journals"
"Is the New Software Engineering Curriculum Agile?","A. Fox; D. Patterson","University of California, Berkeley; University of California, Berkeley","IEEE Software","3 Sep 2013","2013","30","5","88","88","As the last standardization effort was done in 2004, the software engineering curriculum is currently being revised. Haven't we reached the point where agile development should be part of all software engineering curricula? And if so, shouldn't new curriculum standards ensure that it is? Thus, the answer to the question in the title of this article can be affirmative even if the computer science standards committee is absent-minded. Instructors can follow the initial call of the standard for projects by student teams while using an agile process, which is the most natural match. As long as you review both plan-and-document and agile processes in lecture, students can become familiar with both sets of terms and concepts. The more demanding outcomes can be met by the project as well, provided you look to the deeper meaning behind the plan-and-document terms to see where agile can fit.","1937-4194","","10.1109/MS.2013.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6588520","agile;curriculum;ACM-IEEE Computer Society;software engineering","Computer science education;Software engineering;Education courses;Software systems","computer science education;educational courses;software prototyping","software engineering curriculum;standardization;agile development;curriculum standards;computer science standards committee;student teams;agile process;plan-and-document process","","1","","11","","3 Sep 2013","","","IEEE","IEEE Magazines"
"Practices and Technologies in Computer Game Software Engineering","W. Scacchi","University of California, Irvine","IEEE Software","16 Jan 2017","2017","34","1","110","116","Computer games are rich, complex, and often large-scale software applications. They're a significant, interesting, and often compelling domain for innovative research in software engineering techniques and technologies. Computer games are progressively changing the everyday world in many positive ways. Game developers, whether focusing on entertainment market opportunities or game-based applications in nonentertainment domains such as education, healthcare, defense, or scientific research (that is, serious games), thus share a common interest in how best to engineer game software. This article examines techniques and technologies that inform contemporary computer game software engineering.","1937-4194","","10.1109/MS.2017.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819395","computer games;software engineering;software development;software engineering education;game development;game platforms;game engines;software architecture;gameplay;playtesting;software reuse;requirements engineering;runtime services;scalability","Games;Software development;Software engineering;Engines;Computer architecture;Runtime;Requirements engineering","computer games;software engineering","large-scale software applications;entertainment market opportunities;game-based applications;nonentertainment domains;computer game SE;serious games;computer game software engineering","","5","","7","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Crossover Designs in Software Engineering Experiments: Benefits and Perils","S. Vegas; C. Apa; N. Juristo","Escuela Técnica Superior de Ingenieros Informáticos, Universidad Politécnica de Madrid, Boadilla del Monte, Madrid, Spain; Instituto de Computación, Facultad de Ingeniería, Montevideo, Uruguay; Escuela Técnica Superior de Ingenieros Informáticos, Universidad Politécnica de Madrid, Boadilla del Monte, Madrid, Spain","IEEE Transactions on Software Engineering","11 Feb 2016","2016","42","2","120","135","In experiments with crossover design subjects apply more than one treatment. Crossover designs are widespread in software engineering experimentation: they require fewer subjects and control the variability among subjects. However, some researchers disapprove of crossover designs. The main criticisms are: the carryover threat and its troublesome analysis. Carryover is the persistence of the effect of one treatment when another treatment is applied later. It may invalidate the results of an experiment. Additionally, crossover designs are often not properly designed and/or analysed, limiting the validity of the results. In this paper, we aim to make SE researchers aware of the perils of crossover experiments and provide risk avoidance good practices. We study how another discipline (medicine) runs crossover experiments. We review the SE literature and discuss which good practices tend not to be adhered to, giving advice on how they should be applied in SE experiments. We illustrate the concepts discussed analysing a crossover experiment that we have run. We conclude that crossover experiments can yield valid results, provided they are properly designed and analysed, and that, if correctly addressed, carryover is no worse than other validity threats.","1939-3520","","10.1109/TSE.2015.2467378","Spanish Ministry of Economy and Competitiveness research; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7192651","Data analysis;crossover designs;carryover;Experimental software engineering;controlled experiment;data analysis;crossover design;carryover","Software engineering;Animals;Atmospheric measurements;Particle measurements;Psychology;US Government agencies;Information processing","software engineering","crossover design;software engineering experiments;SE research;crossover experiment","","29","","38","","12 Aug 2015","","","IEEE","IEEE Journals"
"Preparing Tomorrow's Software Engineers for Work in a Global Environment","S. Beecham; T. Clear; J. Barr; M. Daniels; M. Oudshoorn; J. Noll",Lero; Auckland University of Technology; Ithaca College; Uppsala University; Northwest Missouri State University; University of East London,"IEEE Software","16 Jan 2017","2017","34","1","9","12","Global software engineering (GSE) is becoming common. It's thus important to educate university software engineering students in GSE. The authors discuss challenges to and recommendations for implementing such instruction.","1937-4194","","10.1109/MS.2017.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819397","global software engineering;GSE;distributed projects;global distance;Valentine's taxonomy;software engineering;software development","Education courses;Software engineering;Teamwork;Cultural differences;Computer science education;Professional development;Globalization","computer science education;educational institutions;software engineering","global software engineering;university software engineering students;GSE","","17","","5","","16 Jan 2017","","","IEEE","IEEE Magazines"
"GALE: Geometric Active Learning for Search-Based Software Engineering","J. Krall; T. Menzies; M. Davies","LoadIQ, NV; Computer ScienceNorth Carolina State University; Intelligent Systems Division, NASA Ames Research Center, CA","IEEE Transactions on Software Engineering","13 Oct 2015","2015","41","10","1001","1018","Multi-objective evolutionary algorithms (MOEAs) help software engineers find novel solutions to complex problems. When automatic tools explore too many options, they are slow to use and hard to comprehend. GALE is a near-linear time MOEA that builds a piecewise approximation to the surface of best solutions along the Pareto frontier. For each piece, GALE mutates solutions towards the better end. In numerous case studies, GALE finds comparable solutions to standard methods (NSGA-II, SPEA2) using far fewer evaluations (e.g. 20 evaluations, not 1,000). GALE is recommended when a model is expensive to evaluate, or when some audience needs to browse and understand how an MOEA has made its conclusions.","1939-3520","","10.1109/TSE.2015.2432024","US National Science Foundation (NSF); Qatar/West Virginia University; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7105950","Multi-objective optimization;search based software engineering;active learning;Multi-objective optimization;search based software engineering;active learning","Optimization;Software;Computational modeling;Approximation methods;Standards;Biological system modeling;Sociology","approximation theory;computational complexity;evolutionary computation;learning (artificial intelligence);Pareto optimisation;software engineering","GALE;geometric active learning;search-based software engineering;multiobjective evolutionary algorithm;near-linear time MOEA;piecewise approximation;Pareto frontier","","23","","64","","12 May 2015","","","IEEE","IEEE Journals"
"Supporting Reflective Practice in Software Engineering Education through a Studio-Based Approach","C. N. Bull; J. Whittle",Lancaster University; Lancaster University,"IEEE Software","13 Jun 2014","2014","31","4","44","50","Learning is a lifelong process, especially in the fast-paced software industry. In addition to formal training courses, good software developers continually learn by reflecting on what they've done in the past. However, reflective practice is rarely taught explicitly in university software engineering education. One way to teach reflective techniques from the start is through studio-based learning.","1937-4194","","10.1109/MS.2014.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774769","software studio;studio;atelier;software engineering education;collaboration;collocation;reflective practice;software engineering;pervasive computing;project management","Learning;Software engineering;Computer science education;Reflection;Computer architecture","computer science education;DP industry;educational courses;educational institutions;further education;software engineering","university software engineering education;studio-based learning;software industry;reflective practice","","20","","10","","18 Mar 2014","","","IEEE","IEEE Magazines"
"Model-Based Software Engineering to Tame the IoT Jungle","B. Morin; N. Harrand; F. Fleurey",SINTEF Information and Communication Technology; SINTEF Information and Communication Technology; SINTEF Information and Communication Technology,"IEEE Software","16 Jan 2017","2017","34","1","30","36","The Internet of Things (IoT) is a challenging combination of distribution and heterogeneity. A number of software engineering solutions address those challenges in isolation, but few solutions tackle them in combination, which poses a set of concrete challenges. The ThingML (Internet of Things Modeling Language) approach attempts to address those challenges. This model-driven, generative approach, which was inspired by UML, integrates concepts targeted at the IoT. Over the past six years, it has been continuously evolved and applied to cases in different domains, including a commercial e-health solution.","1937-4194","","10.1109/MS.2017.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819419","model-driven software engineering;Internet of Things;IoT;e-health;eHealth;ThingML;Tellu;software engineering;software development","Internet of things;Software engineering;Modeling;Computer languages","Internet of Things;software engineering;Unified Modeling Language","model-based software engineering;IoT;ThingML;UML;model-driven generative approach;e-health solution;Internet of Things Modeling Language","","28","","11","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Technologies to Support Collaboration across Time Zones","R. Prikladnicki; S. Marczak; E. Carmel; C. Ebert",Pontifícia Universidade do Rio Grande do Sul; Pontifícia Universidade Católica do Rio Grande do Sul; American University; Vector Consulting Services,"IEEE Software","20 Apr 2012","2012","29","3","10","13","Time zone differences are a challenge to global software engineering. This column surveys the key technologies and tools that support collaboration across time zones. The insights on technologies derive from a meta- analysis of the 2010 and 2011 IEEE International Conference on Global Software Engineering (ICGSE), among others.","1937-4194","","10.1109/MS.2012.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188595","software;technology;global;time zones;distributed software development;global software engineering;international conference on global software engineering;icgse","Collaboration;Synchronization;Software;Software engineering;Programming;Conferences;Educational institutions","software engineering","time zone differences;software engineering;meta analysis","","7","","4","","20 Apr 2012","","","IEEE","IEEE Magazines"
"Variability in Software Systems—A Systematic Literature Review","M. Galster; D. Weyns; D. Tofan; B. Michalik; P. Avgeriou","Department of Computer Science and Software Engineering, University of Canterbury, Private Bag 4800, Christchurch, New Zealand; Department of Computer Science, Linnaeus University, Växjö, Sweden; Department of Mathematics and Computing Science, University of Groningen, Groningen 9700 AK, The Netherlands; Amartus, Poland; Department of Mathematics and Computing Science, University of Groningen, Groningen 9700 AK, The Netherlands","IEEE Transactions on Software Engineering","31 Mar 2014","2014","40","3","282","306","Context: Variability (i.e., the ability of software systems or artifacts to be adjusted for different contexts) became a key property of many systems. Objective: We analyze existing research on variability in software systems. We investigate variability handling in major software engineering phases (e.g., requirements engineering, architecting). Method: We performed a systematic literature review. A manual search covered 13 premium software engineering journals and 18 premium conferences, resulting in 15,430 papers searched and 196 papers considered for analysis. To improve reliability and to increase reproducibility, we complemented the manual search with a targeted automated search. Results: Software quality attributes have not received much attention in the context of variability. Variability is studied in all software engineering phases, but testing is underrepresented. Data to motivate the applicability of current approaches are often insufficient; research designs are vaguely described. Conclusions: Based on our findings we propose dimensions of variability in software engineering. This empirically grounded classification provides a step towards a unifying, integrated perspective of variability in software systems, spanning across disparate or loosely coupled research themes in the software engineering community. Finally, we provide recommendations to bridge the gap between research and practice and point to opportunities for future research.","1939-3520","","10.1109/TSE.2013.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6682901","Variability;systematic review;software engineering","Decision support systems;Software systems;Systematics;Software engineering;Context;Manuals;Data collection","program testing;software product lines;software reliability;software reviews","software systems;variability handling;systematic literature review;manual search;software engineering journals;software reliability;reproducibility;targeted automated search;software engineering phase;software testing;software engineering community","","99","","60","","12 Dec 2013","","","IEEE","IEEE Journals"
"Software Components beyond Programming: From Routines to Services","I. Crnkovic; J. Stafford; C. Szyperski",Mälardalen University; Tufts University; Microsoft,"IEEE Software","25 Apr 2011","2011","28","3","22","26","Software engineering (SE) conference in 1968, Doug Mc Ilroy introduced the concept of software components during his keynote speech, ""Mass-Produced Software Components."" That components hold such an esteemed place in SE history should come as no surprise: componentization is a fundamental engineering principle. Top-down approaches decompose large systems into smaller parts-components and bottom-up approaches compose smaller parts components into larger systems. Since 1968, components have played a role in both SE research and practice. For example, components have been an immanent part of software architecture from its early days.2 In 1998, the In ternational Conference on Software Engineering introduced component based software engineering (CBSE) as a specific area within SE at the first workshop on CBSE.","1937-4194","","10.1109/MS.2011.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5756294","software component;component-based software;engineering","Software architecture;Object oriented modeling;Unified modeling language;Software engineering","object-oriented programming;software engineering","software engineering;mass produced software components;SE;top-down approaches;bottom-up approaches;software architecture;component based software engineering;CBSE","","35","","2","","25 Apr 2011","","","IEEE","IEEE Magazines"
"Katie Malone on Machine Learning","E. Salinas",Microsoft Research,"IEEE Software","11 Jul 2017","2017","34","4","92","96","Host Edaena Salinas talks with Civis Analytics' Katie Malone about the basics of machine learning and why we'll be seeing it much more frequently. The Web extra at http://www.se-radio.net/2017/03/se-radio-episode-286-katie-malone-intro-to-machine-learning/ is an audio recording of this episode of Software Engineering Radio.","1937-4194","","10.1109/MS.2017.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974684","Katie Malone;software engineering;machine learning;supervised machine learning;unsupervised machine learning;data analysis;SE Radio;Software Engineering Radio;software development","Motion pictures;Machine learning;Software engineering;Measurement;Artificial intelligence;Classification algorithms","learning (artificial intelligence);software engineering","machine learning;software engineering radio","","","","","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Trends in the Quality of Human-Centric Software Engineering Experiments--A Quasi-Experiment","B. Kitchenham; D. I. K. Sjøberg; T. Dybå; O. P. Brereton; D. Budgen; M. Höst; P. Runeson","Keele University, Keele; University of Oslo, Oslo; University of Oslo, Oslo and SINTEF, Trondheim; Keele University, Keele; Durham University, Durham; Lund University, Lund; Lund University, Lund","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","1002","1017","Context: Several text books and papers published between 2000 and 2002 have attempted to introduce experimental design and statistical methods to software engineers undertaking empirical studies. Objective: This paper investigates whether there has been an increase in the quality of human-centric experimental and quasi-experimental journal papers over the time period 1993 to 2010. Method: Seventy experimental and quasi-experimental papers published in four general software engineering journals in the years 1992-2002 and 2006-2010 were each assessed for quality by three empirical software engineering researchers using two quality assessment methods (a questionnaire-based method and a subjective overall assessment). Regression analysis was used to assess the relationship between paper quality and the year of publication, publication date group (before 2003 and after 2005), source journal, average coauthor experience, citation of statistical text books and papers, and paper length. The results were validated both by removing papers for which the quality score appeared unreliable and using an alternative quality measure. Results: Paper quality was significantly associated with year, citing general statistical texts, and paper length (p <; 0.05). Paper length did not reach significance when quality was measured using an overall subjective assessment. Conclusions: The quality of experimental and quasi-experimental software engineering papers appears to have improved gradually since 1993.","1939-3520","","10.1109/TSE.2012.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6374196","Quality evaluation;empirical studies;human-centric experiments;experimentation;software engineering","Software engineering;Guidelines;Correlation;Manuals;Educational institutions;Humans;Materials","citation analysis;design of experiments;publishing;regression analysis;software quality;text analysis","human-centric software engineering experiments;experimental design;statistical methods;human-centric experimental journal papers;quasi-experimental journal papers;quality assessment methods;questionnaire-based method;subjective overall assessment;regression analysis;paper quality;publication year;publication date group;source journal;average coauthor experience;statistical text books citation;statistical papers citation;paper length","","10","","28","","4 Dec 2012","","","IEEE","IEEE Journals"
"iTree: Efficiently Discovering High-Coverage Configurations Using Interaction Trees","C. Song; A. Porter; J. S. Foster","Fraunhofer USA Center for Experimental Software Engineering, 5825 University Research Court, Suite 1300, College Park; Department of Computer Science, University of Maryland, A.V. Williams Building, College Park; Department of Computer Science, University of Maryland, A.V. Williams Building, College Park","IEEE Transactions on Software Engineering","31 Mar 2014","2014","40","3","251","265","Modern software systems are increasingly configurable. While this has many benefits, it also makes some software engineering tasks,such as software testing, much harder. This is because, in theory,unique errors could be hiding in any configuration, and, therefore,every configuration may need to undergo expensive testing. As this is generally infeasible, developers need cost-effective technique for selecting which specific configurations they will test. One popular selection approach is combinatorial interaction testing (CIT), where the developer selects a strength t and then computes a covering array (a set of configurations) in which all t-way combinations of configuration option settings appear at least once. In prior work, we demonstrated several limitations of the CIT approach. In particular, we found that a given system's effective configuration space - the minimal set of configurations needed to achieve a specific goal - could comprise only a tiny subset of the system's full configuration space. We also found that effective configuration space may not be well approximated by t-way covering arrays. Based on these insights we have developed an algorithm called interaction tree discovery (iTree). iTree is an iterative learning algorithm that efficiently searches for a small set of configurations that closely approximates a system's effective configuration space. On each iteration iTree tests the system on a small sample of carefully chosen configurations, monitors the system's behaviors, and then applies machine learning techniques to discover which combinations of option settings are potentially responsible for any newly observed behaviors. This information is used in the next iteration to pick a new sample of configurations that are likely to reveal further new behaviors. In prior work, we presented an initial version of iTree and performed an initial evaluation with promising results. This paper presents an improved iTree algorithm in greater detail. The key improvements are based on our use of composite proto-interactions - a construct that improves iTree's ability to correctly learn key configuration option combinations, which in turn significantly improves iTree's running time, without sacrificing effectiveness. Finally, the paper presents a detailed evaluation of the improved iTree algorithm by comparing the coverage it achieves versus that of covering arrays and randomly generated configuration sets, including a significantly expanded scalability evaluation with the ~ 1M-LOC MySQL. Our results strongly suggest that the improved iTree algorithm is highly scalable and can identify a high-coverage test set of configurations more effectively than existing methods.","1939-3520","","10.1109/TSE.2013.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6671585","Empirical software engineering;software configurations;software testing and analysis","Testing;Arrays;Software algorithms;Software engineering;Machine learning algorithms;Software systems;Algorithm design and analysis","iterative methods;learning (artificial intelligence);program testing;software engineering","iTree;efficiently discovering high-coverage configurations;interaction trees;software systems;software engineering;software testing;cost-effective technique;combinatorial interaction testing;CIT;interaction tree discovery;iterative learning algorithm;machine learning techniques;iTree algorithm","","11","","39","","20 Nov 2013","","","IEEE","IEEE Journals"
"Speed, Data, and Ecosystems: The Future of Software Engineering","J. Bosch",Chalmers University of Technology,"IEEE Software","29 Dec 2015","2016","33","1","82","88","An evaluation of recent industrial and societal trends revealed three key factors driving software engineering's future: speed, data, and ecosystems. These factors' implications have led to guidelines for companies to evolve their software engineering practices. This article is part of a special issue on the Future of Software Engineering.","1937-4194","","10.1109/MS.2016.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368022","software;software development;software engineering","Software engineering;Market research;Ecosystems;Business;Technological innovation","software engineering","software engineering","","49","","15","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Reducing Friction in Software Development","P. Avgeriou; P. Kruchten; R. L. Nord; I. Ozkaya; C. Seaman","University of Groningen; University of British Columbia; Software Engineering Institute; Software Engineering Institute; University of Maryland, Baltimore County","IEEE Software","29 Dec 2015","2016","33","1","66","73","Software is being produced so fast that its growth hinders its sustainability. Technical debt, which encompasses internal software quality, evolution and maintenance, reengineering, and economics, is growing such that its management is becoming the dominant driver of software engineering progress. It spans the software engineering life cycle, and its management capitalizes on recent advances in fields such as source code analysis, quality measurement, and project management. Managing technical debt will become an investment activity applying economic theories. It will effectively address the architecture level and will offer specific processes and tools employing data science and analytics to support decision making. It will also be an essential part of the software engineering curriculum. Getting ahead of the software quality and innovation curve will inevitably involve establishing technical-debt management as a core software engineering practice. This article is part of a special issue on the Future of Software Engineering.","1937-4194","","10.1109/MS.2016.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367977","technical debt;software management;software economics;software quality;software engineering;software development;software architecture;maintenance and evolution;sustainability;education","Software development;Economics;Software engineering;Stakeholders;Sustainability;Maintenance engineering","data analysis;decision making;software maintenance;software quality","software reengineering;software maintenance;software evolution;innovation curve;decision making;data analysis;data science;economic theory;investment activity;software engineering life cycle;software engineering progress;internal software quality;software development","","20","","13","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Key Abstractions for IoT-Oriented Software Engineering","F. Zambonelli",University of Modena and Reggio Emilia,"IEEE Software","16 Jan 2017","2017","34","1","38","45","Despite the progress in Internet of Things (IoT) research, a general software engineering approach for systematic development of IoT systems and applications is still missing. A synthesis of the state of the art in the area can help frame the key abstractions related to such development. Such a framework could be the basis for guidelines for IoT-oriented software engineering.","1937-4194","","10.1109/MS.2017.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819396","software engineering;Internet of Things;IoT;software development","Software engineering;Internet of things;Research and development;Software development","Internet of Things;software engineering","IoT-oriented software engineering;key abstractions;Internet of Things;IoT systems","","25","","15","","16 Jan 2017","","","IEEE","IEEE Magazines"
"The “Physics” of Notations: Toward a Scientific Basis for Constructing Visual Notations in Software Engineering","D. Moody","University of Twente , Enschede","IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","756","779","Visual notations form an integral part of the language of software engineering (SE). Yet historically, SE researchers and notation designers have ignored or undervalued issues of visual representation. In evaluating and comparing notations, details of visual syntax are rarely discussed. In designing notations, the majority of effort is spent on semantics, with graphical conventions largely an afterthought. Typically, no design rationale, scientific or otherwise, is provided for visual representation choices. While SE has developed mature methods for evaluating and designing semantics, it lacks equivalent methods for visual syntax. This paper defines a set of principles for designing cognitively effective visual notations: ones that are optimized for human communication and problem solving. Together these form a design theory, called the Physics of Notations as it focuses on the physical (perceptual) properties of notations rather than their logical (semantic) properties. The principles were synthesized from theory and empirical evidence from a wide range of fields and rest on an explicit theory of how visual notations communicate. They can be used to evaluate, compare, and improve existing visual notations as well as to construct new ones. The paper identifies serious design flaws in some of the leading SE notations, together with practical suggestions for improving them. It also showcases some examples of visual notation design excellence from SE and other fields.","1939-3520","","10.1109/TSE.2009.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353439","Modeling;analysis;diagrams;communication;visualization;visual syntax;concrete syntax.","Software engineering;Humans;Visualization;Design optimization;Problem-solving;Physics;Concrete;Flowcharts;Unified modeling language;Computer industry","software engineering","visual notations;software engineering;visual representation;physics of notations;design flaws","","596","1","152","","15 Dec 2009","","","IEEE","IEEE Journals"
"The Ethical Software Engineer","D. Hall",University of Manchester,"IEEE Software","19 Jun 2009","2009","26","4","9","10","Compliance to a professional society's code of ethics carries obligations beyond minimum standards of behavior. Members of software engineering professional societies should also serve the public interest and promote the common good.","1937-4194","","10.1109/MS.2009.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076450","professional ethics;codes of ethics;codes of good practice;professional licensing;software engineering practice","Ethics;Software engineering;Software standards;Standards development;Programming;ISO;Knowledge engineering;Software development management;IEC standards;Career development","ethical aspects;software engineering","ethics;software engineering professional societies;ethical software engineer","","5","","4","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Exploring the Relationship between Software Process Adaptive Capability and Organisational Performance","P. Clarke; R. V. O’Connor; B. Leavy; M. Yilmaz","School of Computing, Dublin City University, Ireland, and Lero—The Irish Software Research Centre; School of Computing, Dublin City University, Ireland, and Lero—The Irish Software Research Centre; Dublin City University Business School, Ireland; Çanyaka University, Ankara, Turkey","IEEE Transactions on Software Engineering","8 Dec 2015","2015","41","12","1169","1183","Software development is a complex socio-technical activity, with the result that software development organisations need to establish and maintain robust software development processes. While much debate exists regarding the effectiveness of various software development approaches, no single approach is perfectly suited to all settings and no setting is unchanging. The capability to adapt the software process is therefore essential to sustaining an optimal software process. We designed an exploratory study to concurrently examine software process adaptive capability and organisational performance in 15 software development organisations, finding that companies with greater software process adaptive capability are shown to also experience greater business success. While our exploratory study of the complex relationship between these phenomena is limited in some respects, the findings indicate that software process adaptive capability may be worthy of further integration into software process engineering techniques. Software process adaptive capability may be an important organisational strength when deriving competitive advantage, and those responsible for the creation and evolution of software process models and methodologies may want to focus some of their future efforts in this area.","1939-3520","","10.1109/TSE.2015.2467388","Science Foundation Ireland; Irish Software Engineering Research Centre; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7214314","Software engineering;Software engineering process;Software development;Software management;Software engineering;software engineering process;software development;software management","Software engineering;Software development;ISO Standards;IEC Standards;Software management","software process improvement","software process adaptive capability;organisational performance;socio-technical activity;software development organisation;robust software development process;software development approach;optimal software process;software process engineering technique;organisational strength","","29","","97","","20 Aug 2015","","","IEEE","IEEE Journals"
"A Cooperative Parallel Search-Based Software Engineering Approach for Code-Smells Detection","W. Kessentini; M. Kessentini; H. Sahraoui; S. Bechikh; A. Ouni","Department of Computer Science, University of Montreal, Montreal, Quebec, Canada; Department of Computer Science, University of Michigan, Dearborn, MI; Department of Computer Science, University of Montreal, Montreal, Quebec, Canada; Department of Computer Science, University of Michigan, Dearborn, MI; Department of Computer Science, University of Michigan, Dearborn, MI","IEEE Transactions on Software Engineering","4 Sep 2014","2014","40","9","841","861","We propose in this paper to consider code-smells detection as a distributed optimization problem. The idea is that different methods are combined in parallel during the optimization process to find a consensus regarding the detection of code-smells. To this end, we used Parallel Evolutionary algorithms (P-EA) where many evolutionary algorithms with different adaptations (fitness functions, solution representations, and change operators) are executed, in a parallel cooperative manner, to solve a common goal which is the detection of code-smells. An empirical evaluation to compare the implementation of our cooperative P-EA approach with random search, two single population-based approaches and two code-smells detection techniques that are not based on meta-heuristics search. The statistical analysis of the obtained results provides evidence to support the claim that cooperative P-EA is more efficient and effective than state of the art detection approaches based on a benchmark of nine large open source systems where more than 85 percent of precision and recall scores are obtained on a variety of eight different types of code-smells.","1939-3520","","10.1109/TSE.2014.2331057","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6835187","Search-based software engineering;code-smells;software quality;distributed evolutionary algorithms","Measurement;Sociology;Statistics;Evolutionary computation;Detectors;Optimization;Computational modeling","evolutionary computation;public domain software;search problems;software engineering;statistical analysis","cooperative parallel search-based software engineering approach;code-smells detection;distributed optimization problem;optimization process;parallel evolutionary algorithms;P-EA approach;random search;single population-based approaches;statistical analysis;open source systems","","51","","57","","16 Jun 2014","","","IEEE","IEEE Journals"
"Evaluating Legal Implementation Readiness Decision-Making","A. K. Massey; P. N. Otto; A. I. Antón","Postdoctoral Fellow at the School of Interactive Computing, Georgia Institute of Technology, Atlanta, GA; Association of Computing Machinery, District of Columbia, 555 13th St. NW, Washington; Professor and Chair of the School of Interactive Computing, Georgia Institute of Technology, Atlanta, GA","IEEE Transactions on Software Engineering","10 Jun 2015","2015","41","6","545","564","Software systems are increasingly regulated. Software engineers therefore must determine which requirements have met or exceeded their legal obligations and which requirements have not. Requirements that have met or exceeded their legal obligations are legally implementation ready, whereas requirements that have not met or exceeded their legal obligations need further refinement. In this paper, we examine how software engineers make these determinations using a multi-case study with three cases. Each case involves assessment of requirements for an electronic health record system that must comply with the US Health Insurance Portability and Accountability Act (HIPAA) and is measured against the evaluations of HIPAA compliance subject matter experts. Our first case examines how individual graduate-level software engineering students assess whether the requirements met or exceeded their HIPAA obligations. Our second case replicates the findings from our first case using a different set of participants. Our third case examines how graduate-level software engineering students assess requirements using the Wideband Delphi approach to deriving consensus in groups. Our findings suggest that the average graduate-level software engineering student is ill-prepared to write legally compliant software with any confidence and that domain experts are an absolute necessity.","1939-3520","","10.1109/TSE.2014.2383374","NSF ITR; NSF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6991569","Legal Implementation Readiness;Regulatory Compliance Software Engineering;Legal Requirements;Requirements Engineering;Legal implementation readiness;regulatory compliance software engineering;legal requirements;requirements engineering","Law;Software;Software engineering;Atmospheric measurements;Particle measurements;Decision making","electronic health records;law;software engineering","legal implementation readiness decision-making;software systems;legal obligations;electronic health record system;US Health Insurance Portability and Accountability Act;HIPAA obligations;requirement assessment;wideband Delphi approach;legally compliant software","","7","","41","","18 Dec 2014","","","IEEE","IEEE Journals"
"How Reliable Are Systematic Reviews in Empirical Software Engineering?","S. MacDonell; M. Shepperd; B. Kitchenham; E. Mendes","Auckland University of Technology, Auckland; Brunel University, West London; Keele University, Keele; The University of Auckland, Auckland","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","676","687","BACKGROUND-The systematic review is becoming a more commonly employed research instrument in empirical software engineering. Before undue reliance is placed on the outcomes of such reviews it would seem useful to consider the robustness of the approach in this particular research context. OBJECTIVE-The aim of this study is to assess the reliability of systematic reviews as a research instrument. In particular, we wish to investigate the consistency of process and the stability of outcomes. METHOD-We compare the results of two independent reviews undertaken with a common research question. RESULTS-The two reviews find similar answers to the research question, although the means of arriving at those answers vary. CONCLUSIONS-In addressing a well-bounded research question, groups of researchers with similar domain experience can arrive at the same review outcomes, even though they may do so in different ways. This provides evidence that, in this context at least, the systematic review is a robust research method.","1939-3520","","10.1109/TSE.2010.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416726","Empirical software engineering;meta-analysis;systematic review;cost estimation.","Software engineering;Instruments;Robustness;Best practices;Stability;Costs;Mathematics;Computer science","software cost estimation;software reviews","systematic review reliability;empirical software engineering;research instrument;software cost estimation","","46","","26","","18 Feb 2010","","","IEEE","IEEE Journals"
"Variability and Reproducibility in Software Engineering: A Study of Four Companies that Developed the Same System","B. C. D. Anda; D. I. K. Sjøberg; A. Mockus","University of Oslo, Oslo; Simula Research Laboratory, Lysaker; Avaya Labs Research, Basking Ridge","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","407","429","The scientific study of a phenomenon requires it to be reproducible. Mature engineering industries are recognized by projects and products that are, to some extent, reproducible. Yet, reproducibility in software engineering (SE) has not been investigated thoroughly, despite the fact that lack of reproducibility has both practical and scientific consequences. We report a longitudinal multiple-case study of variations and reproducibility in software development, from bidding to deployment, on the basis of the same requirement specification. In a call for tender to 81 companies, 35 responded. Four of them developed the system independently. The firm price, planned schedule, and planned development process, had, respectively, ldquolow,rdquo ldquolow,rdquo and ldquomediumrdquo reproducibilities. The contractor's costs, actual lead time, and schedule overrun of the projects had, respectively, ldquomedium,rdquo ldquohigh,rdquo and ldquolowrdquo reproducibilities. The quality dimensions of the delivered products, reliability, usability, and maintainability had, respectively, ldquolow,rdquo ""high,rdquo and ldquolowrdquo reproducibilities. Moreover, variability for predictable reasons is also included in the notion of reproducibility. We found that the observed outcome of the four development projects matched our expectations, which were formulated partially on the basis of SE folklore. Nevertheless, achieving more reproducibility in SE remains a great challenge for SE research, education, and industry.","1939-3520","","10.1109/TSE.2008.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4693714","Software engineering life cycle;software quality;software project success;software process;multiple-case study.;General;Life cycle;Software Quality/SQA;Multiple-case study","Reproducibility of results;Software engineering;Programming;Job shop scheduling;Software quality;Computer industry;Costs;Software measurement;Systems engineering and theory;Usability","software quality","software engineering;mature engineering industries;software development;software quality;software process","","44","","94","","2 Dec 2008","","","IEEE","IEEE Journals"
"Software Engineering: An Idea Whose Time Has Come and Gone?","T. DeMarco",Atlantic Systems Guild,"IEEE Software","19 Jun 2009","2009","26","4","96","96","Certain principles long considered fundamental to software engineering are examined and found wanting.","1937-4194","","10.1109/MS.2009.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076468","software engineering;metrics;control;project management;budget and schedule","Software engineering;Birds;Educational institutions;Documentation;Ethics;Pressure measurement;Feedback;Project management;Financial management;Packaging","","","","8","","","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Crowdsourcing in Software Engineering: Models, Motivations, and Challenges","T. D. LaToza; A. van der Hoek","George Mason University; University of California, Irvine","IEEE Software","29 Dec 2015","2016","33","1","74","80","Almost surreptitiously, crowdsourcing has entered software engineering practice. In-house development, contracting, and outsourcing still dominate, but many development projects use crowdsourcing-for example, to squash bugs, test software, or gather alternative UI designs. Although the overall impact has been mundane so far, crowdsourcing could lead to fundamental, disruptive changes in how software is developed. Various crowdsourcing models have been applied to software development. Such changes offer exciting opportunities, but several challenges must be met for crowdsourcing software development to reach its potential.","1937-4194","","10.1109/MS.2016.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367992","programming teams;staffing;software management;software development;software engineering;crowdsourcing;open innovation;peer production;software development competitions;microtasking","Crowdsourcing;Software develoment;Production facilities;Software engineering;Companies;Testing","outsourcing;software engineering","crowdsourcing;software engineering;software development projects;bug squashing;software testing;UI design","","81","","16","","29 Dec 2015","","","IEEE","IEEE Magazines"
"A Survey of App Store Analysis for Software Engineering","W. Martin; F. Sarro; Y. Jia; Y. Zhang; M. Harman","Department of Computer Science, University College London, London, United Kingdom; Department of Computer Science, University College London, London, United Kingdom; Department of Computer Science, University College London, London, United Kingdom; Department of Computer Science, University College London, London, United Kingdom; Department of Computer Science, University College London, London, United Kingdom","IEEE Transactions on Software Engineering","15 Sep 2017","2017","43","9","817","847","App Store Analysis studies information about applications obtained from app stores. App stores provide a wealth of information derived from users that would not exist had the applications been distributed via previous software deployment methods. App Store Analysis combines this non-technical information with technical information to learn trends and behaviours within these forms of software repositories. Findings from App Store Analysis have a direct and actionable impact on the software teams that develop software for app stores, and have led to techniques for requirements engineering, release planning, software design, security and testing. This survey describes and compares the areas of research that have been explored thus far, drawing out common aspects, trends and directions future research should take to address open problems and challenges.","1939-3520","","10.1109/TSE.2016.2630689","EPRSC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7765038","App store;analysis;mining;API;feature;release planning;requirements engineering;reviews;security;ecosystem","Software;Security;Software engineering;Market research;Ecosystems;Mobile communication;Google","program testing;software engineering","app store analysis;software engineering;software deployment;software repositories;software development;requirements engineering;release planning;software design;software security;software testing","","48","","262","CCBY","2 Dec 2016","","","IEEE","IEEE Journals"
"ASCENT: An Algorithmic Technique for Designing Hardware and Software in Tandem","J. White; B. Doughtery; D. C. Schmidt","Virginia Tech, Blacksburg; Vanderbilt University, Nashville; Vanderbilt University, Nashville","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","838","851","Search-based software engineering is an emerging paradigm that uses automated search algorithms to help designers iteratively find solutions to complicated design problems. For example, when designing a climate monitoring satellite, designers may want to use the minimal amount of computing hardware to reduce weight and cost while supporting the image processing algorithms running onboard. A key problem in these situations is that the hardware and software designs are locked in a tightly coupled cost-constrained producer/consumer relationship that makes it hard to find a good hardware/software design configuration. Search-based software engineering can be used to apply algorithmic techniques to automate the search for hardware/software designs that maximize the image processing accuracy while respecting cost constraints. This paper provides the following contributions to research on search-based software engineering: 1) We show how a cost-constrained producer/consumer problem can be modeled as a set of two multidimensional multiple-choice knapsack problems (MMKPs), 2) we present a polynomial-time search-based software engineering technique, called the Allocation-baSed Configuration Exploration Technique (ASCENT), for finding near optimal hardware/software codesign solutions, and 3) we present empirical results showing that ASCENT's solutions average over 95 percent of the optimal solution's value.","1939-3520","","10.1109/TSE.2010.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5539763","Algorithms;computer aided software engineering;optimization methods;distributed computing.","Software algorithms;Software design;Algorithm design and analysis;Hardware;Software engineering;Iterative algorithms;Costs;Image processing;Monitoring;Satellites","hardware-software codesign;knapsack problems;software engineering","ASCENT;hardware-software codesign;automated search algorithm;climate monitoring satellite;computing hardware;image processing algorithm;hardware/software design configuration;cost-constrained producer/consumer problem;multidimensional multiple choice knapsack problem;polynomial time search-based software engineering;allocation-based configuration exploration technique","","8","","34","","5 Aug 2010","","","IEEE","IEEE Journals"
"An Improved SDA Based Defect Prediction Framework for Both Within-Project and Cross-Project Class-Imbalance Problems","X. Jing; F. Wu; X. Dong; B. Xu","State Key Laboratory of Software Engineering, School of Computer, Wuhan University, Wuhan, China; State Key Laboratory of Software Engineering, School of Computer, Wuhan University, Wuhan, China; State Key Laboratory of Software Engineering, School of Computer, Wuhan University, Wuhan, China; Department of Computer Science and Technology, Nanjing University, Nanjing, China","IEEE Transactions on Software Engineering","14 Apr 2017","2017","43","4","321","339","Background. Solving the class-imbalance problem of within-project software defect prediction (SDP) is an important research topic. Although some class-imbalance learning methods have been presented, there exists room for improvement. For cross-project SDP, we found that the class-imbalanced source usually leads to misclassification of defective instances. However, only one work has paid attention to this cross-project class-imbalance problem. Objective. We aim to provide effective solutions for both within-project and cross-project class-imbalance problems. Method. Subclass discriminant analysis (SDA), an effective feature learning method, is introduced to solve the problems. It can learn features with more powerful classification ability from original metrics. For within-project prediction, we improve SDA for achieving balanced subclasses and propose the improved SDA (ISDA) approach. For cross-project prediction, we employ the semi-supervised transfer component analysis (SSTCA) method to make the distributions of source and target data consistent, and propose the SSTCA+ISDA prediction approach. Results. Extensive experiments on four widely used datasets indicate that: 1) ISDA-based solution performs better than other state-of-the-art methods for within-project class-imbalance problem; 2) SSTCA+ISDA proposed for cross-project class-imbalance problem significantly outperforms related methods. Conclusion. Within-project and cross-project class-imbalance problems greatly affect prediction performance, and we provide a unified and effective prediction framework for both problems.","1939-3520","","10.1109/TSE.2016.2597849","National Natural Science Foundation of China; The Chinese 973 Program; Research Project of NJUPT; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7530877","Software defect prediction (SDP);within-project class-imbalance;cross-project class-imbalance;improved subclass discriminant analysis (ISDA);ISDA based defect prediction framework","Support vector machines;Learning systems;Predictive models;Software;Software engineering;Measurement","learning (artificial intelligence);software engineering","SDA based defect prediction;within-project class-imbalance problem;cross-project class-imbalance problem;software defect prediction;SDP;class-imbalance learning;subclass discriminant analysis;semisupervised transfer component analysis;SSTCA","","69","","78","","3 Aug 2016","","","IEEE","IEEE Journals"
"Imprecise Matching of Requirements Specifications for Software Services Using Fuzzy Logic","M. C. Platenius; A. Shaker; M. Becker; E. Hüllermeier; W. Schäfer","Software Engineering Group, Heinz Nixdorf Institute, Paderborn University, Germany; Intelligent Systems Group, Department of Computer Science, Paderborn University, Germany; Software Engineering Group, Fraunhofer IEM, Paderborn, Germany; Intelligent Systems Group, Department of Computer Science, Paderborn University, Germany; Software Engineering Group, Heinz Nixdorf Institute, Paderborn University, Germany","IEEE Transactions on Software Engineering","11 Aug 2017","2017","43","8","739","759","Today, software components are provided by global markets in the form of services. In order to optimally satisfy service requesters and service providers, adequate techniques for automatic service matching are needed. However, a requester's requirements may be vague and the information available about a provided service may be incomplete. As a consequence, fuzziness is induced into the matching procedure. The contribution of this paper is the development of a systematic matching procedure that leverages concepts and techniques from fuzzy logic and possibility theory based on our formal distinction between different sources and types of fuzziness in the context of service matching. In contrast to existing methods, our approach is able to deal with imprecision and incompleteness in service specifications and to inform users about the extent of induced fuzziness in order to improve the user's decision-making. We demonstrate our approach on the example of specifications for service reputation based on ratings given by previous users. Our evaluation based on real service ratings shows the utility and applicability of our approach.","1939-3520","","10.1109/TSE.2016.2632115","German Research Foundation (DFG); Collaborative Research Center “On-The-Fly Computing”; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7755807","Service selection;service matching;requirements specifications;non-functional properties;fuzzy logic;uncertainty;decision making","Uncertainty;Fuzzy logic;Context;Security;Software;Software engineering;Decision making","decision making;fuzzy logic;fuzzy set theory;pattern matching;software engineering","software components;requirement specification imprecise matching;software services;fuzzy logic;automatic service matching;possibility theory;user decision-making","","","","93","","23 Nov 2016","","","IEEE","IEEE Journals"
"Targeted Scrum: Applying Mission Command to Agile Software Development","D. P. Harvie; A. Agah","Department of Electrical Engineering and Computer Science, University of Kansas, Lawrence, KS; Department of Electrical Engineering and Computer Science, University of Kansas, Lawrence, KS","IEEE Transactions on Software Engineering","12 May 2016","2016","42","5","476","489","Software engineering and mission command are two separate but similar fields, as both are instances of complex problem solving in environments with ever changing requirements. Our research hypothesis is that modifications to agile software development based on inspirations from mission command can improve the software engineering process in terms of planning, prioritizing, and communication of software requirements and progress, as well as improving the overall software product. Targeted Scrum is a modification of Traditional Scrum based on three inspirations from Mission Command: End State, Line of Effort, and Targeting. These inspirations have led to the introduction of the Product Design Meeting and modifications of some current Scrum meetings and artifacts. We tested our research hypothesis using a semester-long undergraduate level software engineering class. Students developed two software projects, one using Traditional Scrum and the other using Targeted Scrum. We then assessed how well both methodologies assisted the software development teams in planning and developing the software architecture, prioritizing requirements, and communicating progress. We also evaluated the software product produced by both methodologies. We found that Targeted Scrum did better in assisting the software development teams in the planning and prioritization of the requirements. However, Targeted Scrum had a negligible effect on improving the software development teams external and internal communications. Finally, Targeted Scrum did not have an impact on the product quality by the top performing and worst performing teams. Targeted Scrum did assist the product quality of the teams in the middle of the performance spectrum.","1939-3520","","10.1109/TSE.2015.2489654","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7296686","Scrum, Mission Command;Line of Effort;Product Design Meeting;Agile;Empirical Software Engineering;Scrum;mission command;line of effort;product design meeting;agile;empirical software engineering","Software;Planning;Scrum (Software development);Product design;Software engineering;Force","software architecture;software prototyping","targeted Scrum;mission command;agile software development;software engineering;software requirements;software product improvement;end state;line of effort;targeting;product design meeting;software projects;traditional Scrum;software architecture;product quality;performance spectrum","","8","","34","","12 Oct 2015","","","IEEE","IEEE Journals"
"ERP Customization as Software Engineering: Knowledge Sharing and Cooperation","Y. Dittrich; S. Vaucouleur; S. Giff",IT University of Copenhagen; IT University of Copenhagen; Microsoft Visual Studio,"IEEE Software","16 Oct 2009","2009","26","6","41","47","Enterprise resource planning (ERP) vendors provide multiple configuration possibilities ranging from module selection to master data provision to steer access rights for different users. These configuration possibilities cover anticipated variability. If the customer requires adaptation beyond what's anticipated, the source code of the product must be adapted. Customizations in this article's context are source code based adaptations of software products. The size and complexity of customizations range from simple report generation to developing independent add-ons that support specific businesses, for example, solutions for flight carriers. The size and lead time of such projects can compare to a full-size software development project. Enterprise resource planning (ERP) systems must be configured and customized to fit a specific company. The authors discuss cooperation with regard to ERP systems customization.","1937-4194","","10.1109/MS.2009.173","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287008","D.2 Software Engineering;D Software/Software Engineering;D.2.14 Human Factors in Software Design;J Computer Applications;J.1 Administrative Data Processing;J.1.a Business","Enterprise resource planning;Software engineering;Permission;Programming;Companies","cooperative systems;enterprise resource planning;software development management","ERP customization;software engineering;knowledge sharing;enterprise resource planning vendor;multiple configuration possibility;module selection;master data provision;product source code;source code based adaptation;software product;customization complexity;independent add-on;report generation;business support;software development project;cooperation","","39","2","14","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Software Development in Startup Companies: The Greenfield Startup Model","C. Giardino; N. Paternoster; M. Unterkalmsteiner; T. Gorschek; P. Abrahamsson","Faculty of Computer Science, Free University of Bolzano/Bozen, Dominikanerplatz 3, Italy; Software Engineering Research Lab Sweden, Blekinge Institute of Technology, Campus Gräsvik, 371 79 Karlskrona, Sweden; Software Engineering Research Lab Sweden, Blekinge Institute of Technology, Campus Gräsvik, 371 79 Karlskrona, Sweden; Software Engineering Research Lab Sweden, Blekinge Institute of Technology, Campus Gräsvik, 371 79 Karlskrona, Sweden; Department of Computer and Information Science, Norwegian University of Science and Technology NTNU, Sem Saelandsvei 7-9, Trondheim, Norway","IEEE Transactions on Software Engineering","10 Jun 2016","2016","42","6","585","604","Software startups are newly created companies with no operating history and oriented towards producing cutting-edge products. However, despite the increasing importance of startups in the economy, few scientific studies attempt to address software engineering issues, especially for early-stage startups. If anything, startups need engineering practices of the same level or better than those of larger companies, as their time and resources are more scarce, and one failed project can put them out of business. In this study we aim to improve understanding of the software development strategies employed by startups. We performed this state-of-practice investigation using a grounded theory approach. We packaged the results in the Greenfield Startup Model (GSM), which explains the priority of startups to release the product as quickly as possible. This strategy allows startups to verify product and market fit, and to adjust the product trajectory according to early collected user feedback. The need to shorten time-to-market, by speeding up the development through low-precision engineering activities, is counterbalanced by the need to restructure the product before targeting further growth. The resulting implications of the GSM outline challenges and gaps, pointing out opportunities for future research to develop and validate engineering practices in the startup context.","1939-3520","","10.1109/TSE.2015.2509970","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7360225","Software Development;Startups;Grounded Theory;Software development;startups;grounded theory","Software;Companies;GSM;Context;Software engineering;History","software development management","Greenfield startup model;software startups;software engineering issues;engineering practices;software development strategies;state-of-practice investigation;grounded theory approach;GSM;user feedback;time-to-market","","55","","119","","17 Dec 2015","","","IEEE","IEEE Journals"
"MADMatch: Many-to-Many Approximate Diagram Matching for Design Comparison","S. Kpodjedo; F. Ricca; P. Galinier; G. Antoniol; Y. Guéhéneuc","Ecole Polytechnique de Montreal, Montreal; Università di Genova, Genova; Ecole Polytechnique de Montreal, Montreal; Ecole Polytechnique de Montreal, Montreal; Ecole Polytechnique de Montreal, Montreal","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1090","1111","Matching algorithms play a fundamental role in many important but difficult software engineering activities, especially design evolution analysis and model comparison. We present MADMatch, a fast and scalable many-to-many approximate diagram matching approach based on an error-tolerant graph matching (ETGM) formulation. Diagrams are represented as graphs, costs are assigned to possible differences between two given graphs, and the goal is to retrieve the cheapest matching. We address the resulting optimization problem with a tabu search enhanced by the novel use of lexical and structural information. Through several case studies with different types of diagrams and tasks, we show that our generic approach obtains better results than dedicated state-of-the-art algorithms, such as AURA, PLTSDiff, or UMLDiff, on the exact same datasets used to introduce (and evaluate) these algorithms.","1939-3520","","10.1109/TSE.2013.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6464271","Diagram differencing;search-based software engineering;approximate graph matching;identifier splitting","Unified modeling language;Algorithm design and analysis;Software;Scalability;Software algorithms;Software engineering;Optimization","graph theory;optimisation;search problems;software engineering","MADMatch approach;many-to-many approximate diagram matching approach;error-tolerant graph matching;ETGM;software engineering;design evolution analysis;model comparison;design comparison;optimization problem;tabu search;lexical information;structural information;AURA algorithm;PLTSDiff algorithm;UMLDiff algorithm","","9","","32","","18 Feb 2013","","","IEEE","IEEE Journals"
"Bayesian Networks For Evidence-Based Decision-Making in Software Engineering","A. T. Misirli; A. B. Bener","Department of Information Processing Science, University of Oulu, Finland; Mechanical and Industrial Engineering Department, Ryerson University, Toronto, CA","IEEE Transactions on Software Engineering","16 Jun 2014","2014","40","6","533","554","Recommendation systems in software engineering (SE) should be designed to integrate evidence into practitioners experience. Bayesian networks (BNs) provide a natural statistical framework for evidence-based decision-making by incorporating an integrated summary of the available evidence and associated uncertainty (of consequences). In this study, we follow the lead of computational biology and healthcare decision-making, and investigate the applications of BNs in SE in terms of 1) main software engineering challenges addressed, 2) techniques used to learn causal relationships among variables, 3) techniques used to infer the parameters, and 4) variable types used as BN nodes. We conduct a systematic mapping study to investigate each of these four facets and compare the current usage of BNs in SE with these two domains. Subsequently, we highlight the main limitations of the usage of BNs in SE and propose a Hybrid BN to improve evidence-based decision-making in SE. In two industrial cases, we build sample hybrid BNs and evaluate their performance. The results of our empirical analyses show that hybrid BNs are powerful frameworks that combine expert knowledge with quantitative data. As researchers in SE become more aware of the underlying dynamics of BNs, the proposed models will also advance and naturally contribute to evidence based-decision-making.","1939-3520","","10.1109/TSE.2014.2321179","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6808495","Evidence-based decision-making;Bayesian networks;Bayesian statistics;software reliability;software metrics;post-release defects","Software engineering;Decision making;Bayes methods;Software;Medical services;Systematics;Buildings","belief networks;decision making;software metrics;software reliability","Bayesian networks;evidence-based decision-making;software engineering;recommendation systems;SE;natural statistical framework;associated uncertainty;computational biology;health care decision-making;systematic mapping study;hybrid BN node;software reliability;software metrics","","32","1","81","","30 Apr 2014","","","IEEE","IEEE Journals"
"Alloy Meets the Algebra of Programming: A Case Study","J. N. Oliveira; M. A. Ferreira","University of Minho, Braga; Software Improvement Group, Amsterdam","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","305","326","Relational algebra offers to software engineering the same degree of conciseness and calculational power as linear algebra in other engineering disciplines. Binary relations play the role of matrices with similar emphasis on multiplication and transposition. This matches with Alloy's lemma “everything is a relation” and with the relational basis of the Algebra of Programming (AoP). Altogether, it provides a simple and coherent approach to checking and calculating programs from abstract models. In this paper, we put Alloy and the Algebra of Programming together in a case study originating from the Verifiable File System mini-challenge put forward by Joshi and Holzmann: verifying the refinement of an abstract file store model into a journaled (Flash) data model catering to wear leveling and recovery from power loss. Our approach relies on diagrams to graphically express typed assertions. It interweaves model checking (in Alloy) with calculational proofs in a way which offers the best of both worlds. This provides ample evidence of the positive impact in software verification of Alloy's focus on relations, complemented by induction-free proofs about data structures such as stores and lists.","1939-3520","","10.1109/TSE.2012.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155724","Model checking;algebra of programming;software verification;grand challenges in computing","Metals;Software;Programming;Matrices;Calculus;Cognition","formal verification;mathematics computing;relational algebra;software engineering","relational algebra;software engineering;linear algebra;Alloys lemma;relational basis;algebra of programming;AoP;calculating programs;verifiable file system;model checking;software verification;data structures","","5","","53","","21 Feb 2012","","","IEEE","IEEE Journals"
"Supporting Change Impact Analysis Using a Recommendation System: An Industrial Case Study in a Safety-Critical Context","M. Borg; K. Wnuk; B. Regnell; P. Runeson","SICS Swedish ICT AB, Ideon Science Park, Building Beta 2, Scheelevägen 17, Lund, Sweden; Blekinge Institute of Technology, Karlskrona, Sweden; Lund University, Lund, Sweden; Lund University, Lund, Sweden","IEEE Transactions on Software Engineering","14 Jul 2017","2017","43","7","675","700","Change Impact Analysis (CIA) during software evolution of safety-critical systems is a labor-intensive task. Several authors have proposed tool support for CIA, but very few tools were evaluated in industry. We present a case study on ImpRec, a recommendation System for Software Engineering (RSSE), tailored for CIA at a process automation company. ImpRec builds on assisted tracing, using information retrieval solutions and mining software repositories to recommend development artifacts, potentially impacted when resolving incoming issue reports. In contrast to the majority of tools for automated CIA, ImpRec explicitly targets development artifacts that are not source code. We evaluate ImpRec in a two-phase study. First, we measure the correctness of ImpRec's recommendations by a simulation based on 12 years' worth of issue reports in the company. Second, we assess the utility of working with ImpRec by deploying the RSSE in two development teams on different continents. The results suggest that ImpRec presents about 40 percent of the true impact among the top-10 recommendations. Furthermore, user log analysis indicates that ImpRec can support CIA in industry, and developers acknowledge the value of ImpRec in interviews. In conclusion, our findings show the potential of reusing traceability associated with developers' past activities in an RSSE.","1939-3520","","10.1109/TSE.2016.2620458","Embedded Applications Software Engineering; ORION; Knowledge Foundation; Lund University; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7637029","Case;maintenance management;software and system safety;tracing","Context;Industries;Software engineering;Unified modeling language;Automation;Software systems","program diagnostics;recommender systems;safety-critical software;software engineering","change impact analysis;safety-critical context;CIA;software evolution;safety-critical system;recommendation system for software engineering;RSSE;ImpRec;information retrieval solution;software repository mining","","6","","120","","24 Oct 2016","","","IEEE","IEEE Journals"
"How Software Development Group Leaders Influence Team Members' Innovative Behavior","F. Q. B. da Silva; C. V. F. Monteiro; I. E. dos Santos; L. F. Capretz","Universidade Federal de Pernambuco; Universidade Federal Rural de Pernambuco; Avanade; Western University, Canada","IEEE Software","24 Aug 2016","2016","33","5","106","109","Innovation is important to a company's success, and a team leader's behavior is a major factor affecting group members' innovative activity. This article examines how software development team leaders influence innovative activity.","1937-4194","","10.1109/MS.2016.120","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548896","innovation;creativity;software development;transformational leadership;transactional leadership;ambidextrous leadership;exploitative innovation;exploratory innovation;software engineering","Technological innovation;Innovation management;Creativity;Software engineering;Software engineering;Management","behavioural sciences computing;human resource management;innovation management;software engineering","software development;innovation;company success;team leader behavior","","","","7","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Automated Fixing of Programs with Contracts","Y. Pei; C. A. Furia; M. Nordio; Y. Wei; B. Meyer; A. Zeller","Chair of Software Engineering, Department of Computer Science, ETH Zürich, Switzerland; Chair of Software Engineering, Department of Computer Science, ETH Zürich, Switzerland; Chair of Software Engineering, Department of Computer Science, ETH Zürich, Switzerland; Constraint Reasoning Group, Microsoft Research Cambridge, United Kingdom; Chair of Software Engineering, Department of Computer Science, ETH Zürich, Switzerland; Software Engineering Chair, Saarland University, Germany","IEEE Transactions on Software Engineering","14 May 2014","2014","40","5","427","449","This paper describes AutoFix, an automatic debugging technique that can fix faults in general-purpose software. To provide high-quality fix suggestions and to enable automation of the whole debugging process, AutoFix relies on the presence of simple specification elements in the form of contracts (such as pre- and postconditions). Using contracts enhances the precision of dynamic analysis techniques for fault detection and localization, and for validating fixes. The only required user input to the AutoFix supporting tool is then a faulty program annotated with contracts; the tool produces a collection of validated fixes for the fault ranked according to an estimate of their suitability. In an extensive experimental evaluation, we applied AutoFix to over 200 faults in four code bases of different maturity and quality (of implementation and of contracts). AutoFix successfully fixed 42 percent of the faults, producing, in the majority of cases, corrections of quality comparable to those competent programmers would write; the used computational resources were modest, with an average time per fix below 20 minutes on commodity hardware. These figures compare favorably to the state of the art in automated program fixing, and demonstrate that the AutoFix approach is successfully applicable to reduce the debugging burden in real-world scenarios.","1939-3520","","10.1109/TSE.2014.2312918","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6776507","Automatic program repair;contracts;dynamic analysis","Indexes;Contracts;Debugging;Libraries;Software engineering;Software;Automation","contracts;fault diagnosis;program debugging;program diagnostics;software tools","automated program fixing;contracts;automatic debugging technique;general-purpose software fault fixing;high-quality fix suggestions;debugging process;dynamic analysis techniques;fault localization;fault detection;AutoFix supporting tool;computational resources;commodity hardware;AutoFix approach","","53","","68","","20 Mar 2014","","","IEEE","IEEE Journals"
"Supporting Scope Tracking and Visualization for Very Large-Scale Requirements Engineering-Utilizing FSC+, Decision Patterns, and Atomic Decision Visualizations","K. Wnuk; T. Gorschek; D. Callele; E. Karlsson; E. Åhlin; B. Regnell","Software Engineering Research Lab (SERL), Department of Software Engineering, Blekinge Institute of Technology, Karlskrona, Sweden; Software Engineering Research Lab (SERL), Department of Software Engineering, Blekinge Institute of Technology, Karlskrona, Sweden; Department of Computer Science, University of Saskatchewan, Saskatoon, Canada; Add a Lot, Sweden; Sony Mobile Communications, Lund, Sweden; Department of Computer Science, Lund University, Lund, Sweden","IEEE Transactions on Software Engineering","7 Jan 2016","2016","42","1","47","74","Deciding the optimal project scope that fulfills the needs of the most important stakeholders is challenging due to a plethora of aspects that may impact decisions. Large companies that operate in rapidly changing environments experience frequently changing customer needs which force decision makers to continuously adjust the scope of their projects. Change intensity is further fueled by fierce market competition and hard time-to-market deadlines. Staying in control of the changes in thousands of features becomes a major issue as information overload hinders decision makers from rapidly extracting relevant information. This paper presents a visual technique, called Feature Survival Charts+ (FSC+), designed to give a quick and effective overview of the requirements scoping process for Very Large-Scale Requirements Engineering (VLSRE). FSC+ were applied at a large company with thousands of features in the database and supported the transition from plan-driven to a more dynamic and change-tolerant release scope management process. FSC+ provides multiple views, filtering, zooming, state-change intensity views, and support for variable time spans. Moreover, this paper introduces five decision archetypes deduced from the dataset and subsequently analyzed and the atomic decision visualization that shows the frequency of various decisions in the process. The capabilities and usefulness of FSC+, decision patterns (state changes that features undergo) and atomic decision visualizations are evaluated through interviews with practitioners who found utility in all techniques and indicated that their inherent flexibility was necessary to meet the varying needs of the stakeholders.","1939-3520","","10.1109/TSE.2015.2445347","IKNOWDM project; Knowledge Foundation in Sweden; SCALARE ITEA2 project; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7123669","- D.2.1Requirements/Specifications D.2.9.d Initiation and scope definition D.2.9 Management;Requirements/specifications;initiation and scope definition;management","Power capacitors;Companies;Planning;Visualization;Software;Software engineering;Electronic mail","data visualisation;formal specification","scope tracking;very large-scale requirements engineering visualization;FSC+;decision patterns;atomic decision visualizations;Feature Survival Charts+;requirements scoping process;very large-scale requirements engineering;VLSRE;change-tolerant release scope management process","","12","","108","","15 Jun 2015","","","IEEE","IEEE Journals"
"Tracking Developers' Eyes in the IDE","B. Sharif; T. Shaffer; J. Wise; J. I. Maletic",Youngstown State University; University of Notre Dame; Youngstown State University; Kent State University,"IEEE Software","25 Apr 2016","2016","33","3","105","108","With recorded eye gaze sessions, researchers will be able to determine all the locations that developers examine in software development artifacts. This will pave the way to further improve IDEs to support developers in various software engineering tasks. Toward that goal, researchers developed iTrace, software that interfaces with an eye tracker and IDE to capture eye gaze on software artifacts and map them to their semantic meaning.","1937-4194","","10.1109/MS.2016.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458758","iTrace;eye tracking;IDE;integrated development environment;software engineering;software development","Software development;Tracking;Gaze tracking;Visualization;Software engineering;Unified modeling language;Integrated development environment","ergonomics;software engineering","IDE;eye gaze sessions;software development artifacts;integrated development environment","","7","","7","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Recommendation Systems for Software Engineering","M. Robillard; R. Walker; T. Zimmermann","McGill University, Montreal; University of Calgary, Calgary; Microsoft Corportation, Redmond","IEEE Software","14 Jun 2010","2010","27","4","80","86","Software development can be challenging because of the large information spaces that developers must navigate. Without assistance, developers can become bogged down and spend a disproportionate amount of their time seeking information at the expense of other value-producing tasks. Recommendation systems for software engineering (RSSEs) are software tools that can assist developers with a wide range of activities, from reusing code to writing effective bug reports. The authors provide an overview of recommendation systems for software engineering: what they are, what they can do for developers, and what they might do in the future.","1937-4194","","10.1109/MS.2009.161","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5235134","software engineering;development tools;programming environments;software construction tools;coding tools and techniques;design tools and techniques","Software engineering;Programming;Navigation;Software tools;Writing","recommender systems;software tools","recommendation system;software engineering;software development;information space;time seeking information;value-producing task;software tool;bug reports","","143","16","17","","11 Sep 2009","","","IEEE","IEEE Magazines"
"Continuing Prospects for an Engineering Discipline of Software","M. Shaw",Carnegie Mellon University,"IEEE Software","16 Oct 2009","2009","26","6","64","67","In her 1990 IEEE Software article ""Prospects for an Engineering Discipline of Software"" (Nov./Dec, pp. 15-24), Mary Shaw identified the key areas that the software development profession must address to become a true engineering discipline. That classic article made the magazine's 25th anniversary top picks list (Jan./Feb. 2009, pp. 9-11). Here, Mary reflects on the evolution of her thinking since the publication of ""Prospects"". The paper dealt with the topics of: programming progress; beyond programming; management of the software production; and progress toward an engineering discipline.","1937-4194","","10.1109/MS.2009.172","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287012","software engineering;commercial practice;critical applications;development techniques;economic force;engineering discipline;expertise;information processing;professional specializations;routine practice;science;scientific basis;software engineering;software technology","Programming profession;Engineering management;Production","social aspects of automation;software engineering","IEEE software article;software engineering discipline;software development profession;prospects publication;programming progress;software production management","","11","","10","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Process Improvement from an Academic Perspective: How Could Software Engineering Education Contribute to CMMI Practices?","A. M. Moreno; M. Sánchez-Segura; F. Medina-Dominguez; G. Cuevas",Universidad Politécnica de Madrid; Universidad Carlos III de Madrid; Universidad Carlos III de Madrid; Universidad Politécnica de Madrid,"IEEE Software","13 Jun 2014","2014","31","4","91","97","Educating software engineers is a longstanding challenge, but the results of examining the overlap between software engineering educational standards (SE 2004 and GSwE 2009) and one of the most well-known software process improvement models (CMMI-DEV) could prove useful to both industry and academia.","1937-4194","","10.1109/MS.2013.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6509869","software engineering education;software process improvement;education;software engineering","Process control;Software development;Process management;Project management;Monitoring","computer science education;software process improvement;software standards","academic perspective;CMMI practices;software engineering educational standards;SE 2004;GSwE 2009;software process improvement models;CMMI-DEV","","1","","13","","29 Apr 2013","","","IEEE","IEEE Magazines"
"Contextualizing empirical evidence","T. Dybå",SINTEF,"IEEE Software","3 Jan 2013","2013","30","1","81","83","What works for whom, where, when, and why is the ultimate question of evidence-based software engineering. Still, the empirical research seems mostly concerned with identifying universal relationships that are independent of how work settings and other contexts interact with the processes important to software practice. Questions of “What is best?” seem to prevail. For example, “Which is better: pair or solo programming? test-first or test-last?” However, just as the question of whether a helicopter is better than a bicycle is meaningless, so are these questions because the answers depend on the settings and goals of the projects studied. Practice settings are rarely, if ever, the same. For example, the environments of software organizations differ, as do their sizes, customer types, countries or geography, and history. All these factors influence engineering practices in unique ways. Additionally, the human factors underlying the organizational culture differ from one organization to the next and also influence the way software is developed. We know these issues and the ways they interrelate are important for the successful uptake of research into practice. However, the nature of these relationships is poorly understood. Consequently, we can't a priori assume that the results of a particular study apply outside the specific context in which it was run. Here, I offer an overview of how context affects empirical research and how to better contextualize empirical evidence so that others can better understand what works for whom, where, when, and why.","1937-4194","","10.1109/MS.2013.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401115","software engineering;empirical software engineering","Software engineering;Context awareness;Information processing;Content management","organisational aspects;software development management","empirical evidence contextualization;evidence-based software engineering;software practice;pair programming;solo programming;test-first;test-last;practice settings;software organization environments;organizational culture","","21","","10","","3 Jan 2013","","","IEEE","IEEE Magazines"
"A Scalable Approach to Exact Model and Commonality Counting for Extended Feature Models","D. Fernandez-Amoros; R. Heradio; J. A. Cerrada; C. Cerrada","Department of Languages and Computer Systems, Spanish Open University (UNED), Madrid, Spain; Department of Software Engineering and Computer Systems, Spanish Open University (UNED), Madrid, Spain; Department of Software Engineering and Computer Systems, Spanish Open University (UNED), Madrid, Spain; Department of Software Engineering and Computer Systems, Spanish Open University (UNED), Madrid, Spain","IEEE Transactions on Software Engineering","4 Sep 2014","2014","40","9","895","910","A software product line is an engineering approach to efficient development of software product portfolios. Key to the success of the approach is to identify the common and variable features of the products and the interdependencies between them, which are usually modeled using feature models. Implicitly, such models also include valuable information that can be used by economic models to estimate the payoffs of a product line. Unfortunately, as product lines grow, analyzing large feature models manually becomes impracticable. This paper proposes an algorithm to compute the total number of products that a feature model represents and, for each feature, the number of products that implement it. The inference of both parameters is helpful to describe the standardization/parameterization balance of a product line, detect scope flaws, assess the product line incremental development, and improve the accuracy of economic models. The paper reports experimental evidence that our algorithm has better runtime performance than existing alternative approaches.","1939-3520","","10.1109/TSE.2014.2331073","Spanish Government; Comunidad de Madrid; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6835200","Feature models;formal methods;economic models;software product lines","Frequency modulation;Computational modeling;Analytical models;Software;Economics;Headphones;Portfolios","software engineering;software product lines","product line incremental development;software product portfolio development;software product line;commonality counting;extended feature models","","7","","56","","16 Jun 2014","","","IEEE","IEEE Journals"
"Distribution, Data, Deployment: Software Architecture Convergence in Big Data Systems","I. Gorton; J. Klein",Software Engineering Institute; Software Engineering Institute,"IEEE Software","23 Apr 2015","2015","32","3","78","85","Big data applications are pushing the limits of software engineering on multiple horizons. Successful solutions span the design of the data, distribution, and deployment architectures. The body of software architecture knowledge must evolve to capture this advanced design knowledge for big data systems. This article is a first step on this path. Our research is proceeding in two complementary directions. First, we're expanding our collection of architecture tactics and encoding them in an environment that supports navigation between quality attributes and tactics, making crosscutting concerns for design choices explicit. Second, we're linking tactics to design solutions based on specific big data technologies, enabling architects to rapidly relate a particular technology's capabilities to a specific set of tactics.","1937-4194","","10.1109/MS.2014.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774768","software architecture;big data;distributed systems;data management;NoSQL;software engineering","Big data;Distributed databases;Computer architecture;Software engineering;Software architecture;Data management;Data models","Big Data;knowledge engineering;software architecture","big data system;software architecture convergence;software engineering;software architecture knowledge;architecture tactics","","44","","15","","18 Mar 2014","","","IEEE","IEEE Magazines"
"Research 2.0?","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","22 Oct 2012","2012","29","6","4","8","IEEE Software Editor in Chief Forrest Shull discuss the state of research in software engineering, focusing on empirical software engineering (ESE) and the expanded goal—question—metric strategies (GQM+Strategies) to tie specific measurements to the technical goals that they address. He also welcomes Girish Suryanarayana as the magazine's newest member of its Industry Advisory Board.","1937-4194","","10.1109/MS.2012.164","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6336718","empirical software engineering;research;software;metrics;systems;test-driven development;tdd;goal-question-metric;gqm","Software engineering;Software testing;Software measurements;Testing","","","","3","","2","","22 Oct 2012","","","IEEE","IEEE Magazines"
"Exploiting Big Data's Benefits","J. Heidrich; A. Trendowicz; C. Ebert",Fraunhofer Institute for Experimental Software Engineering; Fraunhofer Institute for Experimental Software Engineering; Vector Consulting Services,"IEEE Software","23 Jun 2016","2016","33","4","111","116","Knowing about big data's potential for exploiting new business ideas is a key capability for staying successful in the market. Potential analysis provides a systematic way to identify and close the gap between big data's possible benefits and the ability to turn that data into business value.","1937-4194","","10.1109/MS.2016.99","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498546","big data;lambda architecture;smart ecosystems;potential analysis;benefit analysis;readiness analysis;PRO-OPT;IWSM Mensura;software engineering;software development","Big data;Ecosystems;Smart devices;Software engineering;Computer architecture","Big Data;business data processing","big data benefits;business ideas;potential analysis;business value","","7","","4","","23 Jun 2016","","","IEEE","IEEE Magazines"
"Creating Software Process Capability/Maturity Models","C. G. von Wangenheim; J. C. R. Hauck; A. Zoucas; C. F. Salviano; F. McCaffery; F. Shull","Federal University of Santa Catarina; Dundalk Institute of Technology; University of the Valley of Itajaí; CTI (Centro de Tecnologia da Informação) Renato Archer; Dundalk Institute of Technology (DkIT); Fraunhofer Center for Experimental Software Engineering, Maryland","IEEE Software","14 Jun 2010","2010","27","4","92","94","A seeming multitude of software process capability/maturity models (SPCMMs) have emerged, and many software engineers have had to worry about compliance with them at one time or another. Although using SPCMMs is a well-established practice, the ways they're used can vary widely. At best, they can pull together vast bodies of knowledge about good software practices-the hard-won expertise of many engineers-into a form that's easier to work with. At worst, they're misused as ""processes for process' sake,"" in which conforming to the model stifles opportunities for innovation and tailoring. If software engineers had better knowledge about how SPCMMs are developed and the basis of their recommendations, they might be able to interpret and use them to optimize their benefits. We therefore studied these issues in a systematic literature review and follow-on questionnaire.","1937-4194","","10.1109/MS.2010.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484116","software engineering;Process Capability/Maturity Models;CMMI;ISO/IEC 15504","Knowledge engineering;Technological innovation","Capability Maturity Model;software engineering","software process capability;software process maturity models;SPCMM;software engineers;systematic literature;follow on questionnaire","","49","","15","","14 Jun 2010","","","IEEE","IEEE Magazines"
"StakeRare: Using Social Networks and Collaborative Filtering for Large-Scale Requirements Elicitation","S. L. Lim; A. Finkelstein","University College London, London; University College London, London","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","707","735","Requirements elicitation is the software engineering activity in which stakeholder needs are understood. It involves identifying and prioritizing requirements-a process difficult to scale to large software projects with many stakeholders. This paper proposes StakeRare, a novel method that uses social networks and collaborative filtering to identify and prioritize requirements in large software projects. StakeRare identifies stakeholders and asks them to recommend other stakeholders and stakeholder roles, builds a social network with stakeholders as nodes and their recommendations as links, and prioritizes stakeholders using a variety of social network measures to determine their project influence. It then asks the stakeholders to rate an initial list of requirements, recommends other relevant requirements to them using collaborative filtering, and prioritizes their requirements using their ratings weighted by their project influence. StakeRare was evaluated by applying it to a software project for a 30,000-user system, and a substantial empirical study of requirements elicitation was conducted. Using the data collected from surveying and interviewing 87 stakeholders, the study demonstrated that StakeRare predicts stakeholder needs accurately and arrives at a more complete and accurately prioritized list of requirements compared to the existing method used in the project, taking only a fraction of the time.","1939-3520","","10.1109/TSE.2011.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5740931","Requirements/specifications;elicitation methods;requirements prioritization;experimentation;human factors;recommender systems;social network analysis;stakeholder analysis.","Social network services;Collaboration;Filtering;Software;Size measurement;Software engineering;Business","collaborative filtering;data acquisition;project management;recommender systems;social networking (online);software management","social network;collaborative filtering;requirement elicitation;software engineering;stakeholder;StakeRare;recommender system;software project;data collection","","85","","113","","5 Apr 2011","","","IEEE","IEEE Journals"
"Impact of Budget and Schedule Pressure on Software Development Cycle Time and Effort","N. Nan; D. E. Harter","University of Oklahoma, Norman; Syracuse University, Syracuse","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","624","637","As excessive budget and schedule compression becomes the norm in today's software industry, an understanding of its impact on software development performance is crucial for effective management strategies. Previous software engineering research has implied a nonlinear impact of schedule pressure on software development outcomes. Borrowing insights from organizational studies, we formalize the effects of budget and schedule pressure on software cycle time and effort as U-shaped functions. The research models were empirically tested with data from a 25 billion/year international technology firm, where estimation bias is consciously minimized and potential confounding variables are properly tracked. We found that controlling for software process, size, complexity, and conformance quality, budget pressure, a less researched construct, has significant U-shaped relationships with development cycle time and development effort. On the other hand, contrary to our prediction, schedule pressure did not display significant nonlinear impact on development outcomes. A further exploration of the sampled projects revealed that the involvement of clients in the software development might have ldquoerodedrdquo the potential benefits of schedule pressure. This study indicates the importance of budget pressure in software development. Meanwhile, it implies that achieving the potential positive effect of schedule pressure requires cooperation between clients and software development teams.","1939-3520","","10.1109/TSE.2009.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815275","Cost estimation;time estimation;schedule and organizational issues;systems development.","Programming;Job shop scheduling;Software performance;Computer industry;Financial management;Software development management;Software engineering;Testing;Pressure control;Size control","budgeting;DP industry;project management;sampling methods;scheduling;software cost estimation;software development management;software metrics;software quality;statistical testing","budget pressure;schedule pressure;software development cycle time estimation;software development effort estimation;software industry;software development performance;software engineering research;nonlinear impact;organizational study;U-shaped function;empirical testing;international technology firm;potential confounding variable;software process control;software size control;software complexity control;software conformance quality control;sampled project management;potential positive effect;software development team management strategy;software cost estimation","","46","","74","","17 Apr 2009","","","IEEE","IEEE Journals"
"Semi-Proving: An Integrated Method for Program Proving, Testing, and Debugging","T. Y. Chen; T. H. Tse; Z. Q. Zhou","Centre for Software Analysis and Testing, Swinburne University of Technology, Hawthorn, Victoria 3122, Australia; Department of Computer Science, The University of Hong Kong, Pokfulam, Hong Kong; School of Computer Science and Software Engineering, University of Wollongong, Wollongong, NSW 2522, Australia","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","109","125","We present an integrated method for program proving, testing, and debugging. Using the concept of metamorphic relations, we select necessary properties for target programs. For programs where global symbolic evaluation can be conducted and the constraint expressions involved can be solved, we can either prove that these necessary conditions for program correctness are satisfied or identify all inputs that violate the conditions. For other programs, our method can be converted into a symbolic-testing approach. Our method extrapolates from the correctness of a program for tested inputs to the correctness of the program for related untested inputs. The method supports automatic debugging through the identification of constraint expressions that reveal failures.","1939-3520","","10.1109/TSE.2010.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406529","Software/program verification;symbolic execution;testing and debugging.","Software testing;Automatic testing;Computer science;Built-in self-test;Software debugging;Costs;Automation;Australia Council;Communications technology;Software engineering","formal verification;program debugging;program testing","semiproving;program proving;program testing;program debugging;integrated method;metamorphic relation;symbolic evaluation;constraint expression;symbolic testing;automatic debugging;program verification","","45","","60","","5 Feb 2010","","","IEEE","IEEE Journals"
"Strategies for Early-Stage Collaborative Design","A. Dilmaghani; J. Dibble",Oracle; Cooper,"IEEE Software","22 Dec 2011","2012","29","1","39","45","Collaboration can enhance the output of early-stage design. When software designers or architects work together to define a problem and explore potential solutions, they find and address design problems earlier and arrive at more innovative and effective solutions than when they work alone. Nonetheless, collaboration can fail without proper planning. This set of 10 design session ground rules can significantly enhance the process and output of early-stage design.","1937-4194","","10.1109/MS.2011.124","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6035660","analysis;requirements;specifications;software engineering;software;elicitation methods;process;design concepts;human factors;software design","Collaboration;Software design;Product development;Software engineering;Unified modeling language;Software architecture","software engineering","early-stage collaborative design;software designer;software architect","","1","","1","","6 Oct 2011","","","IEEE","IEEE Magazines"
"Steering Software Development Workflow: Lessons from the Internet","M. Cantor; B. MacIsaac; R. Mannan",Cutter Consortium; IBM; IBM,"IEEE Software","24 Aug 2016","2016","33","5","96","102","There's a body of literature on the software factory that might lead readers to believe that software development is analogous to manufacturing: requirements enter one end of a pipeline; tested code exits the other. In The Principles of Product Development Flow, Donald Reinertsen challenged this paradigm, proposing that a flow-based model is more applicable. Reinertsen's principles apply to both communication networks and software development workflows, and network optimization approaches are applicable to software development workflows.","1937-4194","","10.1109/MS.2016.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548902","agile methods;agile software development;lean software development;Scrum;process improvement;queuing;Donald Reinertsen;communication networks;product development flow;WSJF;weighted shortest job first;software engineering","Software engineering;Agile software development;Economics;Job shop scheduling;Internet;Queueing analysis","Internet;software engineering","network optimization;communication networks;Reinertsen principle;flow-based model;product development flow principles;software factory;Internet;software development workflow","","","","10","","24 Aug 2016","","","IEEE","IEEE Magazines"
"The Value of a Single Solution for End-to-End ALM Tool Support","M. Gatrell",Neilson Financial Services,"IEEE Software","24 Aug 2016","2016","33","5","103","105","A single solution for application lifecycle management (ALM) support lets stakeholders see their requirements throughout the ALM process. This ranges from idea origination through to seeing when, and to which environments, an application was released and the changes it has undergone. Such a solution provides metrics that natively cover the ALM process and provide new insights. Finally, it provides a collaboration platform that brings all stakeholders together with a single view over a single source of truth throughout ALM.","1937-4194","","10.1109/MS.2016.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548904","application lifecycle management;ALM;user experience;DevOps;software engineering;software development","Stakeholders;Software engineering;Collaboration;Product life cycle management;Documentation;Ecosystems;Software metrics","groupware;product life cycle management;software engineering","end-to-end ALM tool support;application lifecycle management;collaboration platform","","4","","","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Privacy Requirements in an Age of Increased Sharing","T. Breaux",NA,"IEEE Software","15 Sep 2014","2014","31","5","24","27","Privacy is a critical design principle that must be balanced with how we utilize personal data in software. This article examines the increasing importance of privacy in emerging software ecosystems, legal and standards compliance, and software design practice. The Web extra at http://youtu.be/E9kbrOE8dFA is an audio podcast in which author Travis Breaux provides an audio recording of the Requirements column about the increasing importance of privacy in emerging software ecosystems, legal and standards compliance, and software design practice.","1937-4194","","10.1109/MS.2014.118","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898709","privacy;requirements;design;software engineering","Privacy;Software engineering;Law;Business;Standards","data privacy;law;software engineering;software standards","privacy requirements;data sharing;personal data;software ecosystems;legal compliance;standards compliance;software design practice","","6","","3","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Technical Debt: Challenges and Perspectives","B. Stopford; K. Wallace; J. Allspaw",Confluent; NA; Etsy,"IEEE Software","11 Jul 2017","2017","34","4","79","81","Three IT managers from different domains present their views on the challenges of tackling technical debt.","1937-4194","","10.1109/MS.2017.99","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974723","technical debt;software development;software engineering;Ben Stopford;Ken Wallace;John Allspaw","Information technology;Computer architecture;Software engineering;Parallel processing;Best practices;Software measurement","software engineering","software development","","1","","","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Design Strategy and Software Design Effectiveness","A. Tang; H. van Vliet",Swinburne University of Technology; VU University Amsterdam,"IEEE Software","22 Dec 2011","2012","29","1","51","55","Software design is about a sequence of steps taken to achieve a goal. Designers must plan their approach to carrying out these steps. In studying designers at work, the authors observed breadth- versus depth-first approaches to design-space exploration and problem- versus solution-driven approaches during the actual design. Which approaches and when to use them are important to effective design. The authors suggest four archetypical strategies that designers can choose under different circumstances, thus making design strategy one of the early design decisions.","1937-4194","","10.1109/MS.2011.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6051414","design concepts;software engineering;design tools and techniques","Software design;Product development;Complexity theory;Planning;Software engineering","software engineering","design strategy;software design effectiveness;breadth-first approach;depth-first approach;design-space exploration;problem-driven approach;solution-driven approach","","9","","4","","18 Oct 2011","","","IEEE","IEEE Magazines"
"The Software behind the Higgs Boson Discovery","D. Rousseau",Orsay Université Paris-Sud,"IEEE Software","21 Aug 2012","2012","29","5","11","15","In this column, David Rousseau describes the enormous software development effort associated with teasing out evidence for the elusive Higgs boson, a cornerstone of the Standard Model. In keeping with previous Impact columns, everything about this is huge but the application is unique.","1937-4194","","10.1109/MS.2012.123","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6276293","impact;Higgs boson;physics;CERN;nuclear research;Atlas;decay;software engineering;software development","Software development;Physcis;Nuclear physics;Software engineering;Particle collisions","Higgs bosons;physics computing;software engineering","Higgs boson discovery;software development;standard model","","7","","2","","21 Aug 2012","","","IEEE","IEEE Magazines"
"Requirements Tracery","O. Gotel; S. Morris",independent researcher; City University London,"IEEE Software","18 Aug 2011","2011","28","5","92","94","This paper presents traceability of software. Traceability expresses the potential to create and follow links between pairs of development artifacts to support analytical or development tasks. While a traceability information model or some similar specification of permissible links between artifact types can predefine the intended types of trace to establish and use, the overall tracery obtained in practice is rarely designed or scrutinized. The sum total of the actual traces created within a project provides the scaffolding for supporting many diverse engineering activities. They deserve far more attention.","1937-4194","","10.1109/MS.2011.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984800","software engineering;requirements;techniques;agile;creativity;meaning carriers","Software engineering;Software reliability","formal verification;program diagnostics;software engineering","software traceability;software development;diverse engineering activities;requirements tracery","","1","","2","","18 Aug 2011","","","IEEE","IEEE Magazines"
"A Follow-Up Reflection on Software Process Improvement ROI","R. van Solingen",Delft University of Technology,"IEEE Software","25 Aug 2009","2009","26","5","77","79","Our discipline must shift toward value-based software engineering, because we're obliged to prove our contributions to the financial bottom line. In the May/June 2004 IEEE Software special issue on return on investment (ROI), the author presented measurement results for the ROI of software process improvement (SPI). This article made three main contributions. First, provided a detailed overview of publications containing real-life measurement results from practical applications of SPI, in which the author measured the ROI. My study included 20 cases, with an average ROI of 7 and a median of 6.6. This indicates that SPI's net profit seems to be approximately US$7 for every dollar invested. However, I found no published cases in which SPI investments resulted in a measurable loss; furthermore, the ROI bandwidth was large (between 1.5 and 19). This indicates that the actual ROI of an SPI investment seems hard to really guarantee up front. Second, I showed that benefits are just as easy to quantify as costs. Cost measurements are always based on an agreement about how to measure and quantify costs. Such an agreement can also serve as the basis for measuring benefits. My article contained data from two real-life projects that had made such cost and benefit measurements and calculated ROI. Finally, I concluded that expressing ""value"" is crucial. Software engineering and its improvement are often major investments for organizations. Investments must be profitable. Because different people in different roles share one generic term for value-money, I recommended expressing any software engineering effort and its benefits in financial terms.","1937-4194","","10.1109/MS.2009.120","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222799","software process improvement;return on investment;value-based software engineering;Six Sigma;management commitment;benefit measurement","Reflection;Financial management;Investments;Software engineering;Software measurement;Computer science;Computer industry;Data analysis;Data engineering;Economic indicators","software cost estimation;software metrics;software process improvement","follow-up reflection;ROI software process improvement;value-based software engineering;SPI investment;cost measurement;software organization","","3","","9","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Assessing the Effectiveness of Sequence Diagrams in the Comprehension of Functional Requirements: Results from a Family of Five Experiments","S. Abrahão; C. Gravino; E. Insfran; G. Scanniello; G. Tortora","Universitat Politècnica de València, València; University of Salerno via Ponte Don Melillo, Salerno; Universitat Politècnica de València, València; University of Basilicata Viale DellAteneo, Macchia Romana, Potenza; University of Salerno via Ponte Don Melillo, Salerno","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","327","342","Modeling is a fundamental activity within the requirements engineering process and concerns the construction of abstract descriptions of requirements that are amenable to interpretation and validation. The choice of a modeling technique is critical whenever it is necessary to discuss the interpretation and validation of requirements. This is particularly true in the case of functional requirements and stakeholders with divergent goals and different backgrounds and experience. This paper presents the results of a family of experiments conducted with students and professionals to investigate whether the comprehension of functional requirements is influenced by the use of dynamic models that are represented by means of the UML sequence diagrams. The family contains five experiments performed in different locations and with 112 participants of different abilities and levels of experience with UML. The results show that sequence diagrams improve the comprehension of the modeled functional requirements in the case of high ability and more experienced participants.","1939-3520","","10.1109/TSE.2012.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6193111","Documentation;software engineering;requirements specifications","Unified modeling language;Object oriented modeling;Analytical models;Computational modeling;Software systems;Materials","formal specification;Unified Modeling Language","effectiveness assessment;UML sequence diagrams;functional requirements;family-of-five experiments;requirements engineering process;abstract descriptions;requirement interpretation;requirement validation;functional stakeholders;software engineering;requirements specifications;unified modeling language","","38","","55","","1 May 2012","","","IEEE","IEEE Journals"
"Automated Abstractions for Contract Validation","G. de Caso; V. Braberman; D. Garbervetsky; S. Uchitel","FCEyN, Universidad de Buenos Aires, Buenos Aires; FCEyN, Universidad de Buenos Aires, Buenos Aires; FCEyN, Universidad de Buenos Aires, Buenos Aires; FCEyN, Universidad de Buenos Aires, Buenos Aires and Imperial College, London","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","141","162","Pre/postcondition-based specifications are commonplace in a variety of software engineering activities that range from requirements through to design and implementation. The fragmented nature of these specifications can hinder validation as it is difficult to understand if the specifications for the various operations fit together well. In this paper, we propose a novel technique for automatically constructing abstractions in the form of behavior models from pre/postcondition-based specifications. Abstraction techniques have been used successfully for addressing the complexity of formal artifacts in software engineering; however, the focus has been, up to now, on abstractions for verification. Our aim is abstraction for validation and hence, different and novel trade-offs between precision and tractability are required. More specifically, in this paper, we define and study enabledness-preserving abstractions, that is, models in which concrete states are grouped according to the set of operations that they enable. The abstraction results in a finite model that is intuitive to validate and which facilitates tracing back to the specification for debugging. The paper also reports on the application of the approach to two industrial strength protocol specifications in which concerns were identified.","1939-3520","","10.1109/TSE.2010.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5639021","Requirements/specifications;validation;automated abstraction.","Validation;Software engineering;Object oriented modeling;Protocols;Buffer storage","formal specification;software engineering","automated abstractions;contract validation;software engineering;behavior models;postcondition based specifications;precondition based specifications;formal artifacts;industrial strength","","22","","38","","18 Nov 2010","","","IEEE","IEEE Journals"
"A Taxonomy and Mapping of Computer-Based Critiquing Tools","N. M. Ali; J. Hosking; J. Grundy","Universiti Putra Malaysia, Selangor; Australian National University, Canberra; Swinburne University, Melbourne","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1494","1520","Critics have emerged in recent times as a specific tool feature to support users in computer-mediated tasks. These computer-supported critics provide proactive guidelines or suggestions for improvement to designs, code, and other digital artifacts. The concept of a critic has been adopted in various domains, including medical, programming, software engineering, design sketching, and others. Critics have been shown to be an effective mechanism for providing feedback to users. We propose a new critic taxonomy based on extensive review of the critic literature. The groups and elements of our critic taxonomy are presented and explained collectively with examples, including the mapping of 13 existing critic tools, predominantly for software engineering and programming education tasks to the taxonomy. We believe this critic taxonomy will assist others in identifying, categorizing, developing, and deploying computer-supported critics in a range of domains.","1939-3520","","10.1109/TSE.2013.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6570472","Design critics;critiquing systems;critic taxonomy;software tool support;survey","Taxonomy;Software;Recommender systems;Programming;Software engineering;Unified modeling language;Java","computer science education;programming;software engineering","computer-based critiquing tool taxonomy;computer-based critiquing tool mapping;computer-mediated tasks;computer-supported critics;digital artifacts;critic taxonomy;software engineering;programming education tasks","","8","","68","","26 Jul 2013","","","IEEE","IEEE Journals"
"Naïveté Squared: In Search of Two Taxonomies and a Mapping between Them","R. L. Glass; I. Vessey","Griffith Univ., Brisbane, QLD, Australia; Univ. of Queensland, Brisbane, QLD, Australia","IEEE Software","18 Aug 2011","2011","28","5","14","15","The authors describe an issue that they think is extremely important: the relationship between applications and solutions in the software engineering and information systems fields. In particular, they believe the fields desperately need a taxonomy of application domains, a taxonomy of solution approaches, and a mapping between the two. This article has a Web extra that offers an interview with one of the article's authors, Robert L. Glass, about the ""dark side"" of this topic.","1937-4194","","10.1109/MS.2011.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984790","taxonomy;application domains;software solutions","Software development;Taxonomy;Information systems;Information services;Software engineering;Information retrieval;Industry applications;Computer applications","information systems;software engineering","taxonomies;software engineering;information systems fields","","","2","","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Practicing What We Preach","S. Ghaisas",Tata Consultancy Services,"IEEE Software","28 Feb 2014","2014","31","1","88","92","The rhetorical question ""do we practice what we preach?"" still seems to be relevant, even a decade after it appeared on the requirements engineering research landscape. New perspectives from various seasoned professionals from India address the question yet again. The Web extra at http://youtu.be/QtJcaibyetw is an audio podcast of Requirements column editor Jane Cleland-Huang speaking with Tony Gorschek, a professor of software engineering at the Blekinge Institute of Technology with more than 10 years of experience as a CTO, senior executive consultant, engineer, chief architect, and product manager, about technology transfer in the requirements engineering field.","1937-4194","","10.1109/MS.2014.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6750452","requirements;requirements engineering;fieldwork;requirements practitioners;India","Requirements engineering;Strategic planning;Software engineering;Companies","software engineering;systems analysis","requirements engineering;software engineering;RE community","","3","","8","","28 Feb 2014","","","IEEE","IEEE Magazines"
"Adaptive Multi-Objective Evolutionary Algorithms for Overtime Planning in Software Projects","F. Sarro; F. Ferrucci; M. Harman; A. Manna; J. Ren","University College London, CREST Centre, London, United Kingdom; University of Salerno, Fisciano, SA, Italy; University College London, CREST Centre, London, United Kingdom; University of Salerno, Fisciano, SA, Italy; Beihang University, Beijing, China","IEEE Transactions on Software Engineering","13 Oct 2017","2017","43","10","898","917","Software engineering and development is well-known to suffer from unplanned overtime, which causes stress and illness in engineers and can lead to poor quality software with higher defects. Recently, we introduced a multi-objective decision support approach to help balance project risks and duration against overtime, so that software engineers can better plan overtime. This approach was empirically evaluated on six real world software projects and compared against state-of-the-art evolutionary approaches and currently used overtime strategies. The results showed that our proposal comfortably outperformed all the benchmarks considered. This paper extends our previous work by investigating adaptive multi-objective approaches to meta-heuristic operator selection, thereby extending and (as the results show) improving algorithmic performance. We also extended our empirical study to include two new real world software projects, thereby enhancing the scientific evidence for the technical performance claims made in the paper. Our new results, over all eight projects studied, showed that our adaptive algorithm outperforms the considered state of the art multi-objective approaches in 93 percent of the experiments (with large effect size). The results also confirm that our approach significantly outperforms current overtime planning practices in 100 percent of the experiments (with large effect size).","1939-3520","","10.1109/TSE.2017.2650914","EPSRC; Microsoft Azure Research; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7814340","Software engineering;management;planning;search-based software engineering;project scheduling;overtime;hyperheuristic;multi-objective evolutionary algorithms;NSGAII","Software;Planning;Software engineering;Search problems;Adaptive algorithms;Project management;Standards","decision support systems;DP management;evolutionary computation;project management;software development management;software quality","adaptive multiobjective evolutionary algorithms;multiobjective decision support approach;project risks;software engineers;evolutionary approaches;overtime strategies;adaptive multiobjective approaches;meta-heuristic operator selection;software projects;overtime planning practices","","7","","96","CCBY","11 Jan 2017","","","IEEE","IEEE Journals"
"The Birth of Refactoring: A Retrospective on the Nature of High-Impact Software Engineering Research","W. G. Griswold; W. F. Opdyke","University of California, San Diego; JPMorgan Chase","IEEE Software","28 Oct 2015","2015","32","6","30","38","Software refactoring was independently invented in the late '80s by two students in two research groups: Ralph Johnson's group at the University of Illinois and David Notkin's group at the University of Washington. This article provides a retrospective of the birth of refactoring, reflecting on how the ideas came about and were developed in those two students' doctoral dissertations. The analysis provides useful insights for both researchers and practitioners seeking high impact in their work. This article is part of a special issue on Refactoring.","1937-4194","","10.1109/MS.2015.107","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7274256","refactoring;program restructuring;integrated development environment;history;software development;software engineering;Ralph Johnson;David Notkin;Bill Griswold;Bill Opdyke","Code refractoring;Data structures;Programming;Software engineering;Technological innovation;Semantics;Software development","software maintenance","high-impact software engineering research;software refactoring","","11","","22","","23 Sep 2015","","","IEEE","IEEE Magazines"
"Point/Counterpoint","J. Singer; M. Vigder; J. Segal; S. Clarke",National Research Council Canada; National Research Council Canada; Open University; Microsoft,"IEEE Software","25 Aug 2009","2009","26","5","54","57","Tools help end users develop software, but they're effective only when combined with a basic understanding of software engineering. Given this proliferation of new and old capabilities, how will end users exploit the programming possibilities available to them? Will tools to support end users be enough - or should everyone be taught some form of software engineering literacy? We believe we need a new literacy: not just reading, writing, and arithmetic, but the 3 Rs + SE. With such an education, end users will have greater success customizing environments and manipulating digital information correctly and thoughtfully.","1937-4194","","10.1109/MS.2009.135","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222795","end-user programming;software engineering;version control;configuration management;software testing;debugging;software maintenance","Software engineering;Programming profession;Collaborative work;Collaborative tools;Application software;Collaborative software;Control systems;Engineering management;Software tools;Cellular phones","computer science education;programming;reverse engineering;software tools;teaching","end-user programming teaching;software engineering literacy;software tools;software development;software understanding;SE education;software environment customization;digital information manipulation;reading-writing-and-arithmetic;3 Rs","","","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Empirical Principles and an Industrial Case Study in Retrieving Equivalent Requirements via Natural Language Processing Techniques","D. Falessi; G. Cantone; G. Canfora","Simula Research Laboratory, Lysaker and University of Rome ""TorVergata"", Rome; University of Rome ""TorVergata"", Rome; University of Sannio, Benevento","IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","18","44","Though very important in software engineering, linking artifacts of the same type (clone detection) or different types (traceability recovery) is extremely tedious, error-prone, and effort-intensive. Past research focused on supporting analysts with techniques based on Natural Language Processing (NLP) to identify candidate links. Because many NLP techniques exist and their performance varies according to context, it is crucial to define and use reliable evaluation procedures. The aim of this paper is to propose a set of seven principles for evaluating the performance of NLP techniques in identifying equivalent requirements. In this paper, we conjecture, and verify, that NLP techniques perform on a given dataset according to both ability and the odds of identifying equivalent requirements correctly. For instance, when the odds of identifying equivalent requirements are very high, then it is reasonable to expect that NLP techniques will result in good performance. Our key idea is to measure this random factor of the specific dataset(s) in use and then adjust the observed performance accordingly. To support the application of the principles we report their practical application to a case study that evaluates the performance of a large number of NLP techniques for identifying equivalent requirements in the context of an Italian company in the defense and aerospace domain. The current application context is the evaluation of NLP techniques to identify equivalent requirements. However, most of the proposed principles seem applicable to evaluating any estimation technique aimed at supporting a binary decision (e.g., equivalent/nonequivalent), with the estimate in the range [0,1] (e.g., the similarity provided by the NLP), when the dataset(s) is used as a benchmark (i.e., testbed), independently of the type of estimator (i.e., requirements text) and of the estimation method (e.g., NLP).","1939-3520","","10.1109/TSE.2011.122","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6112783","Empirical software engineering;traceability recovery;natural language processing;equivalent requirements;metrics and measurement","Natural language processing;Context;Semantics;Measurement;Matrix decomposition;Monitoring;Thesauri","information retrieval;natural language processing;program diagnostics;software engineering","industrial case study;equivalent requirement retrieval;natural language processing techniques;software engineering;traceability recovery;clone detection;NLP techniques;reliable evaluation procedures;Italian company;aerospace domain;defense domain;estimation technique;binary decision","","55","","116","","27 Dec 2011","","","IEEE","IEEE Journals"
"Dynamic QoS Management and Optimization in Service-Based Systems","R. Calinescu; L. Grunske; M. Kwiatkowska; R. Mirandola; G. Tamburrelli","Aston University, Birmingham; Swinburne University of Technology, Swinburne; Oxford University Computing Laboratories, Oxford; Politecnico di Milano, Milano; Politecnico di Milano, Milano","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","387","409","Service-based systems that are dynamically composed at runtime to provide complex, adaptive functionality are currently one of the main development paradigms in software engineering. However, the Quality of Service (QoS) delivered by these systems remains an important concern, and needs to be managed in an equally adaptive and predictable way. To address this need, we introduce a novel, tool-supported framework for the development of adaptive service-based systems called QoSMOS (QoS Management and Optimization of Service-based systems). QoSMOS can be used to develop service-based systems that achieve their QoS requirements through dynamically adapting to changes in the system state, environment, and workload. QoSMOS service-based systems translate high-level QoS requirements specified by their administrators into probabilistic temporal logic formulae, which are then formally and automatically analyzed to identify and enforce optimal system configurations. The QoSMOS self-adaptation mechanism can handle reliability and performance-related QoS requirements, and can be integrated into newly developed solutions or legacy systems. The effectiveness and scalability of the approach are validated using simulations and a set of experiments based on an implementation of an adaptive service-based system for remote medical assistance.","1939-3520","","10.1109/TSE.2010.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5611553","Service-oriented software engineering;QoS management;QoS optimization;adaptive systems.","Quality of service;Markov processes;Probabilistic logic;Unified modeling language;Analytical models;Optimization;Scattering","health care;medical computing;optimisation;quality of service;software engineering","QoS management;optimization;service-based systems;software engineering;QoSMOS;remote medical assistance;health care","","185","1","102","","28 Oct 2010","","","IEEE","IEEE Journals"
"Assessing the Refactorability of Software Clones","N. Tsantalis; D. Mazinanian; G. P. Krishnan","Department of Computer Science and Software Engineering, Concordia University, Montreal, Quebec, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, Quebec, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, Quebec, Canada","IEEE Transactions on Software Engineering","10 Nov 2015","2015","41","11","1055","1090","The presence of duplicated code in software systems is significant and several studies have shown that clones can be potentially harmful with respect to the maintainability and evolution of the source code. Despite the significance of the problem, there is still limited support for eliminating software clones through refactoring, because the unification and merging of duplicated code is a very challenging problem, especially when software clones have gone through several modifications after their initial introduction. In this work, we propose an approach for automatically assessing whether a pair of clones can be safely refactored without changing the behavior of the program. In particular, our approach examines if the differences present between the clones can be safely parameterized without causing any side-effects. The evaluation results have shown that the clones assessed as refactorable by our approach can be indeed refactored without causing any compile errors or test failures. Additionally, the computational cost of the proposed approach is negligible (less than a second) in the vast majority of the examined cases. Finally, we perform a large-scale empirical study on over a million clone pairs detected by four different clone detection tools in nine open-source projects to investigate how refactorability is affected by different clone properties and tool configuration options. Among the highlights of our conclusions, we found that (a) clones in production code tend to be more refactorable than clones in test code, (b) clones with a close relative location (i.e., same method, type, or file) tend to be more refactorable than clones in distant locations (i.e., same hierarchy, or unrelated types), (c) Type-1 clones tend to be more refactorable than the other clone types, and (d) clones with a small size tend to be more refactorable than clones with a larger size.","1939-3520","","10.1109/TSE.2015.2448531","European Union (European Social Fund—ESF); Greek national funds through the Operational Program; National Strategic Reference Framework (NSRF); Thalis—Athens University of Economics; Business—Software Engineering Research Platform; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7130676","Code duplication;Software clone management;Clone refactoring;Refactorability assessment;Empirical study;Code duplication;software clone management;clone refactoring;refactorability assessment;empirical study","Cloning;Arrays;Java;Software systems;Production;Space exploration","software maintenance;software management;source code (software)","software clone refactorability assessment;duplicated code;software systems;source code evolution;source code maintainability;duplicated code merging;duplicated code unification;compile errors;test failures;computational cost;large-scale empirical;clone pairs;clone detection tools;open-source projects;clone properties;tool configuration;test code;relative location;distant locations;type-1 clones","","31","","63","","22 Jun 2015","","","IEEE","IEEE Journals"
"Evaluating the Effects of Architectural Documentation: A Case Study of a Large Scale Open Source Project","R. Kazman; D. Goldenson; I. Monarch; W. Nichols; G. Valetto","Software Engineering Institute, Pittsburgh, PA; Software Engineering Institute, Pittsburgh, PA; NA; Software Engineering Institute, Pittsburgh, PA; Distributed Adaptive Systems research unit at Fondazione Bruno Kessler, Italy","IEEE Transactions on Software Engineering","11 Mar 2016","2016","42","3","220","260","Sustaining large open source development efforts requires recruiting new participants; however, a lack of architectural documentation might inhibit new participants since large amounts of project knowledge are unavailable to newcomers. We present the results of a multitrait, multimethod analysis of the effects of introducing architectural documentation into a substantial open source project-the Hadoop Distributed File System (HDFS). HDFS had only minimal architectural documentation, and we wanted to discover whether the putative benefits of architectural documentation could be observed over time. To do this, we created and publicized an architecture document and then monitored its usage and effects on the project. The results were somewhat ambiguous: by some measures the architecture documentation appeared to effect the project but not by others. Perhaps of equal importance is our discovery that the project maintained, in its Web-accessible JIRA archive of software issues and fixes, enough architectural discussion to support architectural thinking and reasoning. This “emergent” architecture documentation served an important purpose in recording core project members' architectural concerns and resolutions. However, this emergent architecture documentation did not serve all project members equally well; it appears that those on the periphery of the project-newcomers and adopters-still require explicit architecture documentation, as we will show.","1939-3520","","10.1109/TSE.2015.2465387","Department of Defense; Carnegie Mellon University; Software Engineering Institute; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7230299","software architecture,;open source software,;documentation;Software architecture;open source software;documentation","Documentation;Computer architecture;Social network services;Electronic mail;Measurement;Open source software","distributed databases;public domain software;software architecture","large-scale substantial open source project;architectural documentation;project knowledge;multitrait-multimethod analysis;Hadoop distributed file system;HDFS;Web-accessible JIRA archive;architectural thinking;architectural reasoning;project members","","13","","77","","31 Aug 2015","","","IEEE","IEEE Journals"
"Generating Complete Controllable Test Suites for Distributed Testing","R. M. Hierons","Department of Computer Science, Brunel University, United Kingdom","IEEE Transactions on Software Engineering","11 Mar 2015","2015","41","3","279","293","A test suite is m-complete for finite state machine (FSM) M if it distinguishes between M and all faulty FSMs with m states or fewer. While there are several algorithms that generate m-complete test suites, they cannot be directly used in distributed testing since there can be additional controllability and observability problems. Indeed, previous results show that there is no general method for generating an m-complete test suite for distributed testing and so the focus has been on conditions under which this is possible. This paper takes a different approach, which is to generate what we call cm-complete test suites: controllable test suites that distinguish an FSM N with no more than m states from M if this is possible in controllable testing. Thus, under the hypothesis that the system under test has no more than m states, a cm-complete test suite achieves as much as is possible given the restriction that testing should be controllable. We show how the problem of generating a cm-complete test suite can be mapped to the problem of generating an m-complete test suite for a partial FSM. Thus, standard test suite generation methods can be adapted for use in distributed testing.","1939-3520","","10.1109/TSE.2014.2364035","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6930767","Software engineering/software/program verification;software engineering/testing and debugging;systems and software;distributed testing;test suite generation;checking experiment;Software engineering/software/program verification;software engineering/testing and debugging;systems and software;distributed testing;test suite generation;checking experiment","Testing;Controllability;Ports (Computers);Protocols;Automata;Computer architecture;Observability","distributed processing;finite state machines;program debugging;program testing","complete controllable test suite generation;distributed testing;m-complete test suite;finite state machine;faulty FSM;controllability problem;observability problem;cm-complete test suites;controllable testing;system under test;partial-FSM;standard test suite generation methods","","10","","49","","20 Oct 2014","","","IEEE","IEEE Journals"
"The Value of Doubt","G. J. Holzmann",Jet Propulsion Laboratory,"IEEE Software","16 Jan 2017","2017","34","1","106","109","Doubt is key to becoming a good programmer. If you don't doubt the correctness of your work, you have no incentive to look for the hidden spoilers that are always there.","1937-4194","","10.1109/MS.2017.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819389","debugging;software bugs;Morris worm;secure software;software development;software engineering","Computer bugs;Debugging;Software reliability;Computer security;Software testing","software engineering","doubt value;software engineering","","2","","3","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Point/Counterpoint","D. L. Parnas; B. Curtis",Middle Road Software; Cast Software,"IEEE Software","16 Oct 2009","2009","26","6","56","59","The need for empirical research into the practicality and efficacy of software development methods is obvious but most published papers have inadequate experimental design. The assumption that what programmers do is ""natural,"" and somehow right or practical, needs to be questioned seriously. Human beings haven't evolved by natural selection to be good programmers. There are people alive today who worked on the first electronic computers. Further, almost all of today's programmers learned from earlier programmers; either they were explicitly taught or they observed how the programmers that preceded them had done their work. If those pioneers were wrong, the methods that we now perceive as natural or intuitive will also be wrong. We can't simply conclude that what we observe in projects today is the best way to do something.","1937-4194","","10.1109/MS.2009.184","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287010","empirical research;software engineering;analysis;independent variables;controlled experiments;exploratory observational studies","Programming profession;Design for experiments;Humans","software engineering","software engineering;software development;experimental design;natural selection;electronic computer","","6","","6","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Vulnerability Discovery with Attack Injection","J. Antunes; N. Neves; M. Correia; P. Verissimo; R. Neves","University of Lisboa, Lisboa; University of Lisboa, Lisboa; University of Lisboa, Lisboa; University of Lisboa, Lisboa; Technical University of Lisbon, Lisboa","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","357","370","The increasing reliance put on networked computer systems demands higher levels of dependability. This is even more relevant as new threats and forms of attack are constantly being revealed, compromising the security of systems. This paper addresses this problem by presenting an attack injection methodology for the automatic discovery of vulnerabilities in software components. The proposed methodology, implemented in AJECT, follows an approach similar to hackers and security analysts to discover vulnerabilities in network-connected servers. AJECT uses a specification of the server's communication protocol and predefined test case generation algorithms to automatically create a large number of attacks. Then, while it injects these attacks through the network, it monitors the execution of the server in the target system and the responses returned to the clients. The observation of an unexpected behavior suggests the presence of a vulnerability that was triggered by some particular attack (or group of attacks). This attack can then be used to reproduce the anomaly and to assist the removal of the error. To assess the usefulness of this approach, several attack injection campaigns were performed with 16 publicly available POP and IMAP servers. The results show that AJECT could effectively be used to locate vulnerabilities, even on well-known servers tested throughout the years.","1939-3520","","10.1109/TSE.2009.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5374427","Testing and debugging;software engineering;test design;testing tools;experimental evaluation;fault injection;attack injection.","Network servers;Software testing;Protocols;Debugging;Application software;Computer networks;Computer hacking;Communication system security;Automatic testing;Software engineering","computer crime;software engineering","vulnerability discovery;attack injection;networked computer systems;software components;security analysts;hackers analysts;AJECT;IMAP servers;POP servers","","24","1","33","","8 Jan 2010","","","IEEE","IEEE Journals"
"Introducing the Pragmatic Architect","F. Buschmann",Siemens Corporate Technology,"IEEE Software","25 Aug 2009","2009","26","5","10","11","This paper present the software architecture, design, and development-but through the eyes of a practicing software architect. From such a perspective, software engineering can appear surprisingly different. This is what's new about this column and what you'll hopefully enjoy-a fresh, new light on the practices and state-of-the-art of the profession.","1937-4194","","10.1109/MS.2009.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222785","software architect;software architecture;software engineering","Computer architecture;Software architecture;Software engineering;Books;Business communication;Design methodology;Publishing;Large-scale systems;Computer industry;Manufacturing automation","software architecture","pragmatic architect;software architecture;software development;software engineering;software architect","","5","","5","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Voice Of Evidence: A look back","F. Shull; T. Dybå; H. Sharp; R. Prikladnicki","Carnegie Mellon University's Software Engineering Institute; SINTEF Digital; The Open University, Milton Keynes; Pontifícia Universidade Católica do Rio Grande do Sul","IEEE Software","11 Jul 2017","2017","34","4","23","25","To celebrate the 200th issue of IEEE Software, Voice of Evidence uses data to examine whether it has helped bridge the gap between research and practice by extracting actionable lessons from the body of research.","1937-4194","","10.1109/MS.2017.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974677","Voice of Evidence;software development;software engineering","Research and development;Software engineering;Bibliometrics","","","","1","","","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Toward Agile Architecture: Insights from 15 Years of ATAM Data","S. Bellomo; I. Gorton; R. Kazman",Software Engineering Institute; Software Engineering Institute; Software Engineering Institute,"IEEE Software","21 Aug 2015","2015","32","5","38","45","Agile teams strive to balance short-term feature development with longer-term quality concerns. These evolutionary approaches often hit a ""complexity wall""' from the cumulative effects of unplanned changes, resulting in unreliable, poorly performing software. So, the agile community is refocusing on approaches to address architectural concerns. Researchers analyzed quality attribute concerns from 15 years of Architecture Trade-Off Analysis Method data, gathered from 31 projects. Modifiability was the dominant concern across all project types; performance, availability, and interoperability also received considerable attention. For IT projects, a relatively new quality-deployability-emerged as a key concern. The study results provide insights for agile teams allocating architecture-related tasks to iterations. For example, teams can use these results to create checklists for release planning or retrospectives to help assess whether to address a given quality to support future needs. This article is part of a special issue on Software Architecture.","1937-4194","","10.1109/MS.2015.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7024074","architecture evaluation;agile;technical debt;incremental development;modifiability;availability;interoperability;deployability;software development;software engineering","Computer architecture;Software architecture;Software development;Complexity theory;Interoperability;Software engineering;Encoding","open systems;software architecture;software performance evaluation;software prototyping;software reliability","agile architecture;ATAM data;agile teams;short-term feature development;longer-term quality concerns;complexity wall;agile community;architecture trade-off analysis method data;interoperability;availability;IT projects;architecture-related task allocation;software architecture","","20","","11","","27 Jan 2015","","","IEEE","IEEE Magazines"
"Building Pipelines for Heterogeneous Execution Environments for Big Data Processing","D. Wu; L. Zhu; X. Xu; S. Sakr; D. Sun; Q. Lu",NICTA; NICTA; NICTA; NICTA; NICTA; NICTA,"IEEE Software","26 Feb 2016","2016","33","2","60","67","Many real-world data analysis scenarios require pipelining and integration of multiple (big) data-processing and data-analytics jobs, which often execute in heterogeneous environments, such as MapReduce; Spark; or R, Python, or Bash scripts. Such a pipeline requires much glue code to get data across environments. Maintaining and evolving these pipelines are difficult. Pipeline frameworks that try to solve such problems are usually built on top of a single environment. They might require rewriting the original job to take into account a new API or paradigm. The Pipeline61 framework supports the building of data pipelines involving heterogeneous execution environments. It reuses the existing code of the deployed jobs in different environments and provides version control and dependency management that deals with typical software engineering issues. A real-world case study shows its effectiveness. This article is part of a special issue on Software Engineering for Big Data Systems.","1937-4194","","10.1109/MS.2016.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420521","big data;pipeline;Spark;MapReduce;software engineering;software development;Pipeline61","Big data;Pipeline processing;Software engineering;Context modeling;Data analysis;Programming;Software development","application program interfaces;Big Data;data analysis;pipeline processing;software engineering","software engineering;data pipeline;API;glue code;data-analytics;multiple Big data-processing;real-world data analysis;heterogeneous execution environment","","21","","1","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Evaluation of Accuracy in Design Pattern Occurrence Detection","N. Pettersson; W. Löwe; J. Nivre","Växjö University, Växjö; Växjö University, Växjö; Växjö University, Växjö","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","575","590","Detection of design pattern occurrences is part of several solutions to software engineering problems, and high accuracy of detection is important to help solve the actual problems. The improvement in accuracy of design pattern occurrence detection requires some way of evaluating various approaches. Currently, there are several different methods used in the community to evaluate accuracy. We show that these differences may greatly influence the accuracy results, which makes it nearly impossible to compare the quality of different techniques. We propose a benchmark suite to improve the situation and a community effort to contribute to, and evolve, the benchmark suite. Also, we propose fine-grained metrics assessing the accuracy of various approaches in the benchmark suite. This allows comparing the detection techniques and helps improve the accuracy of detecting design pattern occurrences.","1939-3520","","10.1109/TSE.2009.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5374428","Patterns;object-oriented design methods;measurement techniques;evaluation;reverse engineering;reengineering;restructuring.","Design methodology;Software systems;Computer science;Natural languages;Software engineering;Measurement techniques;Reverse engineering;Software tools;Application software;Software quality","object-oriented methods;software engineering;software metrics;software performance evaluation","design pattern occurrence detection;software engineering problem;fine grained metric;benchmark suite","","39","","47","","8 Jan 2010","","","IEEE","IEEE Journals"
"Assessing, Comparing, and Combining State Machine-Based Testing and Structural Testing: A Series of Experiments","S. Mouchawrab; L. C. Briand; Y. Labiche; M. Di Penta","Carleton University, Ottawa, Canada; Simula Research Laboratory, Lysaker, Norway; Carleton University, Ottawa, Canada; University of Sannio, Benevento, Italy","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","161","187","A large number of research works have addressed the importance of models in software engineering. However, the adoption of model-based techniques in software organizations is limited since these models are perceived to be expensive and not necessarily cost-effective. Focusing on model-based testing, this paper reports on a series of controlled experiments. It investigates the impact of state machine testing on fault detection in class clusters and its cost when compared with structural testing. Based on previous work showing this is a good compromise in terms of cost and effectiveness, this paper focuses on a specific state-based technique: the round-trip paths coverage criterion. Round-trip paths testing is compared to structural testing, and it is investigated whether they are complementary. Results show that even when a state machine models the behavior of the cluster under test as accurately as possible, no significant difference between the fault detection effectiveness of the two test strategies is observed, while the two test strategies are significantly more effective when combined by augmenting state machine testing with structural testing. A qualitative analysis also investigates the reasons why test techniques do not detect certain faults and how the cost of state machine testing can be brought down.","1939-3520","","10.1109/TSE.2010.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416729","State-based software testing;structural testing;controlled experiments;state machines.","Object oriented modeling;Costs;Fault detection;Unified modeling language;System testing;Software testing;Automatic testing;Software engineering;Software design;Logic testing","fault tolerant computing;finite state machines;program testing;software engineering","state machine based testing;software engineering;model based techniques;software organizations;fault detection;round trip paths testing;structural testing","","46","","69","","18 Feb 2010","","","IEEE","IEEE Journals"
"Dealing with Traceability in the MDDof Model Transformations","J. M. Vara; V. A. Bollati; Á. Jiménez; E. Marcos","Computing Languages and Systems - II, University Rey Juan Carlos, Mostoles, Madrid, Spain; Computing Languages and Systems - II, University Rey Juan Carlos, Mostoles, Madrid, Spain; Computing Languages and Systems - II, University Rey Juan Carlos, Mostoles, Madrid, Spain; Computing Languages and Systems - II, University Rey Juan Carlos, Mostoles, Madrid, Spain","IEEE Transactions on Software Engineering","17 Jun 2014","2014","40","6","555","583","Traceability has always been acknowledged as a relevant topic in Software Engineering. However, keeping track of the relationships between the different assets involved in a development process is a complex and tedious task. The fact that the main assets handled in any model-driven engineering project are models and model transformations eases the task. In order to take advantage of this scenario, which has not been appropriately capitalized on by the most widely adopted model transformation languages before, this work presents MeTAGeM-Trace, a methodological and technical proposal with which to support the model-driven development of model transformations that include trace generation. The underlying idea is to start from a high-level specification of the transformation which is subsequently refined into lower-level transformation models in terms of a set of DSLs until the source code that implements the transformation can be generated. Running this transformation produces not only the corresponding target models, but also a trace model between the elements of the source and target models. As part of the proposal, an EMF-based toolkit has been developed to support the development of ATL and ETL model transformations. This toolkit has been empirically validated by conducting a set of case studies following a systematic research methodology.","1939-3520","","10.1109/TSE.2014.2316132","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6784505","Model-driven engineering;model transformations;traceability","Proposals;Object oriented modeling;Software;DSL;Complexity theory;Data models;Software engineering","research and development;software engineering;source code (software)","MDD;traceability;software engineering;model-driven engineering project;model transformation languages;MeTAGeM-Trace;trace generation;lower-level transformation models;DSL;source code;EMF-based toolkit;ATL model transformations;ETL model transformations;systematic research methodology","","13","","79","","8 Apr 2014","","","IEEE","IEEE Journals"
"Interactive, Evolutionary Search in Upstream Object-Oriented Class Design","C. L. Simons; I. C. Parmee; R. Gwynllyw","University of the West of England, Frenchay; University of the West of England, Frenchay; University of the West of England, Frenchay","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","798","816","Although much evidence exists to suggest that early life cycle software engineering design is a difficult task for software engineers to perform, current computational tool support for software engineers is limited. To address this limitation, interactive search-based approaches using evolutionary computation and software agents are investigated in experimental upstream design episodes for two example design domains. Results show that interactive evolutionary search, supported by software agents, appears highly promising. As an open system, search is steered jointly by designer preferences and software agents. Directly traceable to the design problem domain, a mass of useful and interesting class designs is arrived at which may be visualized by the designer with quantitative measures of structural integrity, such as design coupling and class cohesion. The class designs are found to be of equivalent or better coupling and cohesion when compared to a manual class design for the example design domains, and by exploiting concurrent execution, the runtime performance of the software agents is highly favorable.","1939-3520","","10.1109/TSE.2010.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432223","Software design;evolutionary computation;interactive search.","Software agents;Software design;Software performance;Software tools;Design engineering;Software engineering;Evolutionary computation;Open systems;Visualization;Runtime","evolutionary computation;interactive systems;object-oriented methods;open systems;search problems;software agents;software engineering","upstream object oriented class design;life cycle software engineering design;software agent;interactive evolutionary search;open system;design problem domain;structural integrity;concurrent execution;runtime performance","","50","2","66","","18 Mar 2010","","","IEEE","IEEE Journals"
"Extending the UML Statecharts Notation to Model Security Aspects","M. El-Attar; H. Luqman; P. Kárpáti; G. Sindre; A. L. Opdahl","Information and Computer Science Department, King Fahd University of Petroleum and Minerals, Dhahran, Kingdom of Saudi Arabia; Information and Computer Science Department, King Fahd University of Petroleum and Minerals, Dhahran, Kingdom of Saudi Arabia; Institute for Energy Technology, Halden, Norway; Department of Computer and Information Science, Norwegian University of Science and Technology, Trondheim, Norway; Department of Information Science and Media, University of Bergen, Bergen, Norway","IEEE Transactions on Software Engineering","14 Jul 2015","2015","41","7","661","690","Model driven security has become an active area of research during the past decade. While many research works have contributed significantly to this objective by extending popular modeling notations to model security aspects, there has been little modeling support for state-based views of security issues. This paper undertakes a scientific approach to propose a new notational set that extends the UML (Unified Modeling Language) statecharts notation. An online industrial survey was conducted to measure the perceptions of the new notation with respect to its semantic transparency as well as its coverage of modeling state based security aspects. The survey results indicate that the new notation encompasses the set of semantics required in a state based security modeling language and was largely intuitive to use and understand provided very little training. A subject-based empirical evaluation using software engineering professionals was also conducted to evaluate the cognitive effectiveness of the proposed notation. The main finding was that the new notation is cognitively more effective than the original notational set of UML statecharts as it allowed the subjects to read models created using the new notation much quicker.","1939-3520","","10.1109/TSE.2015.2396526","Deanship of Scientific Research; King Fahd University of Petroleum and Minerals; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7042284","Statecharts;Security Modeling;Extended Notation;Industrial Survey;Subject-Based Experiment;Statecharts;security modeling;extended notation;industrial survey;subject-based experiment","Unified modeling language;Security;Software engineering;Object oriented modeling;Semantics;Proposals;Educational institutions","security of data;software engineering;Unified Modeling Language","UML statecharts notation;model driven security;scientific approach;Unified Modeling Language statecharts notation;semantic transparency;modeling state based security aspect coverage;state based security modeling language;subject-based empirical evaluation;software engineering professionals;notation cognitive effectiveness","","13","","80","","13 Feb 2015","","","IEEE","IEEE Journals"
"Patterns in Effective Distributed Software Development","R. Prikladnicki; J. L. N. Audy; F. Shull","Pontifícia Universidade do Rio Grande do Sul; Pontifícia Universidade do Rio Grande do Sul; Fraunhofer Center for Experimental Software Engineering, Maryland","IEEE Software","25 Feb 2010","2010","27","2","12","15","As with many other industries today, software development must increasingly adapt to teams whose members work together but are geographically distributed. Many factors have contributed to this rise in distributed software development (DSD), including companies' desires to leverage skilled resources wherever they can be found and to reduce costs by working in different labor markets. Its increasing popularity has led to diverse industrial experience, which has in turn led to some best practices and an initial body of knowledge.","1937-4194","","10.1109/MS.2010.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420790","software development;offshoring","Programming;Computer industry;Costs;Best practices","software engineering","distributed software development;organizations;software engineering;software patterns;geographically distributed team members;labor markets","","19","","19","","25 Feb 2010","","","IEEE","IEEE Magazines"
"Self-Supervising BPEL Processes","L. Baresi; S. Guinea","Politecnico di Milano, Milano, Italy; Politecnico di Milano, Milano, Italy","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","247","263","Service compositions suffer changes in their partner services. Even if the composition does not change, its behavior may evolve over time and become incorrect. Such changes cannot be fully foreseen through prerelease validation, but impose a shift in the quality assessment activities. Provided functionality and quality of service must be continuously probed while the application executes, and the application itself must be able to take corrective actions to preserve its dependability and robustness. We propose the idea of self-supervising BPEL processes, that is, special-purpose compositions that assess their behavior and react through user-defined rules. Supervision consists of monitoring and recovery. The former checks the system's execution to see whether everything is proceeding as planned, while the latter attempts to fix any anomalies. The paper introduces two languages for defining monitoring and recovery and explains how to use them to enrich BPEL processes with self-supervision capabilities. Supervision is treated as a cross-cutting concern that is only blended at runtime, allowing different stakeholders to adopt different strategies with no impact on the actual business logic. The paper also presents a supervision-aware runtime framework for executing the enriched processes, and briefly discusses the results of in-lab experiments and of a first evaluation with industrial partners.","1939-3520","","10.1109/TSE.2010.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432226","Software engineering;software/program verification;assertion checkers;assertion languages;performance;design tools and techniques;distributed/Internet-based software engineering tools and techniques.","Runtime;Monitoring;Robustness;Software engineering;Application software;Quality assessment;Quality of service;Logic;Software performance;Software tools","business process re-engineering;program verification;service-oriented architecture;Web services","self supervising BPEL process;quality assessment;stakeholder;business logic;supervision aware runtime framework;industrial partner;business process execution language","","73","","41","","18 Mar 2010","","","IEEE","IEEE Journals"
"Learning Communicating Automata from MSCs","B. Bollig; J. Katoen; C. Kern; M. Leucker","ENS Cachan and CNRS, Cachan; RWTH Aachen University, Aachen; RWTH Aachen University, Aachen; Technical University Munich, Munich","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","390","408","This paper is concerned with bridging the gap between requirements and distributed systems. Requirements are defined as basic message sequence charts (MSCs) specifying positive and negative scenarios. Communicating finite-state machines (CFMs), i.e., finite automata that communicate via FIFO buffers, act as system realizations. The key contribution is a generalization of Angluin's learning algorithm for synthesizing CFMs from MSCs. This approach is exact-the resulting CFM precisely accepts the set of positive scenarios and rejects all negative ones-and yields fully asynchronous implementations. The paper investigates for which classes of MSC languages CFMs can be learned, presents an optimization technique for learning partial orders, and provides substantial empirical evidence indicating the practical feasibility of the approach.","1939-3520","","10.1109/TSE.2009.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5374425","Software engineering/requirements/specifications/elicitation methods;software engineering/design/design concepts;computing methodologies/artificial intelligence/learning/induction;theory of computation/computation by abstract devices/models of computation/automata.","Learning automata;Software engineering;Software design;Unified modeling language;Communication channels;System recovery;Computer Society;Design engineering;Design methodology;Artificial intelligence","distributed processing;finite state machines;learning (artificial intelligence)","communicating automata;MSC;message sequence charts;distributed systems;communicating finite-state machines;finite automata;FIFO buffers;Angluin learning algorithm;optimization technique","","13","","41","","8 Jan 2010","","","IEEE","IEEE Journals"
"How Developers' Experience and Ability Influence Web Application Comprehension Tasks Supported by UML Stereotypes: A Series of Four Experiments","F. Ricca; M. Di Penta; M. Torchiano; P. Tonella; M. Ceccato","University of Genova, Italy; University of Sannio, Benevento; Politecnico di Torino, Torino; Fondazione Bruno Kessler, Trento; Fondazione Bruno Kessler, Trento","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","96","118","In recent years, several design notations have been proposed to model domain-specific applications or reference architectures. In particular, Conallen has proposed the UML Web Application Extension (WAE): a UML extension to model Web applications. The aim of our empirical investigation is to test whether the usage of the Conallen notation supports comprehension and maintenance activities with significant benefits, and whether such benefits depend on developers ability and experience. This paper reports and discusses the results of a series of four experiments performed in different locations and with subjects possessing different experience-namely, undergraduate students, graduate students, and research associates-and different ability levels. The experiments aim at comparing performances of subjects in comprehension tasks where they have the source code complemented either by standard UML diagrams or by diagrams stereotyped using the Conallen notation. Results indicate that, although, in general, it is not possible to observe any significant benefit associated with the usage of stereotyped diagrams, the availability of stereotypes reduces the gap between subjects with low skill or experience and highly skilled or experienced subjects. Results suggest that organizations employing developers with low experience can achieve a significant performance improvement by adopting stereotyped UML diagrams for Web applications.","1939-3520","","10.1109/TSE.2009.69","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5332231","Documentation;maintenance;and enhancement;software engineering;software/software engineering.","Unified modeling language;Application software;Object oriented modeling;Software maintenance;Web pages;Software engineering;Computer Society;Computer architecture;Service oriented architecture;Testing","Internet;Unified Modeling Language","Web application comprehension tasks;UML stereotypes;source code;stereotyped diagrams","","52","","34","","13 Nov 2009","","","IEEE","IEEE Journals"
"Oracles for Distributed Testing","R. M. Hierons","Brunel University, Middlesex","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","629","641","The problem of deciding whether an observed behavior is acceptable is the oracle problem. When testing from a finite state machine (FSM), it is easy to solve the oracle problem and so it has received relatively little attention for FSMs. However, if the system under test has physically distributed interfaces, called ports, then in distributed testing, we observe a local trace at each port and we compare the set of local traces with the set of allowed behaviors (global traces). This paper investigates the oracle problem for deterministic and nondeterministic FSMs and for two alternative definitions of conformance for distributed testing. We show that the oracle problem can be solved in polynomial time for the weaker notion of conformance (⊆w) but is NP-hard for the stronger notion of conformance (⊆), even if the FSM is deterministic. However, when testing from a deterministic FSM with controllable input sequences, the oracle problem can be solved in polynomial time and similar results hold for nondeterministic FSMs. Thus, in some cases, the oracle problem can be efficiently solved when using ⊆s and where this is not the case, we can use the decision procedure for ⊆w as a sound approximation.","1939-3520","","10.1109/TSE.2011.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5750006","Software engineering/software/program verification;software engineering/testing and debugging;systems and software;distributed systems;finite state machine;nondeterminism;test oracle;controllability;local observability.","Testing;Controllability;Observability;Polynomials;Software;Software engineering","distributed processing;finite state machines;polynomials;program testing","distributed testing;oracle problem;finite state machine;FSM;physically distributed interfaces;polynomial time;weaker notion;NP-hard problem;sound approximation;decision procedure","","24","","37","","15 Apr 2011","","","IEEE","IEEE Journals"
"Frameworks Generate Domain-Specific Languages: A Case Study in the Multimedia Domain","X. Amatriain; P. Arumi","Telefonica Research, Barcelona, Spain; Universitat Pompeu Fabra, Barcelona, Spain","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","544","558","We present an approach to software framework development that includes the generation of domain-specific languages (DSLs) and pattern languages as goals for the process. Our model is made of three workflows-framework, metamodel, and patterns-and three phases-inception, construction, and formalization. The main conclusion is that when developing a framework, we can produce with minimal overhead-almost as a side effect-a metamodel with an associated DSL and a pattern language. Both outputs will not only help the framework evolve in the right direction, but will also be valuable in themselves. In order to illustrate these ideas, we present a case study in the multimedia domain. For several years, we have been developing a multimedia framework. The process has produced a full-fledged domain-specific metamodel for the multimedia domain, with an associated DSL and a pattern language.","1939-3520","","10.1109/TSE.2010.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5441292","Domain-specific architectures;visual programming;life cycle;CASE.","Domain specific languages;DSL;Unified modeling language;Vocabulary;Concrete;Software engineering;Computer aided software engineering;Natural languages;Metamodeling;Best practices","multimedia computing;software engineering;specification languages;visual programming","domain-specific languages;multimedia domain;pattern languages;domain-specific metamodel;associated DSL;visual programming;software framework development","","8","","37","","1 Apr 2010","","","IEEE","IEEE Journals"
"Self-Organizing Roles on Agile Software Development Teams","R. Hoda; J. Noble; S. Marshall","The University of Auckland, Auckland; Victoria University of Wellington, Wellington; Victoria University of Wellington, Wellington","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","422","444","Self-organizing teams have been recognized and studied in various forms-as autonomous groups in socio-technical systems, enablers of organizational theories, agents of knowledge management, and as examples of complex-adaptive systems. Over the last decade, self-organizing teams have taken center stage in software engineering when they were incorporated as a hallmark of Agile methods. Despite the long and rich history of self-organizing teams and their recent popularity with Agile methods, there has been little research on the topic within software wngineering. Particularly, there is a dearth of research on how Agile teams organize themselves in practice. Through a Grounded Theory research involving 58 Agile practitioners from 23 software organizations in New Zealand and India over a period of four years, we identified informal, implicit, transient, and spontaneous roles that make Agile teams self-organizing. These roles-Mentor, Coordinator, Translator, Champion, Promoter, and Terminator-are focused toward providing initial guidance and encouraging continued adherence to Agile methods, effectively managing customer expectations and coordinating customer collaboration, securing and sustaining senior management support, and identifying and removing team members threatening the self-organizing ability of the team. Understanding these roles will help software development teams and their managers better comprehend and execute their roles and responsibilities as a self-organizing team.","1939-3520","","10.1109/TSE.2012.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6197202","Self-organizing;team roles;software engineering;Agile software development;grounded theory","Programming;Organizations;Collaboration;Software;Organizing;Software engineering","knowledge management;software management;software prototyping;team working","self-organizing roles;agile software development teams;self-organizing teams;autonomous groups;socio-technical systems;organizational theories enablers;knowledge management agents;complex-adaptive system examples;software engineering;grounded theory research;New Zealand;India;mentor role;coordinator role;translator role;champion role;promoter role;terminator role;customer expectation management;customer collaboration coordination;senior management support security;senior management support sustainability","","92","","115","","8 May 2012","","","IEEE","IEEE Journals"
"What Do We Know about the Effectiveness of Software Design Patterns?","C. Zhang; D. Budgen","Durham University, Durham; Durham University, Durham","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1213","1231","Context. Although research in software engineering largely seeks to improve the practices and products of software development, many practices are based upon codification of expert knowledge, often with little or no underpinning from objective empirical evidence. Software design patterns seek to codify expert knowledge to share experience about successful design structures. Objectives. To investigate how extensively the use of software design patterns has been subjected to empirical study and what evidence is available about how and when their use can provide an effective mechanism for knowledge transfer about design. Method. We conducted a systematic literature review in the form of a mapping study, searching the literature up to the end of 2009 to identify relevant primary studies about the use of the 23 patterns catalogued in the widely referenced book by the “Gang of Four.” These studies were then categorized according to the forms of study employed, the patterns that were studied, as well as the context within which the study took place. Results. Our searches identified 611 candidate papers. Applying our inclusion/exclusion criteria resulted in a final set of 10 papers that described 11 instances of “formal” experimental studies of object-oriented design patterns. We augmented our analysis by including seven “experience” reports that described application of patterns using less rigorous observational forms. We report and review the profiles of the empirical evidence for those patterns for which multiple studies exist. Conclusions. We could not identify firm support for any of the claims made for patterns in general, although there was some support for the usefulness of patterns in providing a framework for maintenance, and some qualitative indication that they do not help novices learn about design. For future studies we recommend that researchers use case studies that focus upon some key patterns, and seek to identify the impact that their use can have upon maintenance.","1939-3520","","10.1109/TSE.2011.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5975176","Design patterns;systematic literature review;empirical software engineering","Software engineering;Software design;Systematics;Search engines;Terminology;Maintenance engineering","object-oriented programming;software maintenance","software design patterns;software engineering;software development;design structures;knowledge transfer;Gang-of-Four;object-oriented design patterns","","46","","66","","4 Aug 2011","","","IEEE","IEEE Journals"
"Technology Transfer: A Software Security Marketplace Case Study","G. McGraw",Cigital,"IEEE Software","18 Aug 2011","2011","28","5","9","11","This paper presents the software security (application security) solutions. It is an idea of engineering software so that it continues to function correctly under malicious attack. Although as a discipline software security is relatively young, much progress has been made on ways to integrate security best practices into the software development life cycle. Microsoft, for example, has helped spearhead soft ware security through its Trustworthy Computing Initiative and the resulting Security Development Lifecycle (SDL). Cigital has also been instrumental in bringing software security to the wider market through its professional services.","1937-4194","","10.1109/MS.2011.110","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984788","code review;technology transfer;software security","Computer security;Technology transfer;Software engineering;Best practices","security of data;software engineering;technology transfer","software security;computer security;software engineering;malicious attack;software development life cycle;Microsoft;trustworthy computing initiative;Cigital;technology transfer","","1","","2","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Facilitating Coordination between Software Developers: A Study and Techniques for Timely and Efficient Recommendations","K. Blincoe; G. Valetto; D. Damian","Software Engineering Global Interaction Lab, Victoria, BC, Canada; Fondazione Bruno Kessler, Trento, Italy; Software Engineering Global Interaction Lab, Victoria, BC, Canada","IEEE Transactions on Software Engineering","13 Oct 2015","2015","41","10","969","985","When software developers fail to coordinate, build failures, duplication of work, schedule slips and software defects can result. However, developers are often unaware of when they need to coordinate, and existing methods and tools that help make developers aware of their coordination needs do not provide timely or efficient recommendations. We describe our techniques to identify timely and efficient coordination recommendations, which we developed and evaluated in a study of coordination needs in the Mylyn software project. We describe how data obtained from tools that capture developer actions within their Integrated Development Environment (IDE) as they occur can be used to timely identify coordination needs; we also describe how properties of tasks coupled with machine learning can focus coordination recommendations to those that are more critical to the developers to reduce information overload and provide more efficient recommendations. We motivate our techniques through developer interviews and report on our quantitative analysis of coordination needs in the Mylyn project. Our results suggest that by leveraging IDE logging facilities, properties of tasks and machine learning techniques awareness tools could make developers aware of critical coordination needs in a timely way. We conclude by discussing implications for software engineering research and tool design.","1939-3520","","10.1109/TSE.2015.2431680","US National Science Foundation (NSF); NECSIS; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7105409","Human Factors in Software Design;Management;Metrics/Measurement;Productivity;Programming Teams;Computer-supported cooperative work;human factors in software design;management;metrics/measurement;productivity;programming teams","Software;Encoding;Interviews;Statistical analysis;Manuals;Accuracy;Correlation","groupware;learning (artificial intelligence);programming environments;project management;software tools","software developers;coordination recommendation;Mylyn software project;integrated development environment;coordination needs quantitative analysis;IDE logging facilities;task properties;machine learning technique awareness tools;software engineering research;tool design","","10","","70","","11 May 2015","","","IEEE","IEEE Journals"
"Test-Driven Development for Spreadsheet Risk Management","K. McDaid; A. Rust","Dundalk Institute of Technology, Ireland; Dundalk Institute of Technology, Ireland","IEEE Software","25 Aug 2009","2009","26","5","31","36","Spreadsheet technology is central to the functioning of the financial sector, but the spreadsheets themselves can have a high level of error that requires innovative supporting processes and tools. Several large-scale international studies conducted in response to the Enron-inspired Sarbanes-Oxley Act confirm the importance and complexity of spreadsheet systems in financial reporting, with some companies using 200+ spreadsheets in manually controlled interconnected ""webs."" Unfortunately, spreadsheets frequently have an unacceptably high number of faults. Early research indicated that between 2 and 5 percent of cell formulas can be incorrect, but a more recent study found that of 50 real-world operational spreadsheets audited, 94 percent contained errors with almost 1 percent of formula cells found to be incorrect. Spreadsheet developers don't appreciate this high risk and thus use little or no formal software development processes.","1937-4194","","10.1109/MS.2009.143","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222791","end-user software engineering;spreadsheets;office automation;information technology and systems applications;IT and systems;testing and debugging;software engineering","Risk management;Inventory management;Environmental management;Financial management;Project management;Protection;Control systems;Software testing;Software engineering;Counting circuits","company reports;financial data processing;legislation;program testing;risk management;software engineering;spreadsheet programs","test-driven development;spreadsheet system risk management technology;financial reporting sector;innovative tool;large-scale international study;Enron-inspired Sarbanes-Oxley Act;cell formula error;formal software development process;spreadsheet fault","","2","","15","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Software Analytics in Practice","D. Zhang; S. Han; Y. Dang; J. Lou; H. Zhang; T. Xie",Microsoft Research Asia; Microsoft Research Asia; Microsoft Research Asia; Microsoft Research Asia; Microsoft Research Asia; University of Illinois at Urbana-Champaign,"IEEE Software","3 Sep 2013","2013","30","5","30","37","With software analytics, software practitioners explore and analyze data to obtain insightful, actionable information for tasks regarding software development, systems, and users. The StackMine project produced a software analytics system for Microsoft product teams. The project provided lessons on applying software analytics technologies to positively impact software development practice. The lessons include focusing on problems that practitioners care about, using domain knowledge for correct data understanding and problem modeling, building prototypes early to get practitioners' feedback, taking into account scalability and customizability, and evaluating analysis results using criteria related to real tasks.","1937-4194","","10.1109/MS.2013.94","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6559957","Algorithm design and analysis;Software systems;Data mining;Performance analysis;Debugging;Software analytics;Software engineering;software engineering;software analytics;mining software repositories;technology transfer;StackMine;data exploration;software artifacts;insightful information;actionable information","Algorithm design and analysis;Software systems;Data mining;Performance analysis;Debugging;Software analytics;Software engineering","data analysis;software engineering","software analytics technology;data exploration;data analysis;StackMine project;Microsoft product team;software development practice;domain knowledge;data understanding;problem modeling;data scalability;data customizability","","47","","13","","16 Jul 2013","","","IEEE","IEEE Magazines"
"Model-Based Self-Aware Performance and Resource Management Using the Descartes Modeling Language","N. Huber; F. Brosig; S. Spinner; S. Kounev; M. Bähr","Department of Computer Science, Chair of Software Engineering, University of Würzburg, Würzburg, Germany; Department of Computer Science, Chair of Software Engineering, University of Würzburg, Würzburg, Germany; Department of Computer Science, Chair of Software Engineering, University of Würzburg, Würzburg, Germany; Department of Computer Science, Chair of Software Engineering, University of Würzburg, Würzburg, Germany; Blue Yonder GmbH & Co. KG., Karlsruhe, Germany","IEEE Transactions on Software Engineering","12 May 2017","2017","43","5","432","452","Modern IT systems have increasingly distributed and dynamic architectures providing flexibility to adapt to changes in the environment and thus enabling higher resource efficiency. However, these benefits come at the cost of higher system complexity and dynamics. Thus, engineering systems that manage their end-to-end application performance and resource efficiency in an autonomic manner is a challenge. In this article, we present a holistic model-based approach for self-aware performance and resource management leveraging the Descartes Modeling Language (DML), an architecture-level modeling language for online performance and resource management. We propose a novel online performance prediction process that dynamically tailors the model solving depending on the requirements regarding accuracy and overhead. Using these prediction capabilities, we implement a generic model-based control loop for proactive system adaptation. We evaluate our model-based approach in the context of two representative case studies showing that with the proposed methods, significant resource efficiency gains can be achieved while maintaining performance requirements. These results represent the first end-to-end validation of our approach, demonstrating its potential for self-aware performance and resource management in the context of modern IT systems and infrastructures.","1939-3520","","10.1109/TSE.2016.2613863","Deutsche Forschungsgemeinschaft (DFG); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7577879","Autonomic;self-aware;adaptation;model-based;modeling language;performance;efficiency","Adaptation models;Resource management;Computer architecture;Predictive models;Unified modeling language;Software;Dynamic scheduling","software architecture;software performance evaluation","model-based self-aware performance;resource management;Descartes modeling language;IT systems;dynamic architectures;distributed architectures;system complexity;engineering systems;end-to-end application performance;resource efficiency;holistic model-based approach;DML;architecture-level modeling language;online performance prediction process;generic model-based control loop;proactive system adaptation;resource efficiency gains","","23","","64","","27 Sep 2016","","","IEEE","IEEE Journals"
"The Crowd in Requirements Engineering: The Landscape and Challenges","E. C. Groen; N. Seyff; R. Ali; F. Dalpiaz; J. Doerr; E. Guzman; M. Hosseini; J. Marco; M. Oriol; A. Perini; M. Stade",Fraunhofer Institute for Experimental Software Engineering; University of Applied Sciences and Arts Northwestern Switzerland; Bournemouth University; Utrecht University; Fraunhofer Institute for Experimental Software Engineering; University of Zurich; Bournemouth University; Polytechnic University of Catalonia; Polytechnic University of Catalonia; FBK Center for Information and Communication Technology; University of Applied Sciences and Arts Northwestern Switzerland,"IEEE Software","28 Mar 2017","2017","34","2","44","52","Crowd-based requirements engineering (CrowdRE) could significantly change RE. Performing RE activities such as elicitation with the crowd of stakeholders turns RE into a participatory effort, leads to more accurate requirements, and ultimately boosts software quality. Although any stakeholder in the crowd can contribute, CrowdRE emphasizes one stakeholder group whose role is often trivialized: users. CrowdRE empowers the management of requirements, such as their prioritization and segmentation, in a dynamic, evolved style through collecting and harnessing a continuous flow of user feedback and monitoring data on the usage context. To analyze the large amount of data obtained from the crowd, automated approaches are key. This article presents current research topics in CrowdRE; discusses the benefits, challenges, and lessons learned from projects and experiments; and assesses how to apply the methods and tools in industrial contexts. This article is part of a special issue on Crowdsourcing for Software Engineering.","1937-4194","","10.1109/MS.2017.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888433","crowd-based requirements engineering;CrowdRE;user feedback;requirements engineering;software requirements;crowdsourcing;software development;software engineering","Software development;Context awareness;Monitoring;Context modeling;Stakeholders;Crowdsourcing;Software engineering","crowdsourcing;data analysis;formal specification;formal verification;software quality","crowd-based requirements engineering;RE activities;software quality;CrowdRE;user feedback;data monitoring;usage context;data analysis;industrial contexts;crowdsourcing","","72","","25","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Rapid Releases and Patch Backouts: A Software Analytics Approach","R. Souza; C. Chavez; R. A. Bittencourt",Federal University of Bahia; Federal University of Bahia; State University of Feira de Santana,"IEEE Software","10 Mar 2015","2015","32","2","89","96","Release engineering deals with decisions that impact the daily lives of developers, testers, and users and thus contribute to a product's success. Although gut feeling is important in such decisions, it's increasingly important to leverage existing data, such as bug reports, source code changes, code reviews, and test results, both to support decisions and to help evaluate current practices. The exploration of software engineering data to obtain insightful information is called software analytics.","1937-4194","","10.1109/MS.2015.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006390","release engineering;rapid releases;software analytics;bug reopening;software engineering;software development;Mozilla;Firefox;Web browsers","Computer bugs;Linux;Continuous production;Marketing and sales;Browsers;Market research;Software analytics;Software engineering;Software development","data analysis;software engineering","software analytics approach;Mozilla;rapid releases;patch backouts;software engineering data","","13","","5","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Multitier Diversification in Web-Based Software Applications","S. Allier; O. Barais; B. Baudry; J. Bourcier; E. Daubert; F. Fleurey; M. Monperrus; H. Song; M. Tricoire",INRIA; University of Rennes 1; INRIA; University of Rennes 1; INRIA; SINTEF Information and Communication Technology; University of Lille; SINTEF Information and Communication Technology; INRIA,"IEEE Software","4 Feb 2015","2015","32","1","83","90","Web application development benefits massively from modular architectures and reuse. This excellent software engineering practice is also the source of a new form of monoculture in application-level co de, which creates a potential risk for dependability. Researchers propose using software diversification in multiple components of Web applications to reconcile the tension between reuse and dependability. This article identifies key enablers for the effective diversification of software, especially at the application-code level. It's possible to combine different software diversification strategies, from deploying different vendor solutions to fine-grained code transformations, to provide different forms of protection.","1937-4194","","10.1109/MS.2014.150","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6957484","software diversity;software monoculture;Web applications;security;dependability;software engineering","Internet;Servers;Operating systems;Computer architecture;Diversity reception;Web services;Software engineering","Internet;software engineering","multitier diversification;Web-based software applications;modular architectures;modular reuse;software engineering practice;application-level code;software diversification;vendor solutions;fine-grained code transformations","","16","","11","","14 Nov 2014","","","IEEE","IEEE Magazines"
"Barriers Faced by Newcomers to Software-Crowdsourcing Projects","A. L. Zanatta; I. Steinmacher; L. S. Machado; C. R. B. de Souza; R. Prikladnicki",Pontifical Catholic University of Rio Grande do Sul; Federal University of Technology-Paraná and Northern Arizona University; Pontifical Catholic University of Rio Grande do Sul; Instituto Tecnológico Vale and Federal University of Pará; Pontifical Catholic University of Rio Grande do Sul,"IEEE Software","28 Mar 2017","2017","34","2","37","43","Crowdsourcing distributes a task to a large network of people-the crowd-through an open call. Newcomers (those attempting to make their first successful contribution) are especially important because they are a source of new ideas and promote a sustainable number of developers. So, newcomers should be encouraged to be active participants in software crowdsourcing. However, newcomers can have difficulty winning algorithm competitions. In addition, six types of barriers can hinder them: lack of documentation, poor task management, problems understanding code structure or architecture, information overload, poor platform usability, and the language barrier. Fortunately, ways exist to minimize the barriers, including consistent documentation, well-structured source code, recommending tasks that are appropriate for newcomers, and assigning tasks to newcomers that let them derive more benefits for themselves. This article is part of a special issue on Crowdsourcing for Software Engineering.","1937-4194","","10.1109/MS.2017.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888391","software crowdsourcing;crowdsourcing;software engineering;software development;Topcoder","Crowdsourcing;Documentation;Usability;Software engineering;Open source software;Software testing;Software development","crowdsourcing;project management;software engineering;software management","software crowdsourcing projects;newcomers;winning algorithm;poor task management;code structure;platform usability;language barriers;consistent documentation;well-structured source code;software engineering","","14","","18","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Preventing Defects: The Impact of Requirements Traceability Completeness on Software Quality","P. Rempel; P. Mäder","Software Engineering for Safety-Critical Systems Group, Technische Universität Ilmenau, Ilmenau, Germany; Software Engineering for Safety-Critical Systems Group, Technische Universität Ilmenau, Ilmenau, Germany","IEEE Transactions on Software Engineering","11 Aug 2017","2017","43","8","777","797","Requirements traceability has long been recognized as an important quality of a well-engineered system. Among stakeholders, traceability is often unpopular due to the unclear benefits. In fact, little evidence exists regarding the expected traceability benefits. There is a need for empirical work that studies the effect of traceability. In this paper, we focus on the four main requirements implementation supporting activities that utilize traceability. For each activity, we propose generalized traceability completeness measures. In a defined process, we selected 24 medium to large-scale open-source projects. For each software project, we quantified the degree to which a studied development activity was enabled by existing traceability with the proposed measures. We analyzed that data in a multi-level Poisson regression analysis. We found that the degree of traceability completeness for three of the studied activities significantly affects software quality, which we quantified as defect rate. Our results provide for the first time empirical evidence that more complete traceability decreases the expected defect rate in the developed software. The strong impact of traceability completeness on the defect rate suggests that traceability is of great practical value for any kind of software development project, even if traceability is not mandated by a standard or regulation.","1939-3520","","10.1109/TSE.2016.2622264","German Ministry of Education and Research (BMBF); Thüringer Aufbaubank (TAB); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7723818","Requirements traceability;traceability completeness;traceability metrics;change impact analysis;requirements satisfaction analysis;source code justification analysis;software quality;error proneness;defects;bugs;empirical validation;regression analysis","Software quality;Software systems;Context;Software engineering;Stakeholders;Standards","public domain software;regression analysis;software quality;stochastic processes","software development project;multilevel Poisson regression analysis;software project;large-scale open-source projects;generalized traceability completeness measurement;requirement traceability completeness impact;software quality","","13","","131","","27 Oct 2016","","","IEEE","IEEE Journals"
"Collaboration Spaces for Virtual Software Teams","K. Dullemond; B. van Gameren; R. van Solingen",Delft University of Technology; Delft University of Technology; Delft University of Technology,"IEEE Software","7 Nov 2014","2014","31","6","47","53","Software engineering is a field in which distributed development through virtual teams is a fact of life. The authors claim that environments for supporting virtual software teams should place collaboration in the forefront. Here, they present a set of eight core requirements for support environments for virtual software teams. These requirements have been derived from, and validated in, industrial settings, and address how to provide virtual software teams with a sufficient level of awareness for their work activities.","1937-4194","","10.1109/MS.2014.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6879053","virtual teams;virtual software teams;global software engineering;collaboration support environments;interrupts;attention and interruption;mood indicators;awareness;computer-supported cooperative work;software environments;software engineering","Collaboration;Software engineering;Research and development;Teamwork;Virtual groups;Computer languages;Programming","groupware;programming environments;software development management;team working","collaboration spaces;virtual software teams;software engineering;distributed development","","7","","15","","15 Aug 2014","","","IEEE","IEEE Magazines"
"Software Development Tooling: Information, Opinion, Guidelines, and Tools","D. Spinellis; S. Androutsellis-Theotokis",Athens University of Economics and Business; NA,"IEEE Software","7 Nov 2014","2014","31","6","21","23","The article depicts in two infographics a summary of what has been presented in the Tools of the Trade column over the past 10 years. The first figure categorizes the major points of each column into information, opinion, and prescriptive guidelines. The second figure associates with each broad theme specific indicative tools.","1937-4194","","10.1109/MS.2014.146","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949502","software engineering tools;Tools of the Trade;infographics;software engineering","Software development;Guidelines;Software engineering;Debugging","","","","","","","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Parallel Algorithms for Testing Finite State Machines:Generating UIO Sequences","R. M. Hierons; U. C. Türker","Department of Computer Science, Brunel University London, United Kingdom; Department of Computer Science, Brunel University London, United Kingdom","IEEE Transactions on Software Engineering","10 Nov 2016","2016","42","11","1077","1091","This paper describes an efficient parallel algorithm that uses many-core GPUs for automatically deriving Unique Input Output sequences (UIOs) from Finite State Machines. The proposed algorithm uses the global scope of the GPU's global memory through coalesced memory access and minimises the transfer between CPU and GPU memory. The results of experiments indicate that the proposed method yields considerably better results compared to a single core UIO construction algorithm. Our algorithm is scalable and when multiple GPUs are added into the system the approach can handle FSMs whose size is larger than the memory available on a single GPU.","1939-3520","","10.1109/TSE.2016.2539964","Scientific and Technological Research Council of Turkey; NVIDIA; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7429774","Software engineering/software/program verification;software engineering/testing and debugging;software engineering/test design;finite state machine;unique input output sequence generation;general purpose graphics processing units","Graphics processing units;Testing;Automata;Algorithm design and analysis;Software algorithms;Automation","finite state machines;graphics processing units;input-output programs;multiprocessing systems;parallel algorithms;program testing","parallel algorithms;finite state machine testing;UIO sequence generation;unique input output sequences;many-core GPU;graphics processing unit;coalesced memory access;memory transfer;single core UIO construction algorithm","","11","","46","","9 Mar 2016","","","IEEE","IEEE Journals"
"End Users at the Bazaar: Designing Next-Generation Enterprise Resource Planning Systems","C. Dorner; S. Draxler; V. Pipek; V. Wulf",University of Siegen; University of Siegen; University of Siegen; University of Siegen,"IEEE Software","25 Aug 2009","2009","26","5","45","51","Studying changing software architectures from an end-user development perspective inspires an enterprise resource planning architecture that lets end users create their own solutions.The ""bazaar,"" a notion Eric Raymond coined, is a well-known metaphor for a software engineering model that developers often use in open source projects. In this model, software development is in view of the public, which means that anyone has access to the source code and can change, improve, test, and use it. Open source projects such as Firefox or the ADempiere ERP Business Suite have produced high-quality results, indicating that bazaar-like software engineering models are effective.","1937-4194","","10.1109/MS.2009.127","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222793","visual programming;domain-specific architectures;graphical user interfaces;workflow management;business;software engineering","Enterprise resource planning;Service oriented architecture;Software tools;Application software;Software engineering;Impedance;Product design;Manufacturing;Meeting planning;Materials requirements planning","program testing;public domain software;software architecture;software quality","next-generation enterprise resource planning system;software architectures;software engineering model;open source project;software development;bazaar-like software engineering model;Firefox;ADempiere ERP Business Suite","","15","","19","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Piloting a Mobile-App Ecosystem for Smart Farming","S. Braun; R. Carbon; M. Naab",Fraunhofer Institute for Experimental Software Engineering; John Deere; Fraunhofer Institute for Experimental Software Engineering,"IEEE Software","23 Jun 2016","2016","33","4","9","14","Mobile apps increasingly constitute complete ecosystems to support businesses such as farming. Software architects and engineers from John Deere and the Fraunhofer Institute for Experimental Software Engineering recently piloted a mobile-app ecosystem for farmers, focusing on data's role in architecting. Having the right data at the right time at the right place is crucial for high user productivity and a good user experience. In particular, offline capability is important but difficult. The authors describe a custom solution for offline capability and share lessons learned regarding data-related architecture decisions.","1937-4194","","10.1109/MS.2016.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498540","software architecture;mobile-app ecosystem;data;offline capability;synchronization;smart farming;software development;software engineering","Synchronization;Mobile communication;Meteorology;Food production;Computer architecture;Agricultural products;Ecosystems","farming;mobile computing","mobile-app ecosystem;smart farming;data-related architecture decision","","4","","6","","23 Jun 2016","","","IEEE","IEEE Magazines"
"Inner Source--Adopting Open Source Development Practices in Organizations: A Tutorial","K. Stol; B. Fitzgerald",Lero--The Irish Software Engineering Research Centre; Lero--The Irish Software Engineering Research Centre,"IEEE Software","30 Jun 2015","2015","32","4","60","67","Inner source, the adoption and tailoring of open source development practices in organizations, is receiving increased interest. However, although it offers numerous benefits, many practitioners are unclear about what it is and how to adopt it. When adopting inner source, organizations should consider nine factors pertaining to product, process, and organization. A description of three inner-source initiatives illustrates these nine factors.","1937-4194","","10.1109/MS.2014.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6809709","open source development;inner source;software engineering;software development;open source","Open source software;Software development;Software engineering;Standards organizations","public domain software;software houses","inner source adoption;open source development practices;software organization;software industry","","26","","16","","2 May 2014","","","IEEE","IEEE Magazines"
"Reflecting on Evidence-Based Timelines","E. Bjarnason; A. Hess; R. Berntsson Svensson; B. Regnell; J. Doerr","Lund University; Fraunhofer Institute for Experimental Software Engineering; Chalmers, University of Gothenburg; Lund University; Fraunhofer Institute for Experimental Software Engineering","IEEE Software","13 Jun 2014","2014","31","4","37","43","Project retrospectives can be powerful tools for project teams to collectively identify communication gaps and practices to improve for future projects. However, even if project members take the time for a retrospective, it can be hard to correctly remember and jointly discuss past events in a constructive way. Fact-based timelines that visualize a project's events offer a possible solution.","1937-4194","","10.1109/MS.2014.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834711","project retrospective;timeline;software process improvement;software engineering;pervasive computing;project management","Software development;Software engineering;Project management;Strategic planning","","","","6","","8","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Why and How Should Open Source Projects Adopt Time-Based Releases?","M. Michlmayr; B. Fitzgerald; K. Stol",Hewlett-Packard; Lero--The Irish Software Engineering Research Centre; Lero--The Irish Software Engineering Research Centre,"IEEE Software","10 Mar 2015","2015","32","2","55","63","Traditional release strategies have problems that can be overcome by time-based release management. Interviews with key members of seven prominent volunteer-based open source projects reveal time-based release's advantages. The authors discuss release planning's importance, the numerous challenges that can result from a lack of such planning, and time-based releases' benefits. They also discuss how to adopt time-based release. An online supplement provides additional information on the projects and interview guide discussed in the article.","1937-4194","","10.1109/MS.2015.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057555","release management;time-based releases;release strategies;open source projects;software development;software engineering;open source software","Schedules;Continuous production;Software development;Project management;Software engineering;Computer bugs;Open source software","public domain software;software development management","traditional release strategies;time-based release management;volunteer-based open source projects;release planning;online supplement;interview guide","","26","","17","","10 Mar 2015","","","IEEE","IEEE Magazines"
"A Systematic Literature Review on Fault Prediction Performance in Software Engineering","T. Hall; S. Beecham; D. Bowes; D. Gray; S. Counsell","Brunel University, Uxbridge; University of Limerick, Limerick; University of Hertfordshire, Hatfield; University of Hertfordshire, Hatfield; Brunel University, Uxbridge","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1276","1304","Background: The accurate prediction of where faults are likely to occur in code can help direct test effort, reduce costs, and improve the quality of software. Objective: We investigate how the context of models, the independent variables used, and the modeling techniques applied influence the performance of fault prediction models. Method: We used a systematic literature review to identify 208 fault prediction studies published from January 2000 to December 2010. We synthesize the quantitative and qualitative results of 36 studies which report sufficient contextual and methodological information according to the criteria we develop and apply. Results: The models that perform well tend to be based on simple modeling techniques such as Naive Bayes or Logistic Regression. Combinations of independent variables have been used by models that perform well. Feature selection has been applied to these combinations when models are performing particularly well. Conclusion: The methodology used to build models seems to be influential to predictive performance. Although there are a set of fault prediction studies in which confidence is possible, more studies are needed that use a reliable methodology and which report their context, methodology, and performance comprehensively.","1939-3520","","10.1109/TSE.2011.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6035727","Systematic literature review;software fault prediction","Predictive models;Context modeling;Software testing;Data models;Systematics;Analytical models;Fault diagnosis","Bayes methods;regression analysis;software fault tolerance;software quality","systematic literature review;fault prediction performance;software engineering;cost reduction;software quality;independent variables;fault prediction models;contextual information;methodological information;simple modeling techniques;naive Bayes;logistic regression;feature selection;predictive performance;fault prediction study;reliable methodology","","462","","241","","6 Oct 2011","","","IEEE","IEEE Journals"
"FAML: A Generic Metamodel for MAS Development","G. Beydoun; G. Low; B. Henderson-Sellers; H. Mouratidis; J. J. Gomez-Sanz; J. Pavon; C. Gonzalez-Perez","University of Wollongong, Wollongong; The University of New South Wales, Sydney; University of Technology, Sydney; University of East London, London; Universidad Complutense de Madrid, Madrid; Universidad Complutense de Madrid, Madrid; Instituto de Estudios Gallegos Padre Sarmiento (CSIC), Santiago de Compostela","IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","841","863","In some areas of software engineering research, there are several metamodels claiming to capture the main issues. Though it is profitable to have variety at the beginning of a research field, after some time, the diversity of metamodels becomes an obstacle, for instance to the sharing of results between research groups. To reach consensus and unification of existing metamodels, metamodel-driven software language engineering can be applied. This paper illustrates an application of software language engineering in the agent-oriented software engineering research domain. Here, we introduce a relatively generic agent-oriented metamodel whose suitability for supporting modeling language development is demonstrated by evaluating it with respect to several existing methodology-specific metamodels. First, the metamodel is constructed by a combination of bottom-up and top-down analysis and best practice. The concepts thus obtained and their relationships are then evaluated by mapping to two agent-oriented metamodels: TAO and Islander. We then refine the metamodel by extending the comparisons with the metamodels implicit or explicit within five more extant agent-oriented approaches: Adelfe, PASSI, Gaia, INGENIAS, and Tropos. The resultant FAML metamodel is a potential candidate for future standardization as an important component for engineering an agent modeling language.","1939-3520","","10.1109/TSE.2009.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4967615","Modeling;metamodel;multiagent systems.","Software engineering;Australia;Application software;Multiagent systems;Management information systems;Best practices;Standardization;Software architecture;Natural languages","languages;multi-agent systems;software engineering","MAS development;metamodel;software language engineering;multiagent systems;FAML","","93","","72","","26 May 2009","","","IEEE","IEEE Journals"
"CrowdSummarizer: Automated Generation of Code Summaries for Java Programs through Crowdsourcing","S. Badihi; A. Heydarnoori",Sharif University of Technology; Sharif University of Technology,"IEEE Software","28 Mar 2017","2017","34","2","71","80","To perform software maintenance, developers must have a relatively good understanding of the program's source code, which is often written by other developers. Code summaries, which describe a program's entities (for example, its methods), help developers better comprehend code more quickly. However, generating code summaries can be challenging. To mitigate this problem, CrowdSummarizer exploits crowdsourcing, gamification, and natural-language processing to automatically generate high-level summaries of Java program methods. Researchers have implemented it as an Eclipse plug-in together with a Web-based code summarization game that can be played by the crowd. Two empirical studies determined that CrowdSummarizer generates quality results. This article is part of a special issue on Crowdsourcing for Software Engineering.","1937-4194","","10.1109/MS.2017.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888409","CrowdSummarizer;crowdsourcing;program comprehension;source code summarization;gamification;software engineering;software development","Software reliability;Crowdsourcing;Java;Software maintenance;Software engineering;Software engineering;Software measurement","computer games;crowdsourcing;Java;natural language processing;software maintenance;source code (software)","Eclipse plug-in;software engineering;Web-based code summarization game;high-level summaries;Java program;gamification;natural-language processing;program source code;software maintenance;code summary automated generation;CrowdSummarizer","","6","","14","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Yakov Fain on Angular","M. Farwell",Nexthink,"IEEE Software","13 Nov 2017","2017","34","6","109","112","Yakov Fain talks with Software Engineering Radio host Matthew Farwell about the popular Angular web development framework.","1937-4194","","10.1109/MS.2017.4121218","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106872","Yakov Fain;Angular;web development frameworks;software engineering;software development;Software Engineering Radio.","Software engineering;Visualization;Programming;Navigation","","","","","","","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Integrate End to End Early and Often","F. H. Bachmann; L. Carballo; J. McHale; R. L. Nord",Software Engineering Institute; Bursatec; Software Engineering Institute; Software Engineering Institute,"IEEE Software","26 Jun 2013","2013","30","4","9","14","This column is all about stories, and this one is as exciting as a paperback whodunit. The details are all included, and I hate to spoil it, but there's a happy ending. The story is about something old--designing and implementing a new system when the old one was really old (two decades!) and something new--using outside research consultants to save the day with a secret sauce. Enjoy!","1937-4194","","10.1109/MS.2013.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547611","software architecture;software process;incremental iterative development;integration;architecture-centric engineering;team software process","Computer architecture;Software development;Aging;Software engineering;Prototypes;Software testing;Software quality","software architecture","end-to-end software integration;software development project;software architecture","","3","","5","","26 Jun 2013","","","IEEE","IEEE Magazines"
"Instance Generator and Problem Representation to Improve Object Oriented Code Coverage","A. Sakti; G. Pesant; Y. Guéhéneuc","Department of Computer and Software Engineering, École Polytechnique de Montral, Montral, QC, Canada; Department of Computer and Software Engineering, École Polytechnique de Montral, Montral, QC, Canada; Department of Computer and Software Engineering, École Polytechnique de Montral, Montral, QC, Canada","IEEE Transactions on Software Engineering","11 Mar 2015","2015","41","3","294","313","Search-based approaches have been extensively applied to solve the problem of software test-data generation. Yet, test-data generation for object-oriented programming (OOP) is challenging due to the features of OOP, e.g., abstraction, encapsulation, and visibility that prevent direct access to some parts of the source code. To address this problem we present a new automated search-based software test-data generation approach that achieves high code coverage for unit-class testing. We first describe how we structure the test-data generation problem for unit-class testing to generate relevant sequences of method calls. Through a static analysis, we consider only methods or constructors changing the state of the class-under-test or that may reach a test target. Then we introduce a generator of instances of classes that is based on a family of means-of-instantiation including subclasses and external factory methods. It also uses a seeding strategy and a diversification strategy to increase the likelihood to reach a test target. Using a search heuristic to reach all test targets at the same time, we implement our approach in a tool, JTExpert, that we evaluate on more than a hundred Java classes from different open-source libraries. JTExpert gives better results in terms of search time and code coverage than the state of the art, EvoSuite, which uses traditional techniques.","1939-3520","","10.1109/TSE.2014.2363479","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6926828","Automatic Test Data Generation;Search Based Software Testing;Unit Class Testing;Seeding Strategy;Diversification Strategy;Java Testing;Automatic test data generation;search based software testing;unit class testing;seeding strategy;diversification strategy;Java testing","Testing;Complexity theory;Generators;Search problems;Java;Production facilities;Libraries","Java;object-oriented programming;program diagnostics;program testing;public domain software","instance generator;problem representation;object oriented code coverage;search-based approach;object-oriented programming;OOP;abstraction;encapsulation;visibility;source code;automated search-based software test-data generation approach;unit-class testing;method call sequences;static analysis;class-under-test;means-of-instantiation;seeding strategy;diversification strategy;search heuristic;JTExpert;Java class evaluation;open-source libraries;search time;EvoSuite","","39","","53","","16 Oct 2014","","","IEEE","IEEE Journals"
"Using Natural Language Processing to Automatically Detect Self-Admitted Technical Debt","E. d. S. Maldonado; E. Shihab; N. Tsantalis","Department of Computer Science and Software Engineering, Data-Driven Analysis of Software (DAS) Lab, Concordia University, Montreal, QC, Canada; Department of Computer Science and Software Engineering, Data-Driven Analysis of Software (DAS) Lab, Concordia University, Montreal, QC, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada","IEEE Transactions on Software Engineering","10 Nov 2017","2017","43","11","1044","1062","The metaphor of technical debt was introduced to express the trade off between productivity and quality, i.e., when developers take shortcuts or perform quick hacks. More recently, our work has shown that it is possible to detect technical debt using source code comments (i.e., self-admitted technical debt), and that the most common types of self-admitted technical debt are design and requirement debt. However, all approaches thus far heavily depend on the manual classification of source code comments. In this paper, we present an approach to automatically identify design and requirement self-admitted technical debt using Natural Language Processing (NLP). We study 10 open source projects: Ant, ArgoUML, Columba, EMF, Hibernate, JEdit, JFreeChart, JMeter, JRuby and SQuirrel SQL and find that 1) we are able to accurately identify self-admitted technical debt, significantly outperforming the current state-of-the-art based on fixed keywords and phrases; 2) words related to sloppy code or mediocre source code quality are the best indicators of design debt, whereas words related to the need to complete a partially implemented requirement in the future are the best indicators of requirement debt; and 3) we can achieve 90 percent of the best classification performance, using as little as 23 percent of the comments for both design and requirement self-admitted technical debt, and 80 percent of the best performance, using as little as 9 and 5 percent of the comments for design and requirement self-admitted technical debt, respectively. The last finding shows that the proposed approach can achieve a good accuracy even with a relatively small training dataset.","1939-3520","","10.1109/TSE.2017.2654244","Natural Sciences and Engineering Research Council of Canada; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7820211","Technical debt;source code comments;natural language processing;empirical study","Software;Natural language processing;Manuals;Entropy;Unified modeling language;Java;Structured Query Language","computer crime;Java;natural language processing;project management;public domain software;software maintenance;software management;software quality;SQL","Natural Language Processing;requirement debt;self-admitted technical debt detection;open source projects;source code quality;source code comment classification;NLP;design debt","","29","","58","Traditional","17 Jan 2017","","","IEEE","IEEE Journals"
"A Learning-Based Framework for Engineering Feature-Oriented Self-Adaptive Software Systems","N. Esfahani; A. Elkhodary; S. Malek","George Mason University, Fairfax; George Mason University, Fairfax; George Mason University, Fairfax","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1467","1493","Self-adaptive software systems are capable of adjusting their behavior at runtime to achieve certain functional or quality-of-service goals. Often a representation that reflects the internal structure of the managed system is used to reason about its characteristics and make the appropriate adaptation decisions. However, runtime conditions can radically change the internal structure in ways that were not accounted for during their design. As a result, unanticipated changes at runtime that violate the assumptions made about the internal structure of the system could degrade the accuracy of the adaptation decisions. We present an approach for engineering self-adaptive software systems that brings about two innovations: 1) a feature-oriented approach for representing engineers' knowledge of adaptation choices that are deemed practical, and 2) an online learning-based approach for assessing and reasoning about adaptation decisions that does not require an explicit representation of the internal structure of the managed software system. Engineers' knowledge, represented in feature-models, adds structure to learning, which in turn makes online learning feasible. We present an empirical evaluation of the framework using a real-world self-adaptive software system. Results demonstrate the framework's ability to accurately learn the changing dynamics of the system while achieving efficient analysis and adaptation.","1939-3520","","10.1109/TSE.2013.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6574860","Self-adaptive software;autonomic computing;feature-orientation;machine learning","Software systems;Runtime;Adaptation models;Quality of service;Authentication;Measurement","inference mechanisms;learning (artificial intelligence);quality of service;software engineering","feature-models;adaptation decision reasoning;adaptation decision assessment;online learning-based approach;runtime conditions;quality-of-service goals;engineering feature-oriented self-adaptive software systems;learning-based framework","","53","1","67","","5 Aug 2013","","","IEEE","IEEE Journals"
"Conservation of Information: Software’sHidden Clockwork?","L. Hatton","Faculty of Science, Engineering and Computing, Kingston University, United Kingdom","IEEE Transactions on Software Engineering","14 May 2014","2014","40","5","450","460","In this paper it is proposed that the Conservation of Hartley-Shannon Information (hereafter contracted to H-S Information) plays the same role in discrete systems as the Conservation of Energy does in physical systems. In particular, using a variational approach, it is shown that the symmetry of scale-invariance, power-laws and the Conservation of H-S Information are intimately related and lead to the prediction that the component sizes of any software system assembled from components made from discrete tokens always asymptote to a scale-free power-law distribution in the unique alphabet of tokens used to construct each component. This is then validated to a very high degree of significance on some 100 million lines of software in seven different programming languages independently of how the software was produced, what it does, who produced it or what stage of maturity it has reached. A further implication of the theory presented here is that the average size of components depends only on their unique alphabet, independently of the package they appear in. This too is demonstrated on the main data set and also on 24 additional Fortran 90 packages.","1939-3520","","10.1109/TSE.2014.2316158","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6784340","Information conservation;component size distribution;power-law;software systems","Software systems;Computer languages;Genomics;Bioinformatics;Genetic communication","information theory;programming languages;software engineering","software hidden clockwork;Hartley-Shannon information conservation;physical systems;discrete systems;energy conservation;variational approach;scale-invariance symmetry;H-S information conservation;software system;scale-free power-law distribution;discrete tokens;Fortran","","3","","30","","8 Apr 2014","","","IEEE","IEEE Journals"
"Reporting Usability Defects: A Systematic Literature Review","N. S. M. Yusop; J. Grundy; R. Vasa","Faculty of Computer and Mathematical Science, Universiti Teknologi MARA, Malaysia; Faculty of Science, Engineering and Built Environment, Deakin University, AUD, Australia; Faculty of Science, Engineering and Built Environment, Deakin University, AUD, Australia","IEEE Transactions on Software Engineering","15 Sep 2017","2017","43","9","848","867","Usability defects can be found either by formal usability evaluation methods or indirectly during system testing or usage. No matter how they are discovered, these defects must be tracked and reported. However, empirical studies indicate that usability defects are often not clearly and fully described. This study aims to identify the state of the art in reporting of usability defects in the software engineering and usability engineering literature. We conducted a systematic literature review of usability defect reporting drawing from both the usability and software engineering literature from January 2000 until March 2016. As a result, a total of 57 studies were identified, in which we classified the studies into three categories: reporting usability defect information, analysing usability defect data and key challenges. Out of these, 20 were software engineering studies and 37 were usability studies. The results of this systematic literature review show that usability defect reporting processes suffer from a number of limitations, including: mixed data, inconsistency of terms and values of usability defect data, and insufficient attributes to classify usability defects. We make a number of recommendations to improve usability defect reporting and management in software engineering.","1939-3520","","10.1109/TSE.2016.2638427","Ministry of Higher Education Malaysia, Universiti Teknologi MARA (UiTM); ARC Discovery projects scheme, the Deakin Software Technology Innovation Lab; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7779159","Systematic review;test management;user interface;usability testing;usability defect reporting","Usability;Systematics;Software engineering;Testing;Human computer interaction;Bibliographies","formal verification;pattern classification;product design;program testing","formal usability evaluation;system testing;software engineering;usability defect reporting processes;mixed data;usability defect data;usability defect classification","","5","","87","Traditional","9 Dec 2016","","","IEEE","IEEE Journals"
"How Programmers Debug, Revisited: An Information Foraging Theory Perspective","J. Lawrance; C. Bogart; M. Burnett; R. Bellamy; K. Rector; S. D. Fleming","Wentworth Institute of Technology, Boston; Oregon State University, Corvallis; Oregon State University, Corvallis; IBM TJ Watson Research Center, Hawthorne; Oregon State University, Corvallis; Oregon State University, Corvallis","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","197","215","Many theories of human debugging rely on complex mental constructs that offer little practical advice to builders of software engineering tools. Although hypotheses are important in debugging, a theory of navigation adds more practical value to our understanding of how programmers debug. Therefore, in this paper, we reconsider how people go about debugging in large collections of source code using a modern programming environment. We present an information foraging theory of debugging that treats programmer navigation during debugging as being analogous to a predator following scent to find prey in the wild. The theory proposes that constructs of scent and topology provide enough information to describe and predict programmer navigation during debugging, without reference to mental states such as hypotheses. We investigate the scope of our theory through an empirical study of 10 professional programmers debugging a real-world open source program. We found that the programmers' verbalizations far more often concerned scent-following than hypotheses. To evaluate the predictiveness of our theory, we created an executable model that predicted programmer navigation behavior more accurately than comparable models that did not consider information scent. Finally, we discuss the implications of our results for enhancing software engineering tools.","1939-3520","","10.1109/TSE.2010.111","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5674060","Information foraging theory;debugging;software maintenance;programmer navigation;information scent;empirical software engineering","Debugging;Navigation;Topology;Programming environments;Predictive models;Approximation methods","cognition;program debugging;public domain software;software maintenance;topology","information foraging theory;human debugging theories;complex mental constructs;navigation theory;programming environment;topology constructs;information scent constructs;open source code program debugging;programmer verbalizations;programmer navigation behavior prediction;software engineering tool enhancement","","59","","54","","23 Dec 2010","","","IEEE","IEEE Journals"
"Managing Variability in Software Product Lines","M. A. Babar; L. Chen; F. Shull","IT University of Copenhagen; Lero, University of Limerick; Fraunhofer Center for Experimental Software Engineering, Maryland","IEEE Software","19 Apr 2010","2010","27","3","89","91, 94","A software product line (SPL) is a set of software-intensive systems that share a common set of features for satisfying a particular market segment needs. SPLs can reduce development costs, shorten time-to-market, and improve product quality by reusing core assets for project-specific customizations. To enable reuse on a large scale, SPL engineering (SPLE) identifies and manages commonalities and variations across a set of system artifacts such as requirements, architectures, code components, and test cases.Variability management (VM) is a fundamental SPLE activity that explicitly represents software artifact variations for managing dependencies among variants and supporting their instantiations throughout the SPL life cycle. Managing variability involves extremely complex and challenging tasks, which must be supported by effective methods, techniques, and tools.","1937-4194","","10.1109/MS.2010.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452151","software engineering;evidence-based software engineering;software product lines","Engineering management;Costs;Time to market;Large-scale systems;Computer architecture;Life testing;Software testing;System testing;Virtual manufacturing","product development;software quality;software reusability","variability management;software product lines;software-intensive systems;product quality improvement;project-specific customizations;development costs reduction","","36","","23","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Trends in Embedded Software Engineering","P. Liggesmeyer; M. Trapp",University of Kaiserslautern; Fraunhofer Institute for Experimental Software Engineering,"IEEE Software","17 Apr 2009","2009","26","3","19","25","Software's importance in the development of embedded systems has been growing rapidly over the last 20 years. Because of current embedded systems' complexity, they require sophisticated engineering methods for systematically developing high-quality software. Embedded software development differs from IT system development in several ways. For example, IT systems developers can use standard hardware and software platforms and don't face the resource requirements that embedded systems developers must take into account. To meet embedded software's extrafunctional requirements, embedded systems development is shifting from programming to model-driven development. Another important trend is the emphasis on the quality assurance of safety-related systems.","1937-4194","","10.1109/MS.2009.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814954","embedded systems development;model-driven development;embedded software;quality assurance;safety-critical systems","Embedded software;Object oriented modeling;Mathematical model;Embedded system;Hardware;IEC standards;Costs;Automotive engineering;Computer languages;Operating systems","embedded systems;software quality","embedded software engineering;embedded systems;embedded software development;IT system development;safety-related systems;quality assurance","","53","","14","","17 Apr 2009","","","IEEE","IEEE Magazines"
"Leveraging Transparency","L. Dabbish; C. Stuart; J. Tsay; J. Herbsleb",Carnegie Mellon University; Carnegie Mellon University; Carnegie Mellon University; Carnegie Mellon University,"IEEE Software","3 Jan 2013","2013","30","1","37","43","A new generation of development environments takes a radical approach to communication and coordination by fusing social networking functionality with flexible, distributed version control. Through these transparent work environments, people, repositories, development activities, and their histories are immediately and easily visible to all users. Developers quickly acquire the skill to interpret this rich information to find useful resources, connect with people, solve technical problems, and enhance their learning opportunities. This article presents the results of a qualitative study of users of one such environment, GitHub. It describes how transparency helps developers on GitHub manage their projects, handle dependencies more effectively, reduce communication needs, and figure out what requires their attention. Although transparency is not a silver bullet, the approach shows great promise for enhancing collaboration and coordination. The Web extra at http://www.youtube.com/watch?v=LpGA2fmAHvM is a video of Joel Spolsky discussing the structure, software, technology, and culture of Stack Exchange.","1937-4194","","10.1109/MS.2012.172","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6357175","Social network services;Software engineering;Collaboration;Organizational aspects;User interfaces;Information technology;Software management;information technology and systems;software engineering tools and techniques;software engineering;organizational management;coordination;group interfaces;organization interfaces;information interfaces and representation;HCI","Social network services;Software engineering;Collaboration;Organizational aspects;User interfaces;Information technology;Software management","Internet;project management;security of data;social networking (online)","transparency leverage;development environments;social networking functionality;distributed version control;learning opportunities;GitHub;project management","","30","","9","","20 Nov 2012","","","IEEE","IEEE Magazines"
"Whole Test Suite Generation","G. Fraser; A. Arcuri","Saarland University, Saarbrücken; Simula Research Laboratory, Lysaker","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","276","291","Not all bugs lead to program crashes, and not always is there a formal specification to check the correctness of a software test's outcome. A common scenario in software testing is therefore that test data are generated, and a tester manually adds test oracles. As this is a difficult task, it is important to produce small yet representative test sets, and this representativeness is typically measured using code coverage. There is, however, a fundamental problem with the common approach of targeting one coverage goal at a time: Coverage goals are not independent, not equally difficult, and sometimes infeasible-the result of test generation is therefore dependent on the order of coverage goals and how many of them are feasible. To overcome this problem, we propose a novel paradigm in which whole test suites are evolved with the aim of covering all coverage goals at the same time while keeping the total size as small as possible. This approach has several advantages, as for example, its effectiveness is not affected by the number of infeasible targets in the code. We have implemented this novel approach in the EvoSuite tool, and compared it to the common approach of addressing one goal at a time. Evaluated on open source libraries and an industrial case study for a total of 1,741 classes, we show that EvoSuite achieved up to 188 times the branch coverage of a traditional approach targeting single branches, with up to 62 percent smaller test suites.","1939-3520","","10.1109/TSE.2012.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6152257","Search-based software engineering;length;branch coverage;genetic algorithm;infeasible goal;collateral coverage","Software;Genetic algorithms;Search problems;Arrays;Genetic programming;Software testing","formal specification;program debugging;program testing","whole test suite generation;program crashes;formal specification;software testing;code coverage;EvoSuite tool;program debugging","","243","2","52","","16 Feb 2012","","","IEEE","IEEE Journals"
"From UML to Petri Nets: The PCM-Based Methodology","S. Distefano; M. Scarpa; A. Puliafito","University of Messina, Sicily; University of Messina, Sicily; University of Messina, Sicily","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","65","79","In this paper, we present an evaluation methodology to validate the performance of a UML model, representing a software architecture. The proposed approach is based on open and well-known standards: UML for software modeling and the OMG Profile for Schedulability, Performance, and Time Specification for the performance annotations into UML models. Such specifications are collected in an intermediate model, called the Performance Context Model (PCM). The intermediate model is translated into a performance model which is subsequently evaluated. The paper is focused on the mapping from the PCM to the performance domain. More specifically, we adopt Petri nets as the performance domain, specifying a mapping process based on a compositional approach we have entirely implemented in the ArgoPerformance tool. All of the rules to derive a Petri net from a PCM and the performance measures assessable from the former are carefully detailed. To validate the proposed technique, we provide an in-depth analysis of a web application for music streaming.","1939-3520","","10.1109/TSE.2010.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5396344","Software engineering;performances evaluation;Petri nets;UML;software performance engineering.","Unified modeling language;Petri nets;Phase change materials;Software architecture;Software performance;Context modeling;Application software;Design engineering;Performance analysis;Stochastic processes","media streaming;Petri nets;software architecture;software metrics;software performance evaluation;Unified Modeling Language;Web services","UML;Petri nets;PCM;software architecture;software modeling;OMG profile;schedulability;time specification;performance context model;mapping process;ArgoPerformance tool;music streaming;Web application","","34","","31","","22 Jan 2010","","","IEEE","IEEE Journals"
"Approaches to Co-Evolution of Metamodels and Models: A Survey","R. Hebig; D. E. Khelladi; R. Bendraou","Computer Science and Engineering Göteborg, Chalmers University of Technology, Göteborg, Sweden; Sorbonne Universités, UPMC Univ Paris 06, UMR 7606, LIP6, Paris, France; Sorbonne Universités, UPMC Univ Paris 06, UMR 7606, LIP6, Paris, France","IEEE Transactions on Software Engineering","12 May 2017","2017","43","5","396","414","Modeling languages, just as all software artifacts, evolve. This poses the risk that legacy models of a company get lost, when they become incompatible with the new language version. To address this risk, a multitude of approaches for metamodel-model co-evolution were proposed in the last 10 years. However, the high number of solutions makes it difficult for practitioners to choose an appropriate approach. In this paper, we present a survey on 31 approaches to support metamodel-model co-evolution. We introduce a taxonomy of solution techniques and classify the existing approaches. To support researchers, we discuss the state of the art, in order to better identify open issues. Furthermore, we use the results to provide a decision support for practitioners, who aim to adopt solutions from research.","1939-3520","","10.1109/TSE.2016.2610424","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7569018","Survey;software engineering;metamodels;models;design notations and documentation","Unified modeling language;Companies;Taxonomy;Biological system modeling;Atmospheric modeling;Libraries;Productivity","software engineering","coevolution approaches;metamodel-model coevolution;solution technique taxonomy;decision support","","15","","84","","15 Sep 2016","","","IEEE","IEEE Journals"
"A Study of Variability Models and Languages in the Systems Software Domain","T. Berger; S. She; R. Lotufo; A. Wasowski; K. Czarnecki","IT University of Copenhagen, Copenhagen; University of Waterloo, Waterloo; University of Waterloo, Waterloo; IT University of Copenhagen, Copenhagen; University of Waterloo, Waterloo","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1611","1640","Variability models represent the common and variable features of products in a product line. Since the introduction of FODA in 1990, several variability modeling languages have been proposed in academia and industry, followed by hundreds of research papers on variability models and modeling. However, little is known about the practical use of such languages. We study the constructs, semantics, usage, and associated tools of two variability modeling languages, Kconfig and CDL, which are independently developed outside academia and used in large and significant software projects. We analyze 128 variability models found in 12 open--source projects using these languages. Our study 1) supports variability modeling research with empirical data on the real-world use of its flagship concepts. However, we 2) also provide requirements for concepts and mechanisms that are not commonly considered in academic techniques, and 3) challenge assumptions about size and complexity of variability models made in academic papers. These results are of interest to researchers working on variability modeling and analysis techniques and to designers of tools, such as feature dependency checkers and interactive product configurators.","1939-3520","","10.1109/TSE.2013.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6572787","Empirical software engineering;software product lines;variability modeling;feature modeling;configuration;open source","Biological system modeling;Software products;Product line;Analytical models;Computational modeling;Semantics;Computer architecture","public domain software;simulation languages;software engineering","interactive product configurators;feature dependency checkers;variability analysis techniques;open-source projects;software projects;associated language tools;language usage;language semantics;language constructs;CDL language;Kconfig language;variability modeling languages;FODA;systems software domain;variability models","","59","","88","","31 Jul 2013","","","IEEE","IEEE Journals"
"A UML/MARTE Model Analysis Method for Uncovering Scenarios Leading to Starvation and Deadlocks in Concurrent Systems","M. Shousha; L. Briand; Y. Labiche","Carleton University, Ottawa; Simula Research Laboratory, Lysaker and University of Oslo, Norway; Carleton University, Ottawa","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","354","374","Concurrency problems such as starvation and deadlocks should be identified early in the design process. As larger, more complex concurrent systems are being developed, this is made increasingly difficult. We propose here a general approach based on the analysis of specialized design models expressed in the Unified Modeling Language (UML) that uses a specifically designed genetic algorithm to detect concurrency problems. Though the current paper addresses deadlocks and starvation, we will show how the approach can be easily tailored to other concurrency issues. Our main motivations are 1) to devise solutions that are applicable in the context of the UML design of concurrent systems without requiring additional modeling and 2) to use a search technique to achieve scalable automation in terms of concurrency problem detection. To achieve the first objective, we show how all relevant concurrency information is extracted from systems' UML models that comply with the UML Modeling and Analysis of Real-Time and Embedded Systems (MARTE) profile. For the second objective, a tailored genetic algorithm is used to search for execution sequences exhibiting deadlock or starvation problems. Scalability in terms of problem detection is achieved by showing that the detection rates of our approach are, in general, high and are not strongly affected by large increases in the size of complex search spaces.","1939-3520","","10.1109/TSE.2010.107","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5661791","Search-based software engineering;MDD;deadlock;starvation;model analysis;concurrent systems;UML;MARTE;genetic algorithms.","Unified modeling language;Concurrent computing;System recovery;Analytical models;Real time systems;Computational modeling;Data mining","concurrency control;embedded systems;genetic algorithms;search problems;software engineering;Unified Modeling Language","UML-MARTE model analysis method;starvation;deadlocks;concurrency problems;design process;complex concurrent systems;specialized design models;Unified Modeling Language;genetic algorithm;UML design;search technique;scalable automation;concurrency problem detection;concurrency information;UML models;UML modeling and analysis;real-time systems;embedded systems;MARTE profile;execution sequences;complex search spaces","","14","","46","","10 Dec 2010","","","IEEE","IEEE Journals"
"Automatic Summarization of Bug Reports","S. Rastkar; G. C. Murphy; G. Murray","Department of Computer Science, University of British Columbia, 2366 Main Mall, Vancouver, Canada; Department of Computer Science, University of British Columbia, 2366 Main Mall, Vancouver, Canada; Computer Information Systems Department, University of the Fraser Valley, 33844 King Road, Abbotsford, Canada","IEEE Transactions on Software Engineering","2 May 2014","2014","40","4","366","380","Software developers access bug reports in a project's bug repository to help with a number of different tasks, including understanding how previous changes have been made and understanding multiple aspects of particular defects. A developer's interaction with existing bug reports often requires perusing a substantial amount of text. In this article, we investigate whether it is possible to summarize bug reports automatically so that developers can perform their tasks by consulting shorter summaries instead of entire bug reports. We investigated whether existing conversation-based automated summarizers are applicable to bug reports and found that the quality of generated summaries is similar to summaries produced for e-mail threads and other conversations. We also trained a summarizer on a bug report corpus. This summarizer produces summaries that are statistically better than summaries produced by existing conversation-based generators. To determine if automatically produced bug report summaries can help a developer with their work, we conducted a task-based evaluation that considered the use of summaries for bug report duplicate detection tasks. We found that summaries helped the study participants save time, that there was no evidence that accuracy degraded when summaries were used and that most participants preferred working with summaries to working with original bug reports.","1939-3520","","10.1109/TSE.2013.2297712","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6704866","Empirical software engineering;summarization of software artifacts;bug report duplicate detection","Software;Electronic mail;Computer bugs;Natural languages;Feature extraction;Detectors","electronic mail;program debugging;software engineering","automatic summarization;bug reports;software developers;bug repository;conversation-based automated summarizers;e-mail threads;bug report corpus;conversation-based generators;bug report summaries;task-based evaluation;bug report duplicate detection tasks","","79","","41","","9 Jan 2014","","","IEEE","IEEE Journals"
"Parallelizing Bzip2: A Case Study in Multicore Software Engineering","V. Pankratius; A. Jannesari; W. F. Tichy",University of Karlsruhe; University of Karlsruhe; University of Karlsruhe,"IEEE Software","16 Oct 2009","2009","26","6","70","77","We conducted a case study of parallelizing a real program for multicore computers using currently available libraries and tools. We selected the sequential Bzip2 compression program for the study because it's a computing-intensive, widely used, and relevant application in everyday life. Its source code is available, and its algorithm is well documented. In addition, the algorithm is non-trivial, but, with 8,000 LOC, the application is small enough to manage in a course.","1937-4194","","10.1109/MS.2009.183","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287014","Programming techniques;concurrent programming;parallel programming;multicore systems;bzip;concurrency;synchronization;patterns;OpenMP;Posix","Multicore processing;Software engineering;Concurrent computing;Software libraries;Application software;Lab-on-a-chip","data compression;parallel programming;software libraries;software tools","multicore software engineering;parallel programming;multicore computers;libraries;tools;sequential Bzip2 compression program","","21","","18","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Embedded-Software Architects: It's Not Only about the Software","P. O. Antonino; A. Morgenstern; T. Kuhn",Fraunhofer Institute for Experimental Software Engineering; Fraunhofer Institute for Experimental Software Engineering; Fraunhofer Institute for Experimental Software Engineering,"IEEE Software","28 Oct 2016","2016","33","6","56","62","Owing to the increasing amount of computation in electromechanical devices, the role of software architect is often found in embedded-systems development. However, because computer scientists usually have limited knowledge of embedded-systems concepts such as controllers, actuators, and buses, embedded-software architects are often engineers with no education in software architecture basics, which is normally a topic in computer science courses. In these environments, serious architectural problems can occur, such as contradictory architecture decisions and inconsistencies between the architecture design and the architecture drivers. This article discusses the current profile of embedded-software architects, characteristics of embedded architectures designed by architects with no computer science background, and the shortcomings of architects whose knowledge is limited to information systems. The authors also discuss how to overcome these challenges.","1937-4194","","10.1109/MS.2016.142","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725234","system architecture;integration and modeling;software architecture;real-time and embedded systems;domain-specific architectures;software development;software engineering;software architect","Computer architecture;Software architecture;Electromechanical devices;Computational modeling","embedded systems;personnel;software architecture;software development management","embedded software architects;electromechanical devices;embedded systems development;software architecture","","11","","14","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Continuous Delivery: Huge Benefits, but Challenges Too","L. Chen",Paddy Power,"IEEE Software","10 Mar 2015","2015","32","2","50","54","Continuous delivery (CD) has emerged as an auspicious alternative to traditional release engineering, promising to provide the capability to release valuable software continuously to customers. Paddy Power has been implementing CD for the past two years. This article explains why Paddy Power decided to adopt CD, describes the resulting CD capability, and reports the huge benefits and challenges involved. These experiences can provide fellow practitioners with insights for their adoption of CD, and the identified challenges can provide researchers valuable input for developing their research agendas.","1937-4194","","10.1109/MS.2015.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006384","continuous delivery;release engineering;software deployment;DevOps;continuous software engineering;software engineering","Pipelines;Software development;Continuous production;Software engineering;Testing;Companies;Context modeling","research and development;software development management","continuous delivery;release engineering;valuable software;Paddy Power;CD capability;research agendas","","82","","5","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Insights from the Past: The IEEE Software History Experiment","Z. Obrenovic",Software Improvement Group,"IEEE Software","11 Jul 2017","2017","34","4","71","78","A look at the IEEE Software history website illustrates the practical value of historical data and offers a glimpse into the magazine's future.","1937-4194","","10.1109/MS.2017.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974718","IEEE Software;software engineering;software development;history;history of software engineering","History;Unified modeling language;Analytical models;Data models;Software engineering;Market research;IEEE publishing","","","","2","","12","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Francois Raynaud on DevSecOps","K. Carter",BinaryMist,"IEEE Software","22 Sep 2017","2017","34","5","93","96","Host Kim Carter talks with Francois Raynaud about how to easily apply DevOps principles to security, and how this helps improve the relationship between security and development teams and ultimately the success of a product or business. The full podcast of this interview is at www.se-radio.net/2017/04/se-radio-episode-288-devsecops.","1937-4194","","10.1109/MS.2017.3571578","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048652","Francois Raynaud;software engineering;DevSecOps;DevOps;security;software development;software security;SE Radio;Software Engineering Radio","Security;Companies;Software engineering;Computer bugs;Software development","","","","4","","","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Amorphous Slicing of Extended Finite State Machines","K. Androutsopoulos; D. Clark; M. Harman; R. M. Hierons; Z. Li; L. Tratt","University College London, London; University College London, London; University College London, London; Brunel University, Uxbridge, Middlesex; Beijing University of Chemical Technology, Beijing; King's Colledge London, London","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","892","909","Slicing is useful for many software engineering applications and has been widely studied for three decades, but there has been comparatively little work on slicing extended finite state machines (EFSMs). This paper introduces a set of dependence-based EFSM slicing algorithms and an accompanying tool. We demonstrate that our algorithms are suitable for dependence-based slicing. We use our tool to conduct experiments on 10 EFSMs, including benchmarks and industrial EFSMs. Ours is the first empirical study of dependence-based program slicing for EFSMs. Compared to the only previously published dependence-based algorithm, our average slice is smaller 40 percent of the time and larger only 10 percent of the time, with an average slice size of 35 percent for termination insensitive slicing.","1939-3520","","10.1109/TSE.2012.72","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6374192","Slicing;extended finite state machines","Automata;Algorithm design and analysis;Approximation algorithms;Software algorithms;Unified modeling language;Educational institutions;Electronic mail","finite state machines;program slicing;software engineering","software engineering application;extended finite state machine slicing;dependence-based EFSM slicing algorithm;benchmarks EFSM;industrial EFSM;dependence-based program slicing;termination insensitive slicing;amorphous slicing","","12","","62","","4 Dec 2012","","","IEEE","IEEE Journals"
"The Role of the Tester's Knowledge in Exploratory Software Testing","J. Itkonen; M. V. Mäntylä; C. Lassenius","Aalto University School of Science, Espoo; Aalto University School of Science, Espoo; Aalto University School of Science, Espoo","IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","707","724","We present a field study on how testers use knowledge while performing exploratory software testing (ET) in industrial settings. We video recorded 12 testing sessions in four industrial organizations, having our subjects think aloud while performing their usual functional testing work. Using applied grounded theory, we analyzed how the subjects performed tests and what type of knowledge they utilized. We discuss how testers recognize failures based on their personal knowledge without detailed test case descriptions. The knowledge is classified under the categories of domain knowledge, system knowledge, and general software engineering knowledge. We found that testers applied their knowledge either as a test oracle to determine whether a result was correct or not, or for test design, to guide them in selecting objects for test and designing tests. Interestingly, a large number of failures, windfall failures, were found outside the actual focus areas of testing as a result of exploratory investigation. We conclude that the way exploratory testers apply their knowledge for test design and failure recognition differs clearly from the test-case-based paradigm and is one of the explanatory factors of the effectiveness of the exploratory testing approach.","1939-3520","","10.1109/TSE.2012.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6298893","Software testing;exploratory testing;validation;test execution;test design;human factors;methods for SQA;and V&V","Software testing;Context;Software;Knowledge engineering;Observers;Organizations","program testing;software engineering","tester knowledge;exploratory software testing;ET;functional testing;grounded theory;personal knowledge;domain knowledge;system knowledge;general software engineering knowledge;test oracle;windfall failures;test design;failure recognition;test-case-based paradigm","","40","","76","","11 Sep 2012","","","IEEE","IEEE Journals"
"Interaction Models and Automated Control under Partial Observable Environments","D. Ciolek; V. Braberman; N. D’Ippolito; N. Piterman; S. Uchitel","Departamento de Computación, Universidad de Buenos Aires, Argentina; Departamento de Computación, Universidad de Buenos Aires, Argentina; Department of Computing, Imperial College, London, United Kingdom; Department of Computer Science, University of Leicester, Leicester, United Kingdom; Department of Computing, Imperial College, London, United Kingdom","IEEE Transactions on Software Engineering","9 Jan 2017","2017","43","1","19","33","The problem of automatically constructing a software component such that when executed in a given environment satisfies a goal, is recurrent in software engineering. Controller synthesis is a field which fits into this vision. In this paper we study controller synthesis for partially observable LTS models. We exploit the link between partially observable control and non-determinism and show that, unlike fully observable LTS or Kripke structure control problems, in this setting the existence of a solution depends on the interaction model between the controller-to-be and its environment. We identify two interaction models, namely Interface Automata and Weak Interface Automata, define appropriate control problems and describe synthesis algorithms for each of them.","1939-3520","","10.1109/TSE.2016.2564959","ERC; PBM-FIMBSE; ANPCYT PICT; ANPCYT PICT; ANPCYT PICT; UBACYT; UBACYT; CONICET PIP; MEALS; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7466810","LTS;controller synthesis;imperfect-information games","Servers;Maintenance engineering;Automata;Context;Observability;Uncertainty","automata theory;software engineering","interaction models;automated control;software engineering;controller synthesis;partially observable LTS models;partially observable control;weak interface automata;labelled transition systems","","8","","35","","9 May 2016","","","IEEE","IEEE Journals"
"Genetic Algorithms for Randomized Unit Testing","J. H. Andrews; T. Menzies; F. C. H. Li","University of Western Ontario, London, Ont., Canada; West Virginia University, Morgantown, WV, USA; University of Western Ontario, London, Ont., Canada","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","80","94","Randomized testing is an effective method for testing software units. The thoroughness of randomized unit testing varies widely according to the settings of certain parameters, such as the relative frequencies with which methods are called. In this paper, we describe Nighthawk, a system which uses a genetic algorithm (GA) to find parameters for randomized unit testing that optimize test coverage. Designing GAs is somewhat of a black art. We therefore use a feature subset selection (FSS) tool to assess the size and content of the representations within the GA. Using that tool, we can reduce the size of the representation substantially while still achieving most of the coverage found using the full representation. Our reduced GA achieves almost the same results as the full system, but in only 10 percent of the time. These results suggest that FSS could significantly optimize metaheuristic search-based software engineering tools.","1939-3520","","10.1109/TSE.2010.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704237","Software testing;randomized testing;genetic algorithms;feature subset selection;search-based optimization;testing tools.","Testing;Biological cells;Gallium;Receivers;Software;Java;Optimization","feature extraction;genetic algorithms;program testing;randomised algorithms;search problems;software engineering","genetic algorithm;randomized unit testing;relative frequency;Nighthawk;optimized test coverage;feature subset selection tool;metaheuristic search;software engineering tool;software testing","","46","","49","","28 Jan 2011","","","IEEE","IEEE Journals"
"Safer User Interfaces: A Case Study in Improving Number Entry","H. Thimbleby","Department of Computer Science, Swansea University, Swansea SA2 0SF, Wales, United Kingdom","IEEE Transactions on Software Engineering","14 Jul 2015","2015","41","7","711","729","Numbers are used in critical applications, including finance, healthcare, aviation, and of course in every aspect of computing. User interfaces for number entry in many devices (calculators, spreadsheets, infusion pumps, mobile phones, etc.) have bugs and design defects that induce unnecessary use errors that compromise their dependability. Focusing on Arabic key interfaces, which use digit keys 0-9-· usually augmented with correction keys, this paper introduces a method for formalising and managing design problems. Since number entry and devices such as calculators have been the subject of extensive user interface research since at least the 1980s, the diverse design defects uncovered imply that user evaluation methodologies are insufficient for critical applications. Likewise, formal methods are not being applied effectively. User interfaces are not trivial and more attention should be paid to their correct design and implementation. The paper includes many recommendations for designing safer number entry user interfaces.","1939-3520","","10.1109/TSE.2014.2383396","Engineering and Physical Sciences Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6991548","Error processing;Software/Software Engineering;User interfaces;Human Factors in Software Design;User Interfaces;Information Interfaces;Representation (HCI);Error processing;software/software engineering;user interfaces;human factors in software design;user interfaces;information interfaces and representation (HCI)","User interfaces;Calculators;Computer bugs;Safety;Pressing;Software;Debugging","user interfaces","safer user interfaces;number entry;Arabic key interfaces;correction keys;design problem formalization;design problem management","","15","","47","","18 Dec 2014","","","IEEE","IEEE Journals"
"Testing from Partial Finite State Machines without Harmonised Traces","R. M. Hierons","Department of Computer Science, Brunel University London, Uxbridge, United Kingdom","IEEE Transactions on Software Engineering","10 Nov 2017","2017","43","11","1033","1043","This paper concerns the problem of testing from a partial, possibly non-deterministic, finite state machine (FSM) S. Two notions of correctness (quasi-reduction and quasi-equivalence) have previously been defined for partial FSMs but these, and the corresponding test generation techniques, only apply to FSMs that have harmonised traces. We show how quasi-reduction and quasi-equivalence can be generalised to all partial FSMs. We also consider the problem of generating an m-complete test suite from a partial FSM S: a test suite that is guaranteed to determine correctness as long as the system under test has no more than m states. We prove that we can complete S to form a completely-specified non-deterministic FSM S' such that any m-complete test suite generated from S' can be converted into an m-complete test suite for S. We also show that there is a correspondence between test suites that are reduced for S and S' and also that are minimal for S and S'.","1939-3520","","10.1109/TSE.2017.2652457","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7815407","Software engineering/software/program verification;software engineering/testing and debugging;systems and software;checking experiment;partial finite state machine","Testing;Fault detection;Redundancy;Automata;Indexes;Software;Debugging","finite state machines;formal specification;program testing","finite state machine;test generation techniques;nondeterministic FSM;partial finite state machines;m-complete test suite;harmonised traces;partial FSMs","","","","30","Traditional","16 Jan 2017","","","IEEE","IEEE Journals"
"An Investigation into the Functional Form of the Size-Defect Relationship for Software Modules","A. G. Koru; D. Zhang; K. El Emam; H. Liu","University of Maryland Baltimore County, Baltimore; University of Maryland Baltimore County, Baltimore; University of Ottawa, Ottawa; Georgetown University, Washington","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","293","304","The importance of the relationship between size and defect proneness of software modules is well recognized. Understanding the nature of that relationship can facilitate various development decisions related to prioritization of quality assurance activities. Overall, the previous research only drew a general conclusion that there was a monotonically increasing relationship between module size and defect proneness. In this study, we analyzed class-level size and defect data in order to increase our understanding of this crucial relationship. In order to obtain validated and more generalizable results, we studied four large-scale object-oriented products, Mozilla, Cn3d, JBoss, and Eclipse. Our results consistently revealed a significant effect of size on defect proneness; however, contrary to common intuition, the size-defect relationship took a logarithmic form, indicating that smaller classes were proportionally more problematic than larger classes. Therefore, practitioners should consider giving higher priority to smaller modules when planning focused quality assurance activities with limited resources. For example, in Mozilla and Eclipse, an inspection strategy investing 80% of available resources on 100-LOC classes and the rest on 1,000-LOC classes would be more than twice as cost effective as the opposite strategy. These results should be immediately useful to guide focused quality assurance activities in large-scale software projects.","1939-3520","","10.1109/TSE.2008.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4693715","Software science;Product metrics;Planning for SQA and Measurement applied to SQA and Software Quality/SQA;Software Engineering;Software/Software Engin;Open-source software;Software science;Product metrics;Planning for SQA and Measurement applied to SQA and Software Quality/SQA;Software Engineering;Software/Software Engin;Open-source software","Open source software;Software quality;Size measurement;Inspection;Object oriented modeling;Predictive models;Quality assurance;Large-scale systems;Software measurement;Density measurement","object-oriented methods;project management;software management;software metrics;software quality","software modules;size-defect relationship;quality assurance activities;object-oriented products;Mozilla;Cn3d;JBoss;Eclipse;software projects;product metrics","","82","","60","","2 Dec 2008","","","IEEE","IEEE Journals"
"State-Density Functions over DBM Domains in the Analysis of Non-Markovian Models","L. Carnevali; L. Grassi; E. Vicario","Università di Firenze, Firenze; Università di Firenze, Firenze; Università di Firenze, Firenze","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","178","194","Quantitative evaluation of models with generally-distributed transitions requires analysis of non-Markovian processes that may be not isomorphic to their underlying untimed models and may include any number of concurrent non-exponential timers. The analysis of stochastic Time Petri Nets copes with the problem by covering the state space with stochastic-classes, which extend Difference Bounds Matrices (DBM) with a state probability density function. We show that the state-density function accepts a continuous piecewise representation over a partition in DBM-shaped sub-domains. We then develop a closed-form symbolic calculus of state-density functions assuming that model transitions have expolynomial distributions. The calculus shows that within each sub-domain the state-density function is a multivariate expolynomial function and makes explicit how this form evolves through subsequent transitions. This enables an efficient implementation of the analysis process and provides the formal basis that supports introduction of an approximate analysis based on Bernstein Polynomials. The approximation attacks practical and theoretical limits in the applicability of stochastic state-classes, and devises a new approach to the analysis of non Markovian models, relying on approximations in the state space rather than in the structure of the model.","1939-3520","","10.1109/TSE.2008.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4711059","Software Engineering;Tools;Validation;Software and System Safety;Software/Program Verification;Formal methods;Reliability;Automata;Parallelism and concurrency;Approximation;Markov processes;Renewal theory;Stochastic processes;Software Engineering;Tools;Validation;Software and System Safety;Software/Program Verification;Formal methods;Reliability;Automata;Parallelism and concurrency;Approximation;Markov processes;Renewal theory;Stochastic processes","Stochastic processes;Function approximation;State-space methods;Petri nets;Density functional theory;Calculus;Polynomials;Software safety;Timing;Encoding","calculus;concurrency control;Petri nets;polynomial approximation;polynomial matrices;program verification;state-space methods;statistical distributions;stochastic processes","difference bound matrix domain;nonMarkovian model analysis;concurrent nonexponential timer;stochastic time Petri net;state space;state probability density function;continuous piecewise representation;closed-form symbolic calculus;expolynomial distribution;multivariate expolynomial function;approximate analysis;Bernstein polynomial;quantitative evaluation;untimed model;timed software verification","","25","","39","","12 Dec 2008","","","IEEE","IEEE Journals"
"Automatic Extraction of Heap Reference Properties in Object-Oriented Programs","B. Demsky; M. Rinard","University of California, Irvine, Irvine; Massachusetts Institute of Technology, Cambridge","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","305","324","We present a new technique for helping developers understand heap referencing properties of object-oriented programs and how the actions of the program affect these properties. Our dynamic analysis uses the aliasing properties of objects to synthesize a set of roles; each role represents an abstract object state intended to be of interest to the developer. We allow the developer to customize the analysis to explore the object states and behavior of the program at multiple different and potentially complementary levels of abstraction. The analysis uses roles as the basis for three abstractions: role transition diagrams, which present the observed transitions between roles and the methods responsible for the transitions; role relationship diagrams, which present the observed referencing relationships between objects playing different roles; and enhanced method interfaces, which present the observed roles of method parameters. Together, these abstractions provide useful information about important object and data structure properties and how the actions of the program affect these properties. We have implemented the role analysis and have used this implementation to explore the behavior of several Java programs. Our experience indicates that, when combined with a powerful graphical user interface, roles are a useful abstraction for helping developers explore and understand the behavior of object-oriented programs.","1939-3520","","10.1109/TSE.2008.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4693716","Program understanding;roles;design recovery.;Requirements/Specifications;Design Tools and Techniques;Software Engineering;Software/Software Engineering;Testing and Debugging","Data structures;Computer Society;Java;Graphical user interfaces;Information analysis;Data mining","data structures;diagrams;graphical user interfaces;Java;object-oriented programming;reverse engineering","automatic extraction;heap reference property;object-oriented program;role transition diagram;enhanced method interface;data structure;Java program;graphical user interface;program understanding;role relationship diagram","","3","1","30","","2 Dec 2008","","","IEEE","IEEE Journals"
"Ant Colony Optimization for Software Project Scheduling and Staffing with an Event-Based Scheduler","W. Chen; J. Zhang","Sun Yat-sen University, Guangzhou; Sun Yat-sen University, Guangzhou","IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","1","17","Research into developing effective computer aided techniques for planning software projects is important and challenging for software engineering. Different from projects in other fields, software projects are people-intensive activities and their related resources are mainly human resources. Thus, an adequate model for software project planning has to deal with not only the problem of project task scheduling but also the problem of human resource allocation. But as both of these two problems are difficult, existing models either suffer from a very large search space or have to restrict the flexibility of human resource allocation to simplify the model. To develop a flexible and effective model for software project planning, this paper develops a novel approach with an event-based scheduler (EBS) and an ant colony optimization (ACO) algorithm. The proposed approach represents a plan by a task list and a planned employee allocation matrix. In this way, both the issues of task scheduling and employee allocation can be taken into account. In the EBS, the beginning time of the project, the time when resources are released from finished tasks, and the time when employees join or leave the project are regarded as events. The basic idea of the EBS is to adjust the allocation of employees at events and keep the allocation unchanged at nonevents. With this strategy, the proposed method enables the modeling of resource conflict and task preemption and preserves the flexibility in human resource allocation. To solve the planning problem, an ACO algorithm is further designed. Experimental results on 83 instances demonstrate that the proposed method is very promising.","1939-3520","","10.1109/TSE.2012.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6165315","Software project planning;project scheduling;resource allocation;workload assignment;ant colony optimization (ACO)","Software;Resource management;Planning;Humans;Project management;Job shop scheduling;Search problems","ant colony optimisation;human resource management;planning (artificial intelligence);project management;scheduling;software management","ant colony optimization algorithm;software project scheduling;software project staffing;event-based scheduler;computer aided techniques;software project planning;software engineering;project task scheduling problem;human resource allocation problem;EBS;ACO;task list;planned employee allocation matrix;resource conflict modeling;task preemption modeling","","94","","51","","6 Mar 2012","","","IEEE","IEEE Journals"
"MOSES: A Framework for QoS Driven Runtime Adaptation of Service-Oriented Systems","V. Cardellini; E. Casalicchio; V. Grassi; S. Iannucci; F. L. Presti; R. Mirandola","University of Roma ""Tor Vergata"", Roma; University of Roma ""Tor Vergata"", Roma; University of Roma ""Tor Vergata"", Roma; University of Roma ""Tor Vergata"", Roma; University of Roma ""Tor Vergata"", Roma; Politecnico di Milano, Milano","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1138","1159","Architecting software systems according to the service-oriented paradigm and designing runtime self-adaptable systems are two relevant research areas in today's software engineering. In this paper, we address issues that lie at the intersection of these two important fields. First, we present a characterization of the problem space of self-adaptation for service-oriented systems, thus providing a frame of reference where our and other approaches can be classified. Then, we present MOSES, a methodology and a software tool implementing it to support QoS-driven adaptation of a service-oriented system. It works in a specific region of the identified problem space, corresponding to the scenario where a service-oriented system architected as a composite service needs to sustain a traffic of requests generated by several users. MOSES integrates within a unified framework different adaptation mechanisms. In this way it achieves greater flexibility in facing various operating environments and the possibly conflicting QoS requirements of several concurrent users. Experimental results obtained with a prototype implementation of MOSES show the effectiveness of the proposed approach.","1939-3520","","10.1109/TSE.2011.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5963694","Service-oriented architecture;runtime adaptation;quality of service","Service oriented architecture;Quality of service;Runtime;Concrete;Semiconductor optical amplifiers;Adaptation models;Software systems","service-oriented architecture","MOSES;QoS driven runtime adaptation;service oriented system;software system architecture;service oriented paradigm;runtime self adaptable system;software engineering;self adaptation;QoS-driven adaptation;service-oriented system","","91","","62","","28 Jul 2011","","","IEEE","IEEE Journals"
"Combining Perceptions and Prescriptions in Requirements Engineering Process Assessment: An Industrial Case Study","N. P. Napier; L. Mathiassen; R. D. Johnson","Georgia Gwinnett College, Lawrenceville; Georgia State University, Atlanta; University of Pretoria, Pretoria","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","593","606","Requirements engineering (RE) is a key discipline in software development and several methods are available to help assess and improve RE processes. However, these methods rely on prescriptive models of RE; they do not, like other disciplines within software engineering, draw directly on stakeholder perceptions and subjective judgments. Given this backdrop, we present an empirical study in RE process assessment. Our aim was to investigate how stakeholder perceptions and process prescriptions can be combined during assessments to effectively inform RE process improvement. We first describe existing methods for RE process assessment and the role played by stakeholder perceptions and subjective judgments in the software engineering and management literature. We then present a method that combines perceptions and prescriptions in RE assessments together with an industrial case study in which the method was applied and evaluated over a three-year period at TelSoft. The data suggest that the combined method led to a comprehensive and rich assessment and it helped TelSoft consider RE as an important and integral part of the broader engineering context. This, in turn, led to improvements that combined plan-driven and adaptive principles for RE. Overall, the combined method helped TelSoft move from Level 1 to Level 2 in RE maturity, and the employees perceived the resulting engineering practices to be improved. Based on these results, we suggest that software managers and researchers combine stakeholder perceptions and process prescriptions as one way to effectively balance the specificity, comparability, and accuracy of software process assessments.","1939-3520","","10.1109/TSE.2009.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4967614","Process implementation and change;qualitative process analysis;requirements engineering process;software management;software process.","Software engineering;Computer industry;Programming;Engineering management;Software quality;Project management;Risk management;Educational institutions;Data engineering;Quality management","formal specification;formal verification;project management;software development management;software maintenance;software process improvement;software quality;statistical analysis;systems analysis","requirements engineering process assessment;industrial case study;software development;RE prescription model;software engineering;stakeholder perception;subjective judgment;empirical study;software RE process improvement;software project management;TelSoft;plan-driven principle;adaptive principle;software process change;qualitative process analysis","","22","","56","","26 May 2009","","","IEEE","IEEE Journals"
"A Framework for Evaluating the Results of the SZZ Approach for Identifying Bug-Introducing Changes","D. A. da Costa; S. McIntosh; W. Shang; U. Kulesza; R. Coelho; A. E. Hassan","Department of Informatics and Applied Mathematics (DIMAp), Federal University of Rio Grande do Norte, Natal-RN, Brazil; Department of Electrical and Computer Engineering, McGill University, Montreal, QC, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada; Department of Informatics and Applied Mathematics (DIMAp), Federal University of Rio Grande do Norte, Natal-RN, Brazil; Department of Informatics and Applied Mathematics (DIMAp), Federal University of Rio Grande do Norte, Natal-RN, Brazil; Software Analysis and Intelligence Lab (SAIL), School of Computing, Queen’s University, Kingston, ON, Canada","IEEE Transactions on Software Engineering","14 Jul 2017","2017","43","7","641","657","The approach proposed by Silwerski, Zimmermann, and Zeller (SZZ) for identifying bug-introducing changes is at the foundation of several research areas within the software engineering discipline. Despite the foundational role of SZZ, little effort has been made to evaluate its results. Such an evaluation is a challenging task because the ground truth is not readily available. By acknowledging such challenges, we propose a framework to evaluate the results of alternative SZZ implementations. The framework evaluates the following criteria: (1) the earliest bug appearance, (2) the future impact of changes, and (3) the realism of bug introduction. We use the proposed framework to evaluate five SZZ implementations using data from ten open source projects. We find that previously proposed improvements to SZZ tend to inflate the number of incorrectly identified bug-introducing changes. We also find that a single bug-introducing change may be blamed for introducing hundreds of future bugs. Furthermore, we find that SZZ implementations report that at least 46 percent of the bugs are caused by bug-introducing changes that are years apart from one another. Such results suggest that current SZZ implementations still lack mechanisms to accurately identify bug-introducing changes. Our proposed framework provides a systematic mean for evaluating the data that is generated by a given SZZ implementation.","1939-3520","","10.1109/TSE.2016.2616306","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7588121","SZZ;evaluation framework;bug detection;software repository mining","Computer bugs;Software engineering;Electronic mail;Software;Manuals;History;Systematics","program debugging","SZZ approach;bug-introducing change identification;Silwerski-Zimmermann-Zeller approach;ground truth;open source projects;data evaluation","","18","","54","","11 Oct 2016","","","IEEE","IEEE Journals"
"Managing Software Complexity and Variability in Coupled Climate Models","S. Rugaber; R. Dunlap; l. mark; S. Ansari",Georgia Institute of Technology; Georgia Institute of Technology; Georgia Institute of Technology; Georgia Institute of Technology,"IEEE Software","20 Oct 2011","2011","28","6","43","48","Coupled climate models exhibit scientific, numerical, and architectural variability. This variability introduces requirements that give rise to complexity. However, techniques exist that can tame this complexity; one such technique is feature analysis. As climate model fidelity and complexity increase, the climate-modeling community should adopt a systematic way to deal with software variability.","1937-4194","","10.1109/MS.2011.114","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5999646","climate modeling;earth and atmospheric sciences;automatic programming;domain engineering;reusable software;software engineering","Meteorology;Atmospheric modeling;Global warming;Software development;Atmospheric measurements;Analytical models;Data models","computational complexity;software engineering","software complexity;software variability;coupled climate models;architectural variability;numerical variability;scientific variability;feature analysis;climate modeling community","","3","","13","","25 Aug 2011","","","IEEE","IEEE Magazines"
"On the Impact of Being Open","R. Schuwer; M. van Genuchten; L. Hatton",Fontys University of Applied Sciences; VitalHealth; Kingston University,"IEEE Software","21 Aug 2015","2015","32","5","81","83","There's much discussion about being open, with topics such as open source software, open innovation, open research, and open education. Will the whole world be open, and, if so, what was all closed in the past? The authors analyze the similarities and differences between the open movements they've been part of and come up with expectations for software's future.","1937-4194","","10.1109/MS.2015.111","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217776","open source;open source software;open education;open research;Creative Commons;open educational resources;OER;massive open online courses;MOOC;software development;software engineering","Companies;Open Access;Education;Open source software;Linux;Licenses","public domain software;software engineering","open source software;open education;open research;open innovation","","7","","14","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Agile Documentation, Anyone?","B. Selic",Malina Software Corp.,"IEEE Software","16 Oct 2009","2009","26","6","11","12","Software developers are notorious for skimping on design documentation, often eschewing it altogether. This trend has led to claims that it is merely an impediment in the fast-paced and highly pliable world of software development-a useless vestige of old-style engineering that should be eliminated altogether. While recognizing the unique nature of software, the author argues that, because of the complexity of modern software systems and the cryptic nature of current programming languages, good design documentation is not only useful but vital. However, we must seek ways of adapting it to suit the medium as well as the exceptionally dynamic development process.","1937-4194","","10.1109/MS.2009.167","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287001","Documentation;Software engineering;Software maintenance","Documentation;Impedance;Software systems;Computer languages","software engineering;system documentation","agile documentation;software development;old-style engineering;modern software system complexity;programming languages;dynamic development process","","30","","2","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Drawing Conclusions from Linked Data on the Web: The EYE Reasoner","R. Verborgh; J. De Roo",Multimedia Lab; Agfa Healthcare,"IEEE Software","23 Apr 2015","2015","32","3","23","27","Linked data represents each piece of data as a link between two things. It lets software reasoners arrive at conclusions in a human-like way. This column discusses how the EYE reasoner exploits linked data and how industry is employing EYE.","1937-4194","","10.1109/MS.2015.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093047","EYE;Semantic Web;software engineering;software development;reasoning;linked data","Software;Cognition;Resource description framework;Engines;Uniform resource locators;Hardware","Internet;software engineering","linked data;eye reasoner;software reasoners","","20","","2","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Frequently Unanswered Questions","G. J. Holzmann",Jet Propulsion Laboratory,"IEEE Software","25 Apr 2016","2016","33","3","10","12","We often think of software development as an ideally streamlined process consisting of three phases: design, build, and test. If we want our code to be useful to anyone, though, we'll reluctantly have to acknowledge that we also need a documentation phase, which typically comes at the very end. Generally, there will be some iterations across these phases before we get everything right. In large software development projects, the design phase should result in a list of requirements the final code must satisfy. There's no reason why you couldn't develop the test suite at that point, which should eventually be able to show that each requirement was met. Documenting the requirements and tests up front will force you to be clear about the intended performance envelope of an application. That in turn can let you make an informed assessment of the risk that the application will find itself outside that performance envelope when conditions aren't favorable.","1937-4194","","10.1109/MS.2016.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458766","software documentation;software design;programming;test-driven development;model-driven design;software engineering;software development","Documentation;Software;Manuals;Reliability;Force;Games","program testing;software engineering","software development;software design phase;software build phase;software test phase","","","","4","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Work Substitution: A Neo-Luddite Look at Software Growth","A. Rutkowski",Tilburg University,"IEEE Software","25 Apr 2016","2016","33","3","101","104","With the big data trend, automated algorithmic decision making will open the door to countless more lines of code. Too many people already worship and revere software as a solution to human needs. And, in a continuous spiral, more data collection accelerates the need for more technology and more automated decision support systems. On a neo-Luddite view, the author is concerned about how such systems will impact our safety, sense of privacy, and psychological well-being, and in the long run replace the best of our humanity-our gut feelings. The author proposes to switch your empathetic button on and consider some of the consequence of building too much software, particularly if you're building automated decision support systems.","1937-4194","","10.1109/MS.2016.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458772","neo-Luddite;software growth;automated systems;self-driving cars;software automation;aviation software;healthcare software;software engineering;software development","Software development;Decision making;Self-driving automobiles;Medical services;Physiology;Automation;Aircraft","decision support systems;software engineering","neo-Luddite view;software growth;Big Data;data collection;decision support systems","","4","","17","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Multimedia Software for Mobile Phones","L. Bouchard",RealNetworks,"IEEE Software","19 Apr 2010","2010","27","3","8","10","The amount of software in mobile phones has increased dramatically over recent years-up to 20 million LOC in some cases-resulting in a magnitude of new features from apps to multimedia. To keep up with the rapidly expanding market, software developers for mobile phones must be innovative and astute.","1937-4194","","10.1109/MS.2010.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452142","software engineering;standards;RealNetworks;Helix;best practices;mobile phones","Mobile handsets;Lab-on-a-chip","mobile computing;mobile handsets;multimedia communication;software engineering","multimedia software;mobile phones;software developer","","10","","","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Out of Bounds","G. J. Holzmann",Jet Propulsion Laboratory,"IEEE Software","28 Oct 2015","2015","32","6","24","26","Writing reliable code means understanding bounds. Only a finite amount of memory is available for computation, only a finite amount of time exists to do it, and every object we store and modify must be finite. Resources are similarly bounded. Stacks are bounded, queues are bounded, file system capacity is bounded, and even numbers are bounded. This makes the world of computer science very different from the world of mathematics, but too few people take this into account when they write code.","1937-4194","","10.1109/MS.2015.147","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310984","reliable code;counter overflow;Deep Impact;Boeing 787;Dreamliner;generator control unit;GCU;LightSail;Curiosity;Mars rover;EPOXI;software engineering;software development","Radiation detectors;Space vehicles;Flash memories;File systems;Random access memory","software engineering","code writing;similarly bounded Resources;bounded stacks;bounded queues;bounded file system capacity;bounded numbers;computer science","","1","","2","","28 Oct 2015","","","IEEE","IEEE Magazines"
"The Role of Design Spaces","M. Shaw",Carnegie-Mellon University,"IEEE Software","22 Dec 2011","2012","29","1","46","50","A central task in design is deciding what artifact will best satisfy the client's needs, whether that requires creating an artifact or choosing from existing alternatives. A design space identifies and organizes the decisions that must be made, together with the alternatives for those decisions, thereby providing guidance for creating artifacts or a framework for comparing them. The Studying Professional Software Design workshop studied three pairs of professional software designers sketching designs for a traffic signal simulator. A discussion of the design space for the simulation task shows how this design space enables comparison of the designs. It also illustrates the benefits of explicitly considering the design space during design and the risks of failing to do so.","1937-4194","","10.1109/MS.2011.121","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6030869","software engineering;design;software design;design space","Software design;Software architecture;Software design;Product development;Object oriented modeling","software engineering","design space;Studying Professional Software Design workshop;traffic signal simulator","","11","","11","","29 Sep 2011","","","IEEE","IEEE Magazines"
"In the Pursuit of Hygge Software","H. D. Vianna; J. L. V. Victória Barbosa; F. Pittoli",University of Vale do Rio dos Sinos; University of Vale do Rio dos Sinos; University of Vale do Rio dos Sinos,"IEEE Software","13 Nov 2017","2017","34","6","48","52","Hygge is a Danish and Norwegian word for well-being related to conviviality. Two healthcare scenarios show ways to achieve hygge by integrating software and distributed technologies.","1937-4194","","10.1109/MS.2017.4121208","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106876","distributed applications;ubiquitous computing;real-time systems;embedded systems;pervasive computing;hygge;U’Ductor;ChronicDuctor;ChronicPrediction;healthcare;software development;software engineering;context-aware and smart healthcare","Middleware;Medical services;Real-time systems;Embedded systems;Privacy;Access control;Context awareness","distributed processing;health care;software engineering","distributed technologies;healthcare;Hygge software","","","","7","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Monitoring Requirements in Systems of Systems","M. Vierhauser; R. Rabiser; P. Grünbacher",Johannes Kepler University Linz; Johannes Kepler University Linz; Johannes Kepler University Linz,"IEEE Software","24 Aug 2016","2016","33","5","22","24","Developers of systems of systems (SoSs) face challenges such as heterogeneous, inconsistent, and changing elements; continuous evolution and deployment; decentralized control; and inherently conflicting and often unknowable requirements. In response to these challenges, researchers are developing the ReMinds tool. Engineers can use it to instrument systems in an SoS to extract events and data at runtime and to define requirements as constraints to check expected behavior and properties. ReMinds can also visualize and explain requirements violations to facilitate diagnosis.","1937-4194","","10.1109/MS.2016.112","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548894","systems of systems;SoS;ReMinds;software requirements;software development;software engineering","Monitoring;Heterogeneous networks;Runtime;Decentralized control;Software systems;Data mining;Data visualization;Runtime","software engineering","SoS requirements monitoring;system-of-systems;ReMinds tool","","","","6","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Job Security","D. Spinellis",Athens University of Economics and Business,"IEEE Software","25 Aug 2009","2009","26","5","14","15","In this paper, job security in code design is discussed. Techniques on how to make codes unreadable is mentioned. Like when naming variables, methods, fields, and classes, the readers can use some languages such as Java that is well-established naming conventions regarding capitalization and the joining of words. The author also suggest that the reader can make use of many IDEs that insert boilerplate comments at the beginning of each method and class. This column also suggest that the more unreadable the code the more indispensable a programmer with his job.","1937-4194","","10.1109/MS.2009.131","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222787","job security;maintainability;analyzability;coupling;stability;testability;design;software engineering","Testing;Data security;Job design;Packaging;Information services;Web sites;Internet;Programming profession;Debugging;Protocols","design engineering;DP industry;software engineering;unemployment","job security;Java;code design;programmer","","","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Gamification","D. Basten",University of Cologne,"IEEE Software","22 Sep 2017","2017","34","5","76","81","Games can help motivate people in otherwise nongame scenarios and engage users in high interaction. This article explores gamification applications and underlying technologies.","1937-4194","","10.1109/MS.2017.3571581","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048643","Badgeville Enterprise Plus;CROWN SharePoint Learning Management System;customer relationship management;Ford p2p Cup;Ford Professional Performance Program Cup;gamification;Jive Advanced Gamification Module;Nitro;SAP Cloud Platform Gamification;software development;software engineering;Zoho CRM;Zurmo","Customer relationship management;Software testing;Games;Companies;Training;Mobile communication","computer games;human computer interaction;software engineering;user interfaces","gamification;users interaction;software technologies","","6","","10","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Conway's Law Revisited: The Evidence for a Task-Based Perspective","I. Kwan; M. Cataldo; D. Damian",Oregon State University; Robert Bosch; University of Victoria,"IEEE Software","22 Dec 2011","2012","29","1","90","93","Conway's law, also called the mirroring hypothesis, predicts that a development organization will inevitably design systems that mirror its organizational communication structure. The alignment between architecture and communication applies to physical systems, but not necessarily to software systems. In this article, the authors present evidence that a task-level view of Conway's law can realize the benefits of alignment in software systems.","1937-4194","","10.1109/MS.2012.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111370","software design;software architecture;organizations;evidence-based software engineering;engineering management","Software design;Product development;Prediction theory;Software deveopment","law;software engineering","Conway law;task-based perspective;mirroring hypothesis law;organizational communication structure;software system alignment","","18","","18","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Software Module Clustering as a Multi-Objective Search Problem","K. Praditwong; M. Harman; X. Yao","The University of Birmingham, Birmingham; University College London, London; The University of Birmingham, Birmingham","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","264","282","Software module clustering is the problem of automatically organizing software units into modules to improve program structure. There has been a great deal of recent interest in search-based formulations of this problem in which module boundaries are identified by automated search, guided by a fitness function that captures the twin objectives of high cohesion and low coupling in a single-objective fitness function. This paper introduces two novel multi-objective formulations of the software module clustering problem, in which several different objectives (including cohesion and coupling) are represented separately. In order to evaluate the effectiveness of the multi-objective approach, a set of experiments was performed on 17 real-world module clustering problems. The results of this empirical study provide strong evidence to support the claim that the multi-objective approach produces significantly better solutions than the existing single-objective approach.","1939-3520","","10.1109/TSE.2010.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406532","SBSE;module clustering;multi-objective optimization;evolutionary computation.","Search problems;Computer science;Performance evaluation;Software engineering;Clustering algorithms;Computational intelligence;Testing;Educational institutions;Computer applications;Application software","optimisation;pattern clustering;search problems;software engineering","software module clustering;multi-objective search problem;program structure","","210","1","32","","5 Feb 2010","","","IEEE","IEEE Journals"
"Mining Sequences of Developer Interactions in Visual Studio for Usage Smells","K. Damevski; D. C. Shepherd; J. Schneider; L. Pollock","Department of Computer Science, Virginia Commonwealth University, Richmond, VA; ABB Corporate Research, Raleigh, NC; ABB Corporate Research, Baden-Dättwill, Switzerland; Department of Computer and Information Sciences, University of Delaware, Newark, DE","IEEE Transactions on Software Engineering","14 Apr 2017","2017","43","4","359","371","In this paper, we present a semi-automatic approach for mining a large-scale dataset of IDE interactions to extract usage smells, i.e., inefficient IDE usage patterns exhibited by developers in the field. The approach outlined in this paper first mines frequent IDE usage patterns, filtered via a set of thresholds and by the authors, that are subsequently supported (or disputed) using a developer survey, in order to form usage smells. In contrast with conventional mining of IDE usage data, our approach identifies time-ordered sequences of developer actions that are exhibited by many developers in the field. This pattern mining workflow is resilient to the ample noise present in IDE datasets due to the mix of actions and events that these datasets typically contain. We identify usage patterns and smells that contribute to the understanding of the usability of Visual Studio for debugging, code search, and active file navigation, and, more broadly, to the understanding of developer behavior during these software development activities. Among our findings is the discovery that developers are reluctant to use conditional breakpoints when debugging, due to perceived IDE performance problems as well as due to the lack of error checking in specifying the conditional.","1939-3520","","10.1109/TSE.2016.2592905","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7516714","IDE usage data;data mining;pattern mining;usability analysis","Data mining;Visualization;Usability;Data analysis;Debugging;Software engineering;Navigation","data mining;program debugging;software engineering","developer interactions sequences mining;visual studio;usage smells extraction;large-scale dataset mining;IDE interactions;frequent IDE usage pattern mining;time-ordered sequences identifies;active file navigation;code search;software development activities","","20","","26","","19 Jul 2016","","","IEEE","IEEE Journals"
"Keeping the Development Environment Up to Date—A Study of the Situated Practices of Appropriating the Eclipse IDE","S. Draxler; G. Stevens; A. Boden","Department for Information Systems and New Media, University of Siegen, Siegen, Germany; Department for Information Systems and New Media, University of Siegen, Siegen, Germany; Usability and User Experience Design Competence Center, Fraunhofer Institute for Applied Information Technology FIT, Sankt Augustin, Germany","IEEE Transactions on Software Engineering","10 Nov 2014","2014","40","11","1061","1074","Software engineers and developers are surrounded by highly complex software systems. What does it take to cope with these? We introduce a field study that explores the maintenance of the Eclipse Integrated Development Environment by software developers as part of their daily work. The study focuses on appropriation of the Eclipse IDE. We present an empirical view on appropriation as a means to maintain the collective ability to work. We visited seven different organizations and observed and interviewed their members. Each organization was chosen to provide an overall picture of Eclipse use throughout the industry. The results decompose the appropriation of Eclipse by software developers in organizations into four categories: learning, tailoring and discovering, as well as the cross-cutting category: collaboration. The categories are grounded in situations that provoked a need to change as well as in policies adopted for coping with this need. By discussing these categories against the background of Eclipse and its ecosystem, we want to illustrate in what ways appropriation of component- or plugin- based software is nowadays a common and highly complex challenge for Eclipse users, and how the related appropriation practices can be supported by IT systems.","1939-3520","","10.1109/TSE.2014.2354047","German Federal Ministry for Education and Research; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898825","Programmer workbench;human factors in software design;deployment;usage experience","Software;Organizations;Computer aided software engineering;Interviews;Context;Employment;Ecosystems","object-oriented languages;object-oriented programming;software engineering","development environment;Eclipse IDE;software engineers;software developers;highly complex software systems;Eclipse Integrated Development Environment;component-based software;plugin-based software;IT systems","","2","","60","","15 Sep 2014","","","IEEE","IEEE Journals"
"Effect of Domain Knowledge on Elicitation Effectiveness: An Internally Replicated Controlled Experiment","A. M. Aranda; O. Dieste; N. Juristo","Escuela Técnica Superior de Ingenieros Informáticos, Universidad Politécnica de Madrid, Campus de Montegancedo, Boadilla del Monte, Spain; Escuela Técnica Superior de Ingenieros Informáticos, Universidad Politécnica de Madrid, Campus de Montegancedo, Boadilla del Monte, Spain; Escuela Técnica Superior de Ingenieros Informáticos, Universidad Politécnica de Madrid, Campus de Montegancedo, Boadilla del Monte, Spain","IEEE Transactions on Software Engineering","12 May 2016","2016","42","5","427","451","Context. Requirements elicitation is a highly communicative activity in which human interactions play a critical role. A number of analyst characteristics or skills may influence elicitation process effectiveness. Aim. Study the influence of analyst problem domain knowledge on elicitation effectiveness. Method. We executed a controlled experiment with post-graduate students. The experimental task was to elicit requirements using open interview and consolidate the elicited information immediately afterwards. We used four different problem domains about which students had different levels of knowledge. Two tasks were used in the experiment, whereas the other two were used in an internal replication of the experiment; that is, we repeated the experiment with the same subjects but with different domains. Results. Analyst problem domain knowledge has a small but statistically significant effect on the effectiveness of the requirements elicitation activity. The interviewee has a big positive and significant influence, as does general training in requirements activities and interview experience. Conclusion. During early contacts with the customer, a key factor is the interviewee; however, training in tasks related to requirements elicitation and knowledge of the problem domain helps requirements analysts to be more effective.","1939-3520","","10.1109/TSE.2015.2494588","Spanish Ministry of Ministry of Economy and Competitiveness; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7307191","Controlled experiment;domain knowledge;requirements elicitation;internal replication;Controlled experiment;domain knowledge;requirements elicitation;internal replication","Interviews;Knowledge engineering;Computer science;Software engineering;Requirements engineering;Training","software engineering","requirements elicitation;elicitation effectiveness;internally replicated controlled experiment;problem domain knowledge","","15","","56","","26 Oct 2015","","","IEEE","IEEE Journals"
"The Impact of Lessons-Learned Sessions on Effort Estimation and Uncertainty Assessments","M. Jørgensen; T. M. Gruschke","Simula Research Laboratory and University of Oslo, Norway; KnowIT Objectnet, Oslo","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","368","383","Inaccurate estimates of software development effort is a frequently reported cause of IT-project failures. We report results from a study that investigated the effect of introducing lessons-learned sessions on estimation accuracy and the assessment of uncertainty. Twenty software professionals were randomly allocated to a Learning group or a Control group and instructed to estimate and complete the same five development tasks. Those in the Learning group but not those in the Control group were instructed to spend at least 30 minutes on identifying, analyzing, and summarizing their effort estimation and uncertainty assessment experience after completing each task. We found that the estimation accuracy and the realism of the uncertainty assessment were not better in the Learning group than in the Control group. A follow-up study with 83 software professionals was completed to better understand this lack of improvement from lessons-learned sessions. The follow-up study found that receiving feedback about other software professionals' estimation performance led to more realistic uncertainty assessments than receiving the same feedback of one's own estimates. Lessons-learned sessions, not only in estimation contexts, have to be carefully designed to avoid wasting resources on learning processes that stimulate rather than reduce learning biases.","1939-3520","","10.1109/TSE.2009.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4752843","Cost estimation;process implementation and change;review and evaluation;software psychology.","Uncertainty;Yield estimation;Feedback;Programming;Software performance;Psychology;Software engineering;Computer industry;Acoustic reflection;Databases","feedback;learning systems;software engineering","lessons-learned sessions;effort estimation;uncertainty assessments;software development;IT-project failures;feedback;learning process","","41","","42","","19 Jan 2009","","","IEEE","IEEE Journals"
"A Model-Based Approach to Families of Embedded Domain-Specific Languages","J. Sanchez Cuadrado; J. G. Molina","University of Murcia, Murcia; University of Murcia, Murcia","IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","825","840","With the emergence of model-driven engineering (MDE), the creation of domain-specific languages (DSLs) is becoming a fundamental part of language engineering. The development cost of a DSL should be modest compared to the cost of developing a general-purpose programming language. Reducing the implementation effort and providing reuse techniques are key aspects for DSL approaches to be really effective. In this paper, we present an approach to build embedded domain-specific languages applying the principles of model-driven engineering. On the basis of this approach, we will tackle reuse of DSLs by defining families of DSLs, addressing reuse both from the DSL developer and user point of views. A family of DSLs will be built up by composing several DSLs, so we will propose composition mechanisms for the abstract syntax, concrete syntax, and model transformation levels of a DSL's definition. Finally, we contribute a software framework to support our approach, and we illustrate the paper with a case study to demonstrate its practical applicability.","1939-3520","","10.1109/TSE.2009.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4782971","Domain-specific languages;model-driven development;families of DSLs;DSL composition.","Domain specific languages;DSL;Model driven engineering;Object oriented modeling;Costs;Computer languages;Concrete;Metamodeling;Proposals;Software engineering","computational linguistics;programming languages;software engineering","embedded domain-specific languages;model-driven engineering;programming language;abstract syntax;concrete syntax;model transformation levels","","25","","38","","13 Feb 2009","","","IEEE","IEEE Journals"
"Data Quality: Some Comments on the NASA Software Defect Datasets","M. Shepperd; Q. Song; Z. Sun; C. Mair","Brunel University, Uxbridge; Xi'an Jiaotong University, Xi'an; Xi'an Jiaotong University, Xi'an; Southampton Solent University, Southampton","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1208","1215","Background--Self-evidently empirical analyses rely upon the quality of their data. Likewise, replications rely upon accurate reporting and using the same rather than similar versions of datasets. In recent years, there has been much interest in using machine learners to classify software modules into defect-prone and not defect-prone categories. The publicly available NASA datasets have been extensively used as part of this research. Objective--This short note investigates the extent to which published analyses based on the NASA defect datasets are meaningful and comparable. Method--We analyze the five studies published in the IEEE Transactions on Software Engineering since 2007 that have utilized these datasets and compare the two versions of the datasets currently in use. Results--We find important differences between the two versions of the datasets, implausible values in one dataset and generally insufficient detail documented on dataset preprocessing. Conclusions--It is recommended that researchers 1) indicate the provenance of the datasets they use, 2) report any preprocessing in sufficient detail to enable meaningful replication, and 3) invest effort in understanding the data prior to applying machine learners.","1939-3520","","10.1109/TSE.2013.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6464273","Empirical software engineering;data quality;machine learning;defect prediction","NASA;Software;PROM;Educational institutions;Sun;Communities;Abstracts","data analysis;learning (artificial intelligence);pattern classification;software reliability","data quality;NASA software defect dataset;National Aeronautics and Space Administration;data replication;machine learning;software module classification;defect-prone classification;not-defect-prone classification;IEEE Transactions on Software Engineering;data preprocessing;dataset provenance","","197","","21","","18 Feb 2013","","","IEEE","IEEE Journals"
"Measuring Code Quality to Improve Specification Mining","C. Le Goues; W. Weimer","University of Virginia, Charlottesville; University of Virginia, Charlottesville","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","175","190","Formal specifications can help with program testing, optimization, refactoring, documentation, and, most importantly, debugging and repair. However, they are difficult to write manually, and automatic mining techniques suffer from 90-99 percent false positive rates. To address this problem, we propose to augment a temporal-property miner by incorporating code quality metrics. We measure code quality by extracting additional information from the software engineering process and using information from code that is more likely to be correct, as well as code that is less likely to be correct. When used as a preprocessing step for an existing specification miner, our technique identifies which input is most indicative of correct program behavior, which allows off-the-shelf techniques to learn the same number of specifications using only 45 percent of their original input. As a novel inference technique, our approach has few false positives in practice (63 percent when balancing precision and recall, 3 percent when focused on precision), while still finding useful specifications (e.g., those that find many bugs) on over 1.5 million lines of code.","1939-3520","","10.1109/TSE.2011.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680914","Specification mining;machine learning;software engineering;code metrics;program understanding.","Software measurement;Refactoring;Data mining;Maintenance engineering;Cloning;Optimization","data mining;formal specification;program debugging;program testing;software quality","specification mining;formal specifications;program testing;optimization;refactoring;documentation;debugging;repair;automatic mining techniques;temporal-property miner;code quality metrics;software engineering process","","20","","61","","6 Jan 2011","","","IEEE","IEEE Journals"
"Identification, Impact, and Refactoring of Smells in Pipe-Like Web Mashups","K. T. Stolee; S. Elbaum","Iowa State University, Ames; University of Nebraska-Lincoln, Lincoln","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1654","1679","With the emergence of tools to support visual mashup creation, tens of thousands of users have started to access, manipulate, and compose data from web sources. We have observed, however, that mashups created by these users tend to suffer from deficiencies that propagate as mashups are reused, which happens frequently. To address these deficiencies, we would like to bring some of the benefits of software engineering techniques to the end users creating these programs. In this work, we focus on identifying code smells indicative of the deficiencies we observed in web mashups programmed in the popular Yahoo! Pipes environment. Through an empirical study, we explore the impact of those smells on the preferences of 61 users, and observe that a significant majority of users prefer mashups without smells. We then introduce refactorings targeting those smells. These refactorings reduce the complexity of the mashup programs, increase their abstraction, update broken data sources and dated components, and standardize their structures to fit the community development patterns. Our assessment of a sample of over 8,000 mashups shows that smells are present in 81 percent of them and that the proposed refactorings can reduce the number of smelly mashups to 16 percent, illustrating the potential of refactoring to support the thousands of end-users programming mashups. Further, we explore how the smells and refactorings can apply to other end-user programming domains to show the generalizability of our approach.","1939-3520","","10.1109/TSE.2013.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6589568","End-user software engineering;end-user programming;web mashups;refactoring;code smells;empirical studies","Mashups;Visualization;Factoring;Generators;Programming","Internet;software maintenance","smell identification;smell impact;smell refactoring;pipe-like Web mashups;visual mashup creation;Web sources;software engineering techniques;Yahoo! Pipes environment;end-users programming mashups","","12","","56","","6 Sep 2013","","","IEEE","IEEE Journals"
"Uncovering Latent Social Communities in Software Development","D. A. Tamburri; P. Lago; H. van Vliet",VU University Amsterdam; VU University Amsterdam; VU University Amsterdam,"IEEE Software","3 Jan 2013","2013","30","1","29","36","Software development is increasingly carried out by developer communities in a global setting. One way to prepare for development success is to uncover and harmonize these communities to exploit their collective, collaborative potential. A proposed decision tree can help practitioners do this.","1937-4194","","10.1109/MS.2012.170","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6336697","Communities;Social network services;Problem-solving;Organizational aspects;Software development;Globalization;Decision making;Decision trees;software engineering organizations;global software engineering;social communities;development communities;community detection","Communities;Social network services;Problem-solving;Organizational aspects;Software development;Globalization;Decision making;Decision trees","decision trees;social networking (online);software engineering","latent social communities;software development;decision tree;developer communities;collaborative potential","","21","","9","","22 Oct 2012","","","IEEE","IEEE Magazines"
"A Tale of Two Conferences","H. Erdogmus",National Research Council Canada,"IEEE Software","22 Dec 2008","2009","26","1","4","7","For the 2008 ICSE and Agile conferences, The magazine's editor in chief prepared a flash poll to gauge key perceptions regarding the separation between software engineering research and software development practice. The results for each conference were interesting, but the differences between the two groups were especially revealing.","1937-4194","","10.1109/MS.2009.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721171","software engineering research;software development practice;collaboration","Software engineering;Coatings;Cultural differences;Circuit testing;Software testing;Project management;Software development management;Programming;Personal communication networks;Sampling methods","","","","","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Safety, Security, Now Sustainability: The Nonfunctional Requirement for the 21st Century","B. Penzenstadler; A. Raturi; D. Richardson; B. Tomlinson","University of California, Irvine; University of California, Irvine; University of California, Irvine; University of California, Irvine","IEEE Software","21 Apr 2014","2014","31","3","40","47","Many software systems today control large-scale sociotechnical systems. These systems aren't just entangled with the environment but also with our dwindling resources and mostly unsustainable way of living, while the planet's population continues to grow. Dealing with sustainability requirements and systematically supporting their elicitation, analysis, and realization is a problem that has yet to be solved. Decades ago, the discipline of software engineering dealt with similar shortcomings in its processes by including safety and security as new system qualities. In light of the increasing consequences of inadequately addressing sustainability in developing software systems, software engineers must apply the lessons learned from these prior research efforts and identify the necessary research agenda. Considering sustainability in software engineering means more than energy efficiency and green IT, which are concerned with the first-order impacts of software systems. Software engineers must also take into account the second- and third-order impacts in the system context, even if they're hard to assess. By doing so, engineers have the potential to considerably improve civilization's sustainability. The Web extra at http://youtu.be/VC07j6a1XUw is a video in which author Birgit Penzenstadler talks about how software engineers can considerably improve civilization's sustainability by taking into account not just the first-order impacts of software systems but also their second- and third-order impacts.","1937-4194","","10.1109/MS.2014.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6728940","requirements engineering;sustainability;green software;software;security;nonfunctional requirements","Security;Safety;Software systems;Green products;Software engineering;Standards","safety;security of data;software engineering","nonfunctional requirement;software systems;large-scale sociotechnical systems;software engineering;civilization sustainability;energy efficiency;green IT;software security;software safety;sustainability requirements","","43","","24","","30 Jan 2014","","","IEEE","IEEE Magazines"
"Clarifications on the Construction and Use of the ManyBugs Benchmark","C. Le Goues; Y. Brun; S. Forrest; W. Weimer","School of Computer Science, Carnegie Mellon University, Pittsburgh, PA; College of Information and Computer Science, University of Massachusetts at Amherst, Amherst, MA; Department of Computer Science, University of New Mexico, Albuquerque, NM; Computer Science and Engineering, University of Michigan, Ann Arbor, MI","IEEE Transactions on Software Engineering","10 Nov 2017","2017","43","11","1089","1090","Automated repair techniques produce variant php interpreters, which should naturally serve as the tested interpreters. However, the answer to the question of what should serve as the testing interpreter is less obvious. php's default test harness configuration uses the same version of the interpreter for both the tested and testing interpreter. However, php may be configured via a command-line argument to use a different interpreter, such as the unmodified defective version, or a separate, manually-repaired version.","1939-3520","","10.1109/TSE.2017.2755651","US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048536","","Maintenance engineering;Benchmark testing;Computer science;Electronic mail;Software engineering;Software","program debugging","ManyBugs benchmark;automated repair techniques;test harness configuration;testing interpreter","","1","","7","Traditional","22 Sep 2017","","","IEEE","IEEE Journals"
"Mutation Operators for Spreadsheets","R. Abraham; M. Erwig","Oregon State University, Corvallis; Oregon State University, Corvallis","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","94","108","Based on 1) research into mutation testing for general-purpose programming languages and 2) spreadsheet errors that have been reported in the literature, we have developed a suite of mutation operators for spreadsheets. We present an evaluation of the mutation adequacy of definition-use adequate test suites generated by a constraint-based automatic test-case generation system we have developed in previous work. The results of the evaluation suggest additional constraints that can be incorporated into the system to target mutation adequacy. In addition to being useful in mutation testing of spreadsheets, the operators can be used in the evaluation of error-detection tools and also for seeding spreadsheets with errors for empirical studies. We describe two case studies where the suite of mutation operators helped us carry out such empirical evaluations. The main contribution of this paper is a suite of mutation operators for spreadsheets that can be used for performing empirical evaluations of spreadsheet tools to indicate ways in which the tools can be improved.","1939-3520","","10.1109/TSE.2008.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4609389","Test coverage of code;Test design;Spreadsheets;Test coverage of code;Test design;Spreadsheets","Genetic mutations;System testing;Software testing;Computer languages;Automatic testing;Software engineering;Costs;Performance evaluation;Spreadsheet programs;Collaboration","program testing;spreadsheet programs","spreadsheet mutation operator;constraint-based automatic test-case generation system;error-detection tool;general purpose programming language;mutation testing","","38","1","86","","29 Aug 2008","","","IEEE","IEEE Journals"
"Performance Analysis for Object-Oriented Software: A Systematic Mapping","D. Maplesden; E. Tempero; J. Hosking; J. C. Grundy","Department of Computer Science, University of Auckland, Private Bag 92019, Auckland 1142, New Zealand; Department of Computer Science, University of Auckland, Private Bag 92019, Auckland 1142, New Zealand; Faculty of Science, University of Auckland, Private Bag 92019, Auckland 1142, New Zealand; Faculty of Information and Communication Technologies, Swinburne University of Technology, Hawthorn, Vic. 3122, Australia","IEEE Transactions on Software Engineering","14 Jul 2015","2015","41","7","691","710","Performance is a crucial attribute for most software, making performance analysis an important software engineering task. The difficulty is that modern applications are challenging to analyse for performance. Many profiling techniques used in real-world software development struggle to provide useful results when applied to large-scale object-oriented applications. There is a substantial body of research into software performance generally but currently there exists no survey of this research that would help identify approaches useful for object-oriented software. To provide such a review we performed a systematic mapping study of empirical performance analysis approaches that are applicable to object-oriented software. Using keyword searches against leading software engineering research databases and manual searches of relevant venues we identified over 5,000 related articles published since January 2000. From these we systematically selected 253 applicable articles and categorised them according to ten facets that capture the intent, implementation and evaluation of the approaches. Our mapping study results allow us to highlight the main contributions of the existing literature and identify areas where there are interesting opportunities. We also find that, despite the research including approaches specifically aimed at object-oriented software, there are significant challenges in providing actionable feedback on the performance of large-scale object-oriented applications.","1939-3520","","10.1109/TSE.2015.2396514","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7024167","Systematic review;survey;performance;object-oriented;Systematic review;survey;performance;object-oriented","Performance analysis;Systematics;Software performance;Databases;Mathematical model;Runtime","database management systems;object-oriented methods;program diagnostics;software performance evaluation","performance analysis;object-oriented software;systematic mapping;software engineering task;profiling techniques;software engineering research database","","9","","17","","27 Jan 2015","","","IEEE","IEEE Journals"
"The Value of Exact Analysis in Requirements Selection","L. Li; M. Harman; F. Wu; Y. Zhang","Department of Computer Science, CREST, University College London, Gower Street, London, United Kingdom; Department of Computer Science, CREST, University College London, Gower Street, London, United Kingdom; Department of Computer Science, CREST, University College London, Gower Street, London, United Kingdom; Department of Computer Science, CREST, University College London, Gower Street, London, United Kingdom","IEEE Transactions on Software Engineering","12 Jun 2017","2017","43","6","580","596","Uncertainty is characterised by incomplete understanding. It is inevitable in the early phase of requirements engineering, and can lead to unsound requirement decisions. Inappropriate requirement choices may result in products that fail to satisfy stakeholders' needs, and might cause loss of revenue. To overcome uncertainty, requirements engineering decision support needs uncertainty management. In this research, we develop a decision support framework METRO for the Next Release Problem (NRP) to manage algorithmic uncertainty and requirements uncertainty. An exact NRP solver (NSGDP) lies at the heart of METRO. NSGDP's exactness eliminates interference caused by approximate existing NRP solvers. We apply NSGDP to three NRP instances, derived from a real world NRP instance, RALIC, and compare with NSGA-II, a widely-used approximate (inexact) technique. We find the randomness of NSGA-II results in decision makers missing up to 99.95 percent of the optimal solutions and obtaining up to 36.48 percent inexact requirement selection decisions. The chance of getting an inexact decision using existing approximate approaches is negatively correlated with the implementation cost of a requirement (Spearman r up to -0.72). Compared to the inexact existing approach, NSGDP saves 15.21 percent lost revenue, on average, for the RALIC dataset.","1939-3520","","10.1109/TSE.2016.2615100","China Scholarship Council (CSC); EPSRC; DAASE; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7582553","Software engineering;exact multi-objective optimisation;simulation optimisation;next release problem","Uncertainty;Stakeholders;Robustness;Optimization;Software;Software engineering;Software algorithms","decision support systems;formal specification","requirements engineering decision support;METRO;next-release problem;algorithmic uncertainty management;requirements uncertainty management;exact NRP solver;NSGDP;NRP solvers;optimal solutions;inexact requirement selection decisions;RALIC dataset","","9","","62","CCBY","4 Oct 2016","","","IEEE","IEEE Journals"
"Improved Evolutionary Algorithm Design for the Project Scheduling Problem Based on Runtime Analysis","L. L. Minku; D. Sudholt; X. Yao","CERCIA, School of Computer Science , The University of Birmingham, Birmingham B15 2TT, United Kingdom; Department of Computer Science , University of Sheffield, Sheffield S1 4DP, United Kingdom; CERCIA, School of Computer Science , The University of Birmingham, Birmingham B15 2TT, United Kingdom","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","1","83","102","Several variants of evolutionary algorithms (EAs) have been applied to solve the project scheduling problem (PSP), yet their performance highly depends on design choices for the EA. It is still unclear how and why different EAs perform differently. We present the first runtime analysis for the PSP, gaining insights into the performance of EAs on the PSP in general, and on specific instance classes that are easy or hard. Our theoretical analysis has practical implications-based on it, we derive an improved EA design. This includes normalizing employees' dedication for different tasks to ensure they are not working overtime; a fitness function that requires fewer pre-defined parameters and provides a clear gradient towards feasible solutions; and an improved representation and mutation operator. Both our theoretical and empirical results show that our design is very effective. Combining the use of normalization to a population gave the best results in our experiments, and normalization was a key component for the practical effectiveness of the new design. Not only does our paper offer a new and effective algorithm for the PSP, it also provides a rigorous theoretical analysis to explain the efficiency of the algorithm, especially for increasingly large projects.","1939-3520","","10.1109/TSE.2013.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648326","Schedule and organizational issues;evolutionary algorithms;software project scheduling;software project management;search-based software engineering;runtime analysis","Software;Schedules;Scheduling;Algorithm design and analysis;Software algorithms;Resource management;Software engineering","evolutionary computation;project management;scheduling;software development management","improved evolutionary algorithm;project scheduling problem;runtime analysis;PSP;improved EA design;employee dedication;fitness function;representation operator;mutation operator;population normalization;software project scheduling","","20","","45","CCBY","25 Oct 2013","","","IEEE","IEEE Journals"
"Learning Project Management Decisions: A Case Study with Case-Based Reasoning versus Data Farming","T. Menzies; A. Brady; J. Keung; J. Hihn; S. Williams; O. El-Rawas; P. Green; B. Boehm","West Virginia University, Morgantown; West Virginia University, Morgantown; The City University of Hong Kong, Hong Kong; California Institute of Technology, Pasadena; Indiana University, Bloomington; West Virginia University, Morgantown; West Virginia University, Morgantown; University of Southern California, Los Angeles","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1698","1713","Background: Given information on just a few prior projects, how do we learn the best and fewest changes for current projects? Aim: To conduct a case study comparing two ways to recommend project changes. 1) Data farmers use Monte Carlo sampling to survey and summarize the space of possible outcomes. 2) Case-based reasoners (CBR) explore the neighborhood around test instances. Method: We applied a state-of-the data farmer (SEESAW) and a CBR tool ()'V2) to software project data. Results: CBR with )'V2 was more effective than SEESAW's data farming for learning best and recommended project changes, effectively reducing runtime, effort, and defects. Further, CBR with )'V2 was comparably easier to build, maintain, and apply in novel domains, especially on noisy data sets. Conclusion: Use CBR tools like )'V2 when data are scarce or noisy or when project data cannot be expressed in the required form of a data farmer. Future Work: This study applied our own CBR tool to several small data sets. Future work could apply other CBR tools and data farmers to other data (perhaps to explore other goals such as, say, minimizing maintenance effort).","1939-3520","","10.1109/TSE.2013.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6600685","Search-based software engineering;case-based reasoning;data farming;COCOMO","Data models;Project management;Search methods;Monte Carlo methods;Mathematical model;Software engineering","case-based reasoning;data handling;learning (artificial intelligence);Monte Carlo methods;project management;sampling methods;software management","project management decision learning;case-based reasoning;data farming;Monte Carlo sampling;CBR;SEESAW;software project data","","8","","101","","16 Sep 2013","","","IEEE","IEEE Journals"
"Does Socio-Technical Congruence Have an Effect on Software Build Success? A Study of Coordination in a Software Project","I. Kwan; A. Schroter; D. Damian","University of Victoria, Victoria; University of Victoria, Victoria; University of Victoria, Victoria","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","307","324","Socio-technical congruence is an approach that measures coordination by examining the alignment between the technical dependencies and the social coordination in the project. We conduct a case study of coordination in the IBM Rational Team Concert project, which consists of 151 developers over seven geographically distributed sites, and expect that high congruence leads to a high probability of successful builds. We examine this relationship by applying two congruence measurements: an unweighted congruence measure from previous literature, and a weighted measure that overcomes limitations of the existing measure. We discover that there is a relationship between socio-technical congruence and build success probability, but only for certain build types, and observe that in some situations, higher congruence actually leads to lower build success rates. We also observe that a large proportion of zero-congruence builds are successful, and that socio-technical gaps in successful builds are larger than gaps in failed builds. Analysis of the social and technical aspects in IBM Rational Team Concert allows us to discuss the effects of congruence on build success. Our findings provide implications with respect to the limits of applicability of socio-technical congruence and suggest further improvements of socio-technical congruence to study coordination.","1939-3520","","10.1109/TSE.2011.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5740929","Empirical software engineering;socio-technical congruence;coordination;awareness;software quality;integration.","Software;Weight measurement;Programming;Software measurement;Collaboration;Software engineering;Context","social aspects of automation;software development management","socio-technical congruence;software build success;software project;social coordination;congruence measurements;unweighted congruence measure;weighted measure","","67","1","54","","5 Apr 2011","","","IEEE","IEEE Journals"
"A Theoretical and Empirical Study of Search-Based Testing: Local, Global, and Hybrid Search","M. Harman; P. McMinn","King's College London, London; University of Sheffield, Sheffield","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","226","247","Search-based optimization techniques have been applied to structural software test data generation since 1992, with a recent upsurge in interest and activity within this area. However, despite the large number of recent studies on the applicability of different search-based optimization approaches, there has been very little theoretical analysis of the types of testing problem for which these techniques are well suited. There are also few empirical studies that present results for larger programs. This paper presents a theoretical exploration of the most widely studied approach, the global search technique embodied by Genetic Algorithms. It also presents results from a large empirical study that compares the behavior of both global and local search-based optimization on real-world programs. The results of this study reveal that cases exist of test data generation problem that suit each algorithm, thereby suggesting that a hybrid global-local search (a Memetic Algorithm) may be appropriate. The paper presents a Memetic Algorithm along with further empirical results studying its performance.","1939-3520","","10.1109/TSE.2009.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5342440","Automated test data generation;search-based testing;search-based software engineering;Evolutionary Testing;Genetic Algorithms;Hill Climbing;schema theory;Royal Road;testing and debugging;testing tools;artificial intelligence;problem solving;control methods;and search;heuristic methods;algorithms;experimentation;measurement;performance;theory.","Software testing;Automatic testing;Genetic algorithms;Costs;Hybrid power systems;Software engineering;Automation;Stress;Debugging;Artificial intelligence","automatic test software;genetic algorithms;program testing;search problems","search based testing;search based optimization techniques;structural software test data generation;genetic algorithms;hybrid global-local search problem;memetic algorithm;real-world programs","","213","","61","","1 Dec 2009","","","IEEE","IEEE Journals"
"UML Everywhere","D. Spinellis",Athens University of Economics and Business,"IEEE Software","19 Aug 2010","2010","27","5","90","91","A standardized and widely used diagramming notation is a sign of a profession's maturity. It simplifies the life of the diverse group of people who read the drawings, it improves the quality of the drawings, and it benefits the profession through network effects. In the field of software engineering we've got a long way to travel. Every one of us should make a concerted effort to use the same graphic notation for drawing all our diagrams. We should adopt the graphic notation techniques of Unified Modeling Language (UML).","1937-4194","","10.1109/MS.2010.131","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551018","Unified modeling language;UML;diagram;notation","Unified modeling language;Programming;Economics","software engineering;Unified Modeling Language","UML;unified modeling language;diagramming notation;software engineering;graphic notation","","","","","","19 Aug 2010","","","IEEE","IEEE Magazines"
"Estimation Tools and Techniques","L. Buglione; C. Ebert",Engineering.IT SpA; Vector Consulting Services,"IEEE Software","25 Apr 2011","2011","28","3","91","94","Estimating size or resources is one of the most important topics in software engineering and IT. You won't deliver according to expectations if you don't plan, and you can't plan if you don't know the underlying dependencies and estimates. This column is an overview of estimation. It covers estimation methods and provides an overview and evaluation of popular estimation tools.","1937-4194","","10.1109/MS.2011.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5756296","estimation;software tools;benchmarking","Estimation;Software measurement;Databases","software engineering","estimation tools;estimation techniques;software engineering;IT","","8","","7","","25 Apr 2011","","","IEEE","IEEE Magazines"
"Next-Generation Architects for a Harsh Business World","W. A. Risi",KPMG Argentina,"IEEE Software","20 Feb 2012","2012","29","2","9","12","Walter Ariel Risi proposes some patterns for hiring productive people that remind me of research done in the early days of patterns by Jim Coplien, who found that hyperproductive teams included, in many cases, musicians! In the old days, companies often hired smart people from other disciplines because software engineering or computer science hadn't joined the academic production of certified, degreed contributors. With the current focus now on degrees, I wonder if we've lost something important.","1937-4194","","10.1109/MS.2012.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155136","personnel;HR;architects;traditional;nontraditional","Career development;Personnel;Engineering profession;Computer science education;Research and development","personnel;recruitment;software engineering","next generation architects;harsh business world;productive people hiring;hyperproductive team;musicians;smart people hiring;software engineering;computer science;academic production;degreed contributor","","1","","","","20 Feb 2012","","","IEEE","IEEE Magazines"
"Keyword Search for Building Service-Based Systems","Q. He; R. Zhou; X. Zhang; Y. Wang; D. Ye; F. Chen; J. C. Grundy; Y. Yang","State Key Laboratory of Software Engineering, Wuhan University, Wuhan, China; Centre for Applied Informatics, Victoria University, Melbourne, Australia; University of Auckland, Auckland, New Zealand; School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia; School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia; School of Engineering and Information Technology, Federation University Australia, Melbourne, Australia; School of Information Technology, Deakin University, Geelong, Victoria, Australia; School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia","IEEE Transactions on Software Engineering","14 Jul 2017","2017","43","7","658","674","With the fast growth of applications of service-oriented architecture (SOA) in software engineering, there has been a rapid increase in demand for building service-based systems (SBSs) by composing existing Web services. Finding appropriate component services to compose is a key step in the SBS engineering process. Existing approaches require that system engineers have detailed knowledge of SOA techniques which is often too demanding. To address this issue, we propose Keyword Search for Service-based Systems (KS3), a novel approach that integrates and automates the system planning, service discovery and service selection operations for building SBSs based on keyword search. KS3 assists system engineers without detailed knowledge of SOA techniques in searching for component services to build SBSs by typing a few keywords that represent the tasks of the SBSs with quality constraints and optimisation goals for system quality, e.g., reliability, throughput and cost. KS3 offers a new paradigm for SBS engineering that can significantly save the time and effort during the system engineering process. We conducted large-scale experiments using two real-world Web service datasets to demonstrate the practicality, effectiveness and efficiency of KS3.","1939-3520","","10.1109/TSE.2016.2624293","Australian Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7731135","Service-based system;keyword search;service composition;web service;quality of service;cloud computing","Service-oriented architecture;Data models;Keyword search;Buildings;Planning;Libraries","service-oriented architecture;Web services","keyword search;service-based system building;service-oriented architecture;software engineering;Web services;SBS engineering process;SOA techniques;KS3","","6","","51","","2 Nov 2016","","","IEEE","IEEE Journals"
"App Store 2.0: From Crowdsourced Information to Actionable Feedback in Mobile Ecosystems","M. Gómez; B. Adams; W. Maalej; M. Monperrus; R. Rouvoy",Inria Lille; Polytechnique Montréal; University of Hamburg; University of Lille; University of Lille,"IEEE Software","28 Mar 2017","2017","34","2","81","89","Given the increasing competition in mobile-app ecosystems, improving the user experience has become a major goal for app vendors. App Store 2.0 will exploit crowdsourced information about apps, devices, and users to increase the overall quality of the delivered mobile apps. App Store 2.0 generates different kinds of actionable feedback from the crowd information. This feedback helps developers deal with potential errors that could affect their apps before publication or even when the apps are in the users' hands. The App Store 2.0 vision has been transformed into a concrete implementation for Android devices. This article is part of a special issue on Crowdsourcing for Software Engineering.","1937-4194","","10.1109/MS.2017.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888388","Android;app store;App Store 2.0;crowdsourcing;user feedback;mobile apps;software engineering;data-driven software development;software development","Computer crashes;Monitoring;Context modeling;Mobile communication;Ecosystems;Performance evaluation;Androids;Mobile computing;Computer applications","Android (operating system);crowdsourcing;mobile computing;smart phones;software engineering","App Store 2.0;crowdsourced information;actionable feedback;mobile ecosystems;mobile-app ecosystems;user experience;app vendors;mobile apps;Android devices;crowdsourcing;software engineering","","11","2","22","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Comprehensive Multiplatform Dynamic Program Analysis for Java and Android","Y. Zheng; S. Kell; L. Bulej; H. Sun; W. Binder",Università della Svizzera italiana; University of Cambridge; Università della Svizzera italiana; Università della Svizzera italiana; Università della Svizzera italiana,"IEEE Software","23 Jun 2016","2016","33","4","55","63","Dynamic program analysis, such as with profiling, tracing, and bug-finding tools, is essential for software engineering. Unfortunately, implementing dynamic analysis for managed languages such as Java is unduly difficult and error prone because the runtime environments provide only complex low-level mechanisms. Programmers writing custom tooling must expend great effort in tool development and maintenance, while still suffering substantial limitations such as incomplete code coverage or lack of portability. Ideally, programmers should have a framework that lets them express dynamic-analysis tools at a high level, robustly, with high coverage and supporting alternative runtimes such as Android. To satisfy these requirements, ShadowVM, an all-in-one dynamic-program-analysis framework, uses a combination of techniques.","1937-4194","","10.1109/MS.2015.151","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7330309","dynamic program analysis;Java;Android;software engineering;software development;ShadowVM;virtual machines","Dynamic programming;Java;Performance analysis;Software development;Androids;Humanoid robots;Virtual machining","Android (operating system);Java;program debugging;program diagnostics;software engineering","multiplatform dynamic program analysis;Java;Android;program profiling;program tracing;bug-finding tool;software engineering;ShadowVM","","6","","12","","18 Nov 2015","","","IEEE","IEEE Magazines"
"A Distributed Access Control Architecture for Cloud Computing","A. Almutairi; M. Sarfraz; S. Basalamah; W. Aref; A. Ghafoor",Purdue University; Purdue University; Umm Al-Qura University; Purdue University; Purdue University,"IEEE Software","20 Feb 2012","2012","29","2","36","44","The large-scale, dynamic, and heterogeneous nature of cloud computing poses numerous security challenges. But the cloud's main challenge is to provide a robust authorization mechanism that incorporates multitenancy and virtualization aspects of resources. The authors present a distributed architecture that incorporates principles from security management and software engineering and propose key requirements and a design model for the architecture.","1937-4194","","10.1109/MS.2011.153","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095492","software engineering;distributed access control;cloud computing;multitenancy;resource virtualization","Collaboration;Cloud computing;Authorization;Computer architecture;Resource management;Computer security","authorisation;cloud computing;software engineering;virtualisation","distributed access control architecture;cloud computing;authorization mechanism;multitenancy aspect;virtualization aspect;security management;software engineering","","77","2","10","","6 Dec 2011","","","IEEE","IEEE Magazines"
"Learning from Quality Issues of BPMN Models from Industry","H. Leopold; J. Mendling; O. Günther",Vrije Universiteit Amsterdam; Wirtschaftsuniversität Wien; Universität Potsdam,"IEEE Software","23 Jun 2016","2016","33","4","26","33","Many organizations use business process models to document business operations and formalize business requirements in software-engineering projects. The Business Process Model and Notation (BPMN), a specification by the Object Management Group, has evolved into the leading standard for process modeling. One challenge is BPMN's complexity: it offers a huge variety of elements and often several representational choices for the same semantics. This raises the question of how well modelers can deal with these choices. Empirical insights into BPMN use from the practitioners' perspective are still missing. To close this gap, researchers analyzed 585 BPMN 2.0 process models from six companies. They found that split and join representations, message flow, the lack of proper model decomposition, and labeling related to quality issues. They give five specific recommendations on how to avoid these issues.","1937-4194","","10.1109/MS.2015.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7106381","process model quality;modeling guidelines;Business Process Model and Notation;BPMN;industry study;software engineering;software development","Data models;Business processes;Documentation;Logic gates","business data processing;organisational aspects;software engineering","quality issues;organizations;business operations;business requirements;software-engineering projects;business process model and notation;object management group;BPMN 2.0 process models;split representations;message flow;join representations","","26","","13","","13 May 2015","","","IEEE","IEEE Magazines"
"On Event-Based Middleware for Location-Aware Mobile Applications","R. Meier; V. Cahill","Trinity College Dublin, Dublin and Lero—The Irish Software Engineering Research Centre; Trinity College Dublin, Dublin and Lero—The Irish Software Engineering Research Centre","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","409","430","As mobile applications become more widespread, programming paradigms and middleware architectures designed to support their development are becoming increasingly important. The event-based programming paradigm is a strong candidate for the development of mobile applications due to its inherent support for the loose coupling between components required by mobile applications. However, existing middleware that supports the event-based programming paradigm is not well suited to supporting location-aware mobile applications in which highly mobile components come together dynamically to collaborate at some location. This paper presents a number of techniques including location-independent announcement and subscription coupled with location-dependent filtering and event delivery that can be used by event-based middleware to support such collaboration. We describe how these techniques have been implemented in STEAM, an event-based middleware with a fully decentralized architecture, which is particularly well suited to deployment in ad hoc network environments. The cost of such location-based event dissemination and the benefits of distributed event filtering are evaluated.","1939-3520","","10.1109/TSE.2009.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5374426","Distributed systems;middleware;publish subscribe;event-based communication;mobile computing;collaborative and location-aware applications;wireless ad hoc networks.","Middleware;Collaboration;Mobile computing;Application software;Mobile communication;Unmanned aerial vehicles;Pervasive computing;Computer architecture;Filtering;Ad hoc networks","information dissemination;middleware;mobile computing;software architecture","event-based middleware;location-aware mobile applications;event-based programming paradigm;location-independent announcement;location-dependent filtering;STEAM;decentralized architecture;ad hoc network environments;location-based event dissemination;distributed event filtering","","21","2","56","","8 Jan 2010","","","IEEE","IEEE Journals"
"Impact of Introducing Domain-Specific Modelling in Software Maintenance: An Industrial Case Study","N. Mellegård; A. Ferwerda; K. Lind; R. Heldal; M. R. V. Chaudron","Electromobility Group at the Research Institute Viktoria Swedish ICT, Gothenburg, Sweden; Centric, Gouda, The Netherlands; Electromobility Group at the Research Institute Viktoria Swedish ICT, Gothenburg, Sweden; Software Engineering Division at the joint Department of Computer Science and Engineering, Chalmers and Gothenborg University, Gothenburg, Sweden; Software Engineering Division at the joint Department of Computer Science and Engineering, Chalmers and Gothenborg University, Gothenburg, Sweden","IEEE Transactions on Software Engineering","11 Mar 2016","2016","42","3","245","260","Domain-specific modelling (DSM) is a modern software development technology that aims at enhancing productivity. One of the claimed advantages of DSM is increased maintainability of software. However, current empirical evidence supporting this claim is lacking. In this paper, we contribute evidence from a case study conducted at a software development company. We study how the introduction of DSM affected the maintenance of a legacy system. We collected data about the maintenance phase of a system that was initially developed using manual programming, but which was gradually replaced by DSM development. We performed statistical analyses of the relation between the use of DSM and the time needed to resolve defects, the defect density, and the phase in which defects were detected. The results show that after introducing DSM the defect density is lower, that defects are found earlier, but resolving defects takes longer. Other observed benefits are that the number of developers and the number of person-hours needed for maintaining the system decreased, and the portability to new platforms increased. Our findings are useful for organizations that consider introducing DSM and would like to know which benefits can be realized in software maintenance.","1939-3520","","10.1109/TSE.2015.2479221","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7270333","Empirical investigation;software maintenance;maintenance measurement;process measurement;productivity;Empirical investigation;software maintenance;maintenance measurement;process measurement;productivity","DSL;Maintenance engineering;Unified modeling language;Business;Software maintenance;Productivity","software maintenance;statistical analysis","domain-specific modelling;software maintenance;DSM;software development technology;software maintainability;software development company;legacy system;manual programming;statistical analysis","","10","","42","","16 Sep 2015","","","IEEE","IEEE Journals"
"Resource Management for Complex, Dynamic Environments","M. S. Raunak; L. J. Osterweil","Loyola University MD, Baltimore; University of Massachusetts Amherst, Amherst","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","384","402","This paper describes an approach to the specification and management of the agents and resources that are required to support the execution of complex systems and processes. The paper suggests that a resource should be viewed as a provider of a set of capabilities that are needed by a system or process, where that set may vary dynamically over time and with circumstances. This view of resources is defined and then made the basis for the framework of an approach to specifying, managing, and allocating resources in the presence of real-world complexity and dynamism. The ROMEO prototype resource management system is presented as an example of how this framework can be instantiated. Some case studies of the use of ROMEO to support system execution are presented and used to evaluate the framework, the ROMEO prototype, and our view of the nature of resources.","1939-3520","","10.1109/TSE.2012.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6197203","Resources management;process modeling;discrete event simulation;healthcare processes","Resource management;Hospitals;Surgery;Software;Context;Databases","formal specification;software agents;software engineering","resource management;dynamic environments;complex environments;complex systems;complex processes;ROMEO prototype resource management system;software engineering","","20","","40","","8 May 2012","","","IEEE","IEEE Journals"
"Sustainable Embedded Software Life-Cycle Planning","D. Lee; H. P. In; K. Lee; S. Park; M. Hinchey","Korea University; Korea University; Samsung Electronics; Sogang University; Lero--The Irish Software Engineering Research Centre, University of Limerick","IEEE Software","26 Jun 2013","2013","30","4","72","80","Time to market is a crucial factor in increasing market share in consumer electronics. Furthermore, fierce market competition tends to sharply lower the prices of new consumer electronics products as soon as they're released. Researchers have studied software-intensive embedded system design methods, such as hardware/software co-design, with the goal of reducing development lead time by designing hardware and software simultaneously. However, most studies concentrate on static design methods, in which a design remains unchanged once it's determined. To survive the market competition in consumer electronics requires a dynamic design strategy that takes various market conditions into account for software-intensive embedded systems. This article proposes a sustainable embedded software life-cycle planning (SeSLP) process based on the evolution of embedded software. The SeSLP process provides a dynamic method for both selecting product life-cycle design alternatives and generating a profit-maximizing transition plan that covers the entire product life cycle.","1937-4194","","10.1109/MS.2012.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226340","software engineering;product life cycle;embedded systems;embedded software evolution","Market research;Analytical models;Software development;Consumer electronics;Product design;Competitive intelligence;Marketing and sales","consumer electronics;electronics industry;embedded systems;hardware-software codesign;planning;production engineering computing;software engineering;sustainable development","sustainable embedded software;software life-cycle planning;consumer electronics;market competition;software-intensive embedded system;embedded system design method;hardware-software codesign;static design method;dynamic design strategy;SeSLP process;embedded software evolution;product life-cycle design alternative;profit-maximizing transition plan;time-to-market factor","","2","","6","","26 Jun 2012","","","IEEE","IEEE Magazines"
"Requirements: The Key to Sustainability","C. Becker; S. Betz; R. Chitchyan; L. Duboc; S. M. Easterbrook; B. Penzenstadler; N. Seyff; C. C. Venters","University of Toronto; Karlsruhe Institute of Technology; University of Leicester; State University of Rio de Janeiro; University of Toronto; California State University, Long Beach; University of Applied Sciences and Arts Northwestern Switzerland; University of Huddersfield","IEEE Software","29 Dec 2015","2016","33","1","56","65","Software's critical role in society demands a paradigm shift in the software engineering mind-set. This shift's focus begins in requirements engineering. This article is part of a special issue on the Future of Software Engineering.","1937-4194","","10.1109/MS.2015.158","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7325195","software engineering;requirements;sustainability;sustainability design;software development","Stakeholders;Economics;Procurement;Software systems;Software engineering;Requirements engineering;Sustainability","formal specification","software engineering;requirements engineering","","44","","11","","11 Nov 2015","","","IEEE","IEEE Magazines"
"Using Genetic Search for Reverse Engineering of Parametric Behavior Models for Performance Prediction","K. Krogmann; M. Kuperberg; R. Reussner","Karlsruhe Institute of Technology (KIT), Karlsruhe; Karlsruhe Institute of Technology (KIT), Karlsruhe; Karlsruhe Institute of Technology (KIT), Karlsruhe","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","865","877","In component-based software engineering, existing components are often reused in new applications. Correspondingly, the response time of an entire component-based application can be predicted from the execution durations of individual component services. These execution durations depend on the runtime behavior of a component which itself is influenced by three factors: the execution platform, the usage profile, and the component wiring. To cover all relevant combinations of these influencing factors, conventional prediction of response times requires repeated deployment and measurements of component services for all such combinations, incurring a substantial effort. This paper presents a novel comprehensive approach for reverse engineering and performance prediction of components. In it, genetic programming is utilized for reconstructing a behavior model from monitoring data, runtime bytecode counts, and static bytecode analysis. The resulting behavior model is parameterized over all three performance-influencing factors, which are specified separately. This results in significantly fewer measurements: The behavior model is reconstructed only once per component service, and one application-independent bytecode benchmark run is sufficient to characterize an execution platform. To predict the execution durations for a concrete platform, our approach combines the behavior model with platform-specific benchmarking results. We validate our approach by predicting the performance of a file sharing application.","1939-3520","","10.1109/TSE.2010.69","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5530323","Genetic search;genetic programming;reverse engineering;performance prediction;bytecode benchmarking.","Reverse engineering;Predictive models;Application software;Delay;Runtime;Software engineering;Wiring;Genetic programming;Monitoring;Concrete","genetic algorithms;object-oriented programming;reverse engineering;search problems;software performance evaluation","genetic search;reverse engineering;parametric behavior model;component based software engineering;genetic programming;runtime bytecode count;static bytecode analysis;application independent bytecode benchmark","","34","2","38","","29 Jul 2010","","","IEEE","IEEE Journals"
"A Second Replicated Quantitative Analysis of Fault Distributions in Complex Software Systems","T. Galinac Grbac; P. Runeson; D. Huljenić","Univesity of Rijeka, Rijeka; Lund University, Lund; Ericsson Nikola Tesla, Zagreb","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","462","476","Background: Software engineering is searching for general principles that apply across contexts, for example, to help guide software quality assurance. Fenton and Ohlsson presented such observations on fault distributions, which have been replicated once. Objectives: We aimed to replicate their study again to assess the robustness of the findings in a new environment, five years later. Method: We conducted a literal replication, collecting defect data from five consecutive releases of a large software system in the telecommunications domain, and conducted the same analysis as in the original study. Results: The replication confirms results on unevenly distributed faults over modules, and that fault proneness distributions persist over test phases. Size measures are not useful as predictors of fault proneness, while fault densities are of the same order of magnitude across releases and contexts. Conclusions: This replication confirms that the uneven distribution of defects motivates uneven distribution of quality assurance efforts, although predictors for such distribution of efforts are not sufficiently precise.","1939-3520","","10.1109/TSE.2012.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6235962","Software fault distributions;software metrics;empirical research;replication","Testing;Measurement;Context;Software;Software engineering;Complexity theory;Telecommunications","software fault tolerance;software quality","second replicated quantitative analysis;fault distribution;complex software system;software engineering;literal replication;telecommunications domain;data analysis;data collection;fault proneness distribution;size measure;fault density;quality assurance effort","","21","","43","","10 Jul 2012","","","IEEE","IEEE Journals"
"How Software Developers Use Tagging to Support Reminding and Refinding","M. Storey; J. Ryall; J. Singer; D. Myers; L. Cheng; M. Muller","University of Victoria, Victoria; University of Victoria, Victoria; National Research Council Canada, Ottawa; University of Victoria, Victoria; IBM Research, Cambridge; IBM Research, Cambridge","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","470","483","Developers frequently add annotations to source code to help them remember pertinent information and mark locations of interest for future investigation. Finding and refinding these notes is a form of navigation that is integral to software maintenance. Although there is some tool support in modern development environments for authoring and navigating these comments, we have observed that these annotations often fail to remind and are sometimes difficult to find by the programmer. To address these shortcomings, we have designed a new approach for software navigation called tags for software engineering activities (TagSEA). TagSEA combines the notion of waypointing (a mechanism for marking locations in spatial navigation) with social tagging to support programmers in defining semantically rich annotations to source code comments. The tool provides support for creating, editing, navigating, and managing these annotations. We present the results from two empirical studies, where we observed and then analyzed how professional programmers used source code annotations to support their development activities over 24 months. Our findings indicate that the addition of semantic information to annotations can improve their value. We also provide suggestions on how annotation tools in general may be improved.","1939-3520","","10.1109/TSE.2009.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4782972","Annotations;software navigation;software tagging;tags;software development tools.","Tagging;Navigation;Programming profession;Software maintenance;Software tools;Software engineering;Filters;Software development management;Maintenance engineering;Computer science","authoring systems;software maintenance","source code annotations;software maintenance;modern development environments;software navigation;software engineering activities;waypointing;social tagging;software development tools","","35","1","34","","13 Feb 2009","","","IEEE","IEEE Journals"
"Stressing Search with Scenarios for Flexible Solutions to Real-Time Task Allocation Problems","P. Emberson; I. Bate","University of York, York; University of York, York","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","704","718","One of the most important properties of a good software engineering process and of the design of the software it produces is robustness to changing requirements. Scenario-based analysis is a popular method for improving the flexibility of software architectures. This paper demonstrates a search-based technique for automating scenario-based analysis in the software architecture deployment view. Specifically, a novel parallel simulated annealing search algorithm is applied to the real-time task allocation problem to find baseline solutions which require a minimal number of changes in order to meet the requirements of potential upgrade scenarios. Another simulated annealing-based search is used for finding a solution that is similar to an existing baseline when new requirements arise. Solutions generated using a variety of scenarios are judged by how well they respond to different system requirements changes. The evaluation is performed on a set of problems with a controlled set of different characteristics.","1939-3520","","10.1109/TSE.2009.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5262947","Maintainability;extensibility;heuristics;search;scheduling;scenarios.","Software architecture;Computer architecture;Hardware;Real time systems;Software engineering;Software design;Simulated annealing;System testing;Robustness;Performance evaluation","parallel algorithms;real-time systems;search problems;simulated annealing;software architecture;task analysis","real-time task allocation problem;search stress;software engineering process;software design;scenario-based analysis;software architectures;search-based technique;parallel simulated annealing search algorithm","","16","","37","","25 Sep 2009","","","IEEE","IEEE Journals"
"Engineering a Sound Assertion Semantics for the Verifying Compiler","P. Chalin","Dependable Software Research Group, Concordia University, Montreal","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","275","287","The Verifying Compiler (VC) project is a core component of the Dependable Systems Evolution Grand Challenge. The VC offers the promise of automatically proving that a program or component is correct, where correctness is defined by program assertions. While several VC prototypes exist, all adopt a semantics for assertions that is unsound. This paper presents a consolidation of VC requirements analysis (RA) activities that, in particular, brought us to ask targeted VC customers what kind of semantics they wanted. Taking into account both practitioners' needs and current technological factors, we offer recovery of soundness through an adjusted definition of assertion validity that matches user expectations and can be implemented practically using current prover technology. For decades, there have been debates concerning the most appropriate semantics for program assertions. Our contribution here is unique in that we have applied fundamental software engineering techniques by asking primary stakeholders what they want and, based on this, proposed a means of efficiently realizing the semantics stakeholders want using standard tools and techniques. We describe how support for the new semantics has been added to ESC/Java2, one of the most fully developed VC prototypes. Case studies demonstrate the effectiveness of the new semantics at uncovering previously indiscernible specification errors.","1939-3520","","10.1109/TSE.2009.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5262949","Software verification;assertions;programming by contract;logics of programs;requirements engineering.","Acoustical engineering;Virtual colonoscopy;Prototypes;Software prototyping;Java;Logic programming;Runtime;Software engineering;Software standards;Contracts","program compilers;program verification;systems analysis","verifying compiler project;Dependable Systems Evolution Grand Challenge;sound assertion semantics engineering;program correctness proving;VC requirements analysis;software engineering techniques;program assertions;ESC/Java2","","5","","70","","25 Sep 2009","","","IEEE","IEEE Journals"
"What Types of Defects Are Really Discovered in Code Reviews?","M. V. Mäntylä; C. Lassenius","Helsinki University of Technology, TKK; Helsinki University of Technology, TKK","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","430","448","Research on code reviews has often focused on defect counts instead of defect types, which offers an imperfect view of code review benefits. In this paper, we classified the defects of nine industrial (C/C++) and 23 student (Java) code reviews, detecting 388 and 371 defects, respectively. First, we discovered that 75 percent of defects found during the review do not affect the visible functionality of the software. Instead, these defects improved software evolvability by making it easier to understand and modify. Second, we created a defect classification consisting of functional and evolvability defects. The evolvability defect classification is based on the defect types found in this study, but, for the functional defects, we studied and compared existing functional defect classifications. The classification can be useful for assigning code review roles, creating checklists, assessing software evolvability, and building software engineering tools. We conclude that, in addition to functional defects, code reviews find many evolvability defects and, thus, offer additional benefits over execution-based quality assurance methods that cannot detect evolvability defects. We suggest that code reviews may be most valuable for software products with long life cycles as the value of discovering evolvability defects in them is greater than for short life cycle systems.","1939-3520","","10.1109/TSE.2008.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4604671","Code inspections and walkthroughs;enhancement;extensibility;maintainability;restructuring.;Source code organization;Code documentation;Construction QA;Methods for SQA and V&V;Measurement applied to SQA and V&V;Code inspections and walkthroughs;Maintainability","Quality assurance;Inspection;Runtime;Java;Software tools;Software engineering;Software measurement;Software quality;Guidelines;Timing","pattern classification;software maintenance;software reviews","software functionality;software evolvability;defect classification;software engineering tools;execution-based quality assurance methods;software products","","76","","73","","22 Aug 2008","","","IEEE","IEEE Journals"
"GEA: A Goal-Driven Approach toDiscovering Early Aspects","J. Lee; K. Hsu","Department of Computer Science and Information Engineering, National Taiwan University, Taipei, Taiwan; Department of Computer Science, National Taichung University of Education, Taichung, Taiwan","IEEE Transactions on Software Engineering","16 Jun 2014","2014","40","6","584","602","Aspect-oriented software development has become an important development and maintenance approach to software engineering across requirements, design and implementation phases. However, discovering early aspects from requirements for a better integration of crosscutting concerns into a target system is still not well addressed in the existing works. In this paper, we propose a Goal-driven Early Aspect approach (called GEA) to discovering early aspects by means of a clustering algorithm in which relationships among goals and use cases are utilized to explore similarity degrees of clustering goals, and total interaction degrees are devised to check the validity of the formation of each cluster. Introducing early aspects not only enhances the goal-driven requirements modeling to manage crosscutting concerns, but also provides modularity insights into the analysis and design of software development. Moreover, relationships among goals represented numerically are more informative to discover early aspects and more easily to be processed computationally than qualitative terms. The proposed approach is illustrated by using two problem domains: a meeting scheduler system and a course enrollment system. An experiment is also conducted to evaluate the benefits of the proposed approach with Mann-Whitney U-test to show that the difference between with GEA and without GEA is statistically significant.","1939-3520","","10.1109/TSE.2014.2322368","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6822606","Early aspects;goals;goals interaction;fuzzy logic;use cases;goal cluster","Software;Clustering algorithms;Educational institutions;Analytical models;Computer science;Software engineering;Documentation","aspect-oriented programming;pattern clustering;software maintenance","GEA;early aspect discovery;aspect-oriented software development;maintenance approach;software engineering;goal-driven early aspect approach;clustering algorithm;goal-driven requirements;crosscutting concerns;meeting scheduler system;course enrollment system;Mann-Whitney U-test","","3","","51","","29 May 2014","","","IEEE","IEEE Journals"
"Dynamic Software Project Scheduling through a Proactive-Rescheduling Method","X. Shen; L. L. Minku; R. Bahsoon; X. Yao","B-DAT & CICAEET, School of Information and Control, Nanjing University of Information Science and Technology, No.219, Ning-Liu Road, Pu-Kou District, Nanjing, P.R. China; Department of Computer Science, University of Leicester, University Road, Leicester, United Kingdom; CERCIA, University of Birmingham, Edgbaston, Birmingham, United Kingdom; CERCIA, University of Birmingham, Edgbaston, Birmingham, United Kingdom","IEEE Transactions on Software Engineering","14 Jul 2016","2016","42","7","658","686","Software project scheduling in dynamic and uncertain environments is of significant importance to real-world software development. Yet most studies schedule software projects by considering static and deterministic scenarios only, which may cause performance deterioration or even infeasibility when facing disruptions. In order to capture more dynamic features of software project scheduling than the previous work, this paper formulates the project scheduling problem by considering uncertainties and dynamic events that often occur during software project development, and constructs a mathematical model for the resulting multi-objective dynamic project scheduling problem (MODPSP), where the four objectives of project cost, duration, robustness and stability are considered simultaneously under a variety of practical constraints. In order to solve MODPSP appropriately, a multi-objective evolutionary algorithm based proactive-rescheduling method is proposed, which generates a robust schedule predictively and adapts the previous schedule in response to critical dynamic events during the project execution. Extensive experimental results on 21 problem instances, including three instances derived from real-world software projects, show that our novel method is very effective. By introducing the robustness and stability objectives, and incorporating the dynamic optimization strategies specifically designed for MODPSP, our proactive-rescheduling method achieves a very good overall performance in a dynamic environment.","1939-3520","","10.1109/TSE.2015.2512266","National Natural Science Foundation of China (NSFC); Natural Science Foundation of Jiangsu Province of China; EPSRC; DAASE: Dynamic Adaptive Automated Software Engineering; EPSRC; Evolutionary Computation for Dynamic Optimization in Network Environments; CERCIA; School of Computer Science, University of Birmingham, United Kingdom; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7365465","Schedule and organizational issues;dynamic software project scheduling;search-based software engineering;multi-objective evolutionary algorithms;mathematical modeling","Dynamic scheduling;Software;Schedules;Uncertainty;Robustness;Job shop scheduling","evolutionary computation;project management;scheduling;software development management","uncertain environments;dynamic environments;dynamic features;software project development;multiobjective dynamic software project scheduling problem;MODPSP;project cost;project duration;project robustness;project stability;multiobjective evolutionary algorithm based proactive-rescheduling method;critical dynamic events;project execution;dynamic optimization strategies","","23","","49","CCBY","24 Dec 2015","","","IEEE","IEEE Journals"
"Self-Adaptive and Online QoS Modeling for Cloud-Based Software Services","T. Chen; R. Bahsoon","CERCIA, School of Computer Science, University of Birmingham, Birmingham, United Kingdom; CERCIA, School of Computer Science, University of Birmingham, Birmingham, United Kingdom","IEEE Transactions on Software Engineering","12 May 2017","2017","43","5","453","475","In the presence of scale, dynamism, uncertainty and elasticity, cloud software engineers faces several challenges when modeling Quality of Service (QoS) for cloud-based software services. These challenges can be best managed through self-adaptivity because engineers' intervention is difficult, if not impossible, given the dynamic and uncertain QoS sensitivity to the environment and control knobs in the cloud. This is especially true for the shared infrastructure of cloud, where unexpected interference can be caused by co-located software services running on the same virtual machine; and co-hosted virtual machines within the same physical machine. In this paper, we describe the related challenges and present a fully dynamic, self-adaptive and online QoS modeling approach, which grounds on sound information theory and machine learning algorithms, to create QoS model that is capable to predict the QoS value as output over time by using the information on environmental conditions, control knobs and interference as inputs. In particular, we report on in-depth analysis on the correlations of selected inputs to the accuracy of QoS model in cloud. To dynamically selects inputs to the models at runtime and tune accuracy, we design self-adaptive hybrid dual-learners that partition the possible inputs space into two sub-spaces, each of which applies different symmetric uncertainty based selection techniques; the results of sub-spaces are then combined. Subsequently, we propose the use of adaptive multi-learners for building the model. These learners simultaneously allow several learning algorithms to model the QoS function, permitting the capability for dynamically selecting the best model for prediction on the fly. We experimentally evaluate our models in the cloud environment using RUBiS benchmark and realistic FIFA 98 workload. The results show that our approach is more accurate and effective than state-of-the-art modelings.","1939-3520","","10.1109/TSE.2016.2608826","EPSRC Grant; DAASE: Dynamic Adaptive Automated Software Engineering; The PhD scholarship from the School of Computer Science; University of Birmingham; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7572219","Software quality;search-based software engineering;self-adaptive systems;machine learning;cloud computing;performance modeling","Quality of service;Cloud computing;Interference;Adaptation models;Sensitivity;Uncertainty","cloud computing;learning (artificial intelligence);quality of service;virtual machines","cloud-based software services;quality of service;self-adaptivity;uncertain QoS sensitivity;cloud infrastructure;colocated software service;virtual machine;fully dynamic self-adaptive online QoS modeling;information theory;machine learning algorithm;environmental conditions;control knobs;self-adaptive hybrid dual-learners;input space partitioning;symmetric uncertainty based selection technique;QoS function;cloud environment;RUBiS benchmark;FIFA 98 workload","","25","","54","CCBY","20 Sep 2016","","","IEEE","IEEE Journals"
"A Probabilistic Analysis of the Efficiency of Automated Software Testing","M. Böhme; S. Paul","Software Engineering Chair, Germany; School of Computing, National University of Singapore, Singapore","IEEE Transactions on Software Engineering","14 Apr 2016","2016","42","4","345","360","We study the relative efficiencies of the random and systematic approaches to automated software testing. Using a simple but realistic set of assumptions, we propose a general model for software testing and define sampling strategies for random (R) and systematic (S0) testing, where each sampling is associated with a sampling cost: 1 and c units of time, respectively. The two most important goals of software testing are: (i) achieving in minimal time a given degree of confidence x in a program's correctness and (ii) discovering a maximal number of errors within a given time bound n̂. For both (i) and (ii), we show that there exists a bound on c beyond which R performs better than S0 on the average. Moreover for (i), this bound depends asymptotically only on x. We also show that the efficiency of R can be fitted to the exponential curve. Using these results we design a hybrid strategy H that starts with R and switches to S0 when S0 is expected to discover more errors per unit time. In our experiments we find that H performs similarly or better than the most efficient of both and that S0 may need to be significantly faster than our bounds suggest to retain efficiency over R.","1939-3520","","10.1109/TSE.2015.2487274","Singapore's Ministry of Education; ERC; SPECMATE; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7289448","Partition Testing;Random Testing;Error-based Partitioning;Efficient Testing;Testing Theory;Partition testing;random testing;error-based partitioning;efficient testing;testing theory","Systematics;Software testing;Software engineering;Input variables;Random variables;Color","probability;program testing","probabilistic analysis;automated software testing;sampling strategies;random testing;systematic testing;exponential curve;hybrid strategy","","23","","37","","5 Oct 2015","","","IEEE","IEEE Journals"
"The Role of Method Chains and Comments in Software Readability and Comprehension—An Experiment","J. Börstler; B. Paech","Department of Software Engineering, Blekinge Institute of Technology, Karlskrona, Sweden; Department of Computer Science, Heidelberg University, Heidelberg, Germany","IEEE Transactions on Software Engineering","15 Sep 2016","2016","42","9","886","898","Software readability and comprehension are important factors in software maintenance. There is a large body of research on software measurement, but the actual factors that make software easier to read or easier to comprehend are not well understood. In the present study, we investigate the role of method chains and code comments in software readability and comprehension. Our analysis comprises data from 104 students with varying programming experience. Readability and comprehension were measured by perceived readability, reading time and performance on a simple cloze test. Regarding perceived readability, our results show statistically significant differences between comment variants, but not between method chain variants. Regarding comprehension, there are no significant differences between method chain or comment variants. Student groups with low and high experience, respectively, show significant differences in perceived readability and performance on the cloze tests. Our results do not show any significant relationships between perceived readability and the other measures taken in the present study. Perceived readability might therefore be insufficient as the sole measure of software readability or comprehension. We also did not find any statistically significant relationships between size and perceived readability, reading time and comprehension.","1939-3520","","10.1109/TSE.2016.2527791","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7404062","Software readability;software comprehension;software measurement;comments;method chains;experiment","Software;Guidelines;Software measurement;Software engineering;Programming;Complexity theory;Object oriented modeling","software maintenance;software metrics","software readability;software comprehension;software maintenance;software measurement;method chains;code comments;cloze tests","","9","","57","","11 Feb 2016","","","IEEE","IEEE Journals"
"Mining Workflow Models from Web Applications","M. Schur; A. Roth; A. Zeller","SAP SE; SAP SE, Germany; Saarland University–Chair for Software Engineering, Germany","IEEE Transactions on Software Engineering","8 Dec 2015","2015","41","12","1184","1201","Modern business applications predominantly rely on web technology, enabling software vendors to efficiently provide them as a service, removing some of the complexity of the traditional release and update process. While this facilitates shorter, more efficient and frequent release cycles, it requires continuous testing. Having insight into application behavior through explicit models can largely support development, testing and maintenance. Model-based testing allows efficient test creation based on a description of the states the application can be in and the transitions between these states. As specifying behavior models that are precise enough to be executable by a test automation tool is a hard task, an alternative is to extract them from running applications. However, mining such models is a challenge, in particular because one needs to know when two states are equivalent, as well as how to reach that state. We present Process Crawler (ProCrawl), a tool to mine behavior models from web applications that support multi-user workflows. ProCrawl incrementally learns a model by generating program runs and observing the application behavior through the user interface. In our evaluation on several real-world web applications, ProCrawl extracted models that concisely describe the implemented workflows and can be directly used for model-based testing.","1939-3520","","10.1109/TSE.2015.2461542","German Federal Ministry of Education and Research (BMBF); European Research Council (ERC); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7169616","Specification mining;dynamic analysis;model-based testing;web system testing;Specification mining;dynamic analysis;model-based testing;web system testing","Web services;Software engineering;Data models;Data mining;Automation;Browsers","data mining;Internet;program testing;system monitoring;user interfaces","user interface;multiuser workflow;ProCrawl;Process Crawler;test automation tool;behavior model;test creation;model-based testing;continuous testing;software vendor;Web technology;Web applications;mining workflow model","","7","","47","","28 Jul 2015","","","IEEE","IEEE Journals"
"A Survey on Software Fault Localization","W. E. Wong; R. Gao; Y. Li; R. Abreu; F. Wotawa","State Key Laboratory of Software Engineering, Wuhan University, Department of Computer Science, University of Texas at Dallas, Richardson, TX; Department of Computer Science, University of Texas at Dallas, Richardson, TX; Department of Computer Science, University of Texas at Dallas, Richardson, TX; Department of Informatics Engineering, University of Porto, Palo Alto Research Center (PARC), Palo Alto, CA; Institute for Software Technology, Graz University of Technology, Austria","IEEE Transactions on Software Engineering","11 Aug 2016","2016","42","8","707","740","Software fault localization, the act of identifying the locations of faults in a program, is widely recognized to be one of the most tedious, time consuming, and expensive - yet equally critical - activities in program debugging. Due to the increasing scale and complexity of software today, manually locating faults when failures occur is rapidly becoming infeasible, and consequently, there is a strong demand for techniques that can guide software developers to the locations of faults in a program with minimal human intervention. This demand in turn has fueled the proposal and development of a broad spectrum of fault localization techniques, each of which aims to streamline the fault localization process and make it more effective by attacking the problem in a unique way. In this article, we catalog and provide a comprehensive overview of such techniques and discuss key issues and concerns that are pertinent to software fault localization as a whole.","1939-3520","","10.1109/TSE.2016.2521368","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7390282","Software fault localization;program debugging;software testing;execution trace;suspicious code;survey","Debugging;Software engineering;Computer bugs;Software debugging;Fault diagnosis;Complexity theory","program debugging;software reliability","software fault localization;program debugging;software developers;program fault locations;human intervention","","264","","427","","25 Jan 2016","","","IEEE","IEEE Journals"
"Intelligently Transparent Software Ecosystems","J. Herbsleb; C. Kästner; C. Bogart",Carnegie Mellon University; Carnegie Mellon University; Carnegie Mellon University,"IEEE Software","29 Dec 2015","2016","33","1","89","96","Today's social-coding tools foreshadow a transformation of the software industry, as it relies increasingly on open libraries, frameworks, and code fragments. Our vision calls for new intelligently transparent services that support rapid development of innovative products while helping developers manage risk and issuing them early warnings of looming failures. Intelligent transparency is enabled by an infrastructure that applies analytics to data from all phases of the life cycle of open source projects, from development to deployment. Such an infrastructure brings stakeholders the information they need when they need it.","1937-4194","","10.1109/MS.2015.156","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7325197","programming environments;metrics;software management;software development;software engineering;intelligent software assurance and monitoring;intelligent transparency;ISAM","Software engineering;Stability analysis;Business;Software assurance;Ecosystems;Software management;Programming","innovation management;public domain software;risk management;software engineering;software houses","intelligently transparent software ecosystems;risk management;data analytics;open source projects;innovative products;social-coding tools;software industry;open libraries","","1","","15","","11 Nov 2015","","","IEEE","IEEE Magazines"
"What are Hackathons for?","M. Komssi; D. Pichlis; M. Raatikainen; K. Kindström; J. Järvinen",F-Secure; Aalto University; Aalto University; F-Secure; F-Secure,"IEEE Software","21 Aug 2015","2015","32","5","60","67","A swift execution from idea to market has become a key competitive advantage for software companies to enable them to survive and grow in turbulent business environments. To combat this challenge, companies are using hackathons. A hackathon is a highly engaging, continuous event in which people in small groups produce working software prototypes in a limited amount of time. F-Secure, a software product company, views hackathons as a possible solution to the fundamental business problem of how to make revenue from an idea, spanning the phases from creating the idea to producing a software prototype. However, hackathons pose the challenge of how to transform those promising prototypes into finalized products that create revenue and real business value.","1937-4194","","10.1109/MS.2014.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6809711","rapid prototyping;design;software engineering;process implementation and change;requirements and specifications;initiation and scope definition;organizational management and coordination;hackathon","Requirements engineering;Software engineering;Market research;Business;Prototypes;Software development","software engineering","hackathons;f-secure;software product company;business problem","","46","","8","","2 May 2014","","","IEEE","IEEE Magazines"
"Metadesign: Guidelines for Supporting Domain Experts in Software Development","G. Fischer; K. Nakakoji; Y. Ye",University of Colorado at Boulder; University of Tokyo; Software Research Associates,"IEEE Software","25 Aug 2009","2009","26","5","37","44","Our collaborative research activities in software development (at the University of Colorado's Center for Lifelong Learning and Design, the University of Tokyo, and Software Research Associates) have focused on understanding the implications of the quickly disappearing distinction between users and developers. We've also concentrated on establishing new software development methodologies by viewing software systems as continuously evolving sociotechnical systems driven by design activities of both professional software engineers and users. We believe that domain experts, as the owners of problems, need to be in charge of developing the software they require. Toward that end, we've created the metadesign framework, which reformulates software development activities as a continuum of different degrees of design and use. In addition, on the basis of our research and our findings in the research literature, we've developed a set of guidelines for supporting domain experts in software development.","1937-4194","","10.1109/MS.2009.134","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222792","software developers;domain experts;end-user development;end-user software engineering;domain-specific software development;domain-oriented design environments;seeding;evolutionary growth;reseeding;metadesign;mash-ups;open source;ecologies of participation;software development","Guidelines;Software systems;Application software;Software engineering;Instruments;Biological system modeling;Environmental factors;Data analysis;Programming profession;Productivity","software engineering","metadesign;domain experts;software development;sociotechnical systems;professional software engineers;software users","","27","","17","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Programming with Implicit Flows","G. Salvaneschi; P. Eugster; M. Mezini","Technical University of Darmstadt, Darmstadt; Purdue University, West Lafayette; Darmstadt University of Technology, Darmstadt","IEEE Software","15 Sep 2014","2014","31","5","52","59","Modern software differs significantly from traditional computer applications that mostly process reasonably small amounts of static input data-sets in batch mode. Modern software increasingly processes massive amounts of data, whereby it is also often the case that new input data is produced and/or existing data is modified on the fly. Consequently, programming models that facilitate the development of such software are emerging. What characterizes them is that data, respectively changes thereof, implicitly flow through computation modules. The software engineer declaratively defines computations as compositions of other computations without explicitly modeling how data should flow along dependency relations between data producer and data consumer modules, letting the runtime to automatically manage and optimize data flows.","1937-4194","","10.1109/MS.2014.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6840828","reactive programming;event;stream;big data;data-flow;programming languages;software engineering","Programming;Big data;Computational modeling;Runtime;Software engineering;Data models;Market research","software engineering","implicit flows programming;static input data-sets;programming models;software development;computation modules;data producer module;data consumer module;data flow management;data flow optimization","","6","","13","","20 Jun 2014","","","IEEE","IEEE Magazines"
"Modeling Test Cases in BPMN for Behavior-Driven Development","D. Lübke; T. van Lessen",innoQ; innoQ,"IEEE Software","24 Aug 2016","2016","33","5","15","21","Testing large-scale process integration solutions is complex and cumbersome. To tackle this problem, researchers employed behavior-driven development. They used the Business Process Model and Notation language to model domain-specific test cases. These test cases can be understood by both developers and business stakeholders and can be executed automatically.","1937-4194","","10.1109/MS.2016.117","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548916","business processes;Business Process Model and Notation;BPMN;behavior-driven development;BDD;test-driven development;TDD;software testing;software development;software engineering","Simple object access protocol;Business process management;Modeling;Testing;Software engineering;Behaviorial sciences","business data processing;program testing;software engineering","test case modelling;Business Process Model and Notation;BPMN;behavior-driven development","","8","","10","","24 Aug 2016","","","IEEE","IEEE Magazines"
"How Expertise Affects a Digital-Rights-Management-Sharing Application's Usability","U. Lah; J. R. Lewis",EMO-Orodjarna; IBM,"IEEE Software","25 Apr 2016","2016","33","3","76","82","Researchers performed a usability study of a digital-rights-management sharing (DRMS) application with which users protect and share digital files. Besides the standard goal of identifying usability problems, the study investigated how expertise affects objective and perceived usability, the correlations among the usability metrics, and how the usability outcomes compared with emerging norms. The researchers divided the 18 study participants into two groups of nine according to skill level. The participants performed seven DRMS tasks. The groups differed significantly in objective usability (successful task completions, errors, and completion times) and perceived usability (ratings of a variant of the System Usability Scale [SUS]). Two correlations were statistically significant (success with the SUS and success with errors); all six possible correlations were in the expected direction. On the basis of the published norms, the overall success rate was below average; the SUS's overall mean was average. The main takeaways for practitioners are two practical examples. The first involved using independently derived benchmarks to assess the perceived usability and effectiveness; the second involved testing different skill groups.","1937-4194","","10.1109/MS.2015.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7281117","digital rights management;DRM;digital-rights-management sharing;DRMS;usability study;perceived usability;System Usability Scale;SUS;success rates;usability metrics;usability norms;software engineering;software development","Digital rights management;Copyright protection;Software development;Correlation;Software engineering;Portable computers","digital rights management;software engineering","digital-rights-management sharing application;DRMS application;digital files protection;digital files sharing;objective usability;perceived usability;usability metrics;usability outcomes;system usability scale","","8","","15","","29 Sep 2015","","","IEEE","IEEE Magazines"
"DevOps: Making It Easy to Do the Right Thing","M. Callanan; A. Spillane",Wotif; Wotif,"IEEE Software","25 Apr 2016","2016","33","3","53","59","Wotif Group used DevOps principles to recover from the downward spiral of manual release activity that many IT departments face. Its approach involved the idea of ""making it easy to do the right thing."" By defining the right thing (deployment standards) for development and operations teams and making it easy to adopt, Wotif drastically improved the average release cycle time. This article is part of a theme issue on DevOps.","1937-4194","","10.1109/MS.2016.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7436644","software release;software delivery;software release management and delivery;Internet;e-commerce;DevOps;continuous delivery;continuous deployment;Wotif Group;software development;software engineering","Software development;Testing;Software delivery;Production processes;Software development;Software engineering;Automation","software engineering","DevOps principles;software development;software deployment standards;release cycle time;Wotif Group","","26","","11","","18 Mar 2016","","","IEEE","IEEE Magazines"
"Model-Driven Engineering for Mission-Critical IoT Systems","F. Ciccozzi; I. Crnkovic; D. Di Ruscio; I. Malavolta; P. Pelliccione; R. Spalazzese",Mälardalen University; Chalmers University of Technology and University of Gothenburg; University of L'Aquila; Vrije Universiteit Amsterdam; Chalmers University of Technology and University of Gothenburg; Malmö University,"IEEE Software","16 Jan 2017","2017","34","1","46","53","Mission-critical Internet of Things (MC-IoT) systems involve heterogeneous things from both the digital and physical worlds. They run applications whose failure might cause significant and possibly dramatic consequences, such as interruption of public services, significant business losses, and deterioration of enterprise operations. These applications require not only high availability, reliability, safety, and security but also regulatory compliance, scalability, and serviceability. At the same time, they're exposed to various facets of uncertainty, spanning from software and hardware variability to mission planning and execution in possibly unforeseeable environments. Model-driven engineering can potentially meet these challenges and better enable the adoption of MC-IoT systems.","1937-4194","","10.1109/MS.2017.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819388","software engineering;Internet of Things;IoT;model-driven engineering;mission-critical systems;software development","Internet of things;Mission critical systems;Software engineering;Software development","Internet of Things;software engineering","model-driven engineering;IoT systems;mission-critical Internet of Things;software variability;hardware variability;MC-IoT systems","","37","","23","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Deep Learning in Automotive Software","F. Falcini; G. Lami; A. M. Costanza",Information Science and Technologies Institute of the National Research Council of Italy; Information Science and Technologies Institute of the National Research Council of Italy; Fiat Chrysler Automobiles,"IEEE Software","15 May 2017","2017","34","3","56","63","Deep-learning-based systems are becoming pervasive in automotive software. So, in the automotive software engineering community, the awareness of the need to integrate deep-learning-based development with traditional development approaches is growing, at the technical, methodological, and cultural levels. In particular, data-intensive deep neural network (DNN) training, using ad hoc training data, is pivotal in the development of software for vehicle functions that rely on deep learning. Researchers have devised a development lifecycle for deep-learning-based development and are participating in an initiative, based on Automotive SPICE (Software Process Improvement and Capability Determination), that's promoting the effective adoption of DNN in automotive software.","1937-4194","","10.1109/MS.2017.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927925","artificial neural networks;neural networks;deep neural networks;ANNs;W model;V model;Automotive SPICE;ISO 26262;ISO/AWI PAS 21448;software engineering process;software engineering;vision and scene understanding;computer vision;artificial intelligence;computing methodologies;standards;software development","Deep leanring;Machine learning;Software development;Biological neural networks;Artificial neural networks;Automotive electronics","automotive engineering;intelligent transportation systems;learning (artificial intelligence);neural nets;software process improvement","Software Process Improvement and Capability Determination;automotive software engineering;automotive SPICE;development lifecycle;software development;ad hoc training data;DNN training;data-intensive deep neural network training;deep learning","","44","","14","","15 May 2017","","","IEEE","IEEE Magazines"
"Palantir: Early Detection of Development Conflicts Arising from Parallel Code Changes","A. Sarma; D. F. Redmiles; A. van der Hoek","University of Nebraska- Lincoln, Lincoln; University of California, Irvine, Irvine; University of California, Irvine, Irvine","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","889","908","The earlier a conflict is detected, the easier it is to resolve-this is the main precept of workspace awareness. Workspace awareness seeks to provide users with information of relevant ongoing parallel changes occurring in private workspaces, thereby enabling the early detection and resolution of potential conflicts. The key approach is to unobtrusively inform developers of potential conflicts arising because of concurrent changes to the same file and dependency violations in ongoing parallel work. This paper describes our research goals, approach, and implementation of workspace awareness through Palantír and includes a comprehensive evaluation involving two laboratory experiments. We present both quantitative and qualitative results from the experiments, which demonstrate that the use of Palantír, as compared to not using Palantír 1) leads to both earlier detection and earlier resolution of a larger number of conflicts, 2) leaves fewer conflicts unresolved in the code base that was ultimately checked in, and 3) involves reasonable overhead. Furthermore, we report on interesting changes in users' behavior, especially how conflict resolution strategies changed among Palantír users.","1939-3520","","10.1109/TSE.2011.64","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928359","Software engineering;computer-supported collaborative work;programmer workbench;configuration management","Monitoring;Measurement;Instant messaging;Computer architecture;Databases;Context;Laboratories","configuration management;groupware;parallel processing;software management","Palantír;development conflict early detection;parallel code changes;workspace awareness;dependency violations;laboratory experiments;conflict resolution strategies;software configuration management system;computer-supported collaborative work;software engineering","","38","1","55","","23 Jun 2011","","","IEEE","IEEE Journals"
"Roundtable: What's Next in Software Analytics","A. E. Hassan; A. Hindle; P. Runeson; M. Shepperd; P. Devanbu; S. Kim","Queen's University, Canada; University of Alberta; Lund University; Brunel University; University of California, Davis; Hong Kong University of Science and Technology","IEEE Software","26 Jun 2013","2013","30","4","53","56","For this special issue, the guest editors asked a panel of six established experts in software analytics to highlight what they thought were the most important, or overlooked, aspect of this field. They all pleaded for a much broader view of analytics than seen in current practice: software analytics should go beyond developers (Ahmed Hassan) and numbers (Per Runeson). Analytics should also prove its relevance to practitioners (Abram Hindle, Martin Shepperd). There are now opportunities for ""natural"" software analytics based on statistical natural language processing (Prem Devanbu). Lastly, software analytics needs information analysts and field agents like Chloe O'Brian and Jack Bauer in the TV show 24 (Sung Kim).","1937-4194","","10.1109/MS.2013.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547637","software/program verification;statistical methods;testing and debugging;metrics;management;information search and retrieval;decision support","Software development;Data mining;Software engineering;Analytical models;Natural language processing;Analytical models","natural language processing;software engineering;statistical analysis","natural software analytics;statistical natural language processing","","13","","7","","26 Jun 2013","","","IEEE","IEEE Magazines"
"What Do Programmers Know about Software Energy Consumption?","C. Pang; A. Hindle; B. Adams; A. E. Hassan",University of Alberta; University of Alberta; Polytechnique Montréal; Queen's University,"IEEE Software","25 Apr 2016","2016","33","3","83","89","Traditionally, programmers received a range of training on programming languages and methodologies, but they rarely receive training on software energy consumption. Yet, the popularity of mobile devices and cloud computing requires increased awareness of software energy consumption. On mobile devices, battery life often limits computation. Under the demands of cloud computing, datacenters struggle to reduce energy consumption through virtualization and datacenter-infrastructure-management systems. Efficient software energy consumption is increasingly becoming an important nonfunctional requirement for programmers. However, are programmers knowledgeable enough about software energy consumption? Do they base their implementation decision on popular beliefs? Researchers surveyed more than 100 programmers regarding their knowledge of software energy consumption. They found that the programmers had limited knowledge of energy efficiency, lacked knowledge of the best practices to reduce software energy consumption, and were often unsure about how software consumes energy. These results highlight the need for better training and education on energy consumption and efficiency.","1937-4194","","10.1109/MS.2015.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7155416","software energy consumption;energy efficiency;software power consumption;power usage","Software engineering;Energy consumption;Power demand;Energy measurement;Software measurement;Mobile handsets;Battery charge measurement","energy consumption;green computing;software engineering","programmers;programming languages;programming methodologies;software energy consumption;mobile devices;cloud computing;virtualization;data center-infrastructure-management systems;best practices;energy efficiency","","50","","10","","13 Jul 2015","","","IEEE","IEEE Magazines"
"Coupled Evolution in Model-Driven Engineering","D. Di Ruscio; L. Iovino; A. Pierantonio",Università degli Studi dell'Aquila; Università degli Studi dell'Aquila; Università degli Studi dell'Aquila,"IEEE Software","22 Oct 2012","2012","29","6","78","84","Model-driven engineering bases a wide range of artifacts on metamodels. When such metamodels evolve, such as a new version of Unified Modeling Language or Business Process Execution Notation or a company-specific metamodel, underlying artifacts often become invalid. In this article, the authors provide an overview of coupled evolution methods and tools to handle such dependencies. I look forward to hearing from both readers and prospective authors about this column and the technologies you want to know more about.","1937-4194","","10.1109/MS.2012.153","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6336727","software technology;coupled evolution;model-driven engineering;Unified Modeling Language","Software engineering;Software development;Modeling;Unified modeling language","software engineering","coupled evolution;model-driven engineering;metamodel","","24","","5","","22 Oct 2012","","","IEEE","IEEE Magazines"
"Social Psychology and Software Teams: Establishing Task-Effective Group Norms","A. Teh; E. Baniassad; D. van Rooy; C. Boughton",Australian National University; Australian National University; Australian National University; Australian National University,"IEEE Software","10 Aug 2012","2012","29","4","53","58","It's a common belief that groups that possess appropriate expertise and work well together will be more likely to successfully complete a project. However, social psychological research shows that getting the right mix of people doesn't guarantee a successful outcome. Group success also relies on group norms, which are derived as much from the group's context as from the people in it. A small, preliminary study illustrates how norm manipulation affected how well groups performed requirements elicitation. Results show that groups performed better on this task when norms emphasized creativity rather than agreeability. Norm manipulation might be a practical way to enhance group performance in software engineering tasks. There is an erratum in this article: in Figure 1, the description in the “Constructive norm condition” box should have read “Priming: list what they had learned in their requirements-analysis course.” The description in the “Critical norm condition” box should have read “Priming: debate and reach consensus on the statement‘Requirements specifications should always reflect design constraints.’”","1937-4194","","10.1109/MS.2011.157","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095494","group norms;sociology;teamwork;software engineering","Psychology;Memory management;Software engineering;Sociology;Collaboration;Software engineering;Design methodology;Teamwork","","","","16","","15","","6 Dec 2011","","","IEEE","IEEE Magazines"
"Architectural Mismatch: Why Reuse Is Still So Hard","D. Garlan; R. Allen; J. Ockerbloom",Carnegie Mellon University; IBM; University of Pennsylvania,"IEEE Software","19 Jun 2009","2009","26","4","66","69","In this article, David Garlan, Robert Allen, and John Ockerbloom reflect on the state of architectural mismatch, a term they coined in their 1995 IEEE Software article, ""Architectural Mismatch: Why Reuse Is So Hard."" Although the nature of software systems has changed dramatically since the earlier article was published, the challenge of architectural mismatch remains an important concern for the software engineering field.","1937-4194","","10.1109/MS.2009.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076461","architecture mismatch;software architecture;component-based systems;software engineering","Software systems;Filters;Connectors;Software tools;Communication standards;Software standards;Open source software;Software libraries;Programming;User interfaces","software architecture;software reusability","architectural mismatch;software systems;software engineering field","","39","","6","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Doubt and Software Standards","R. L. Glass",Griffith University,"IEEE Software","25 Aug 2009","2009","26","5","104","104","Software standards. Now there's a subject that brooks no ""loyal opposition,"" right? Standards are material provided by some software god, biblically significant, subject to no doubt? In recent years I've come to question all that.In 2006, my colleague Johann Rost wrote a guest Loyal Opposition column on the standard for requirements documents. He explained that at the conceptual level he understood the standard quite well, but at the implementation level he found it impossible to follow. I offered him sympathy, hosted his column here, and sort of forgot about it. Time passed. Another colleague, Barbara Kitchenham, was beginning to struggle with certain software standards. One standard gave ""inappropriate advice for measuring software engineering processes."" Another standard was ""not suitable for measuring the design quality of a software product."" Echoing Johann's concerns, Barbara commented that ""experienced designers will be able to construct a number of different interpretations of the standard, implying that [it] is not a standard at all."" Barbara pointed me at yet another critic of software standards, Magne Jorgensen. He noted that one standard for software quality ""requires quality measurement and at the same time admits that there are no (universally) accepted quality measures"".","1937-4194","","10.1109/MS.2009.126","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222806","software engineering;software standards","Software standards;Environmental economics;Project management;Subscriptions;Industrial economics;Radio access networks;ISO standards;IEC standards;Software systems","software quality;software standards","software standard;requirements documents;software engineering process;design quality;software product;software quality;quality measurement","","","","7","","25 Aug 2009","","","IEEE","IEEE Magazines"
"How Software Architects Drive Connected Vehicles","S. Frey; L. Charissis; J. Nahm",Daimler TSS; Daimler TSS; Daimler TSS,"IEEE Software","28 Oct 2016","2016","33","6","41","47","For many years, software engineering researchers and practitioners have tried to determine, define, and redefine the role of software architects. But we still haven't reached a real consensus. The popularity of agile methods such as Scrum and Kanban, with their clear focus on team collaboration, threatens many roles traditionally assigned to individual experts. Some organizations are even challenging the raison d'être of the software architect role. However, researchers' experiences developing connected-vehicle software revealed two reasons why successful projects still often assign architecture-related responsibilities to individual experts acting as software architects. First, the experts help effectively manage complexity; second, they act as knowledge multipliers when development must scale up.","1937-4194","","10.1109/MS.2016.145","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725231","software architectures;software engineering;staffing;project and people management;management of computing and information systems;real-time and embedded systems;special-purpose and application-based systems;computer systems organization;software development;software architects","Software development;Context modeling;Complexity theory;Scrum (Software development);Software architecture;Software architecture","personnel;software development management","software architect role;software engineering;agile methods;Scrum method;Kanban method;team collaboration;connected-vehicle software;complexity management","","4","","12","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Four Trends Leading to Java Runtime Bloat","N. Mitchell; E. Schonberg; G. Sevitsky",IBM Research; IBM Research; IBM Research,"IEEE Software","31 Dec 2009","2010","27","1","56","63","Today, programmers work in an environment of rapid global development of large-scale applications that have become increasingly interconnected. These drivers are the backdrop for four important software engineering trends: the wide adoption of object-oriented principles, the pervasive use of abstractions, system and data integration, and the increasing need for software flexibility. Programmers no longer write monolithic applications; they assemble code from a sea of reuseable libraries and frameworks. Many programmers believe that improved productivity always outweighs any resulting loss in performance, but experience with large Java applications doesn't support this belief.","1937-4194","","10.1109/MS.2010.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370764","software construction;data storage representations;metrics;measurements;language constructs and features","Java;Runtime;Programming profession;Application software;Large-scale systems;Software engineering;Assembly;Software libraries;Productivity;Performance loss","Java;software engineering","Java runtime;software engineering trend;abstractions application;data integration;system integration;software flexibility;reuseable library;object-oriented principles","","30","1","15","","31 Dec 2009","","","IEEE","IEEE Magazines"
"From Programming to Modeling - and Back Again","M. Volter",NA,"IEEE Software","20 Oct 2011","2011","28","6","20","25","The authors describe an issue that they think is extremely important: the relationship between applications and solutions in the software engineering and information systems fields. In particular, they believe the fields desperately need a taxonomy of application domains, a taxonomy of solution approaches, and a mapping between the two. This article has a Web extra that offers an interview with one of the article's authors, Robert L. Glass, about the ""dark side"" of this topic.","1937-4194","","10.1109/MS.2011.139","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6055659","software modeling;programming;application-domain specific;composable languages","Software engineering;Information systems;Software development;Programming environments;Application programming interfaces;Taxonomy","information systems;programming;software engineering","software engineering;information systems;application domains","","18","","2","","20 Oct 2011","","","IEEE","IEEE Magazines"
"What Makes an Architect Successful?","J. Klein",Software Engineering Institute,"IEEE Software","29 Dec 2015","2016","33","1","20","22","An architect whose skills and capabilities match a project's needs will more likely be successful. Moreover, each software life-cycle phase requires different skills. A proposed model identifies the skills needed at each phase and helps explain common failure patterns.","1937-4194","","10.1109/MS.2016.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367982","agile teams;software architect;software architecture;software design;software development;software engineering","Software development;Computer architecture;Software architecture;Pragmatics;Performance evaluation;Business","professional aspects;software architecture;software reliability","software life-cycle phase;failure patterns;user skills","","4","","5","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Measuring Developers: Aligning Perspectives and Other Best Practices","M. Umarji; F. Shull","University of Maryland Baltimore County; Fraunhofer Center for Experimental Software Engineering, Maryland","IEEE Software","16 Oct 2009","2009","26","6","92","94","The paper discusses the software metrics programs. Software metrics programs might rank among the all-time touchiest subjects in software development. Done well, a measurement program can prove an effective tool for keeping on top of development effort-especially for large, distributed projects. It can help developers feel that they have a fair and objective way of communicating their progress and getting resources allocated where they're needed most. An effective metrics program must address both products and processes. Product-related metrics can be tied to customer satisfaction. They often represent objectively verifiable properties such as the number of bugs or defects found in a product. Process metrics, include measures of effort and effectiveness and can give quick feedback about the status of defect containment, productivity, and other desirable properties at many points during development. However, instituting these metrics poses different challenges that the authors discussed and developed some best practice solutions. These include design measures with multiple stakeholders, build on measures that come naturally out of existing processes, and transparency.","1937-4194","","10.1109/MS.2009.180","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287018","Software engineering;software metrics","Best practices;Software metrics;Programming;Resource management;Customer satisfaction;Computer bugs;Feedback;Productivity","software metrics","software metrics programs;software development;product-related metrics;process metrics;stakeholder design solutions;measure building solutions;transparency solutions","","1","","11","","16 Oct 2009","","","IEEE","IEEE Magazines"
"ICSE Highlights","J. C. Carver; A. Serebrenik",University of Alabama; Eindhoven University of Technology,"IEEE Software","13 Nov 2017","2017","34","6","18","20","This issue’s column reports on papers from the 2017 International Conference on Software Engineering. Topics include context-based analytics, defect prediction, software development and energy consumption, continuous delivery, and continuous deployment.","1937-4194","","10.1109/MS.2017.4121213","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106866","context-based analytics;defect prediction;summation;energy consumption;continuous delivery;continuous deployment;feature freeze;ICSE;International Conference on Software Engineering;software engineering;software development;Practitioners’ Digest","","","","","","","","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Quantifying the Effect of Using Kanban versus Scrum: A Case Study","D. I. K. Sjøberg; A. Johnsen; J. Solberg",University of Oslo; Software Innovation; Software Innovation,"IEEE Software","21 Aug 2012","2012","29","5","47","53","Proponents of various processes and methods in the agile and lean communities have made many bold claims about usefulness, but those claims are rarely supported by empirical investigations. Data gathered from more than 12,000 work items collected over two years sheds light on Kanban versus Scrum.To acquire more knowledge about the performance of different agile or lean methods, scholars should conduct similar studies in different organizations in different application domains and with people of different cultures and competences.","1937-4194","","10.1109/MS.2012.110","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6231615","lean;software process models;software engineering process;software engineering;process metrics;measurement;productivity;management","Computer bugs;Product life cycle management;Agile manufacturing;Productivity;Software engineering;Software management;Software measurement","kanban;lean production;software development management;software prototyping","agile communities;lean communities;Kanban;Scrum","","32","","8","","3 Jul 2012","","","IEEE","IEEE Magazines"
"Five Years of Software Architecture Checking: A Case Study of Eclipse","J. Brunet; G. C. Murphy; D. Serey; J. Figueiredo",Federal University of Campina Grande; University of British Columbia; Federal University of Campina Grande; Federal University of Campina Grande,"IEEE Software","21 Aug 2015","2015","32","5","30","36","Over time, source code tends to drift from the intended software architecture, often resulting in the loss of desired software qualities. To help keep code aligned with the intended architecture, the developers of core parts of the open source Eclipse platform introduced API Tools to express and check architectural rules. Researchers analyzed five years of Eclipse architecture-checking reports that API Tools produced. They investigated what kinds of rules the developers found helpful to check, how code diverged from the intended architecture, and how the developers dealt with architectural violations over time. This article is part of a special issue on Software Architecture.","1937-4194","","10.1109/MS.2014.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6879058","architecture checking;empirical software engineering;Eclipse;software development;software engineering","Computer architecture;Software architecture;Software engineering;Documentation;Software maintenance;Computer science","application program interfaces;program verification;software architecture","software architecture checking;source code;software qualities;open source Eclipse platform;API tools;architectural rules;Eclipse architecture-checking;architectural violations","","7","","9","","15 Aug 2014","","","IEEE","IEEE Magazines"
"Microblogging in Open Source Software Development: The Case of Drupal and Twitter","X. Wang; I. Kuzmickaja; K. Stol; P. Abrahamsson; B. Fitzgerald",Free University of Bozen-Bolzano; Free University of Bozen-Bolzano; Lero--The Irish Software Engineering Research Centre; Free University of Bozen-Bolzano; Lero--The Irish Software Engineering Research Centre,"IEEE Software","13 Jun 2014","2014","31","4","72","80","Microblogging is a popular form of social media that has quickly permeated both enterprise and open source software development communities. However, how exactly open source communities can leverage microblogging isn't yet well understood.","1937-4194","","10.1109/MS.2013.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6576114","Twitter;microblogging;social media;open source software development;Drupal;communication;crowdsourcing;software engineering;pervasive computing","Open source software;Social network services;Media;Blogs;Twitter","public domain software;social networking (online)","microblogging;drupal;twitter;social media;enterprise;open source software development community;open source community","","14","","16","","7 Aug 2013","","","IEEE","IEEE Magazines"
"Strategic Prototyping for Developing Big Data Systems","H. Chen; R. Kazman; S. Haziyev",University of Hawaii at Manoa; University of Hawaii at Manoa; SoftServe,"IEEE Software","26 Feb 2016","2016","33","2","36","43","Conventional horizontal evolutionary prototyping for small-data system development is inadequate and too expensive for identifying, analyzing, and mitigating risks in big data system development. RASP (Risk-Based, Architecture-Centric Strategic Prototyping) is a model for cost-effective, systematic risk management in agile big data system development. It uses prototyping strategically and only in areas that architecture analysis can't sufficiently address. Developers use less costly vertical evolutionary prototypes instead of blindly building full-scale prototypes. An embedded multiple-case study of nine big data projects at a global outsourcing firm validated RASP. A decision flowchart and guidelines distilled from lessons learned can help architects decide whether, when, and how to do strategic prototyping. This article is part of a special issue on Software Engineering for Big Data Systems.","1937-4194","","10.1109/MS.2016.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420518","big data;RASP;risk management;rapid prototyping;evolutionary prototyping;throwaway prototyping;software architecture;software development;software engineering","Big data;Risk management;Rapid prototyping;Data models;Data structures;Boolean functions;Software architecture;Software engineering","Big Data;outsourcing;risk management;software prototyping","evolutionary prototyping;small-data system development;Big data systems;RASP;risk-based architecture-centric strategic prototyping;cost-effective systematic risk management;agile big data system development;big data projects;global outsourcing firm;decision flowchart;software engineering","","20","","16","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Operational-Log Analysis for Big Data Systems: Challenges and Solutions","A. Miranskyy; A. Hamou-Lhadj; E. Cialini; A. Larsson","Ryerson University; Concordia University, Montreal; IBM; Ericsson","IEEE Software","26 Feb 2016","2016","33","2","52","59","Big data systems (BDSs) are complex, consisting of multiple interacting hardware and software components, such as distributed computing nodes, databases, and middleware. Any of these components can fail. Finding the failures' root causes is extremely laborious. Analysis of BDS-generated logs can speed up this process. The logs can also help improve testing processes, detect security breaches, customize operational profiles, and aid with any other tasks requiring runtime-data analysis. However, practical challenges hamper log analysis tools' adoption. The logs emitted by a BDS can be thought of as big data themselves. When working with large logs, practitioners face seven main issues: scarce storage, unscalable log analysis, inaccurate capture and replay of logs, inadequate log-processing tools, incorrect log classification, a variety of log formats, and inadequate privacy of sensitive data. Some practical solutions exist, but serious challenges remain. This article is part of a special issue on Software Engineering for Big Data Systems.","1937-4194","","10.1109/MS.2016.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7412635","big data;software tracing and logging;software engineering;software development","Big data;Computer security;Software engineering;Distributed databases;Tracking;Software development","Big Data;middleware;security of data","operational-log analysis;Big Data systems;hardware components;software components;distributed computing nodes;database management;middleware;BDS-generated log analysis;testing process improvement;security breach detection;operational profile customization;runtime-data analysis;software engineering","","22","","14","","18 Feb 2016","","","IEEE","IEEE Magazines"
"Mining for Computing Jobs","A. Aken; C. Litecky; A. Ahmad; J. Nelson","Southern Illinois University, Carbondale; Southern Illinois University, Carbondale; Southern Illinois University, Carbondale; Southern Illinois University, Carbondale","IEEE Software","31 Dec 2009","2010","27","1","78","85","A Web content mining approach identified 20 job categories and the associated skills needs prevalent in the computing professions. Using a Web content data mining application, we extracted almost a quarter million unique IT job descriptions from various job search engines and distilled each to its required skill sets. We statistically examined these, revealing 20 clusters of similar skill sets that map to specific job definitions. The results allow software engineering professionals to tune their skills portfolio to match those in demand from real computing jobs across the US to attain more lucrative salaries and more mobility in a chaotic environment.","1937-4194","","10.1109/MS.2009.150","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5232798","clustering;web mining;data mining;computer and information science education;employment;occupations;software;software engineering","Data mining;Application software;Search engines;Software engineering;Portfolios;Remuneration;Chaos","data mining;information filtering;Internet;search engines;statistical analysis","Web content data mining application;IT job description extraction;job search engines;statistical analysis;software engineering professionals;chaotic environment","","34","","32","","4 Sep 2009","","","IEEE","IEEE Magazines"
"A Deep-Intelligence Framework for Online Video Processing","W. Zhang; L. Xu; Z. Li; Q. Lu; Y. Liu","China University of Petroleum; China University of Petroleum; China University of Petroleum; China University of Petroleum; Concordia University, Montreal","IEEE Software","26 Feb 2016","2016","33","2","44","51","Video data has become the largest source of big data. Owing to video data's complexities, velocity, and volume, public security and other surveillance applications require efficient, intelligent runtime video processing. To address these challenges, a proposed framework combines two cloud-computing technologies: Storm stream processing and Hadoop batch processing. It uses deep learning to realize deep intelligence that can help reveal knowledge hidden in video data. An implementation of this framework combines five architecture styles: service-oriented architecture, publish-subscribe, the Shared Data pattern, MapReduce, and a layered architecture. Evaluations of performance, scalability, and fault tolerance showed the framework's effectiveness. This article is part of a special issue on Software Engineering for Big Data Systems.","1937-4194","","10.1109/MS.2016.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7412619","big data;cloud computing;deep learning;fault tolerance;video processing;MapReduce;Storm;Hadoop;software engineering;software development","Streaming media;Computer architecture;Real-time systems;Big data;Machine learning;Scalability;Software engineering;Cloud computing;Fault tolerance;Software development;Deep learning","Big Data;cloud computing;data handling;learning (artificial intelligence);service-oriented architecture;software fault tolerance;video signal processing","deep-intelligence framework;online video processing;cloud-computing technologies;storm stream processing;Hadoop batch processing;deep learning;service-oriented architecture;publish-subscribe style;shared data pattern;MapReduce;layered architecture;fault tolerance;software engineering;big data systems","","34","","6","","18 Feb 2016","","","IEEE","IEEE Magazines"
"Why Software Is Like Baseball","R. Valerdi",University of Arizona,"IEEE Software","22 Sep 2017","2017","34","5","7","9","In baseball, the practice of sabermetrics uses data to make objective decisions about which players to draft, which players to play, how much to pay players, and which personnel trades between teams make the most sense. Applying such thinking to software projects might help software teams find hidden value and operate more efficiently and effectively.","1937-4194","","10.1109/MS.2017.3571583","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048622","baseball;Moneyball;sabermetrics;software development;COCOMO II;software engineering","Decision making;Software development;Software measurement;Software engineering;Games","decision making;project management;software management","decisions making;software projects;software teams","","","","4","","22 Sep 2017","","","IEEE","IEEE Magazines"
"How Do I Know Whether to Trust a Research Result?","M. Shepperd",Brunel University London,"IEEE Software","4 Feb 2015","2015","32","1","106","109","A meta-analysis indicated that some areas of computer science research are subject to researcher bias. However, rather than mistrust all scientific research, researchers should examine research to determine its validity.","1937-4194","","10.1109/MS.2015.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030205","meta-analysis;software engineering;research results;statistical significance;software defect prediction;Matthews correlation coefficient;researcher bias;scientific research","Research and development;Systematics;Software engineering;Statistical analysis;Internet","computer science;trusted computing","trust;scientific research result;meta-analysis;computer science research;researcher bias","","3","","6","","4 Feb 2015","","","IEEE","IEEE Magazines"
"Service-Oriented Architecture and Legacy Systems","N. Serrano; J. Hernantes; G. Gallardo",NA; NA; NA,"IEEE Software","15 Sep 2014","2014","31","5","15","19","Enterprise systems are quickly evolving from monolithic silos to distributed applications with service-oriented flexible usage schemes. To keep up, IT organizations must adapt their legacy systems to meet changing business challenges almost in real time, with no second chances. Service-oriented architectures (SOAs) have evolved to flexibly operate and federate business processes and underlying systems. Authors Nicolas Serrano, Josune Hernantes, and Gorka Gallardo provide an overview of current SOA technologies and how to evolve in legacy environments.","1937-4194","","10.1109/MS.2014.125","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898686","software engineering;SOA;service-oriented architecture;cloud computing;Web services;APIs;legacy systems;systems integration;HTTP;SOAP;REST","Service-oriented architecture;Simple object access protocol;Software engineering;Legacy systems","service-oriented architecture;software maintenance","service-oriented architecture;legacy systems;enterprise systems;service-oriented flexible usage schemes;IT organizations;information technology;SOA;legacy environment","","17","","5","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Release Stabilization on Linux and Chrome","M. T. Rahman; P. C. Rigby",Concordia University; Concordia University,"IEEE Software","10 Mar 2015","2015","32","2","81","88","An empirical study of the time and effort for release stabilization on Linux and Chrome found that small teams controlled the stabilization effort, few changes were reverted, and the original developer didn't do much of the rework. Despite regular rapid release cycles, a rush period occurred before release stabilization, and stabilization periods could vary up to 10 days.","1937-4194","","10.1109/MS.2015.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006343","software engineering;software release management and delivery;configuration management","Continuous production;Software development;Schedules;Software engineering;Software measurement;Standards;Configuration management","Linux;online front-ends;software development management","Linux;Chrome;release stabilization;stabilization effort;regular rapid release cycles;rush period","","14","","12","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Breezing My Way as a Solution Architect: A Retrospective on Skill Development and Use","R. Krishnamurthy",Cognizant Technology Solutions,"IEEE Software","15 May 2017","2017","34","3","9","13","Solution architecture is a team effort balancing various forces. Solution architects must consciously cultivate skills cutting across technical, social, and behavioral domains. In this article, Raghuraman Krishnamurthy discusses eight such skills that will likely be helpful.","1937-4194","","10.1109/MS.2017.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927930","software architecture;software systems;knowledge management;software engineering;software development","Software architecture;Databases;Stakeholders;Strategic planning;Software engineering;Software development","software architecture;team working","skill development;solution architecture;team effort;skills cultivation;technical domains;social domains;behavioral domains;Raghuraman Krishnamurthy","","3","","14","","15 May 2017","","","IEEE","IEEE Magazines"
"Just Enough Anticipation: Architect Your Time Dimension","E. Poort; C. Pautasso; O. Zimmermann",CGI; University of Lugano; University of Applied Sciences of Eastern Switzerland,"IEEE Software","28 Oct 2016","2016","33","6","11","15","Documenting the time dimension part of your architecture might look like extra work. However, anticipation should be a large part of your job as an architect, anyway. If you communicate your anticipation as an evolution viewpoint or architecture roadmap, your architecture description will stay valid longer. And, you'll have a ready answer when stakeholders ask how you've addressed their change and planning concerns.","1937-4194","","10.1109/MS.2016.134","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725228","software architecture;architecture roadmapping;software evolution;software development;software engineering;technical debt;RCDA;risk- and cost-driven architecture;agile development","Software architecture;Software development;Documentation;Service-oriented architecture;Software engineering","software architecture","evolution viewpoint;architecture roadmap;architecture description;time dimension part","","5","","8","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Data Center Energy Demand: What Got Us Here Won't Get Us There","R. Bashroush; E. Woods; A. Noureddine",University of East London; Endava; University of East London,"IEEE Software","26 Feb 2016","2016","33","2","18","21","Given environmentalism's rising tide and increasing energy prices and IT workloads, architects must determine whether they can continue designing systems without considering energy and power efficiency.","1937-4194","","10.1109/MS.2016.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420488","energy efficiency;green computing;software architect;software architecture;software design;software development;software engineering","Energy efficiency;Software engineering;Software architecture;Computer architecture;Software design;Green computing;Environmental factors","computer centres;energy conservation;energy consumption;power aware computing","energy prices;IT workloads;energy efficiency;power efficiency;data center energy demand","","4","","6","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Cyclomatic Complexity","C. Ebert; J. Cain; G. Antoniol; S. Counsell; P. Laplante",University of Stuttgart; Brunel University; Polytechnique Montréal; Pennsylvania State University; Brunel University,"IEEE Software","28 Oct 2016","2016","33","6","27","29","The cyclomatic complexity (CC) metric measures the number of linearly independent paths through a piece of code. Although Thomas McCabe developed CC for procedural languages, its popularity has endured throughout the object-oriented era. That said, CC is one of the most controversial metrics, shunned for the most part by academia for certain theoretical weaknesses and the belief that it's no more useful than a simple “lines of code” metric. However, most metrics collection tools support its collection, and, paradoxically, industry uses it extensively. So, why is this the case? This question also leads to fundamental perennial questions about industry's exposure to academic opinion and whether academic research fails to take account of software development's daily practicalities. Maybe industry is simply looking for straightforward, widely understood metrics?","1937-4194","","10.1109/MS.2016.147","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725232","cyclomatic complexity;software industry;software engineering;software development","Software measurement;Software engineering;Software development;Complexity theory;Software testing;Blogs","software metrics","cyclomatic complexity metric;CC metric;procedural languages;object-oriented language;software development","","13","","1","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Evaluating Lehman's Laws of Software Evolution for Software Product Lines","R. P. de Oliveira; E. S. de Almeida",Federal Institute of Sergipe; Federal University of Bahia,"IEEE Software","25 Apr 2016","2016","33","3","90","93","The evolution of software to maintain its performance and usefulness over time occurs in successful software development processes. To address this, Meir Lehman formulated his well-known software-evolution laws. This article evaluates Lehman's laws in the context of two companies' real-world software-product-line projects to gain useful insights about the evolution process.","1937-4194","","10.1109/MS.2016.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458762","software;software evolution;Lehman's laws;Meir Lehman;software product lines;SPL;software development;software engineering","Software development;Product lines;Complexity theory;Software engineering;Software product lines;Stability analysis","software product lines","Lehman software evolution laws;software product lines;software development process;software evolution process","","2","","7","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Driving Agile Architecting with Cost and Risk","E. R. Poort",NA,"IEEE Software","15 Sep 2014","2014","31","5","20","23","Five pieces of advice can help architects become more effective in an agile world without having to implement new methods or frameworks. They describe changes in attitude or behavior rather than complete practices or principles so they're easy to digest and apply. The ideas are based on a solution architecting approach called Risk- and Cost-Driven Architecture. Core to the approach is the use of risk and cost to determine the architectural significance of concerns. Agility is achieved by keeping the architecture lightweight, addressing only those concerns that are especially risky or costly. A risk- and cost-driven backlog of architectural concerns balances the generally value-driven product backlog to achieve “just enough anticipation” in the evolution of software solutions.","1937-4194","","10.1109/MS.2014.111","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898730","software engineering;project management;agile;architecture","Computer architecture;Agile manufacturing;Software engineering;Pragmatics;Project management","costing;risk management;software architecture;software prototyping","agile architecture;solution architecting approach;risk-driven architecture;cost-driven architecture;software agility;risk-driven backlog;cost-driven backlog;value-driven product backlog;software solutions","","10","","4","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Architectural Principles for Energy-Aware Internet-Scale Applications","R. Bashroush; E. Woods",University of East London; Endava,"IEEE Software","15 May 2017","2017","34","3","14","17","Optimizing the energy consumption of today's Internet-scale systems will require a radical approach that considers the whole system. To address system-level energy efficiency, software architects can follow three simple design principles. A case study illustrates the possible savings.","1937-4194","","10.1109/MS.2017.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927928","software architect;green computing;energy;energy efficiency;datacenters;software engineering;Internet;cloud;eBay;software development","Software engineering;Redundancy;Internet;Energy consumption;Optimization","Internet;power aware computing;software architecture","architectural principles;energy-aware Internet-scale applications;energy consumption;Internet-scale systems;system-level energy efficiency;software architects","","3","","8","","15 May 2017","","","IEEE","IEEE Magazines"
"From Raw Project Data to Business Intelligence","P. Mäder; J. Cleland-Huang",Technische Universität Ilmenau; DePaul University,"IEEE Software","30 Jun 2015","2015","32","4","22","25","VTML (Visual Trace Modeling Language) empowers project stakeholders to issue useful queries. The Web extra at https://youtu.be/RH4rvFgj8lQ is an audio podcast in which author Jane Cleland-Huang provides an audio recording of the Requirements column, in which she discusses how VTML (Visual Trace Modeling Language) empowers project stakeholders to issue useful queries.","1937-4194","","10.1109/MS.2015.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140680","TIM;Traceability Information Mode;VTML;Visual Trace Modeling Language;SQL queries;trace links;software engineering;software development","Unified modeling language;Visualization;Data models;Software development;Software engineering;Visual analytics;Query processing","competitive intelligence;project management;visual languages","business intelligence;raw project data;visual trace modeling language;VTML;project stakeholders","","1","","2","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Mobile Money's Impact on Tanzanian Agriculture","B. Seetharam; D. Johnson",Vodafone Solutions; TechnoServe,"IEEE Software","4 Feb 2015","2015","32","1","29","34","Software has enabled the use of mobile money by farmers and significantly benefited Tanzanian agriculture.","1937-4194","","10.1109/MS.2015.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030183","Tanzania;mobile money;cell phones;mobile networks;agriculture;M-Pesa;Multiflower;software engineering","Mobile communication;Servers;Mobile handsets;Finance;Mobile computing;Software engineering;Logic gates","agriculture;electronic money;mobile computing","mobile money impact;Tanzanian agriculture;farmers","","1","","8","","4 Feb 2015","","","IEEE","IEEE Magazines"
"Caring: An Undiscovered ""Super -ility"" of Smart Healthcare","N. Laplante; P. A. Laplante; J. Voas",Widener University; Pennsylvania State University; US National Institute of Standards and Technology,"IEEE Software","28 Oct 2016","2016","33","6","16","19","As new and exciting healthcare applications arise that use smart technologies, the Internet of Things, data analytics, and other technologies, a critical problem is emerging: the potential loss of caring. Although these exciting technologies have improved patient care by allowing for better assessment, surveillance, and treatment, their use can disassociate the caregiver from the patient, essentially removing the ""care"" from healthcare. So, you can view caring as an undiscovered -ility that ranks at least as important as other well-known -ilities in healthcare systems. The Web Extra at https://youtu.be/bDyZ2geRyJE is an audio podcast of author Phil Laplante reading this article.","1937-4194","","10.1109/MS.2016.136","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725236","smart healthcare systems;Internet of Things;requirements;-ilities;software engineering;software development;healthcare;caring;nursing","Medical services;Software engineering;Internet of things;Smart devices","data analysis;health care;Internet of Things","smart healthcare;smart technologies;Internet of Things;data analytics;patient care","","6","","5","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Collaboration in Formative Design: Working Together at a Whiteboard","J. Rooksby; N. Ikeya",University of St Andrews; Keio University,"IEEE Software","22 Dec 2011","2012","29","1","56","60","To successfully collaborate in a creative design session, software developers must achieve and maintain a shared focus, encourage and challenge each other, and manage their working relations, even in stressful situations. This article describes six key ways professional software developers do this using examples from a video study of professional developers designing at a whiteboard.","1937-4194","","10.1109/MS.2011.123","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6035658","programming teams;software engineering process;qualitative process analysis;management","Collaboration;Software design;Software engineering;Product development;Software development management","software development management;team working","formative design collaboration;creative design session;professional software developer;whiteboard","","5","","7","","6 Oct 2011","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Parallelism on the Desktop","V. Pankratius; W. Schulte; K. Keutzer","Karlsruhe Institute of Technology; Microsoft; University of California, Berkeley","IEEE Software","20 Dec 2010","2011","28","1","14","16","The computer industry is experiencing a major shift: improved single processor performance via higher clock rates has reached its technical limits due to overheating. Fortunately, Moore's law still holds, so chip makers use transistors to boost performance through parallelism in multicore and manycore processors. However, exploiting the full potential of these processors requires parallel programming. Thus, a large number of developers need to parallelize desktop applications, including browsers, business applications, media processing, and other domain-specific applications. This is likely to result in the largest rewrite of software in the history of the desktop. To be successful, systematic engineering principles must be applied to parallelize performance-critical applications and environments. In light of these developments, we're pleased to present this special issue on programming methods, tools, and libraries for parallelizing desktop applications.","1937-4194","","10.1109/MS.2011.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5672515","Multicore;Manycore;parallel programming;multicore software engineering","Special issues and sections;Parallel processing;Instruction sets;Software engineering;Multicore processing","","","","","","","","20 Dec 2010","","","IEEE","IEEE Magazines"
"It Is Cold. And Lonely.","G. Booch",NA,"IEEE Software","25 Apr 2016","2016","33","3","7","9","The next generation of software-intensive systems will be taught instead of programmed. This poses considerable pragmatic challenges in how we develop, deliver, and evolve them. The Web extra at https://youtu.be/_tAxyi5Cma0 is an audio podcast of author Grady Booch reading his column.","1937-4194","","10.1109/MS.2016.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458768","software engineering;deep learning;development tools;ethics;software development","Neural networks;Ehtics;Complexity theory;Software engineering;Artificial intelligence;Deep learning;Robots;Software development","learning (artificial intelligence)","machine learning;software-intensive system;IBM Watson;AlphaGo;arificial intelligence","","","","6","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Software Mythbusters Explore Formal Methods","C. Jaspan; M. Keeling; L. Maccherone; G. L. Zenarosa; M. Shaw",Carnegie Mellon University; Carnegie Mellon University; Carnegie Mellon University; University of Pittsburgh; Carnegie Mellon University,"IEEE Software","16 Oct 2009","2009","26","6","60","63","In 1990, Anthony Hall identified and challenged seven common myths about formal methods in the IEEE Software article ""Seven Myths of Formal Methods."" This update re-examines those myths, reflecting both on the authors' experience with formal methods in practice and on their persistent mythic status","1937-4194","","10.1109/MS.2009.188","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287011","formal methods;formal specification;specifications;education;software engineering education;development process;mathematics;specification tool","Application software;Unified modeling language;Computer industry;Defense industry;Springs;Seminars;Software engineering;Programming;Real time systems;Biomedical informatics","","","","4","","1","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Architecture Haiku: A Case Study in Lean Documentation [The Pragmatic Architect]","M. Keeling",IBM,"IEEE Software","23 Apr 2015","2015","32","3","35","39","An architecture haiku aims to capture software system architecture's most important details on a single piece of paper. An architecture haiku helps development teams focus on the most essential information relevant to the architecture, provides clear guidance for construction, and encourages collaboration.","1937-4194","","10.1109/MS.2015.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093016","architecture haiku;software architecture;software documentation;software engineering;software development","Computer architecture;Software engineering;Documentation;Pragmatics;Software development;Context modeling","software architecture","software system architecture;Haiku;lean documentation","","1","","4","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Requirements and Architectures for Secure Vehicles","M. W. Whalen; D. Cofer; A. Gacek",University of Minnesota; Rockwell Collins Advanced Technology Center; Rockwell Collins Advanced Technology Center,"IEEE Software","23 Jun 2016","2016","33","4","22","25","In the High-Assurance Cyber Military Systems project, researchers are investigating how to construct complex networked-vehicle software securely. Experiments demonstrated that careful attention to requirements and system architecture, along with formally verified approaches that remove known security weaknesses, can lead to vehicles that can withstand attacks from even sophisticated attackers with access to vehicle design data. The Web extra at https://youtu.be/EvG7fjdvyro is an audio podcast of author Michael W. Whalen reading the column that he cowrote with Darren Cofer and Andrew Gacek.","1937-4194","","10.1109/MS.2016.94","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498541","software requirements;vehicle security;HACMS;High-Assurance Cyber Military Systems;UAVs;unmanned aerial vehicles;software development;software engineering","Software engineering;Computer architecture;Encryption;Computer crime;Unmanned aerial vehicles;Military communication","military computing;military vehicles","secure vehicles;high-assurance cyber military systems project;networked-vehicle software;system architecture;security weaknesses;sophisticated attackers;vehicle design data","","9","","5","","23 Jun 2016","","","IEEE","IEEE Magazines"
"Web App Security: A Comparison and Categorization of Testing Frameworks","S. M. Srinivasan; R. S. Sangwan",Penn State University; Penn State University,"IEEE Software","16 Jan 2017","2017","34","1","99","102","Web app developers often face challenges in using the many available security-testing frameworks, owing to those frameworks' inherent complexity and the lack of proper documentation. No up-to-date criteria exist that can help practitioners and organizations select an appropriate framework. Consequently, numerous vulnerabilities go undetected in the final product, creating a potential for major attacks. To help practitioners select the right framework, researchers classified 26 frameworks, using 27 criteria.","1937-4194","","10.1109/MS.2017.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819409","Web apps;security testing;software security;software development;software engineering","Computer applications;Authentication;Authorization;Software engineering;Forgery;High performance computing;Computer security;Software testing","Internet;program testing;safety-critical software","documentation;security-testing frameworks;Web application security","","6","","4","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Disrupting the Disrupters","G. Booch",NA,"IEEE Software","23 Jun 2016","2016","33","4","6","8","How do you disrupt an industry? Question the fundamental, sacred assumptions on which that industry is founded, then journey along the path of the possible. The Web extra at https://youtu.be/bDVbj5XO2bU is an audio podcast of author Grady Booch reading his column.","1937-4194","","10.1109/MS.2016.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498539","software engineering;disruption;human experience;computing;software development","Software engineering;Behavioral science;Human factors;Technological innovation;Software development","software prototyping","computing disruption;pair programming;development process","","","","3","","23 Jun 2016","","","IEEE","IEEE Magazines"
"Obstanovka: Exploring Nearby Space","J. Nagy; K. Balajthy; S. Szalai; B. Sódor; I. Horváth; C. Lipusz",Wigner Research Centre for Physics; Wigner Research Centre for Physics; SGF Ltd.; Wigner Research Centre for Physics; Wigner Research Centre for Physics; Ericsson,"IEEE Software","23 Jun 2016","2016","33","4","101","105","The exploration and examination of near-Earth space helps us better understand our solar system and deeply affects our everyday life in areas such as telecommunications, Earth observation, and weather forecasting. Toward that end, scientists developed the onboard data acquisition and control system of the Obstanovka (Russian for environment) experiment in the Russian segment of the International Space Station. Obstanovka, developed by nine teams from different countries, employs 11 sensors to study how the Sun, magnetosphere, and ionosphere influence Earth's weather.","1937-4194","","10.1109/MS.2016.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498543","Obstanovka;space exploration;magnetosphere;ionosphere;International Space Station;software development;software engineering","Space research;Sensors;Space stations;Software engineering;Real-time systems;Linux;Telemetry","aerospace engineering;control engineering computing;control systems;data acquisition;solar system;weather forecasting","Obstanovka;near-Earth space;solar system;Earth observation;weather forecasting;onboard data acquisition;control system;International Space Station","","1","","1","","23 Jun 2016","","","IEEE","IEEE Magazines"
"Requirements in a Global World","J. Cleland-Huang; P. Laurent",DePaul University; Blue Cross Blue Shield,"IEEE Software","7 Nov 2014","2014","31","6","34","37","The challenges of eliciting requirements in global projects can be addressed through deliberate up-front planning processes that take into consideration, people, technology, meeting locations, communication, workflow processes, and documentation needs. The authors present a practical approach to support this planning process. The Web extra at http://youtu.be/eLk66zSFS6c is an audio podcast in which author Jane Cleland-Huang provides an audio recording of the Requirements column, coauthored with Paula Laurent, in which she discusses how the challenges of eliciting requirements in global projects can be addressed through deliberate upfront planning processes that take into consideration people, technology, meeting locations, communication, workflow processes, and documentation needs.","1937-4194","","10.1109/MS.2014.144","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949515","global projects;requirements elicitation;collaboration;project planning;software engineering","Globalization;Software engineering;Planning;Software development;Collaboration","planning;software development management","requirements elicitation;planning process","","","","4","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Automating the Web with CoScripter: An Interview with Tessa Lau","A. J. Ko",University of Washington,"IEEE Software","25 Aug 2009","2009","26","5","52","53","The future of computer use is undeniably on the Web. People bank, store documents, do research, and even make and maintain friendships online. With this explosion of Web-based content and applications has come a proliferation of tools to streamline and automate people's interactions on the Web, leading many users to write Web scripts to simplify their work. With CoScripter, users can automate Web activities through scripting and share scripts with others.","1937-4194","","10.1109/MS.2009.122","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222794","Web;automation;scripting;software engineering","Interviews;Debugging;Computer bugs;Collaboration;Advertising;Web pages;Software engineering;Tagging;Web page design;Automatic control","social networking (online)","Web activity automation;computer use;Tessa Lau;Web script sharing;social sharing;social networking;online friendship;people bank;document storage","","","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Scaling Agile","C. Ebert; M. Paasivaara",Vector Consulting Services; IT University of Copenhagen,"IEEE Software","13 Nov 2017","2017","34","6","98","103","Agile software development has become mainstream. Industry-scale agility for distributed teams, large projects, or critical systems requires scaling agile practices, which agile scaling frameworks attempt to provide. Here, Maria Paasivaara and I explore frameworks such as the Scaled Agile Framework (SAFe) and show best practices from two industry case studies. I look forward to hearing from both readers and prospective column authors about this column and the technologies you want to know more about.","1937-4194","","10.1109/MS.2017.4121226","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106870","agile development;Scaled Agile Framework;SAFe;Large-Scale Scrum;LeSS;Disciplined Agile Delivery;DAD;Scrum of Scrums;SoS;Lean Scalable Agility for Engineering;LeanSAFE;software engineering;software development;Software Technology","Agile development;Software engineering;Scrum (Software development);Modeling","software prototyping","agile software development;industry-scale agility;agile scaling frameworks;scaled agile framework;SAFe","","9","","6","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Software Developers, Moods, Emotions, and Performance","D. Graziotin; X. Wang; P. Abrahamsson",Free University of Bozen-Bolzano; Free University of Bozen-Bolzano; Free University of Bozen-Bolzano,"IEEE Software","13 Jun 2014","2014","31","4","24","27","Studies show that software developers' happiness pays off when it comes to productivity.","1937-4194","","10.1109/MS.2014.94","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834716","software engineering;performance;development;human factors","Software development;Mood;Software engineering;Productivity","","","","30","","14","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Agile Compass: A Tool for Identifying Maturity in Agile Software-Development Teams","R. M. Fontana; S. Reinehr; A. Malucelli",Pontifical Catholic University of Paraná; Pontifical Catholic University of Paraná; Pontifical Catholic University of Paraná,"IEEE Software","28 Oct 2015","2015","32","6","20","23","Researchers investigated how agile software development teams evolve. They analyzed nine teams' evolution of practices and found that the process was idiosyncratic. Each team adopted practices on the basis of its circumstances and improved the practices on the basis of the challenges it faced. Using this research, the researchers designed the Agile Compass, a questionnaire based on a set of guidelines for agile-development improvement, supported by real teams' values and principles. The article has three Web extras. The first shows the Agile Compass questionnaire (https://s3.amazonaws.com/ieeecs.cdn.csdl.public/mags/so/2015/06/extras/mso201506_AnAgile_s1.pdf), which can help development teams identify which outcomes they have accomplished. The second describes the Agile Compass research approach (https://s3.amazonaws.com/ieeecs.cdn.csdl.public/mags/so/2015/06/extras/mso201506_AnAgile_s2.png). The third is the Map of Evidence (https://s3.amazonaws.com/ieeecs.cdn.csdl.public/mags/so/2015/06/extras/mso201506_AnAgile_s3.png), showing the information supporting each type of project outcome that the authors gathered during interviews with development teams.","1937-4194","","10.1109/MS.2015.135","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7311000","Agile Compass;agile software development;software process maturity;software development;software engineering","Agile software;Software development;Programming;Encoding;Software engineering;Context modeling","software development management;software prototyping","maturity identification;agile software-development teams;agile-development improvement;team values;team principles;Agile Compass research approach;map-of-evidence approach","","10","","4","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Conflict-Centric Software Architectural Views: Exposing Trade-Offs in Quality Requirements","J. Savolainen; T. Mannisto","Nokia Research Center, Finland; Aalto University","IEEE Software","14 Oct 2010","2010","27","6","33","37","Architectural documentation improves the overall understanding of a proposed software system's design, but its true value comes from facilitating the process of satisfying architecturally significant requirements (ASRs). Architectural views are a tool for documenting ASRs in the context of particular quality attributes. Views offer a convenient way to capture architectural decisions, rationales, and alternatives considered. However, when multiple stakeholders have conflicting quality requirements, traditional architectural views tend to scatter their resolutions throughout the documentation.","1937-4194","","10.1109/MS.2010.139","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5604360","software architecture;software engineering","Software architecture;Software engineering ;Quality;Investments","formal specification;formal verification;software architecture;software quality;system documentation","software architecture;software system;architecturally significant requirement;software quality;architectural decision;documentation","","5","","9","","14 Oct 2010","","","IEEE","IEEE Magazines"
"Creating the Virtual Universe","S. P. Zwart; J. Bedorf",Leiden Observatory; Leiden Observatory,"IEEE Software","24 Aug 2016","2016","33","5","25","29","Simulation software is important to our understanding of the universe. The intrinsic multiphysics aspects are spiced with a range of temporal scales and spatial scales, both of which cover more digits than are available in the standard hardware. This, together with the intrinsic chaotic nature of many physical processes, poses quite a challenge. To meet this challenge, researchers developed the Astronomical Multipurpose Environment (AMUSE). Instead of writing a suite of multiphysics solvers from scratch, AMUSE's developers coupled existing solvers for each physical ingredient. The result is a highly inhomogeneous collection of dedicated solvers with a homogeneous protocol that scales to supercomputers.","1937-4194","","10.1109/MS.2016.113","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548908","simulation software;Astronomical Multipurpose Environment;AMUSE;astrophysics;astrophysics simulations;software development;software engineering","Graphics processing units;Computational modeling;Software development;Astrophysics;Software engineering;Astronomy","astronomy computing;digital simulation","virtual universe;simulation software;astronomical multipurpose environment;AMUSE;multiphysics solver","","3","","9","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Anarchy and Order [On Computing]","G. Booch",IBM,"IEEE Software","23 Apr 2015","2015","32","3","20","22","Computing amplifies governments' actions but can also temper their behavior by enabling mechanisms for private communication and for open, transparent communication by a nation's people. Similarly, governments can help focus the artifacts of computing on their citizens' health and happiness, and temper it as well. The Web extra at http://youtu.be/GuFNqmvbkrE is an audio podcast of Grady Booch's On Computing column, in which he discusses how computing amplifies the actions of governments, but can also temper its behavior by enabling mechanisms for private communication as well as for open and transparent communication by the people of a nation. Similarly, governments can help focus the artifacts of computing to the health and happiness of its citizens, but temper it as well.","1937-4194","","10.1109/MS.2015.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093028","software engineering;computing;government;privacy;security","Software engineering;Network security;Government policies;Privacy;Digital audio broadcasting","government data processing;Web sites","government actions;private communication;open transparent communication;citizen happiness;citizen health;Web extra;audio podcast;government behavior","","","","","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Toward Learning Teams","R. Hoda; J. Babb; J. Nørbjerg",University of Auckland; West Texas A&M University; Copenhagen Business School,"IEEE Software","26 Jun 2013","2013","30","4","95","98","Today's software development challenges require learning teams that can continuously apply new engineering and management practices, new and complex technical skills, cross-functional skills, and experiential lessons learned. The pressure of delivering working software often forces software teams to sacrifice learning-focused practices. Effective learning under pressure involves conscious efforts to implement original agile practices such as retrospectives and adapted strategies such as learning spikes. Teams, their management, and customers must all recognize the importance of creating learning teams as the key to braving the erratic climates and uncharted territories of future software development.","1937-4194","","10.1109/MS.2013.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547633","programming teams;software engineering process;agile processes;learning teams","Software development;Information systems;Software engineering;Training","learning (artificial intelligence);software prototyping;team working","learning teams;software development;engineering practice;management practice;complex technical skills;cross-functional skills;experiential lessons;software teams;learning-focused practice;agile practice;adapted strategy","","3","","9","","26 Jun 2013","","","IEEE","IEEE Magazines"
"What Do We Know about Test-Driven Development?","F. Shull; G. Melnik; B. Turhan; L. Layman; M. Diep; H. Erdogmus",University of Maryland; Microsoft; University of Oulu; University of Maryland; University of Nebraska-Lincoln; Kalemun Research,"IEEE Software","14 Oct 2010","2010","27","6","16","19","What if someone argued that one of your basic conceptions about how to develop software was misguided? What would it take to change your mind? That's essentially the dilemma faced by advocates of test-driven development (TDD). The TDD paradigm argues that the basic cycle of developing code and then testing it to make sure it does what it's supposed to do-something drilled into most of us from the time we began learning software development- isn't the most effective approach. TDD replaces the traditional ""code then test"" cycle. First, you develop test cases for a small increment of functionality; then you write code that makes those tests run correctly. After each increment, you refactor the code to maintain code quality.","1937-4194","","10.1109/MS.2010.152","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5604358","software engineering","Software engineering;Testing","program testing;software maintenance;software quality","test driven development;code development;software development;code refactoring;code quality","","38","","3","","14 Oct 2010","","","IEEE","IEEE Magazines"
"Critical Decisions in Software Development: Updating the State of the Practice","M. A. Cusumano; A. MacCormack; C. F. Kemerer; W. Crandall",Massachusetts Institute of Technology; Massachusetts Institute of Technology; University of Pittsburgh; Hewlett-Packard,"IEEE Software","25 Aug 2009","2009","26","5","84","87","This article focuses on how to choose the ""right"" software development process, how to structure global software design chains, how to manage the interaction of project structure and software design, and how to balance innovation and efficiency in a software business.","1937-4194","","10.1109/MS.2009.124","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222801","software development process;project management;software design;software business;software engineering","Uncertainty;Europe;Software prototyping;Software development management;Productivity;Radio access networks;Testing;Programming profession;Software engineering;Process design","software development management","critical decision;software development;global software design;software business","","15","","9","","25 Aug 2009","","","IEEE","IEEE Magazines"
"ADAPT: A Framework for Agile Distributed Software Development","R. Vallon; S. Strobl; M. Bernhart; R. Prikladnicki; T. Grechenig",TU Wien; TU Wien; TU Wien; Pontifical Catholic University of Rio Grande do Sul; TU Wien,"IEEE Software","28 Oct 2016","2016","33","6","106","111","A growing number of developers are using agile practices in distributed software projects. Researchers have created the ADAPT (Agile Distributed Adaptable Process Toolkit) framework to guide the implementation of agile practices in distributed environments. The Web Extras detail the research methods the authors employed.","1937-4194","","10.1109/MS.2016.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725219","agile software development;distributed software development;ADAPT;Agile Distributed Adaptable Process Toolkit;software engineering;software development","Guidelines;Software development;Industries;Agile manufacturing;Outsourcing;Software engineering","software prototyping","ADAPT framework;agile distributed adaptable process toolkit;agile distributed software development;distributed environment;distributed software projects;agile practices","","1","","5","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Software Crowdsourcing Platforms","A. L. Zanatta; L. S. Machado; G. B. Pereira; R. Prikladnicki; E. Carmel","Pontifical Catholic University of Rio Grande do Sul; Pontifical Catholic University of Rio Grande do Sul; PROCERGS; Pontifical Catholic University of Rio Grande do Sul; American University, Washington, DC","IEEE Software","28 Oct 2016","2016","33","6","112","116","Software crowdsourcing is mediated by platforms that connect requesters (buyers) with online workers--the crowd. Thus, these platforms have emerged as an important stakeholder in software development. This article introduces them and groups them by development phase.","1937-4194","","10.1109/MS.2016.151","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725223","crowdsourcing;software development;software engineering;outsourcing;software development phases;Crowdtest","Software;Crowdsourcing;Testing;Computer bugs;Recruitment;Software engineering","","","","7","","5","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Listen, Then Use EARS","A. Mavin",Rolls-Royce,"IEEE Software","20 Feb 2012","2012","29","2","17","18","Applying the Easy Approach to Requirements Syntax (EARS) template can result in a simple, clear requirement. However, to be able to write a simple statement, you must first understand what you want the system to do, which might be difficult. The simplicity of the EARS templates prevents engineers from hiding behind ambiguous statements of what the system must do.","1937-4194","","10.1109/MS.2012.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155138","easy approach to requirements syntax;ears;template;requirements;software engineering;developers;development;notation;natural language","Software engineering;Software development;Natural language processing","computational linguistics;formal specification","EARS template;Easy Approach to Requirements Syntax;event-driven requirement","","13","","2","","20 Feb 2012","","","IEEE","IEEE Magazines"
"Architectural Refactoring: A Task-Centric View on Software Evolution","O. Zimmermann","Institute for Software at the University of Applied Sciences of Eastern Switzerland, Rapperswil","IEEE Software","10 Mar 2015","2015","32","2","26","29","A refactoring aims to improve a certain quality while preserving others. For example, code refactoring restructures code to make it more maintainable without changing its observable behavior. Given the success of code refactoring, it's surprising that architectural refactoring (AR) hasn't taken off yet. This article examines AR from a new angle: as an evolution technique that revisits architectural decisions and identifies related design, implementation, and documentation tasks.","1937-4194","","10.1109/MS.2015.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057560","refactoring;software evolution;software development;software engineering","Software development;Computer architecture;Context modeling;Software engineering;Catalogs;Pragmatics;Software architecture","program compilers;software architecture;software maintenance","architectural refactoring;task centric view;software evolution;code refactoring restructures code;observable behavior;code refactoring;AR;evolution technique","","15","","5","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Aligning Architecture Work with Agile Teams","E. Woods",Endava,"IEEE Software","21 Aug 2015","2015","32","5","24","26","Difficulties frequently arise when agile development teams and software architects work together. By adopting practices aligned with the ""agile manifesto,"" software architects can work constructively with agile teams and significantly contribute to a project's success.","1937-4194","","10.1109/MS.2015.119","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217769","software architecture;software engineering;software development;software design;agile teams","Tutorials;Computer architecture;Pragmatics;Agile software development;Software architecture;Documentation;Software engineering;Agile development;Software development","software architecture;software prototyping","agile development teams;software architects","","10","","5","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Start-Ups Must Be Ready to Pivot","S. S. Bajwa; X. Wang; A. N. Duc; R. M. Chanin; R. Prikladnicki; L. B. Pompermaier; P. Abrahamsson",Free University of Bozen-Bolzano; Free University of Bozen-Bolzano; Norwegian University of Science and Technology; Pontifical Catholic University of Rio Grande do Sul; Pontifical Catholic University of Rio Grande do Sul; Pontifical Catholic University of Rio Grande do Sul; Norwegian University of Science and Technology,"IEEE Software","15 May 2017","2017","34","3","18","22","As prominent examples such as Twitter have demonstrated, software start-ups frequently find that their initial product ideas don't pan out commercially. So, they must be prepared to change direction in one or more ways, a process called pivoting.","1937-4194","","10.1109/MS.2017.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927923","start-up;software;pivot;pivot triggers;pivot types;Tecnopuc;software engineering;software development","Software engineering;Social network services;Twitter;Market opportunities","DP industry;innovation management;software houses","Twitter;software start-ups;initial product ideas;pivoting","","9","","7","","15 May 2017","","","IEEE","IEEE Magazines"
"Replicating Rare Software Failures with Exploratory Visual GUI Testing","E. Alégroth; J. Gustafsson; H. Ivarsson; R. Feldt",Chalmers University of Technology; Saab AB; Saab AB; Blekinge Institute of Technology,"IEEE Software","22 Sep 2017","2017","34","5","53","59","Saab AB developed software that had a defect that manifested itself only after months of continuous system use. After years of customer failure reports, the defect still persisted, until Saab developed failure replication based on visual GUI testing.","1937-4194","","10.1109/MS.2017.3571568","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048660","visual GUI testing;failure replication;industrial success story;semiautomated testing;industry–academia collaboration;software engineering;software development;software testing;Saab AB","Graphical user interfaces;Failure analysis;Companies;Software engineering;Visualization;Memory management","graphical user interfaces;program testing;software fault tolerance","software failure replication;visual GUI testing;Saab AB developed software","","","","14","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Beyond Data Mining","T. Menzies",West Virginia University,"IEEE Software","18 Apr 2013","2013","30","3","92","92","Last century, it wasn't known if data miners could find structure within software projects. This century, we know better: data mining has been successfully applied to many different artifacts from software projects. So it's time to move on to ""What's next?"" In the author's view, ""discussion mining"" is the next great challenge for the predictive modeling community. These discussion miners know that while predictions and decisions are important, so too are the questions and insights generated on the way to those conclusions.","1937-4194","","10.1109/MS.2013.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6504887","data mining;software engineering;predictive modeling","Data mining;Software engineering;Predictive modeling","","","","2","","5","","18 Apr 2013","","","IEEE","IEEE Magazines"
"Naming the Pain in Requirements Engineering: Comparing Practices in Brazil and Germany","D. M. Fernández; S. Wagner; M. Kalinowski; A. Schekelmann; A. Tuzcu; T. Conte; R. Spinola; R. Prikladnicki",Technische Universität München; University of Stuttgart; Fluminense Federal University; Niederrhein University of Applied Sciences; zeb.rolfes.schierenbeck.associates; Federal University of Amazonas; Federal University of Bahia; Pontifical Catholic University of Rio Grande of the South,"IEEE Software","21 Aug 2015","2015","32","5","16","23","As part of the Naming the Pain in Requirements Engineering (NaPiRE) initiative, researchers compared problems that companies in Brazil and Germany encountered during requirements engineering (RE). The key takeaway was that in RE, human interaction is necessary for eliciting and specifying high-quality requirements, regardless of country, project type, or company size.","1937-4194","","10.1109/MS.2015.122","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217775","requirements engineering;NaPiRE;software development;software engineering;cause and effect analysis","Requirements engineering;Software engineering;Product development;Collaboration","formal verification","Brazil;Germany;naming the pain in requirements engineering;NaPiRE;human interaction","","20","","7","","21 Aug 2015","","","IEEE","IEEE Magazines"
"First, Do No Harm","D. Spinellis",Athens University of Economics and Business,"IEEE Software","15 Sep 2014","2014","31","5","12","14","When we maintain existing code, we must be very careful to avoid breaking or degrading the system we're working on. During development, we can minimize problems through reviews, adherence to style rules, defensive programming, maintenance of backward compatibility, and the preservation of architectural properties. Thorough testing at all levels can catch many issues before they reach the deployment stage. Finally, during deployment, a phased rollout, a back-off plan, and careful planning can minimize the occurrence of catastrophic failures. The Web extra at http://youtu.be/pifgzfFXanE is an audio podcast of the Tools of the Trade column in which author Diomidis Spinellis discusses how we must be very careful to avoid breaking or degrading the system while working to maintain existing code.","1937-4194","","10.1109/MS.2014.112","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898723","maintenance;defensive programming;testing;deployment;operations;reviews;software engineering","Software engineering;Software testing;Codes;Computer applicaitons;Programming","software architecture;software maintenance","code maintenance;code development;defensive programming;backward compatibility;code architectural properties","","","","","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Assertive Testing [Reliable Code]","G. J. Holzmann",NASA/JPL,"IEEE Software","23 Apr 2015","2015","32","3","12","15","Standard software testing might not catch important defects, and formal methods can be difficult to use. But, there's a middle ground between the two. This middle ground involves adding five steps to standard testing and employing test randomization, model-based testing, and a more aggressive use of assertions (also called self-tests).","1937-4194","","10.1109/MS.2015.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093042","software testing;model-based testing;software defects;software reliability;software failures;assertion density;software engineering;software development","Failure analysis;Software reliability;Software testing;Software engineering;Software measurement;Software development","program testing","assertive testing;standard software testing;formal methods;test randomization;model-based testing","","1","","5","","23 Apr 2015","","","IEEE","IEEE Magazines"
"What Do We Know about Software Development in Startups?","C. Giardino; M. Unterkalmsteiner; N. Paternoster; T. Gorschek; P. Abrahamsson",NA; NA; NA; NA; NA,"IEEE Software","15 Sep 2014","2014","31","5","28","32","An impressive number of new startups are launched every day as a result of growing new markets, accessible technologies, and venture capital. New ventures such as Facebook, Supercell, Linkedin, Spotify, WhatsApp, and Dropbox, to name a few, are good examples of startups that evolved into successful businesses. However, despite many successful stories, the great majority of them fail prematurely. Operating in a chaotic and rapidly evolving domain conveys new uncharted challenges for startuppers. In this study, the authors characterize their context and identify common software development startup practices.","1937-4194","","10.1109/MS.2014.129","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898758","startups;software development;systematic mapping study;software engineering","Software development;Companies;Software engineering;Market research;Commercialization","software development management","Facebook;Supercell;Linkedin;Spotify;WhatsApp;Dropbox;software development startup practices","","47","","15","","15 Sep 2014","","","IEEE","IEEE Magazines"
"To Pay or Not to Pay Technical Debt","F. Buschmann",NA,"IEEE Software","20 Oct 2011","2011","28","6","29","31","Ward Cunningham coined the term technical debt as a metaphor for the trade-off between writing clean code at higher cost and delayed de livery, and writing messy code cheap and fast at the cost of higher maintenance efforts once it's shipped. Joshua Kerievsky extended the metaphor to architecture and design. Technical debt is similar to financial debt: it supports quick development at the cost of compound interest to be paid later. The longer we wait to garden our design and code, the larger the amount of interest. Discussions of the metaphor have distinguished different types of technical debt and how and when to best pay them off. Most agree that, sooner or later, technical debt will come due. But is this assumption universally true? If it's better to pay interest, what factors influence the decision to service the debt? And if we decide to retire it, what approach should we take?","1937-4194","","10.1109/MS.2011.150","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6055661","technical debt;software;software engineering;architecture","Software engineering;Software architecture;System analysis and design;Encoding;Business","program compilers;software development management;software maintenance","technical debt;clean code;messy code;maintenance efforts","","18","","9","","20 Oct 2011","","","IEEE","IEEE Magazines"
"Fifteen Years of Service-Oriented Architecture at Credit Suisse","S. Murer; C. Hagen",NA; NA,"IEEE Software","7 Nov 2014","2014","31","6","9","15","Credit Suisse has been an adopter of service oriented architecture (SOA) principles and patterns since the beginnings of this architectural style, even before the term appeared. The authors reflect on the financial institution's journey from using tightly integrated mainframe programs to open SOA services, emphasizing the importance of interface contracts and service governance in corporate IT.","1937-4194","","10.1109/MS.2013.137","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6654116","service-oriented architecture;SOA;Credit Suisse;software engineering;interface contracts;service governance;corporate IT","Computer architecture;Service-oriented architecture;Banks;Documentation;Quality assurance;Software engineering;Business;Information technology","service-oriented architecture","service-oriented architecture;Credit Suisse;SOA principles;SOA patterns;SOA services;service governance;interface contracts;corporate IT;information technology","","7","","6","","4 Nov 2013","","","IEEE","IEEE Magazines"
"What Type of People Are Software Architects?","M. Erder; P. Pureur",NA; NA,"IEEE Software","11 Jul 2017","2017","34","4","20","22","Psychometrics measures mental traits, abilities, and processes. This article presents popular industry approaches to psychometric testing and how to apply them to the role of the software architect.","1937-4194","","10.1109/MS.2017.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974721","psychometrics;personality testing;software architect;Myers-Briggs Type Indicator;MBTI;Herrmann Brain Dominance Instrument;HBDI;Belbin Team Roles;software architecture;software engineering;software development","Computer architecture;Software engineering;Sociology;Statistics;Pragmatics;Psychology;Monitoring","psychometric testing;software architecture","software architect;psychometric testing","","1","","7","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Injecting Value-Thinking into Prioritization Decisions","J. Cleland-Huang",DePaul University,"IEEE Software","10 Mar 2015","2015","32","2","14","18","A proposed approach injects value-thinking into feature prioritization, using story mapping. The Web extra at http://youtu.be/Xm5VqODvVZE is an audio podcast in which author Jane Cleland-Huang provides an audio recording of the Requirements column, in which she discusses an approach that injects value-thinking into feature prioritization by using story mapping.","1937-4194","","10.1109/MS.2015.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057568","value-thinking;feature prioritization;story mapping;release planning;minimum marketable features;minimum viable product;incremental funding;return on investment;ROI;software engineering","Software engineering;Planning;Investments;Marketing and sales;Funding;Schedules","decision making;formal specification;formal verification","value-thinking injection;prioritization decision;feature prioritization;story mapping;requirements column","","3","","3","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Industry Trends 2017","C. Ebert; K. Shankar",Vector Consulting Services; Microsoft,"IEEE Software","28 Mar 2017","2017","34","2","112","116","A survey of software industry professionals revealed trends involving efficiency and cost, security and safety, innovation, the digital transformation, connectivity, and governance and compliance. On the basis of the survey and personal experience in the industry, researchers have developed recommendations on how software development organizations can deal with these trends.","1937-4194","","10.1109/MS.2017.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888415","software industry;efficiency;cost;security;privacy;innovation;connectivity;governance;compliance;quality;software development;software engineering","Software development;Technological innovation;Performance evaluation;Market research;Computer security;Safety;Software engineering","","","","7","","2","","28 Mar 2017","","","IEEE","IEEE Magazines"
"The Inhibited Analyst","N. Maiden",NA,"IEEE Software","20 Oct 2011","2011","28","6","100","102","Requirements analysts need to ask the right questions repeatedly. They need to be more inquisitive and know why people want things as well as what happens beforehand. This requires them to become less inhibited and keep asking questions until they and their stakeholders are satisfied with the answers.","1937-4194","","10.1109/MS.2011.149","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6055667","software;software engineering;requirements;engineer;analysis;analyst;stakeholders;social modeling;modelling;questions","Information analysis;Knowledge acquisition;Software engineering;Modeling;Social factors;Query processing","","","","1","","2","","20 Oct 2011","","","IEEE","IEEE Magazines"
"Managing Technical Debt: Insights from Recent Empirical Evidence","N. Ramasubbu; C. F. Kemerer; C. J. Woodard",University of Pittsburgh; University of Pittsburgh; Singapore Management University,"IEEE Software","10 Mar 2015","2015","32","2","22","25","Technical debt refers to maintenance obligations that software teams accumulate as a result of their actions. Empirical research has led researchers to suggest three dimensions along which software development teams should map their technical-debt metrics: customer satisfaction needs, reliability needs, and the probability of technology disruption.","1937-4194","","10.1109/MS.2015.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057576","technical debt;software development;software maintenance;disruptive technology;reliability;customer satisfaction;software engineering","Software development;Software reliability;Software engineering;Customer satisfaction;Software measurement","customer satisfaction;software development management;software metrics;software reliability","empirical evidence;maintenance obligations;software development teams;technical-debt metrics;customer satisfaction needs;reliability needs;technology disruption","","6","","5","","10 Mar 2015","","","IEEE","IEEE Magazines"
"The Risk of Overly Strict Requirements","R. Lutz; J. Cleland-Huang",Iowa State University; University of Notre Dame,"IEEE Software","28 Mar 2017","2017","34","2","26","29","Overly strict requirements can lead to more work, more dependencies, and more code, all of which place extra pressure on software development project schedules and budgets. Identifying such requirements and considering viable alternatives can reduce needless design complexity and project risk. The Web Extra https://youtu.be/SMdU78gPP1Q is an audio podcast of the Requirements article ""The Risk of Overly Strict Requirements"".","1937-4194","","10.1109/MS.2017.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888423","software requirements;fit criteria;GRAIL;software engineering;software development","Space vehicles;Software development;NASA;Complexity theory;Stakeholders;Safety;Software engineering","formal specification;formal verification;project management;software development management","overly strict requirements risk;software development project schedules;software development project budgets;design complexity;project risk","","1","","9","","28 Mar 2017","","","IEEE","IEEE Magazines"
"A Tail-Tolerant Cloud API Wrapper","Q. Lu; X. Xu; L. Bass; L. Zhu; W. Zhang","China University of Petroleum, Qingdao, China; NICTA; NICTA; NICTA; China University of Petroleum, Qingdao, China","IEEE Software","4 Feb 2015","2015","32","1","76","82","System operations (such as deployment, upgrade, and reconfiguration) for cloud applications are failure prone. These failures occur because these operations are performed through cloud APIs provided by cloud providers and because cloud APIs, in turn, are failure prone. Researchers have explored the characteristics of cloud APIs using Amazon EC2 (Elastic Compute Cloud) as a testbed and have devised mechanisms to improve cloud API performance. Specifically, mining the Amazon EC2 discussion forum revealed that 45 percent of complaints referred to cloud API timing failures. A series of experiments on cloud API timing behavior showed that cloud APIs have a long-tail distribution. A proposed cloud API wrapper implements mechanisms to avoid long tails. In experiments, this wrapper largely removed long tails, compared with the unwrapped APIs.","1937-4194","","10.1109/MS.2015.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030263","cloud computing;API;fault tolerance;long tail;dependability;software engineering","Fault tolerance;Cloud computing;Software engineering;Systems engineering and theory","application program interfaces;cloud computing;data mining","tail-tolerant cloud API wrapper;system operations;cloud applications;Amazon EC2;Elastic Compute Cloud;Amazon EC2 discussion forum mining;cloud API timing failures;cloud API timing behavior;long-tail distribution","","1","","9","","4 Feb 2015","","","IEEE","IEEE Magazines"
"Supporting the Management of Reusable Automotive Software","X. Larrucea; A. Walker; R. Colomo-Palacios",Tecnalia; Lorit Consultancy; Østfold University College,"IEEE Software","15 May 2017","2017","34","3","40","47","Improvements in the automotive industry are introducing challenges related to management, software development, and safety requirements. The safety requirements involve both products and processes, the latter requirements stemming from regulations and standards such as ISO 26262. The OpenCert toolkit helps engineers define safety cases, manage evidence, and comply with ISO 26262. The development of a Safety Element out of Context (SEooC) based on a Hall-effect sensor illustrates this tool's use. SEooCs are reusable and are particularly demanding regarding process requirements and the associated information. This article is part of a theme issue on Automotive Software.","1937-4194","","10.1109/MS.2017.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927906","ISO 26262;compliance;OpenCert;Hall-effect sensors;Hall sensors;Safety Element out of Context;SEooC;automotive software;safety-critical software;software engineering;software development","ISO Standards;Safety;Software engineering;Automotive engineering;Context modeling;Magnetic domains","automobile industry;automotive engineering;Hall effect transducers;ISO standards;software management;software reusability","reusable automotive software management;automotive industry;safety requirements;software development;ISO 26262 standard;OpenCert toolkit;safety element out-of-context;SEooC;Hall-effect sensor","","13","","14","","15 May 2017","","","IEEE","IEEE Magazines"
"Brace Yourself","G. J. Holzmann",Jet Propulsion Laboratory,"IEEE Software","24 Aug 2016","2016","33","5","34","37","The author states that to reduce the risk of hard-to-spot coding mistakes, you can do one simple thing: correctly use parentheses.","1937-4194","","10.1109/MS.2016.123","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548903","C code;C operators;software verification;precedence rules;operator precedence;programming;software development;software engineering","Software reliability;Software algorithms;Software engineering;Encoding;Software verification;Operator precendence","programming","programming;coding mistakes","","2","","4","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Dataflow Modeling with Crosscutting Concerns and a Concept Lattice","Y. Chernak",Valley Forge Consulting,"IEEE Software","7 Nov 2014","2014","31","6","70","78","Applying the concept of crosscutting concerns to dataflow modeling can help software practitioners better deal with the complexity of business applications and produce more complete and compact dataflow diagrams in the form of a concept lattice.","1937-4194","","10.1109/MS.2014.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6728935","aspect-oriented analysis;crosscutting concerns;data flow;requirements composition table;change impact analysis;ripple effect;formal concept analysis;concept lattice;software engineering","Data models;Software development;Software engineering;Formal concept analysis","data flow analysis","dataflow modeling;crosscutting concerns;concept lattice;business applications;dataflow diagrams","","","","13","","30 Jan 2014","","","IEEE","IEEE Magazines"
"Machine Learning","P. Louridas; C. Ebert",Athens University of Economics and Business; Vector Consulting Services,"IEEE Software","24 Aug 2016","2016","33","5","110","115","In machine learning, a computer first learns to perform a task by studying a training set of examples. The computer then performs the same task with data it hasn't encountered before. This article presents a brief overview of machine-learning technologies, with a concrete case study from code analysis.","1937-4194","","10.1109/MS.2016.114","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548905","machine learning;supervised learning;unsupervised learning;classification;regression;clustering;dimensionality reduction;R;Python;Hadoop;Spark;H2O;Julia;Matlab;SAS;TensorFlow;artificial neural networks;ANNs;deep learning;software development;software engineering;software technology","Machine learning;Software engineering;Classification;Complexity theory;Neural networks;Artificial neural networks;Clustering;Supervised learning","learning (artificial intelligence)","machine learning;code analysis","","73","1","4","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Evaluating Software Project Managers: A Multidimensional Perspective","L. Peters; A. M. Moreno",Universidad Politécnica de Madrid; Universidad Politécnica de Madrid,"IEEE Software","13 Nov 2017","2017","34","6","104","108","Qualified, motivated project managers are key contributors to software organizations. Experts have identified a capable project manager as the most important factor in a software project's success. Project managers' value to software projects, software engineers, and their companies is unquestionable. Thus, getting the most out of those managers is critical. The literature about knowledge workers' psychological profiles show that the best motivator is feedback about how well they've done. This is consistent with our experience in software project management and consulting. Frequent, detailed feedback can also be a positive learning experience and an opportunity to improve skills. Feedback and recognition require the evaluation of professionals, who must accept responsibility for their work if they're going to consider assessments as an opportunity instead of a burden. However, the criteria needed to evaluate professionals aren't obvious. Unfortunately, the literature provides little empirical data about evaluating software project managers. At best, the literature refers to assessing managers in terms of whether a project meets or exceeds its time and cost requirements. Our combined 50 years' experience in software project management (see the “Our Experience in Software Project Management” sidebar) has revealed some best practices for evaluating software project managers.","1937-4194","","10.1109/MS.2017.4121223","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106867","software project managers;evaluations;multidimensional;senior managers;software engineers;clients;balanced scorecard;software engineering;software development;Voice of Evidence","Software engineering;Project management;Stakeholders;Appraisal","DP industry;human factors;project management;software development management","software project manager evaluation;software organizations;software engineers;software project management;software project consulting;best practices;knowledge workers psychological profiles","","2","","12","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Adaptable Blockchain-Based Systems: A Case Study for Product Traceability","Q. Lu; X. Xu",China University of Petroleum; Commonwealth Scientific and Industrial Research Organisation (CSIRO),"IEEE Software","13 Nov 2017","2017","34","6","21","27","Tracing the origin of products across complex supply chains requires a transparent, tamper-proof metadata infrastructure that's not only trusted by all the involved parties but also adaptable to changing environments and regulations. Can such advanced infrastructure be implemented in a decentralized way? Qinghua Lu and Xiwei Xu share their story of developing the originChain system, which leverages emerging blockchain technology to do so.","1937-4194","","10.1109/MS.2017.4121227","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106871","blockchain;traceability;supply chain;originChain;software development;software engineering;Insights","Tracking;Production facilities;Supply chains;Databases;Software engineering;Memory management","meta data;supply chains","complex supply chains;advanced infrastructure;blockchain technology;originChain system;transparent infrastructure;tamper-proof metadata infrastructure;product traceability;adaptable blockchain-based systems","","58","","9","","13 Nov 2017","","","IEEE","IEEE Magazines"
"What's the Evidence for Lean?","T. Dybå; H. Sharp",SINTEF; Open University,"IEEE Software","21 Aug 2012","2012","29","5","19","21","A close look at the evidence underpinning the original concept of lean production and its popular interpretation reveals the inherent challenges of measuring and interpreting evidence for performance differences.","1937-4194","","10.1109/MS.2012.126","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6276295","software engineering methodologies","Software engineering;Performance evaluation","lean production;production engineering computing;software performance evaluation","lean production;performance differences;evidence interpretation","","3","","5","","21 Aug 2012","","","IEEE","IEEE Magazines"
"Unintentional and Unbalanced Transparency","G. Booch",IBM,"IEEE Software","18 Aug 2011","2011","28","5","12","13","Security and privacy are interdependent concepts. Each impacts the other, but to say that they are alternatives is a false dichotomy. Both are issues of human concern; their policies and their risks may be made manifest in software-intensive systems. Architecting a system that attends to the needs of security and privacy is possible and desirable, yet there are often unintended and unexpected consequences in so doing.","1937-4194","","10.1109/MS.2011.112","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984789","architecture;software-intensive system;security;privacy;software engineering;standards and best practices","Privacy;Computer security;Computer architecture;Best practices;Surveillance;Software engineering","data privacy;security of data;software architecture","software-intensive systems;data security;data privacy","","1","","","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Software Project Management: Learning from Our Mistakes [Voice of Evidence]","P. Silva; A. M. Moreno; L. Peters",Universidad Politécnica de Madrid; Universidad Politécnica de Madrid; Universidad Politécnica de Madrid,"IEEE Software","23 Apr 2015","2015","32","3","40","43","Software project management antipatterns can help practitioners identify and avoid practices that will hinder success. This article provides a consolidated list of such antipatterns and discusses their implications.","1937-4194","","10.1109/MS.2015.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093031","software project management;antipatterns;software development;software engineering","Software development;Project management;pattern recognition;Process control;Software engineering","project management;software management","software project management antipatterns;consolidated list","","7","","12","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Reference Architectures for the Internet of Things","M. Weyrich; C. Ebert",University of Stuttgart; Vector Consulting Services,"IEEE Software","29 Dec 2015","2016","33","1","112","116","The Internet of Things (IoT) is about innovative functionality and better productivity by seamlessly connecting devices. But a major threat is the lack of architecture standards for the industrial Internet and connectivity in the IoT. This article reviews recent IoT architecture evolution and what it means for industry projects.","1937-4194","","10.1109/MS.2016.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367994","Internet of Things;IoT;Internet of Things--Architecture;IoT-A;Industrial Internet Reference Architecture;IIRA;reference architecture;software engineering;software development","Computer architecture;Software engineering;Industries;Internet of things;Standards;Protocols","Internet;Internet of Things","reference architectures;Internet of Things;architecture standards;industrial Internet;IoT connectivity;IoT architecture evolution","","179","","4","","29 Dec 2015","","","IEEE","IEEE Magazines"
"To Code Is Human","G. J. Holzmann",NASA/JPL,"IEEE Software","4 Feb 2015","2015","32","1","14","17","Programmers have found creative ways around programming rules. However, such tactics have a cost.","1937-4194","","10.1109/MS.2015.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030198","computer programming;programming errors;compilers;software engineering","Encoding;Software reliability;Computer programs;Software engineering;Reliability engineering;program processors","programming","programmer;programming rules","","","","4","","4 Feb 2015","","","IEEE","IEEE Magazines"
"What's the Architect's Role in an Agile, Cloud-Centric World?","M. Erder; P. Pureur",NA; NA,"IEEE Software","24 Aug 2016","2016","33","5","30","33","The software architecture pendulum is swinging away from traditional practices and toward agile and continuous practices. To be successful in this new world, architects should emphasize products over projects, drive architectural decisions, understand code, and communicate and collaborate effectively with delivery teams.","1937-4194","","10.1109/MS.2016.119","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548909","software architect;agile;cloud;software engineering;software development","Computer architecture;Software engineering;Microarchitecture;Pragmatics;Stakeholders","software architecture;software prototyping","agile cloud-centric world;software architecture;agile architecture;architectural decisions;continuous architecture","","7","","4","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Techniques and Tools for Parallelizing Software","H. Vandierendonck; T. Mens","Research Foundation Flanders; University of Mons, Belgium","IEEE Software","20 Feb 2012","2012","29","2","22","25","With the emergence of multicore and manycore processors, engineers must design and develop software in drastically new ways to benefit from the computational power of all cores. However, developing parallel software is much harder than sequential software because parallelism can't be abstracted away easily. Authors Hans Vandierendonck and Tom Mens provide an overview of technologies and tools to support developers in this complex and error-prone task.","1937-4194","","10.1109/MS.2012.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155141","multicore;manycore;parallelization;parallelism;debugging;programming;software engineering;software;hardware","Multicore processing;Software engineering;Software development","multiprocessing systems;parallel programming;software tools","parallelizing software;multicore processors;manycore processors;core computational power;sequential software;support tools","","4","","8","","20 Feb 2012","","","IEEE","IEEE Magazines"
"Managing Software's Impact","M. van Genuchten; L. Hatton",VitalHealth Software; Oakwood Computing Associates,"IEEE Software","30 Jun 2015","2015","32","4","15","17","As a review of past articles in IEEE Software's Impact department shows, software economics largely determines a software product's success, and volume plays a key role.","1937-4194","","10.1109/MS.2015.99","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140700","software development;software engineering;software economics;software size;software mileage","Software maintenance;Economics;Software development;Software quality;Software engineering","","","","","","15","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Fault Intolerance [Reliable Code]","G. J. Holzmann",NASA/JPL,"IEEE Software","7 Nov 2014","2014","31","6","16","20","The author considers what it takes to develop truly reliable software systems, and what the role is of program verification in all this. One problem he focuses on is the difficulty of writing good specifications, particularly in making sure that those specifications are complete. Reality can be surprisingly good in showing that our painfully constructed software design requirements are incomplete or even incorrect.","1937-4194","","10.1109/MS.2014.136","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949563","software verification;reliable software systems;software specification;requirements;software engineering","Software engineering;Documentation;Software reliability;Fault tolerance;Encoding;Programming;Software reliability","formal specification;program verification;software fault tolerance;software reliability","fault intolerance;reliable software systems;program verification;software design requirements;specifications","","3","","3","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Peter Hilton on Naming","F. Hermans",Delft University of Technology,"IEEE Software","15 May 2017","2017","34","3","117","120","Host Felienne Hermans talks with Peter Hilton about why naming is much harder than we think, why it matters in programming and program comprehension, and how to improve your naming skills.","1937-4194","","10.1109/MS.2017.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927922","Peter Hilton;software engineering;naming;software naming;SE Radio;software development;coding","Software engineering;Programming;Computer bugs;Software testing","","","","","","","","15 May 2017","","","IEEE","IEEE Magazines"
"Service Orientation and Systems of Systems","G. Lewis; E. Morris; S. Simanta; D. Smith",Software Engineering Institute; Software Engineering Institute; Software Engineering Institute; Software Engineering Institute,"IEEE Software","20 Dec 2010","2011","28","1","58","63","Interconnected systems of systems provide capabilities that aren't available in any single system. Fundamental service-oriented principles can help in engineering them, regardless of the implementation technologies used.","1937-4194","","10.1109/MS.2011.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5672519","SOA;service-oriented architecture;service orientation;systems of systems;SoS;SoS engineering","Service oriented architecture;Interconnected systems;Couplings;Runtime;Systems engineering and theory;Standards","interconnected systems;service-oriented architecture","service orientation;interconnected systems of systems;service-oriented principles;service- oriented architecture;SOA","","20","","11","","20 Dec 2010","","","IEEE","IEEE Magazines"
"Design Patterns: Magic or Myth?","D. Budgen",Durham University,"IEEE Software","25 Feb 2013","2013","30","2","87","90","A mapping study of design pattern literature combined with two follow-on surveys shows only limited empirical evidence that the ""Gang of Four"" patterns provide a useful way of transferring design knowledge or that their use will lead to better designs.","1937-4194","","10.1109/MS.2013.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6470594","software design;software design patterns;research","Software design;Production facilities;Maintenance engineering;Design methodology;Pattern recognition;Research and development","software engineering","magic;myth;mapping study;design pattern literature;gang of four patterns;transferring design knowledge;software engineering","","2","","8","","25 Feb 2013","","","IEEE","IEEE Magazines"
"The highways and country roads to continuous deployment","M. Leppänen; S. Mäkinen; M. Pagels; V. Eloranta; J. Itkonen; M. V. Mäntylä; T. Männistö",Tampere University of Technology; University of Helsinki; University of Helsinki; Tampere University of Technology; Aalto University; Aalto University; University of Helsinki,"IEEE Software","10 Mar 2015","2015","32","2","64","72","As part of a Finnish research program, researchers interviewed 15 information and communications technology companies to determine the extent to which the companies adopted continuous deployment. They also aimed to find out why continuous deployment is considered beneficial and what the obstacles are to its full adoption. The benefits mentioned the most often were the ability to get faster feedback, the ability to deploy more often to keep customers satisfied, and improved quality and productivity. Despite understanding the benefits, none of the companies adopted a fully automatic deployment pipeline. The companies also had higher continuous-deployment capability than what they practiced. In many cases, they consciously chose to not aim for full continuous deployment. Obstacles to full adoption included domain-imposed restrictions, resistance to change, customer desires, and developers' skill and confidence.","1937-4194","","10.1109/MS.2015.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057604","continuous deployment;software development;software engineering;thematic analysis;continuous delivery;continuous integration","Continuous production;Software engineering;Production;Software development;Software engineering;Testing","customer satisfaction;management of change;software development management","Finnish research program;information and communications technology companies;customer satisfaction;fully automatic deployment pipeline;continuous-deployment capability;domain-imposed restrictions;customer desires;developers skill;developers confidence;change resistance","","47","","9","","10 Mar 2015","","","IEEE","IEEE Magazines"
"To Boldly Go Where No One Has Gone Before","F. Buschmann",Siemens Corporate Technology,"IEEE Software","22 Dec 2011","2012","29","1","23","25","Architecture mastery is more than professional expertise in modern software engineering methods and techniques. It is mainly in how architects approach design. Particularly, the ""things between things"" require the architect's full attention: domain concepts hidden between the lines of code; interactions and interfaces residing between components; and even choices between design options. This is the architect's territory, and successful architecture uncovers the things ""in-between"" as early as possible, make them explicit, and decide about them!","1937-4194","","10.1109/MS.2012.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111363","architecture;domain-driven design;interface design;interaction design;integration design","Software architecture;Software design;Software engineering;Product development","software architecture","software architecture;software engineering method","","2","","10","","22 Dec 2011","","","IEEE","IEEE Magazines"
"The Human Factor","J. C. Carver; B. Penzenstadler; A. Serebrenik; A. Yamashita","University of Alabama; California State University, Long Beach; Eindhoven University of Technology; Oslo and Akershus University","IEEE Software","22 Sep 2017","2017","34","5","90","92","This installment reports on five papers from the 39th International Conference on Software Engineering and its collocated events. These papers focus on human factors in software engineering, with the last three dealing with open source software.","1937-4194","","10.1109/MS.2017.3571580","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048655","brainstorming;inclusiveness;privacy;privacy requirements;code review;open source licenses;Docker;GitHub;39th International Conference on Software Engineering;ICSE;software development;software engineering","","","","","","","","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Adaptation of Service Protocols Using Process Algebra and On-the-Fly Reduction Techniques","R. Mateescu; P. Poizat; G. Salaün","Inria Grenoble-Rhône-Alpes/CONVECS, Montbonnot Saint-Martin; Université d'Evry Val d'Essonne, Paris and LRI UMR CNRS, Université Paris Sud, Orsay; Grenoble INP and Inria Grenoble-Rhône-Alpes/CONVECS, Montbonnot Saint-Martin","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","755","777","Reuse and composition are increasingly advocated and put into practice in modern software engineering. However, the software entities that are to be reused to build an application, e.g., services, have seldom been developed to integrate and to cope with the application requirements. As a consequence, they present mismatch, which directly hampers their reusability and the possibility of composing them. Software Adaptation has become a hot topic as a nonintrusive solution to work mismatch out using corrective pieces named adaptors. However, adaptation is a complex issue, especially when behavioral interfaces, or conversations, are taken into account. In this paper, we present state-of-the-art techniques to generate adaptors given the description of reused entities' conversations and an abstract specification of the way mismatch can be solved. We use a process algebra to encode the adaptation problem, and propose on-the-fly exploration and reduction techniques to compute adaptor protocols. Our approach follows the model-driven engineering paradigm, applied to service-oriented computing as a representative field of composition-based software engineering. We take service description languages as inputs of the adaptation process and we implement adaptors as centralized service compositions, i.e., orchestrations. Our approach is completely tool supported.","1939-3520","","10.1109/TSE.2011.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928357","Service composition;software adaptation;interfaces;protocols;mismatch;adaptation contracts;process algebra;on--the-fly generation;verification;tools","Adaptation model;Protocols;Contracts;Algebra;Semantics;Encoding;Computational modeling","formal specification;process algebra;protocols;service-oriented architecture;software reusability;specification languages","service protocol adaptation;process algebra;on-the-fly reduction techniques;composition;software entities;reusability;software adaptation;adaptors;reused entity conversations;abstract specification;on-the-fly exploration;model-driven engineering paradigm;service-oriented computing;composition-based software engineering;service description languages;centralized service compositions","","35","","65","","23 Jun 2011","","","IEEE","IEEE Journals"
"Leveraging the Power of the Crowd for Software Testing","N. Leicht; I. Blohm; J. M. Leimeister",University of St. Gallen; University of St. Gallen; University of St. Gallen,"IEEE Software","28 Mar 2017","2017","34","2","62","69","The rapid development of new IT-enabled business models, a fast-growing hardware market, and that market's segmentation are making software testing more complex. So, manual testing is becoming less applicable--economically and practicably. One approach to overcome these issues is crowdtesting--using crowdsourcing to perform testing. To profit from crowdtesting, companies can use three approaches: engage an external crowd of Internet users, engage their employees, or engage their customers. Three case studies illustrate these approaches' differences, benefits, and challenges, and the potential solutions to those challenges. Researchers' experiences with these approaches have led to guidelines that can help software development executives establish crowdtesting in their organizations. The Web Extra at extras.computer.org/extra/mso2017020062s1.pdf describes the procedure for the case studies. This article is part of a special issue on Crowdsourcing for Software Engineering.","1937-4194","","10.1109/MS.2017.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888424","software engineering;software testing;crowdsourcing;debugging;testing strategies;distributed testing;crowdtesting;software development","Companies;Information technology;Computer bugs;Software testing;Crowdsourcing;Hardware","crowdsourcing;Internet;personnel;program testing;software engineering","software testing;IT-enabled business models;manual testing;crowdtesting;crowdsourcing;Internet users;employees;software development executives","","14","","16","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Understanding Exception Handling: Viewpoints of Novices and Experts","H. Shah; C. Gorg; M. J. Harrold","Georgia Institute of Technology, Atlanta; Georgia Institute of Technology, Atlanta; Georgia Institute of Technology, Atlanta","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","150","161","Several recent studies indicate that many industrial applications exhibit poor quality in the design of exception-handling. To improve the quality of error-handling, we need to understand the problems and obstacles that developers face when designing and implementing exception-handling. In this paper, we present our research on understanding the viewpoint of developers-novices and experts-toward exception-handling. First, we conducted a study with novice developers in industry. The study results reveal that novices tend to ignore exceptions because of the complex nature of exception-handling. Then, we conducted a second study with experts in industry to understand their perspective on exception-handling. The study results show that, for experts, exception-handling is a crucial part in the development process. Experts also confirm the novices' approach of ignoring exception-handling and provide insights as to why novices do so. After analyzing the study data, we identified factors that influence experts' strategy selection process for handling exceptions and then built a model that represents a strategy selection process experts use to handle exceptions. Our model is based on interacting modules and fault scope. We conclude with some recommendations to help novices improve their understanding of exception-handling.","1939-3520","","10.1109/TSE.2010.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383375","Exception handling;user study;software developers.","Software performance;Application software;Debugging;Data analysis;Software tools;Functional programming;Programming profession;Performance evaluation;Visualization","error handling;software engineering","exception handling design;error handling quality;software development process;expert strategy selection process","","30","","15","","15 Jan 2010","","","IEEE","IEEE Journals"
"How Software Designers Interact with Sketches at the Whiteboard","N. Mangano; T. D. LaToza; M. Petre; A. van der Hoek","Molimur, Mission Viejo, CA; Department of Informatics, Donald Bren School Information and Computer Sciences, University of California, Irvine, CA; Faculty of Mathematics and Computing, The Open University, Milton Keynes, United Kingdom; Department of Informatics, Donald Bren School Information and Computer Sciences, University of California, Irvine, CA","IEEE Transactions on Software Engineering","10 Feb 2015","2015","41","2","135","156","Whiteboard sketches play a crucial role in software development, helping to support groups of designers in reasoning about a software design problem at hand. However, little is known about these sketches and how they support design `in the moment', particularly in terms of the relationships among sketches, visual syntactic elements within sketches, and reasoning activities. To address this gap, we analyzed 14 hours of design activity by eight pairs of professional software designers, manually coding over 4000 events capturing the introduction of visual syntactic elements into sketches, focus transitions between sketches, and reasoning activities. Our findings indicate that sketches serve as a rich medium for supporting design conversations. Designers often use general-purpose notations. Designers introduce new syntactic elements to record aspects of the design, or re-purpose sketches as the design develops. Designers constantly shift focus between sketches, using groups of sketches together that contain complementary information. Finally, sketches play an important role in supporting several types of reasoning activities (mental simulation, review of progress, consideration of alternatives). But these activities often leave no trace and rarely lead to sketch creation. We discuss the implications of these and other findings for the practice of software design at the whiteboard and for the creation of new electronic software design sketching tools.","1939-3520","","10.1109/TSE.2014.2362924","National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6922572","Interaction styles;systems analysis and design;user-centered design;Interaction styles;systems analysis and design;user-centered design","Encoding;Cognition;Software design;Visualization;Syntactics;Videos","software engineering","software design;whiteboard sketch;software development;visual syntactic elements;reasoning activity","","9","","60","","14 Oct 2014","","","IEEE","IEEE Journals"
"Process Aspects and Social Dynamics of Contemporary Code Review: Insights from Open Source Development and Industrial Practice at Microsoft","A. Bosu; J. C. Carver; C. Bird; J. Orbeck; C. Chockley","Department of Computer Science, Southern Illinois University, Carbondale, IL; Department of Computer Science, University of Alabama, Tuscaloosa, AL; Microsoft Research, Microsoft Corportation, Redmond, WA; Department of Computer Science, University of Alabama, Tuscaloosa, AL; Department of Computer Science, University of Alabama, Tuscaloosa, AL","IEEE Transactions on Software Engineering","9 Jan 2017","2017","43","1","56","75","Many open source and commercial developers practice contemporary code review, a lightweight, informal, tool-based code review process. To better understand this process and its benefits, we gathered information about code review practices via surveys of open source software developers and developers from Microsoft. The results of our analysis suggest that developers spend approximately 10-15 percent of their time in code reviews, with the amount of effort increasing with experience. Developers consider code review important, stating that in addition to finding defects, code reviews offer other benefits, including knowledge sharing, community building, and maintaining code quality. The quality of the code submitted for review helps reviewers form impressions about their teammates, which can influence future collaborations. We found a large amount of similarity between the Microsoft and OSS respondents. One interesting difference is that while OSS respondents view code review as an important method of impression formation, Microsoft respondents found knowledge dissemination to be more important. Finally, we found little difference between distributed and co-located Microsoft teams. Our findings identify the following key areas that warrant focused research: 1) exploring the non-technical benefits of code reviews, 2) helping developers in articulating review comments, and 3) assisting reviewers' program comprehension during code reviews.","1939-3520","","10.1109/TSE.2016.2576451","US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7484733","Code review;open source;OSS;survey;peer impressions;commercial projects","Inspection;Organizations;Collaboration;Context;Instruments;Measurement;Human factors","public domain software;software engineering;software management;software reviews;team working","contemporary code review;open source software developers;code quality;OSS;knowledge dissemination;Microsoft teams","","32","","58","","7 Jun 2016","","","IEEE","IEEE Journals"
"Early Detection of Collaboration Conflicts and Risks","Y. Brun; R. Holmes; M. D. Ernst; D. Notkin","University of Massachusetts, Amherst; University of Waterloo, Waterloo; University of Washington, Seattle; University of Washington, Seattle","IEEE Transactions on Software Engineering","25 Sep 2013","2013","39","10","1358","1375","Conflicts among developers' inconsistent copies of a shared project arise in collaborative development and can slow progress and decrease quality. Identifying and resolving such conflicts early can help. Identifying situations which may lead to conflicts can prevent some conflicts altogether. By studying nine open-source systems totaling 3.4 million lines of code, we establish that conflicts are frequent, persistent, and appear not only as overlapping textual edits but also as subsequent build and test failures. Motivated by this finding, we develop a speculative analysis technique that uses previously unexploited information from version control operations to precisely diagnose important classes of conflicts. Then, we design and implement Crystal, a publicly available tool that helps developers identify, manage, and prevent conflicts. Crystal uses speculative analysis to make concrete advice unobtrusively available to developers.","1939-3520","","10.1109/TSE.2013.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6520859","Collaborative development;collaboration conflicts;developer awareness;speculative analysis;version control;Crystal","Crystals;Collaboration;History;Open source software;Control systems;Terminology;Computer science","configuration management;groupware;program diagnostics;public domain software;software engineering","collaboration conflicts;collaborative development;open-source systems;overlapping textual edits;subsequent build-and-test failures;speculative analysis technique;version control operations;Crystal;publicly available tool;source code","","32","","48","","27 May 2013","","","IEEE","IEEE Journals"
"A Comparison of Six UML-Based Languages for Software Process Modeling","R. Bendraou; J. Jézéquel; M. Gervais; X. Blanc","University of Pierre and Marie Curie (UPMC), Paris; IRISA, INRIA-Rennes Bretagne Atlantique, Rennes; University of Paris Ouest Nanterre La Défense, Paris; University of Pierre and Marie Curie (UPMC), Paris","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","662","675","Describing and managing activities, resources, and constraints of software development processes is a challenging goal for many organizations. A first generation of Software Process Modeling Languages (SPMLs) appeared in the 1990s but failed to gain broad industrial support. Recently, however, a second generation of SPMLs has appeared, leveraging the strong industrial interest for modeling languages such as UML. In this paper, we propose a comparison of these UML-based SPMLs. While not exhaustive, this comparison concentrates on SPMLs most representative of the various alternative approaches, ranging from UML-based framework specializations to full-blown executable metamodeling approaches. To support the comparison of these various approaches, we propose a frame gathering a set of requirements for process modeling, such as semantic richness, modularity, executability, conformity to the UML standard, and formality. Beyond discussing the relative merits of these approaches, we also evaluate the overall suitability of these UML-based SPMLs for software process modeling. Finally, we discuss the impact of these approaches on the current state of the practice, and conclude with lessons we have learned in doing this comparison.","1939-3520","","10.1109/TSE.2009.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5593045","Metamodeling;process modeling and execution;software process modeling languages;UML.","Unified modeling language;Software;Object oriented modeling;Analytical models;Semantics;Programming;Computational modeling","software engineering;Unified Modeling Language","UML based language;software development process;software process modeling language;UML based SPML;metamodeling approach","","48","","78","","30 Sep 2010","","","IEEE","IEEE Journals"
"The Work Life of Developers: Activities, Switches and Perceived Productivity","A. N. Meyer; L. E. Barton; G. C. Murphy; T. Zimmermann; T. Fritz","University of Zurich, Zürich, Switzerland; University of British Columbia, Vancouver, BC, Canada; University of British Columbia, Vancouver, BC, Canada; Microsoft Research, Redmond, WA; University of Zurich, Zürich, Switzerland","IEEE Transactions on Software Engineering","8 Dec 2017","2017","43","12","1178","1193","Many software development organizations strive to enhance the productivity of their developers. All too often, efforts aimed at improving developer productivity are undertaken without knowledge about how developers spend their time at work and how it influences their own perception of productivity. To fill in this gap, we deployed a monitoring application at 20 computers of professional software developers from four companies for an average of 11 full work day in situ. Corroborating earlier findings, we found that developers spend their time on a wide variety of activities and switch regularly between them, resulting in highly fragmented work. Our findings extend beyond existing research in that we correlate developers' work habits with perceived productivity and also show productivity is a personal matter. Although productivity is personal, developers can be roughly grouped into morning, low-at-lunch and afternoon people. A stepwise linear regression per participant revealed that more user input is most often associated with a positive, and emails, planned meetings and work unrelated websites with a negative perception of productivity. We discuss opportunities of our findings, the potential to predict high and low productivity and suggest design approaches to create better tool support for planning developers' work day and improving their personal productivity.","1939-3520","","10.1109/TSE.2017.2656886","ABB; SNF; NSERC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7829407","Productivity;developer activity;work fragmentation;interruptions;human factors;user studies","Productivity;Software development;Encoding;Human factors;Monitoring","regression analysis;software development management;software engineering","developer productivity;software development organizations;personal productivity;work unrelated websites;perceived productivity;highly fragmented work;professional software developers","","24","","64","Traditional","23 Jan 2017","","","IEEE","IEEE Journals"
"A Dissection of the Test-Driven Development Process: Does It Really Matter to Test-First or to Test-Last?","D. Fucci; H. Erdogmus; B. Turhan; M. Oivo; N. Juristo","Department of Information Processing Science, University of Oulu, Oulu, Finland; Silicon Valley Campus, Carnegie Mellon University, Pittsburgh, PA; Department of Information Processing Science, University of Oulu, Oulu, Finland; Department of Information Processing Science, University of Oulu, Oulu, Finland; Department of Information Processing Science, University of Oulu, Oulu, Finland","IEEE Transactions on Software Engineering","14 Jul 2017","2017","43","7","597","614","Background: Test-driven development (TDD) is a technique that repeats short coding cycles interleaved with testing. The developer first writes a unit test for the desired functionality, followed by the necessary production code, and refactors the code. Many empirical studies neglect unique process characteristics related to TDD iterative nature. Aim: We formulate four process characteristic: sequencing, granularity, uniformity, and refactoring effort. We investigate how these characteristics impact quality and productivity in TDD and related variations. Method: We analyzed 82 data points collected from 39 professionals, each capturing the process used while performing a specific development task. We built regression models to assess the impact of process characteristics on quality and productivity. Quality was measured by functional correctness. Result: Quality and productivity improvements were primarily positively associated with the granularity and uniformity. Sequencing, the order in which test and production code are written, had no important influence. Refactoring effort was negatively associated with both outcomes. We explain the unexpected negative correlation with quality by possible prevalence of mixed refactoring. Conclusion: The claimed benefits of TDD may not be due to its distinctive test-first dynamic, but rather due to the fact that TDD-like processes encourage fine-grained, steady steps that improve focus and flow.","1939-3520","","10.1109/TSE.2016.2616877","Academy of Finland; TEKES; FiDiPro; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7592412","Test-driven development;empirical investigation;process dimensions;external quality;productivity","Testing;Productivity;Context;Companies;Sequential analysis;Conferences","program testing;regression analysis;software engineering","test-driven development process;TDD technique;TDD iterative nature;sequencing characteristic;granularity characteristic;uniformity characteristic;refactoring effort characteristic;regression model","","9","","46","","18 Oct 2016","","","IEEE","IEEE Journals"
"A Model-Driven Methodology for Developing Secure Data-Management Applications","D. Basin; M. Clavel; M. Egea; M. A. G. de Dios; C. Dania","ETH Zürich, Zürich, Switzerland; IMDEA Software, Campus de Montegancedo, s/n, Pozuelo de Alarcon, Madrid, Spain; ATOS Research & Innovation, Madrid, Spain; IMDEA Software, Campus de Montegancedo, s/n, Pozuelo de Alarcon, Madrid, Spain; IMDEA Software, Campus de Montegancedo, s/n, Pozuelo de Alarcon, Madrid, Spain","IEEE Transactions on Software Engineering","2 May 2014","2014","40","4","324","337","We present a novel model-driven methodology for developing secure data-management applications. System developers proceed by modeling three different views of the desired application: its data model, security model, and GUI model. These models formalize respectively the application's data domain, authorization policy, and its graphical interface together with the application's behavior. Afterwards a model-transformation function lifts the policy specified by the security model to the GUI model. This allows a separation of concerns where behavior and security are specified separately, and subsequently combined to generate a security-aware GUI model. Finally, a code generator generates a multi-tier application, along with all support for access control, from the security-aware GUI model. We report on applications built using our approach and the associated tool.","1939-3520","","10.1109/TSE.2013.2297116","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6698396","Model-driven development;model-driven security;access control;GUI models;model transformation","Data models;Graphical user interfaces;Unified modeling language;Authorization;Syntactics","authorisation;graphical user interfaces;software engineering","model-driven methodology;secure data-management applications;data model;security model;graphical user intefaces;authorization policy;model-transformation function;security-aware GUI model;code generator;multitier application;access control","","14","","30","","2 Jan 2014","","","IEEE","IEEE Journals"
"Program Characterization Using Runtime Values and Its Application to Software Plagiarism Detection","Y. Jhi; X. Jia; X. Wang; S. Zhu; P. Liu; D. Wu","Samsung SDS R&D Center, Seoul, Korea; State Key Laboratory of Information Security, Institute of Information Engineering, Beijing, Haidian District, China; Shape Security, Mountain View, CA; Department of Computer Science and Engineering, Pennsylvania State University, University Park, PA; College of Information Sciences and Technology, Pennsylvania State University, University Park, PA; College of Information Sciences and Technology, Pennsylvania State University, University Park, PA","IEEE Transactions on Software Engineering","15 Sep 2015","2015","41","9","925","943","Illegal code reuse has become a serious threat to the software community. Identifying similar or identical code fragments becomes much more challenging in code theft cases where plagiarizers can use various automated code transformation or obfuscation techniques to hide stolen code from being detected. Previous works in this field are largely limited in that (i) most of them cannot handle advanced obfuscation techniques, and (ii) the methods based on source code analysis are not practical since the source code of suspicious programs typically cannot be obtained until strong evidences have been collected. Based on the observation that some critical runtime values of a program are hard to be replaced or eliminated by semantics-preserving transformation techniques, we introduce a novel approach to dynamic characterization of executable programs. Leveraging such invariant values, our technique is resilient to various control and data obfuscation techniques. We show how the values can be extracted and refined to expose the critical values and how we can apply this runtime property to help solve problems in software plagiarism detection. We have implemented a prototype with a dynamic taint analyzer atop a generic processor emulator. Our value-based plagiarism detection method (VaPD) uses the longest common subsequence based similarity measuring algorithms to check whether two code fragments belong to the same lineage. We evaluate our proposed method through a set of real-world automated obfuscators. Our experimental results show that the value-based method successfully discriminates 34 plagiarisms obfuscated by SandMark, plagiarisms heavily obfuscated by KlassMaster, programs obfuscated by Thicket, and executables obfuscated by Loco/Diablo.","1939-3520","","10.1109/TSE.2015.2418777","US National Science Foundation (NSF); AFRL; National Natural Science Foundation of China (NSFC); National High-tech R&D Program of China; Strategic Priority Research Program of the Chinese Academy of Sciences; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7076635","Software plagiarism detection;dynamic code identification.;Software plagiarism detection;dynamic code identification","Plagiarism;Runtime;Optimization;Program processors;Semantics;Java","security of data;software engineering;source code (software)","program characterization;runtime values;software plagiarism detection;illegal code reuse;software community;identical code fragments;obfuscation techniques;source code;semantics-preserving transformation techniques;generic processor emulator;value-based plagiarism detection method;VaPD;SandMark;Thicket;Loco/Diablo","","18","1","59","","1 Apr 2015","","","IEEE","IEEE Journals"
"FlowTalk: Language Support for Long-Latency Operations in Embedded Devices","A. Bergel; W. Harrison; V. Cahill; S. Clarke","University of Chile, Santiago; Software Structure Group; Lero and Trinity College Dublin, Ireland; Lero and Trinity College Dublin, Ireland","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","526","543","Wireless sensor networks necessitate a programming model different from those used to develop desktop applications. Typically, resources in terms of power and memory are constrained. C is the most common programming language used to develop applications on very small embedded sensor devices. We claim that C does not provide efficient mechanisms to address the implicit asynchronous nature of sensor sampling. C applications for these devices suffer from a disruption in their control flow. In this paper, we present FlowTalk, a new object-oriented programming language aimed at making software development for wireless embedded sensor devices easier. FlowTalk is an object-oriented programming language in which dynamicity (e.g., object creation) has been traded for a reduction in memory consumption. The event model that traditionally comes from using sensors is adapted in FlowTalk with controlled disruption, a light-weight continuation mechanism. The essence of our model is to turn asynchronous long-latency operations into synchronous and blocking method calls. FlowTalk is built for TinyOS and can be used to develop applications that can fit in 4 KB of memory for a large number of wireless sensor devices.","1939-3520","","10.1109/TSE.2010.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5492692","Embedded systems;object-based programming.","Sampling methods;Object oriented modeling;Wireless sensor networks;Application software;Computer languages;Object oriented programming;Java;Biosensors;Automotive engineering;Embedded software","C language;embedded systems;intelligent sensors;object-oriented languages;object-oriented programming;software engineering;wireless sensor networks","FlowTalk;language support;wireless sensor networks;programming language;C language;embedded sensor devices;sensor sampling;object-oriented programming language;memory consumption;light-weight continuation mechanism;asynchronous long-latency operations;TinyOS;memory size 4 KByte","","1","","44","","28 Jun 2010","","","IEEE","IEEE Journals"
"Engineering of Framework-Specific Modeling Languages","M. Antkiewicz; K. Czarnecki; M. Stephan","University of Waterloo, Waterloo; University of Waterloo, Waterloo; University of Waterloo, Waterloo","IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","795","824","Framework-specific modeling languages (FSMLs) help developers build applications based on object-oriented frameworks. FSMLs model abstractions and rules of application programming interfaces (APIs) exposed by frameworks and can express models of how applications use APIs. Such models aid developers in understanding, creating, and evolving application code. We present four exemplar FSMLs and a method for engineering new FSMLs. The method was created postmortem by generalizing the experience of building the exemplars and by specializing existing approaches to domain analysis, software development, and quality evaluation of models and languages. The method is driven by the use cases that the FSML under development should support and the evaluation of the constructed FSML is guided by two existing quality frameworks. The method description provides concrete examples for the engineering steps, outcomes, and challenges. It also provides strategies for making engineering decisions. Our work offers a concrete example of software language engineering and its benefits. FSMLs capture existing domain knowledge in language form and support application code understanding through reverse engineering, application code creation through forward engineering, and application code evolution through round-trip engineering.","1939-3520","","10.1109/TSE.2009.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907004","Framework-specific modeling language;domain-specific language;object-oriented framework;application programming interface (API);feature model;framework-specific model;forward engineering;reverse engineering;round-trip engineering;evolution;code pattern;mapping.","Object oriented modeling;Application software;Documentation;Writing;Concrete;Reverse engineering;Knowledge engineering;Java;Scattering;Buildings","application program interfaces;object-oriented programming;software engineering","framework-specific modeling languages;object-oriented frameworks;application programming interfaces;software development;software language engineering;reverse engineering;application code creation through forward engineering;application code evolution through round-trip engineering","","34","","102","","2 May 2009","","","IEEE","IEEE Journals"
"Extracting Development Tasks to Navigate Software Documentation","C. Treude; M. P. Robillard; B. Dagenais","Departamento de Informática e Matemática Aplicada, Universidade Federal do Rio Grande do Norte, Natal, RN, Brazil; School of Computer Science, McGill University, Montréal, QC, Canada; Resulto, Montréal, QC, Canada","IEEE Transactions on Software Engineering","10 Jun 2015","2015","41","6","565","581","Knowledge management plays a central role in many software development organizations. While much of the important technical knowledge can be captured in documentation, there often exists a gap between the information needs of software developers and the documentation structure. To help developers navigate documentation, we developed a technique for automatically extracting tasks from software documentation by conceptualizing tasks as specific programming actions that have been described in the documentation. More than 70 percent of the tasks we extracted from the documentation of two projects were judged meaningful by at least one of two developers. We present TaskNavigator, a user interface for search queries that suggests tasks extracted with our technique in an auto-complete list along with concepts, code elements, and section headers. We conducted a field study in which six professional developers used TaskNavigator for two weeks as part of their ongoing work. We found search results identified through extracted tasks to be more helpful to developers than those found through concepts, code elements, and section headers. The results indicate that task descriptions can be effectively extracted from software documentation, and that they help bridge the gap between documentation structure and the information needs of software developers.","1939-3520","","10.1109/TSE.2014.2387172","NSERC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7000568","Software Documentation;Development Tasks;Navigation;Auto-Complete;Natural Language Processing;Software documentation;development tasks;navigation;auto-complete;natural language processing","Documentation;Software;Navigation;Data mining;Programming;Natural language processing;Subscriptions","knowledge management;software engineering;user interfaces","software documentation navigation;knowledge management;software developers;information needs;programming action;TaskNavigator user interface;documentation structure","","35","","59","","31 Dec 2014","","","IEEE","IEEE Journals"
"Supporting Domain Analysis through Mining and Recommending Features from Online Product Listings","N. Hariri; C. Castro-Herrera; M. Mirakhorli; J. Cleland-Huang; B. Mobasher","DePaul University, Chicago; Google Inc.; DePaul University, Chicago; DePaul University, Chicago; DePaul University, Chicago","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1736","1752","Domain analysis is a labor-intensive task in which related software systems are analyzed to discover their common and variable parts. Many software projects include extensive domain analysis activities, intended to jumpstart the requirements process through identifying potential features. In this paper, we present a recommender system that is designed to reduce the human effort of performing domain analysis. Our approach relies on data mining techniques to discover common features across products as well as relationships among those features. We use a novel incremental diffusive algorithm to extract features from online product descriptions, and then employ association rule mining and the (k)-nearest neighbor machine learning method to make feature recommendations during the domain analysis process. Our feature mining and feature recommendation algorithms are quantitatively evaluated and the results are presented. Also, the performance of the recommender system is illustrated and evaluated within the context of a case study for an enterprise-level collaborative software suite. The results clearly highlight the benefits and limitations of our approach, as well as the necessary preconditions for its success.","1939-3520","","10.1109/TSE.2013.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6582404","Domain analysis;recommender systems;clustering;association rule mining;k-nearest neighbor","Feature extraction;Recommender systems;Clustering algorithms;Domain analysis;Data mining;Algorithm design and analysis;Electronic mail;Nearest neighbor search;Clustering","data mining;groupware;Internet;learning (artificial intelligence);pattern classification;recommender systems;software engineering","enterprise-level collaborative software suite;feature recommendation algorithms;feature mining;k-nearest neighbor machine learning method;association rule mining;online product descriptions;feature extraction;incremental diffusive algorithm;data mining techniques;recommender system;domain analysis activity;software projects;software systems;labor-intensive task;online product listings","","56","","52","","16 Aug 2013","","","IEEE","IEEE Journals"
"Visualizing Co-Change Information with the Evolution Radar","M. D'Ambros; M. Lanza; M. Lungu","University of Lugano, Lugano; University of Lugano, Lugano; University of Lugano, Lugano","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","720","735","Software evolution analysis provides a valuable source of information that can be used both to understand a system's design and predict its future development. While for many program comprehension purposes, it is sufficient to model a single version of a system, there are types of information that can only be recovered when the history of a system is taken into account. Logical coupling, the implicit dependency between software artifacts that have been changed together, is an example of such information. Previous research has dealt with low-level couplings between files, leading to an explosion of the data to be analyzed, or has abstracted the logical couplings to the level of modules, leading to a loss of detailed information. In this paper, we present a visualization-based approach that integrates logical coupling information at different levels of abstraction. This facilitates an in-depth analysis of the logical couplings, and at the same time, leads to a characterization of a system's modules in terms of their logical coupling. The presented approach supports the retrospective analysis of a software system and maintenance activities such as restructuring and redocumentation. We illustrate retrospective analysis on two large open-source software systems.","1939-3520","","10.1109/TSE.2009.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815274","Software evolution;software visualization;logical coupling.","Radar;Information analysis;Software systems;Information resources;System analysis and design;History;Explosions;Data analysis;Data visualization;Software maintenance","data visualisation;software engineering;systems re-engineering","evolution radar;software evolution analysis;software artifacts;visualization;logical coupling information;abstraction;system module;open source software system analysis","","54","","38","","17 Apr 2009","","","IEEE","IEEE Journals"
"Automatic Detection and Resolution of Lexical Ambiguity in Process Models","F. Pittke; H. Leopold; J. Mendling","Institute for Information Business, Vienna, WU, Austria; Department of Computer Science, VU University Amsterdam, The Netherlands; Institute for Information Business, Vienna, WU, Austria","IEEE Transactions on Software Engineering","10 Jun 2015","2015","41","6","526","544","System-related engineering tasks are often conducted using process models. In this context, it is essential that these models do not contain structural or terminological inconsistencies. To this end, several automatic analysis techniques have been proposed to support quality assurance. While formal properties of control flow can be checked in an automated fashion, there is a lack of techniques addressing textual quality. More specifically, there is currently no technique available for handling the issue of lexical ambiguity caused by homonyms and synonyms. In this paper, we address this research gap and propose a technique that detects and resolves lexical ambiguities in process models. We evaluate the technique using three process model collections from practice varying in size, domain, and degree of standardization. The evaluation demonstrates that the technique significantly reduces the level of lexical ambiguity and that meaningful candidates are proposed for resolving ambiguity.","1939-3520","","10.1109/TSE.2015.2396895","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7027184","Identification of Lexical Ambiguity;Resolution of Lexical Ambiguity;Business Process Models;Identification of lexical ambiguity;resolution of lexical ambiguity;business process models","Unified modeling language;Object oriented modeling;Context;Business;Natural languages;Manuals;Vectors","computational linguistics;grammars;natural language processing;software engineering","automatic detection;automatic resolution;lexical ambiguity;system-related engineering task;structural inconsistency;terminological inconsistency;automatic analysis technique;quality assurance;control flow;automated fashion;textual quality;homonyms;synonyms;process model collection","","32","","106","","29 Jan 2015","","","IEEE","IEEE Journals"
"Time and Probability-Based Information Flow Analysis","R. Lanotte; A. Maggiolo-Schettini; A. Troina","Università dell'Insubria, Como; Università di Pisa, Pisa; Università di Torino, Torino","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","719","734","In multilevel systems, it is important to avoid unwanted indirect information flow from higher levels to lower levels, namely, the so-called covert channels. Initial studies of information flow analysis were performed by abstracting away from time and probability. It is already known that systems that are proven to be secure in a possibilistic framework may turn out to be insecure when time or probability is considered. Recently, work has been done in order to consider also aspects either of time or of probability, but not both. In this paper, we propose a general framework based on Probabilistic Timed Automata, where both probabilistic and timing covert channels can be studied. We define a Noninterference security property and a Nondeducibility on Composition security property, which allow expressing information flow in a timed and probabilistic setting. We then compare these properties with analogous ones defined in contexts where either time or probability or neither of them are taken into account. This permits a classification of the properties depending on their discerning power. As an application, we study a system with covert channels that we are able to discover by applying our techniques.","1939-3520","","10.1109/TSE.2010.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383372","Probabilistic timed automata;multilevel security;information flow analysis;weak bisimulation.","Information analysis;Information security;Automata;Clocks;Multilevel systems;Timing;Communication system control;Performance analysis;Power system security;Control systems","data flow analysis;probabilistic automata;probability;security of data;software agents;software engineering","probability based information flow analysis;multilevel system;indirect unwanted information flow;covert channel;probabilistic timed automata;probabilistic covert channel;timing covert channel;noninterference security property;nondeducibility;composition security property","","9","","45","","15 Jan 2010","","","IEEE","IEEE Journals"
"Range Fixes: Interactive Error Resolution for Software Configuration","Y. Xiong; H. Zhang; A. Hubaux; S. She; J. Wang; K. Czarnecki","School of Electronics Engineering and Computer Science, Institute of Software, Peking University, Beijing, PR China; School of Electronics Engineering and Computer Science, Institute of Software, Peking University, Beijing, PR China; ASML, Eindhoven, the Netherlands; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, Canada; School of Electronics Engineering and Computer Science, Institute of Software, Peking University, Beijing, PR China; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, Canada","IEEE Transactions on Software Engineering","10 Jun 2015","2015","41","6","603","619","To prevent ill-formed configurations, highly configurable software often allows defining constraints over the available options. As these constraints can be complex, fixing a configuration that violates one or more constraints can be challenging. Although several fix-generation approaches exist, their applicability is limited because (1) they typically generate only one fix or a very long fix list, difficult for the user to identify the desirable fix; and (2) they do not fully support non-Boolean constraints, which contain arithmetic, inequality, and string operators. This paper proposes a novel concept, range fix, for software configuration. A range fix specifies the options to change and the ranges of values for these options. We also design an algorithm that automatically generates range fixes for a violated constraint. We have evaluated our approach with three different strategies for handling constraint interactions, on data from nine open source projects over two configuration platforms. The evaluation shows that our notion of range fix leads to mostly simple yet complete sets of fixes, and our algorithm is able to generate fixes within one second for configuration systems with a few thousands options and constraints.","1939-3520","","10.1109/TSE.2014.2383381","National Basic Research Program of China; High-Tech Research and Development Program of China; National Natural Science Foundation of China; NSERC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6991616","Consistency Management;Error Resolution;Range Fix;Software Configuration;Consistency management;error resolution;range fix;software configuration","Concrete;Linux;Biological system modeling;Reactive power;Kernel;Navigation","constraint handling;software engineering","range fixes;interactive error resolution;software configuration;fix-generation approaches;constraint interaction handling;open source projects","","13","","46","","18 Dec 2014","","","IEEE","IEEE Journals"
"The Design Space of Bug Fixes and How Developers Navigate It","E. Murphy-Hill; T. Zimmermann; C. Bird; N. Nagappan","Department of Computer Science, North Carolina State University, Raleigh, NC; Microsoft Research, Redmond, WA; Microsoft Research, Redmond, WA; Microsoft Research, Redmond, WA","IEEE Transactions on Software Engineering","7 Jan 2015","2015","41","1","65","81","When software engineers fix bugs, they may have several options as to how to fix those bugs. Which fix they choose has many implications, both for practitioners and researchers: What is the risk of introducing other bugs during the fix? Is the bug fix in the same code that caused the bug? Is the change fixing the cause or just covering a symptom? In this paper, we investigate alternative fixes to bugs and present an empirical study of how engineers make design choices about how to fix bugs. We start with a motivating case study of the Pex4Fun environment. Then, based on qualitative interviews with 40 engineers working on a variety of products, data from six bug triage meetings, and a survey filled out by 326 Microsoft engineers and 37 developers from other companies, we found a number of factors, many of them non-technical, that influence how bugs are fixed, such as how close to release the software is. We also discuss implications for research and practice, including how to make bug prediction and localization more accurate.","1939-3520","","10.1109/TSE.2014.2357438","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6901259","Design concepts;human factors in software design;maintainability","Interviews;Computer bugs;Software;Encoding;Navigation;Protocols;Buildings","program debugging;software engineering","bug fix design space;software engineers;design choices;Pex4Fun environment;qualitative interviews;bug triage meetings;Microsoft engineers;bug prediction;bug localization","","24","","36","","17 Sep 2014","","","IEEE","IEEE Journals"
"Automatically Recommending Peer Reviewers in Modern Code Review","M. B. Zanjani; H. Kagdi; C. Bird","Department of Electrical Engineering and Computer Science, Wichita State University, Wichita, Kansas; Department of Electrical Engineering and Computer Science, Wichita State University, Wichita, Kansas; Microsoft Research, Redmond, WA","IEEE Transactions on Software Engineering","10 Jun 2016","2016","42","6","530","543","Code review is an important part of the software development process. Recently, many open source projects have begun practicing code review through “modern” tools such as GitHub pull-requests and Gerrit. Many commercial software companies use similar tools for code review internally. These tools enable the owner of a source code change to request individuals to participate in the review, i.e., reviewers. However, this task comes with a challenge. Prior work has shown that the benefits of code review are dependent upon the expertise of the reviewers involved. Thus, a common problem faced by authors of source code changes is that of identifying the best reviewers for their source code change. To address this problem, we present an approach, namely cHRev, to automatically recommend reviewers who are best suited to participate in a given review, based on their historical contributions as demonstrated in their prior reviews. We evaluate the effectiveness of cHRev on three open source systems as well as a commercial codebase at Microsoft and compare it to the state of the art in reviewer recommendation. We show that by leveraging the specific information in previously completed reviews (i.e.,quantification of review comments and their recency), we are able to improve dramatically on the performance of prior approaches, which (limitedly) operate on generic review information (i.e., reviewers of similar source code file and path names) or source coderepository data. We also present the insights into why our approach cHRev outperforms the existing approaches.","1939-3520","","10.1109/TSE.2015.2500238","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7328331","Modern code review;reviewer recommendation;code change;Gerrit;Modern code review;reviewer recommendation;code change;Gerrit","History;Electronic mail;Birds;Inspection;Androids;Humanoid robots;Software","software engineering;software reviews","peer reviewer recommendation;code review;software development process;open source projects;GitHub pull-requests tool;Gerrit tool;source code change;cHRev approach;commercial codebase","","46","","55","","12 Nov 2015","","","IEEE","IEEE Journals"
"Exploring Mobile End User Development: Existing Use and Design Factors","A. Namoun; A. Daskalopoulou; N. Mehandjiev; Z. Xun","Islamic University of Madinah, Medina, Saudi Arabia; University of Manchester, Booth Street West, Manchester, United Kingdom; University of Manchester, Booth Street West, Manchester, United Kingdom; University of Manchester, Booth Street West, Manchester, United Kingdom","IEEE Transactions on Software Engineering","13 Oct 2016","2016","42","10","960","976","Mobile devices are everywhere, and the scope of their use is growing from simple calling and texting through Internet browsing to more technical activities such as creating message processing filters and connecting different apps. However, building tools which provide effective support for such advanced technical use of mobile devices by non-programmers (mobile end user development or mEUD) requires thorough understanding of user needs and motivations, including factors which can impact user intentions regarding mEUD activities. We propose a model linking these mEUD factors with mobile users' attitudes towards, and intent of doing mEUD, and discuss a number of implications for supporting mEUD. Our research process is user-centered, and we formulate a number of hypotheses by fusing results from an exploratory survey which gathers facts about mEUD motivations and activities, and from a focus group study, which delivers deeper understanding of particular mEUD practices and issues. We then test the hypothesized relationships through a follow-up enquiry mixing quantitative and qualitative techniques, leading to the creation of a preliminary mEUD model. Altogether we have involved 275 mobile users in our research. Our contribution links seven mEUD factors with mEUD intentions and attitudes, and highlights a number of implications for mEUD support.","1939-3520","","10.1109/TSE.2016.2532873","Manchester Business School; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7416245","Human factors in software design;mobile environments;models and principles;requirements/specifications","Mobile communication;Mobile handsets;Mashups;Games;Context;Electronic mail","human factors;mobile computing;software engineering;user centred design","mobile end user development;mEUD;user attitude;user-centered design;mobile device;software development","","9","","50","","23 Feb 2016","","","IEEE","IEEE Journals"
"Optimized Resource Allocation for Software Release Planning","A. Ngo-The; G. Ruhe","Expert Decisions Inc., Calgary; University of Calgary, Calgary","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","109","123","Release planning for incremental software development assigns features to releases such that technical, resource, risk and budget constraints are met. Planning of software releases and allocation of resources cannot be handled in isolation. A feature can be offered as part of a release only if all its necessary tasks are done before the given release date. We assume a given pool of human resources with different degrees of productivity to perform different types of tasks. To address the inherent difficulty of this process, we propose a two-phased optimization approach that combines the strength of two existing solution methods. The industrial applicability of the approach is primarily directed towards mature organizations having systematic development and measurement processes in place. The expected practical benefit of the planning method is to provide release plan solutions that achieve a better overall business value (e.g., expressed by the degree of stakeholder satisfaction) by better allocation of resources. Without ignoring the importance of the human expert in this process, the contributions of the paper are seen in making the overall process more objective and the resulting decisions more transparent.","1939-3520","","10.1109/TSE.2008.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4641940","Planning;Management;Planning;Management","Resource management;Humans;Productivity;Optimization methods;Constraint optimization;Integer linear programming;Genetic programming;Project management;Feedback;Companies","project management;resource allocation;software engineering;software management","optimized resource allocation;software release planning;incremental software development;software project management","","54","3","41","","10 Oct 2008","","","IEEE","IEEE Journals"
"Systematic review and aggregation of empirical studies on elicitation techniques","O. Dieste; N. Juristo","Universidad Politécnica de Madrid, Boadilla del Monte; Universidad Politécnica de Madrid, Boadilla del Monte","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","283","304","We have located the results of empirical studies on elicitation techniques and aggregated these results to gather empirically grounded evidence. Our chosen surveying methodology was systematic review, whereas we used an adaptation of comparative analysis for aggregation because meta-analysis techniques could not be applied. The review identified 564 publications from the SCOPUS, IEEEXPLORE, and ACM DL databases, as well as Google. We selected and extracted data from 26 of those publications. The selected publications contain 30 empirical studies. These studies were designed to test 43 elicitation techniques and 50 different response variables. We got 100 separate results from the experiments. The aggregation generated 17 pieces of knowledge about the interviewing, laddering, sorting, and protocol analysis elicitation techniques. We provide a set of guidelines based on the gathered pieces of knowledge.","1939-3520","","10.1109/TSE.2010.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416730","Elicitation methods;performance measures;experimentation;systematic literature review.","Protocols;Information analysis;Sensitivity analysis;Databases;Data mining;Sorting;Software measurement","knowledge acquisition;software engineering","empirically grounded evidence;elicitation techniques;surveying methodology;systematic review;SCOPUS;IEEEXPLORE;ACM DL databases;Google","","72","","102","","18 Feb 2010","","","IEEE","IEEE Journals"
"CACheck: Detecting and Repairing Cell Arrays in Spreadsheets","W. Dou; C. Xu; S. C. Cheung; J. Wei","State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing, China; State Key Laboratory for Novel Software Technology, Department of Computer Science and Technology, Nanjing University, Nanjing, Jiangsu, China; Department of Computer Science and Engineering, Hong Kong University of Science and Technology, Kowloon, Hong Kong, China; State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing, China","IEEE Transactions on Software Engineering","14 Mar 2017","2017","43","3","226","251","Spreadsheets are widely used by end users for numerical computation in their business. Spreadsheet cells whose computation is subject to the same semantics are often clustered in a row or column as a cell array. When a spreadsheet evolves, the cells in a cell array can degenerate due to ad hoc modifications. Such degenerated cell arrays no longer keep cells prescribing the same computational semantics, and are said to exhibit ambiguous computation smells. We propose CACheck, a novel technique that automatically detects and repairs smelly cell arrays by recovering their intended computational semantics. Our empirical study on the EUSES and Enron corpora finds that such smelly cell arrays are common. Our study also suggests that CACheck is useful for detecting and repairing real spreadsheet problems caused by smelly cell arrays. Compared with our previous work AmCheck, CACheck detects smelly cell arrays with higher precision and recall rate.","1939-3520","","10.1109/TSE.2016.2584059","Beijing Natural Science Foundation; National Key Research and Development Plan; Research Grants Council; General Research Fund; National Natural Science Foundation; Collaborative Innovation Center of Novel Software Technology and Industrialization of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498607","Spreadsheet;cell array;ambiguous computation smell","Semantics;Maintenance engineering;Software;Computer science;Nonhomogeneous media;Electronic mail;Business","software engineering;spreadsheet programs","spreadsheets;CACheck;numerical computation;ad hoc modifications;EUSES corpora;Enron corpora;smelly cell arrays","","16","","63","","23 Jun 2016","","","IEEE","IEEE Journals"
"Scalable Differential Analysis of Process Algebra Models","M. Tribastone; S. Gilmore; J. Hillston","The University of Edinburgh, Edinburgh; The University of Edinburgh, Edinburgh; The University of Edinburgh, Edinburgh","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","205","219","The exact performance analysis of large-scale software systems with discrete-state approaches is difficult because of the well-known problem of state-space explosion. This paper considers this problem with regard to the stochastic process algebra PEPA, presenting a deterministic approximation to the underlying Markov chain model based on ordinary differential equations. The accuracy of the approximation is assessed by means of a substantial case study of a distributed multithreaded application.","1939-3520","","10.1109/TSE.2010.82","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5567115","Modeling and prediction;ordinary differential equations;Markov processes.","Mathematical model;Semantics;Computational modeling;Approximation methods;Numerical models;Stochastic processes;Markov methods","differential equations;Markov processes;multi-threading;process algebra;software engineering","scalable differential analysis;large-scale software systems;discrete-state approach;stochastic process algebra;PEPA;Markov chain model;ordinary differential equations;distributed multithreaded application","","65","","26","","9 Sep 2010","","","IEEE","IEEE Journals"
"Power-Law Distributions of Component Size in General Software Systems","L. Hatton","CISM, University, United Kingdom","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","566","572","This paper begins by modeling general software systems using concepts from statistical mechanics which provide a framework for linking microscopic and macroscopic features of any complex system. This analysis provides a way of linking two features of particular interest in software systems: first the microscopic distribution of defects within components and second the macroscopic distribution of component sizes in a typical system. The former has been studied extensively, but the latter much less so. This paper shows that subject to an external constraint that the total number of defects is fixed in an equilibrium system, commonly used defect models for individual components directly imply that the distribution of component sizes in such a system will obey a power-law Pareto distribution. The paper continues by analyzing a large number of mature systems of different total sizes, different implementation languages, and very different application areas, and demonstrates that the component sizes do indeed appear to obey the predicted power-law distribution. Some possible implications of this are explored.","1939-3520","","10.1109/TSE.2008.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4711063","Defects;macroscopic system behavior;component size distribution;Pareto.;General systems theory;Software science;Design concepts;Reliability;availability;and serviceability","Software systems;Power system modeling;Joining processes;Microscopy;Thermodynamics;Temperature distribution;Predictive models;Assembly systems;Software standards;Equations","Pareto distribution;software engineering;statistical mechanics","general software systems modeling;statistical mechanics;complex system;defects distribution;component sizes distribution;power-law Pareto distribution","","20","","15","","12 Dec 2008","","","IEEE","IEEE Journals"
"Semantics-Based Obfuscation-Resilient Binary Code Similarity Comparison with Applications to Software and Algorithm Plagiarism Detection","L. Luo; J. Ming; D. Wu; P. Liu; S. Zhu","College of Information Sciences and Technology, Pennsylvania State University, University Park, PA; Department of Computer Science and Engineering, University of Texas at Arlington, Arlington, TX; College of Information Sciences and Technology, Pennsylvania State University, University Park, PA; College of Information Sciences and Technology, Pennsylvania State University, University Park, PA; Department of Computer Science and Engineering, Pennsylvania State University, University Park, PA","IEEE Transactions on Software Engineering","8 Dec 2017","2017","43","12","1157","1177","Existing code similarity comparison methods, whether source or binary code based, are mostly not resilient to obfuscations. Identifying similar or identical code fragments among programs is very important in some applications. For example, one application is to detect illegal code reuse. In the code theft cases, emerging obfuscation techniques have made automated detection increasingly difficult. Another application is to identify cryptographic algorithms which are widely employed by modern malware to circumvent detection, hide network communications, and protect payloads among other purposes. Due to diverse coding styles and high programming flexibility, different implementation of the same algorithm may appear very distinct, causing automatic detection to be very hard, let alone code obfuscations are sometimes applied. In this paper, we propose a binary-oriented, obfuscation-resilient binary code similarity comparison method based on a new concept, longest common subsequence of semantically equivalent basic blocks , which combines rigorous program semantics with longest common subsequence based fuzzy matching. We model the semantics of a basic block by a set of symbolic formulas representing the input-output relations of the block. This way, the semantic equivalence (and similarity) of two blocks can be checked by a theorem prover. We then model the semantic similarity of two paths using the longest common subsequence with basic blocks as elements. This novel combination has resulted in strong resiliency to code obfuscation. We have developed a prototype. The experimental results show that our method can be applied to software plagiarism and algorithm detection, and is effective and practical to analyze real-world software.","1939-3520","","10.1109/TSE.2017.2655046","US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7823022","Software plagiarism detection;algorithm detection;binary code similarity comparison;obfuscation;symbolic execution;constraint solving","Semantics;Software development;Plagiarism;Binary codes;Software algorithms;Syntactics;Computational modeling","fuzzy set theory;invasive software;program diagnostics;software engineering;theorem proving","code similarity comparison methods;identical code fragments;illegal code reuse;code theft cases;obfuscation techniques;cryptographic algorithms;diverse coding styles;automatic detection;code obfuscations;obfuscation-resilient binary code similarity comparison method;longest common subsequence;semantically equivalent basic blocks;rigorous program semantics;semantic similarity","","14","","81","Traditional","18 Jan 2017","","","IEEE","IEEE Journals"
"Schedule of Bad Smell Detection and Resolution: A New Way to Save Effort","H. Liu; Z. Ma; W. Shao; Z. Niu","Beijing Institute of Technology and Ministry of Education, Beijing; Ministry of Education, Beijing; Ministry of Education, Beijing; Beijing Institute of Technology, Beijing","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","220","235","Bad smells are signs of potential problems in code. Detecting and resolving bad smells, however, remain time-consuming for software engineers despite proposals on bad smell detection and refactoring tools. Numerous bad smells have been recognized, yet the sequences in which the detection and resolution of different kinds of bad smells are performed are rarely discussed because software engineers do not know how to optimize sequences or determine the benefits of an optimal sequence. To this end, we propose a detection and resolution sequence for different kinds of bad smells to simplify their detection and resolution. We highlight the necessity of managing bad smell resolution sequences with a motivating example, and recommend a suitable sequence for commonly occurring bad smells. We evaluate this recommendation on two nontrivial open source applications, and the evaluation results suggest that a significant reduction in effort ranging from 17.64 to 20 percent can be achieved when bad smells are detected and resolved using the proposed sequence.","1939-3520","","10.1109/TSE.2011.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680918","Scheme;bad smell;software refactoring;effort;detection;schedule.","Refactoring;Feature extraction;Distance measurement;Scheduling","scheduling;software engineering","bad smell detection;bad smell resolution;software engineers;optimal sequence;resolution sequence;detection sequence;open source applications","","55","","54","","6 Jan 2011","","","IEEE","IEEE Journals"
"Identifying and Summarizing Systematic Code Changes via Rule Inference","M. Kim; D. Notkin; D. Grossman; G. Wilson","The University of Texas at Austin, Austin; University of Washington, Seattle; University of Washington, Seattle; The University of Texas at Austin, Austin","IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","45","62","Programmers often need to reason about how a program evolved between two or more program versions. Reasoning about program changes is challenging as there is a significant gap between how programmers think about changes and how existing program differencing tools represent such changes. For example, even though modification of a locking protocol is conceptually simple and systematic at a code level, diff extracts scattered text additions and deletions per file. To enable programmers to reason about program differences at a high level, this paper proposes a rule-based program differencing approach that automatically discovers and represents systematic changes as logic rules. To demonstrate the viability of this approach, we instantiated this approach at two different abstraction levels in Java: first at the level of application programming interface (API) names and signatures, and second at the level of code elements (e.g., types, methods, and fields) and structural dependences (e.g., method-calls, field-accesses, and subtyping relationships). The benefit of this approach is demonstrated through its application to several open source projects as well as a focus group study with professional software engineers from a large e-commerce company.","1939-3520","","10.1109/TSE.2012.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6165314","Software evolution;program differencing;rule learning;logic-based program representation","Systematics;Syntactics;Inference algorithms;Cloning;Software;Semantics;Libraries","application program interfaces;electronic commerce;inference mechanisms;Java;reasoning about programs;software engineering","systematic code;rule inference;reasoning about program;locking protocol;scattered text additions;rule-based program differencing approach;Java;application programming interface;API;professional software engineers;large e-commerce company;structural dependences","","28","","50","","6 Mar 2012","","","IEEE","IEEE Journals"
"ARENA: An Approach for the Automated Generation of Release Notes","L. Moreno; G. Bavota; M. D. Penta; R. Oliveto; A. Marcus; G. Canfora","University of Texas at Dallas, Richardson, TX; University of Lugano, Lugano, Switzerland; University of Sannio, Benevento, Italy; University of Molise, Pesche, IS, Italy; University of Texas at Dallas, Richardson, TX; University of Sannio, Benevento, Italy","IEEE Transactions on Software Engineering","13 Feb 2017","2017","43","2","106","127","Release notes document corrections, enhancements, and, in general, changes that were implemented in a new release of a software project. They are usually created manually and may include hundreds of different items, such as descriptions of new features, bug fixes, structural changes, new or deprecated APIs, and changes to software licenses. Thus, producing them can be a time-consuming and daunting task. This paper describes ARENA (Automatic RElease Notes generAtor), an approach for the automatic generation of release notes. ARENA extracts changes from the source code, summarizes them, and integrates them with information from versioning systems and issue trackers. ARENA was designed based on the manual analysis of 990 existing release notes. In order to evaluate the quality of the release notes automatically generated by ARENA, we performed four empirical studies involving a total of 56 participants (48 professional developers and eight students). The obtained results indicate that the generated release notes are very good approximations of the ones manually produced by developers and often include important information that is missing in the manually created release notes.","1939-3520","","10.1109/TSE.2016.2591536","National Science Foundation; Markos project; European Commission; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7513412","Release notes;software documentation;software evolution","Libraries;Licenses;Feature extraction;Documentation;Computer bugs;Open source software","application program interfaces;program debugging;software engineering;source code (software);system documentation","ARENA;automated release note generation;release note document corrections;release note document enhancements;software project;bug fixes;new features;structural changes;API;software licenses;source code change extraction;source code change summarization","","26","","40","","14 Jul 2016","","","IEEE","IEEE Journals"
"Cina: Suppressing the Detection of Unstable Context Inconsistency","C. Xu; W. Xi; S. C. Cheung; X. Ma; C. Cao; J. Lu","State Key Laboratory for Novel Software Technology and the Department of Computer Science and Technology, Nanjing University, Nanjing, Jiangsu, China; State Key Laboratory for Novel Software Technology and the Department of Computer Science and Technology, Nanjing University, Nanjing, Jiangsu, China; Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Kowloon, Hong Kong, China; State Key Laboratory for Novel Software Technology and the Department of Computer Science and Technology, Nanjing University, Nanjing, Jiangsu, China; State Key Laboratory for Novel Software Technology and the Department of Computer Science and Technology, Nanjing University, Nanjing, Jiangsu, China; State Key Laboratory for Novel Software Technology and the Department of Computer Science and Technology, Nanjing University, Nanjing, Jiangsu, China","IEEE Transactions on Software Engineering","15 Sep 2015","2015","41","9","842","865","Context-aware applications adapt their behavior based on contexts. Contexts can, however, be incorrect. A popular means to build dependable applications is to augment them with a set of constraints to govern the consistency of context values. These constraints are evaluated upon context changes to detect inconsistencies so that they can be timely handled. However, we observe that many context inconsistencies are unstable. They vanish by themselves and do not require handling. Such inconsistencies are detected due to misaligned sensor sampling or improper inconsistency detection scheduling. We call them unstable context inconsistencies (or STINs). STINs should be avoided to prevent unnecessary inconsistency handling and unstable behavioral adaptation to applications. In this article, we study STINs systematically, from examples to theoretical analysis, and present algorithms to suppress their detection. Our key insight is that only certain patterns of context changes can make a consistency constraint subject to the detection of STINs. We derive such patterns and proactively use them to suppress the detection of STINs. We implemented our idea and applied it to real-world applications. Experimental results confirmed its effectiveness in suppressing the detection of numerous STINs with negligible overhead, while preserving the detection of stable context inconsistencies that require inconsistency handling.","1939-3520","","10.1109/TSE.2015.2418760","National Basic Research 973 Program; National Natural Science Foundation; Research Grants Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7078871","Constraint;context inconsistency;impact propagation;instability analysis;pervasive computing;Constraint;context inconsistency;impact propagation;instability analysis;pervasive computing","Context;Schedules;Delays;Sensors;Middleware;Finite element analysis","software engineering;ubiquitous computing","CINA;unstable context inconsistency detection;context-aware applications;STIN","","7","","65","","2 Apr 2015","","","IEEE","IEEE Journals"
"Locating Need-to-Externalize Constant Strings for Software Internationalization with Generalized String-Taint Analysis","X. Wang; L. Zhang; T. Xie; H. Mei; J. Sun","Peking University, Beijing; Peking University, Beijing; North Carolina State University, Raleigh; Peking University, Beijing; Peking University, Beijing","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","516","536","Nowadays, a software product usually faces a global market. To meet the requirements of different local users, the software product must be internationalized. In an internationalized software product, user-visible hard-coded constant strings are externalized to resource files so that local versions can be generated by translating the resource files. In many cases, a software product is not internationalized at the beginning of the software development process. To internationalize an existing product, the developers must locate the user-visible constant strings that should be externalized. This locating process is tedious and error-prone due to 1) the large number of both user-visible and non-user-visible constant strings and 2) the complex data flows from constant strings to the Graphical User Interface (GUI). In this paper, we propose an automatic approach to locating need-to-externalize constant strings in the source code of a software product. Given a list of precollected API methods that output values of their string argument variables to the GUI and the source code of the software product under analysis, our approach traces from the invocation sites (within the source code) of these methods back to the need-to-externalize constant strings using generalized string-taint analysis. In our empirical evaluation, we used our approach to locate need-to-externalize constant strings in the uninternationalized versions of seven real-world open source software products. The results of our evaluation demonstrate that our approach is able to effectively locate need-to-externalize constant strings in uninternationalized software products. Furthermore, to help developers understand why a constant string requires translation and properly translate the need-to-externalize strings, we provide visual representation of the string dependencies related to the need-to-externalize strings.","1939-3520","","10.1109/TSE.2012.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6216383","Software internationalization;need-to-externalize constant strings;string-taint analysis","Software;Graphical user interfaces;Prototypes;Java;Libraries;Production;Globalization","globalisation;graphical user interfaces;public domain software;software engineering","need-to-externalize constant string location;software internationalization;generalized string-taint analysis;user requirement;internationalized software product;user-visible hard-coded constant string;software development process;graphical user interface;GUI;data flow;API method;application program interface;string argument variable;open source software product;string dependency","","6","","31","","12 Jun 2012","","","IEEE","IEEE Journals"
"Improving Source Code Lexicon via Traceability and Information Retrieval","A. De Lucia; M. Di Penta; R. Oliveto","University of Salerno, Fisciano; University of Sannio, Benevento; University of Molise, Pesche","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","205","227","The paper presents an approach helping developers to maintain source code identifiers and comments consistent with high-level artifacts. Specifically, the approach computes and shows the textual similarity between source code and related high-level artifacts. Our conjecture is that developers are induced to improve the source code lexicon, i.e., terms used in identifiers or comments, if the software development environment provides information about the textual similarity between the source code under development and the related high-level artifacts. The proposed approach also recommends candidate identifiers built from high-level artifacts related to the source code under development and has been implemented as an Eclipse plug-in, called COde Comprehension Nurturant Using Traceability (COCONUT). The paper also reports on two controlled experiments performed with master's and bachelor's students. The goal of the experiments is to evaluate the quality of identifiers and comments (in terms of their consistency with high-level artifacts) in the source code produced when using or not using COCONUT. The achieved results confirm our conjecture that providing the developers with similarity between code and high-level artifacts helps to improve the quality of source code lexicon. This indicates the potential usefulness of COCONUT as a feature for software development environments.","1939-3520","","10.1109/TSE.2010.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5601742","Software traceability;source code comprehensibility;source code identifier quality;information retrieval;software development environments;empirical software engineering.","Documentation;Programming;Large scale integration;Semantics;Software quality;Couplings","information retrieval;program diagnostics;software quality","source code lexicon;information retrieval;textual similarity;high level artifact;software development;candidate identifier;code comprehension nurturant using traceability;COCONUT;bachelor student;master student","","40","2","72","","14 Oct 2010","","","IEEE","IEEE Journals"
"Reasoning About Identifier Spaces: How to Make Chord Correct","P. Zave","AT&T Laboratories—Research, Bedminster, NJ","IEEE Transactions on Software Engineering","8 Dec 2017","2017","43","12","1144","1156","The Chord distributed hash table (DHT) is well-known and often used to implement peer-to-peer systems. Chord peers find other peers, and access their data, through a ring-shaped pointer structure in a large identifier space. Despite claims of proven correctness, i.e., eventual reachability, previous work has shown that the Chord ring-maintenance protocol is not correct under its original operating assumptions. Previous work has not, however, discovered whether Chord could be made correct under the same assumptions. The contribution of this paper is to provide the first specification of correct operations and initialization for Chord, an inductive invariant that is necessary and sufficient to support a proof of correctness, and two independent proofs of correctness. One proof is informal and intuitive, and applies to networks of any size. The other proof is based on a formal model in Alloy, and uses fully automated analysis to prove the assertions for networks of bounded size. The two proofs complement each other in several important ways.","1939-3520","","10.1109/TSE.2017.2655056","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7823003","Computers and information processing;distributed computing;peer-to-peer computing;software engineering;formal verification","Peer-to-peer computing;Formal verification;Information processing;Analytical models;Structural rings;Distributed processing","peer-to-peer computing;protocols;telecommunication network topology","hash table;peer-to-peer systems;Chord peers;ring-shaped pointer structure;identifier space;Chord ring-maintenance protocol","","4","","33","Traditional","18 Jan 2017","","","IEEE","IEEE Journals"
"Modeling Human-in-the-Loop Security Analysis and Decision-Making Processes","M. A. Schumann; D. Drusinsky; J. B. Michael; D. Wijesekera","KEYW Corporation, 7740 Milestone Pkwy, Suite 400, Hanover; Department of Computer Science , Naval Postgraduate School, Monterey; Departments of Computer Science and Electrical & Computer Engineering, Naval Postgraduate School, 900 N Glebe Road, Arlington; Department of Computer Science , George Mason University, Fairfax","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","2","154","166","This paper presents a novel application of computer-assisted formal methods for systematically specifying, documenting, statically and dynamically checking, and maintaining human-centered workflow processes. This approach provides for end-to-end verification and validation of process workflows, which is needed for process workflows that are intended for use in developing and maintaining high-integrity systems. We demonstrate the technical feasibility of our approach by applying it on the development of the US government's process workflow for implementing, certifying, and accrediting cross-domain computer security solutions. Our approach involves identifying human-in-the-loop decision points in the process activities and then modeling these via statechart assertions. We developed techniques to specify and enforce workflow hierarchies, which was a challenge due to the existence of concurrent activities within complex workflow processes. Some of the key advantages of our approach are: it results in development of a model that is executable, supporting both upfront and runtime checking of process-workflow requirements; aids comprehension and communication among stakeholders and process engineers; and provides for incorporating accountability and risk management into the engineering of process workflows.","1939-3520","","10.1109/TSE.2014.2302433","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6727512","Formal methods;information assurance;process modeling;software engineering;statechart assertions;verification and validation","Unified modeling language;Object oriented modeling;Software;Runtime;Formal specifications;Analytical models;Business","decision making;formal specification;formal verification;government data processing;security of data;workflow management software","human-in-the-loop security analysis;decision-making process;computer-assisted formal methods;human-centered workflow process;process specification;process documentation;process statically checking;process dynamically checking;process maintenance;end-to-end verification;end-to-end validation;high-integrity systems;US government process workflow;United States;cross-domain computer security solutions;human-in-the-loop decision points;process activities;statechart assertions;workflow hierarchies;accountability;risk management;process workflows engineering","","5","","44","","28 Jan 2014","","","IEEE","IEEE Journals"
"Effects of Developer Experience on Learning and Applying Unit Test-Driven Development","R. Latorre","Universidad Autónoma de Madrid, Madrid, Spain","IEEE Transactions on Software Engineering","2 May 2014","2014","40","4","381","395","Unit test-driven development (UTDD) is a software development practice where unit test cases are specified iteratively and incrementally before production code. In the last years, researchers have conducted several studies within academia and industry on the effectiveness of this software development practice. They have investigated its utility as compared to other development techniques, focusing mainly on code quality and productivity. This quasi-experiment analyzes the influence of the developers' experience level on the ability to learn and apply UTDD. The ability to apply UTDD is measured in terms of process conformance and development time. From the research point of view, our goal is to evaluate how difficult is learning UTDD by professionals without any prior experience in this technique. From the industrial point of view, the goal is to evaluate the possibility of using this software development practice as an effective solution to take into account in real projects. Our results suggest that skilled developers are able to quickly learn the UTDD concepts and, after practicing them for a short while, become as effective in performing small programming tasks as compared to more traditional test-last development techniques. Junior programmers differ only in their ability to discover the best design, and this translates into a performance penalty since they need to revise their design choices more frequently than senior programmers.","1939-3520","","10.1109/TSE.2013.2295827","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6690135","Test-driven development;test-first design;software engineering process;software quality/SQA;software construction;process conformance;programmer productivity","Software;Testing;Training;Programming profession;Context;Production","learning (artificial intelligence);program testing;software quality","learning;unit test-driven development;UTDD;software development;code quality;productivity","","12","","44","","20 Dec 2013","","","IEEE","IEEE Journals"
"Software Development Estimation Biases: The Role of Interdependence","M. Jorgensen; S. Grimstad","University of Oslo, Lysaker; University of Oslo, Lysaker","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","677","693","Software development effort estimates are frequently too low, which may lead to poor project plans and project failures. One reason for this bias seems to be that the effort estimates produced by software developers are affected by information that has no relevance for the actual use of effort. We attempted to acquire a better understanding of the underlying mechanisms and the robustness of this type of estimation bias. For this purpose, we hired 374 software developers working in outsourcing companies to participate in a set of three experiments. The experiments examined the connection between estimation bias and developer dimensions: self-construal (how one sees oneself), thinking style, nationality, experience, skill, education, sex, and organizational role. We found that estimation bias was present along most of the studied dimensions. The most interesting finding may be that the estimation bias increased significantly with higher levels of interdependence, i.e., with stronger emphasis on connectedness, social context, and relationships. We propose that this connection may be enabled by an activation of one's self-construal when engaging in effort estimation, and a connection between a more interdependent self-construal and increased search for indirect messages, lower ability to ignore irrelevant context, and a stronger emphasis on socially desirable responses.","1939-3520","","10.1109/TSE.2011.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6193066","Effort estimation;estimation bias;cultural differences;software engineering.","Estimation;Software;Companies;Context;Programming;Outsourcing;Instruments","estimation theory;software management","software development estimation;interdependence role;project failures;project plans;outsourcing companies","","13","","48","","1 May 2012","","","IEEE","IEEE Journals"
"Requirements Elicitation and Specification Using the Agent Paradigm: The Case Study of an Aircraft Turnaround Simulator","T. Miller; B. Lu; L. Sterling; G. Beydoun; K. Taveter","Department of Computing and Information Systems, The University of Melbourne, Melbourne, Victoria, Autralia; Department of Computing and Information Systems, The University of Melbourne, Melbourne, Victoria, Autralia; Faculty of ICT, Swinburne University of Technology, Melbourne, Victoria, Autralia; Faculty of Informatics, University of Wollongong, Wollongong, NSW 2522, Australia; Institute of Informatics, Tallinn University of Technology, Tallinn, EU, Estonia","IEEE Transactions on Software Engineering","9 Oct 2014","2014","40","10","1007","1024","In this paper, we describe research results arising from a technology transfer exercise on agent-oriented requirements engineering with an industry partner. We introduce two improvements to the state-of-the-art in agent-oriented requirements engineering, designed to mitigate two problems experienced by ourselves and our industry partner: (1) the lack of systematic methods for agent-oriented requirements elicitation and modelling; and (2) the lack of prescribed deliverables in agent-oriented requirements engineering. We discuss the application of our new approach to an aircraft turnaround simulator built in conjunction with our industry partner, and show how agent-oriented models can be derived and used to construct a complete requirements package. We evaluate this by having three independent people design and implement prototypes of the aircraft turnaround simulator, and comparing the three prototypes. Our evaluation indicates that our approach is effective at delivering correct, complete, and consistent requirements that satisfy the stakeholders, and can be used in a repeatable manner to produce designs and implementations. We discuss lessons learnt from applying this approach.","1939-3520","","10.1109/TSE.2014.2339827","Australian Research Council Linkage; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6860260","Agent-oriented software engineering;agent-oriented modelling;technology transfer","Object oriented modeling;Aircraft;Atmospheric modeling;Software;Industries;Analytical models;Educational institutions","aerospace computing;aircraft;formal specification;multi-agent systems;object-oriented programming;software agents","requirements elicitation;requirements specification;agent paradigm;aircraft turnaround simulator;agent oriented requirements engineering;industry partner;systematic methods;agent-oriented requirements elicitation;agent-oriented requirement modelling;independent people design","","23","","46","","18 Jul 2014","","","IEEE","IEEE Journals"
"Coping with Existing Systems in Information Systems Development","F. Zickert; R. Beck","Goethe University Frankfurt, Frankfurt; Goethe University Frankfurt, Frankfurt","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1027","1039","Determining how to cope with existing systems is an important issue for information systems development (ISD). In this paper, we investigate how well different ISD patterns are suited for coping with existing systems. Empirical results, gathered from three software development projects undertaken by a financial institution, suggest propositions regarding how ISD patterns and existing systems affect the characteristics of objective ISD complexity, which in turn determine overall experienced complexity. Existing systems increase complexity due to conflicting interdependencies, but ISD patterns that reduce this complexity, such as those that employ bottom-up or concurrent consideration patterns, are best suited for coping with existing systems. In contrast, top-down and iterative focusing patterns, as classically used in new development, increase the complexity associated with conflicting interdependency, which makes them particularly unsuited for coping with existing systems in ISD.","1939-3520","","10.1109/TSE.2011.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5999674","Complexity measures;improvements;software maintenance;software engineering process","Complexity theory;Information systems;Maintenance engineering;Software maintenance;File systems;Programming;Servers","financial data processing;information systems;investment;project management;software maintenance;software metrics","information systems development;ISD patterns;software development projects;financial institution;complexity reduction;bottom-up patterns;concurrent consideration patterns;top-down focusing patterns;iterative focusing patterns;information systems portfolio;complexity measures;software maintenance","","","","73","","25 Aug 2011","","","IEEE","IEEE Journals"
"A Theoretical and Empirical Analysis of the Role of Test Sequence Length in Software Testing for Structural Coverage","A. Arcuri","Simula Research Laboratory, Lysaker","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","497","519","In the presence of an internal state, often a sequence of function calls is required to test software. In fact, to cover a particular branch of the code, a sequence of previous function calls might be required to put the internal state in the appropriate configuration. Internal states are not only present in object-oriented software, but also in procedural software (e.g., static variables in C programs). In the literature, there are many techniques to test this type of software. However, to the best of our knowledge, the properties related to the choice of the length of these sequences have received only a little attention in the literature. In this paper, we analyze the role that the length plays in software testing, in particular branch coverage. We show that, on “difficult” software testing benchmarks, longer test sequences make their testing trivial. Hence, we argue that the choice of the length of the test sequences is very important in software testing. Theoretical analyses and empirical studies on widely used benchmarks and on an industrial software are carried out to support our claims.","1939-3520","","10.1109/TSE.2011.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5750005","Evolutionary testing;object-oriented software;state problem;search-based software engineering;software testing;length;test sequence.","Software;Containers;Software testing;Algorithm design and analysis;Search problems;Software algorithms","C language;object-oriented programming;program testing","empirical analysis;theoretical analysis;test sequence length;software testing;structural coverage;internal state;function calls;object-oriented software;procedural software;C programs;static variables;test sequences","","19","","40","","15 Apr 2011","","","IEEE","IEEE Journals"
"Supporting the Combined Selection of Model-Based Testing Techniques","A. C. Dias-Neto; G. H. Travassos","Institute of Computing, Federal University of Amazonas, Manaus, Brazil; Systems Engineering and Computer Science Programme at COPPE, Federal University of Rio de Janeiro, Rio de Janeiro , Brazil","IEEE Transactions on Software Engineering","9 Oct 2014","2014","40","10","1025","1041","The technical literature on model-based testing (MBT) offers us several techniques with different characteristics and goals. Contemporary software projects usually need to make use of different software testing techniques. However, a lack of empirical information regarding their scalability and effectiveness is observed. It makes their application difficult in real projects, increasing the technical difficulties to combine two or more MBT techniques for the same software project. In addition, current software testing selection approaches offer limited support for the combined selection of techniques. Therefore, this paper describes the conception and evaluation of an approach aimed at supporting the combined selection of MBT techniques for software projects. It consists of an evidence-based body of knowledge with 219 MBT techniques and their corresponding characteristics and a selection process that provides indicators on the level of adequacy (impact indicator) amongst MBT techniques and software projects characteristics. Results from the data analysis indicate it contributes to improve the effectiveness and efficiency of the selection process when compared to another selection approach available in the technical literature. Aiming at facilitating its use, a computerized infrastructure, evaluated into an industrial context and evolved to implement all the facilities needed to support such selection approach, is presented.","1939-3520","","10.1109/TSE.2014.2312915","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6776497","Software testing;model-based testing;software technology selection;recommendation system;experimental software engineering","Software testing;Context;Computational modeling;Organizations;Software quality","program testing;project management;software development management","model-based testing techniques;technical literature;software projects;software testing techniques;MBT techniques;software testing selection;impact indicator;software project characteristics;data analysis;computerized infrastructure","","10","","39","","20 Mar 2014","","","IEEE","IEEE Journals"
"Generating Test Data from OCL Constraints with Search Techniques","S. Ali; M. Zohaib Iqbal; A. Arcuri; L. C. Briand","Simula Research Lab, Norway; National University of Computer and Emerging Sciences, Islamabad and University of Luxembourg, Luxembourg; Simula Research Lab, Norway; University of Luxembourg, Luxembourg","IEEE Transactions on Software Engineering","25 Sep 2013","2013","39","10","1376","1402","Model-based testing (MBT) aims at automated, scalable, and systematic testing solutions for complex industrial software systems. To increase chances of adoption in industrial contexts, software systems can be modeled using well-established standards such as the Unified Modeling Language (UML) and the Object Constraint Language (OCL). Given that test data generation is one of the major challenges to automate MBT, we focus on test data generation from OCL constraints in this paper. This endeavor is all the more challenging given the numerous OCL constructs and operations that are designed to facilitate the definition of constraints. Though search-based software testing has been applied to test data generation for white-box testing (e.g., branch coverage), its application to the MBT of industrial software systems has been limited. In this paper, we propose a set of search heuristics targeted to OCL constraints to guide test data generation and automate MBT in industrial applications. We evaluate these heuristics for three search algorithms: Genetic Algorithm, (1+1) Evolutionary Algorithm, and Alternating Variable Method. We empirically evaluate our heuristics using complex artificial problems, followed by empirical analyses of the feasibility of our approach on one industrial system in the context of robustness testing. Our approach is also compared with the most widely referenced OCL solver (UMLtoCSP) in the literature and shows to be significantly more efficient.","1939-3520","","10.1109/TSE.2013.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6491405","OCL;search-based testing;test data generation;empirical evaluation;search-based software engineering;model-based testing","Unified modeling language;Search problems;Software algorithms;Genetic algorithms;Standards;Software testing","genetic algorithms;program testing;specification languages","test data generation;OCL constraints;search techniques;model-based testing;MBT;industrial software systems;object constraint language;unified modeling language;UML;OCL constructs;OCL operations;search-based software testing;white-box testing;genetic algorithm;one-plus-one evolutionary algorithm;alternating variable method;empirical analysis;robustness testing context;UMLtoCSP OCL solver","","71","","75","","1 Apr 2013","","","IEEE","IEEE Journals"
"Incremental Test Generation for Software Product Lines","E. Uzuncaova; S. Khurshid; D. Batory","Microsoft, Redmond; University of Texas at Austin, Austin; University of Texas at Austin, Austin","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","309","322","Recent advances in mechanical techniques for systematic testing have increased our ability to automatically find subtle bugs, and hence, to deploy more dependable software. This paper builds on one such systematic technique, scope-bounded testing, to develop a novel specification-based approach for efficiently generating tests for products in a software product line. Given properties of features as first-order logic formulas in Alloy, our approach uses SAT-based analysis to automatically generate test inputs for each product in a product line. To ensure soundness of generation, we introduce an automatic technique for mapping a formula that specifies a feature into a transformation that defines incremental refinement of test suites. Our experimental results using different data structure product lines show that an incremental approach can provide an order of magnitude speedup over conventional techniques. We also present a further optimization using dedicated integer constraint solvers for feature properties that introduce integer constraints, and show how to use a combination of solvers in tandem for solving Alloy formulas.","1939-3520","","10.1109/TSE.2010.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5456077","Software/program verification;testing and debugging;software engineering.","Software testing;Automatic testing;System testing;Computer bugs;Logic testing;Data structures;Software quality;Automatic logic units;Acoustic testing;Constraint optimization","computability;data structures;program testing;program verification","incremental test generation;software product lines;mechanical techniques;systematic testing;scope-bounded testing;specification-based approach;first-order logic formulas;SAT-based analysis;data structure product lines;dedicated integer constraint solvers;Alloy formulas;program verification","","49","","60","","29 Apr 2010","","","IEEE","IEEE Journals"
"SMT-Based Bounded Model Checking for Embedded ANSI-C Software","L. Cordeiro; B. Fischer; J. Marques-Silva","Federal University of Amazonas, Brazil; University of Southampton, Southampton; University College Dublin, Dublin","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","957","974","Propositional bounded model checking has been applied successfully to verify embedded software, but remains limited by increasing propositional formula sizes and the loss of high-level information during the translation preventing potential optimizations to reduce the state space to be explored. These limitations can be overcome by encoding high-level information in theories richer than propositional logic and using SMT solvers for the generated verification conditions. Here, we propose the application of different background theories and SMT solvers to the verification of embedded software written in ANSI-C in order to improve scalability and precision in a completely automatic way. We have modified and extended the encodings from previous SMT-based bounded model checkers to provide more accurate support for variables of finite bit width, bit-vector operations, arrays, structures, unions, and pointers. We have integrated the CVC3, Boolector, and Z3 solvers with the CBMC front-end and evaluated them using both standard software model checking benchmarks and typical embedded software applications from telecommunications, control systems, and medical devices. The experiments show that our ESBMC model checker can analyze larger problems than existing tools and substantially reduce the verification time.","1939-3520","","10.1109/TSE.2011.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928354","Software engineering;formal methods;verification;model checking","Encoding;Embedded software;Safety;Space exploration;Optimization;Electronic mail","embedded systems;formal verification","SMT based bounded model checking;embedded ANSI-C software;embedded software verification;SMT solvers;model checkers;software model checking benchmarks","","74","1","64","","23 Jun 2011","","","IEEE","IEEE Journals"
"How Social and Communication Channels Shape and Challenge a Participatory Culture in Software Development","M. Storey; A. Zagalsky; F. F. Filho; L. Singer; D. M. German","University of Victoria, Victoria, BC, Canada; University of Victoria, Victoria, BC, Canada; Universidade Federal do Rio Grande do Norte, Natal, Brazil; University of Victoria, Victoria, BC, Canada; University of Victoria, Victoria, BC, Canada","IEEE Transactions on Software Engineering","13 Feb 2017","2017","43","2","185","204","Software developers use many different communication tools and channels in their work. The diversity of these tools has dramatically increased over the past decade and developers now have access to a wide range of socially enabled communication channels and social media to support their activities. The availability of such social tools is leading to a participatory culture of software development, where developers want to engage with, learn from, and co-create software with other developers. However, the interplay of these social channels, as well as the opportunities and challenges they may create when used together within this participatory development culture are not yet well understood. In this paper, we report on a large-scale survey conducted with 1,449 GitHub users. We discuss the channels these developers find essential to their work and gain an understanding of the challenges they face using them. Our findings lay the empirical foundation for providing recommendations to developers and tool designers on how to use and improve tools for software developers.","1939-3520","","10.1109/TSE.2016.2584053","Natural Sciences and Engineering Research Council of Canada; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498605","Participatory culture;communication;social media;CSCW;software engineering","Software;Communication channels;Media;Collaboration;Electronic mail;Face;Knowledge engineering","cultural aspects;professional communication;social networking (online);software development management;team working","social channels;software development;participatory culture;communication tools;socially enabled communication channels;social media;social tools;GitHub users;software developers","","53","","41","","23 Jun 2016","","","IEEE","IEEE Journals"
"Using Dependency Structures for Prioritization of Functional Test Suites","S. Haidry; T. Miller","University of Melbourne, Parkville; University of Melbourne, Parkville","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","258","275","Test case prioritization is the process of ordering the execution of test cases to achieve a certain goal, such as increasing the rate of fault detection. Increasing the rate of fault detection can provide earlier feedback to system developers, improving fault fixing activity and, ultimately, software delivery. Many existing test case prioritization techniques consider that tests can be run in any order. However, due to functional dependencies that may exist between some test cases-that is, one test case must be executed before another-this is often not the case. In this paper, we present a family of test case prioritization techniques that use the dependency information from a test suite to prioritize that test suite. The nature of the techniques preserves the dependencies in the test ordering. The hypothesis of this work is that dependencies between tests are representative of interactions in the system under test, and executing complex interactions earlier is likely to increase the fault detection rate, compared to arbitrary test orderings. Empirical evaluations on six systems built toward industry use demonstrate that these techniques increase the rate of fault detection compared to the rates achieved by the untreated order, random orders, and test suites ordered using existing ""coarse-grained” techniques based on function coverage.","1939-3520","","10.1109/TSE.2012.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6189361","Software engineering;testing and debugging;test execution","Fault detection;Digital signal processing;Schedules;Software;Complexity theory;Testing;Weight measurement","program debugging;program testing;software fault tolerance;software process improvement","dependency structures;functional test suite prioritization;test case execution ordering;fault detection rate;system developers;fault fixing improvement;software delivery;functional dependencies;test case prioritization technique;dependency information;system under test;software debugging","","29","","31","","24 Apr 2012","","","IEEE","IEEE Journals"
"Governing Software Process Improvementsin Globally Distributed Product Development","N. Ramasubbu","Joseph M. Katz Graduate School of Business, University of Pittsburgh, 354 Mervis Hall, Pittsburgh","IEEE Transactions on Software Engineering","31 Mar 2014","2014","40","3","235","250","Continuous software process improvement (SPI) practices have been extensively prescribed to improve performance of software projects. However, SPI implementation mechanisms have received little scholarly attention, especially in the context of distributed software product development. We took an action research approach to study the SPI journey of a large multinational enterprise that adopted a distributed product development strategy. We describe the interventions and action research cycles enacted over a period of five years in collaboration with the firm, which resulted in a custom SPI framework that catered to both the social and technical needs of the firm's distributed teams. Institutionalizing the process maturity framework got stalled initially because the SPI initiatives were perceived by product line managers as a mechanism for exercising wider controls by the firm's top management. The implementation mechanism was subsequently altered to co-opt product line managers, which contributed to a wider adoption of the SPI framework. Insights that emerge from our analysis of the firm's SPI journey pertain to the integration of the technical and social views of software development, preserving process diversity through the use of a multi-tiered, non-blueprint approach to SPI, the linkage between key process areas and project control modes, and the role of SPI in aiding organizational learning.","1939-3520","","10.1109/TSE.2013.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6682900","Software process improvement (SPI);distributed teams;software engineering;process control;action research","Software;Product development;Process control;Benchmark testing;ISO standards;Resource management;Quality management","software management;software process improvement;software product lines","software process improvements;globally distributed software product development strategy;software project performance;large multinational enterprise;custom SPI framework;process maturity framework;product line managers;firm top management;multitiered nonblueprint approach;project control modes;organizational learning;action research approach","","42","","93","","12 Dec 2013","","","IEEE","IEEE Journals"
"Swarm Verification Techniques","G. J. Holzmann; R. Joshi; A. Groce","California Institute of Technology, Pasadena; California Institute of Technology, Pasadena; Oregon State University, Corvallis","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","845","857","The range of verification problems that can be solved with logic model checking tools has increased significantly in the last few decades. This increase in capability is based on algorithmic advances and new theoretical insights, but it has also benefitted from the steady increase in processing speeds and main memory sizes on standard computers. The steady increase in processing speeds, though, ended when chip-makers started redirecting their efforts to the development of multicore systems. For the near-term future, we can anticipate the appearance of systems with large numbers of CPU cores, but without matching increases in clock-speeds. We will describe a model checking strategy that can allow us to leverage this trend and that allows us to tackle significantly larger problem sizes than before.","1939-3520","","10.1109/TSE.2010.110","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5661793","Software engineering tools and techniques;logic model checking;distributed algorithms;software verification.","Memory management;Formal verification;Search problems;Computational modeling;Multicore processing;Data models;Parallel processing","formal verification;multiprocessing systems","swarm verification techniques;logic model checking tools;multicore system development;CPU cores","","49","","22","","10 Dec 2010","","","IEEE","IEEE Journals"
"Verifying Protocol Conformance Using Software Model Checking for the Model-Driven Development of Embedded Systems","Y. Moffett; J. Dingel; A. Beaulieu","CF 18 Avionics System Engineering, Ottawa; Queens University, Kingston; Royal Military College, Kingston","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1307","13256","To facilitate modular development, the use of state machines has been proposed to specify the protocol (i.e., the sequence of messages) that each port of a component can engage in. The protocol conformance checking problem consists of determining whether the actual behavior of a component conforms to the protocol specifications on its ports. In this paper, we consider this problem in the context of the model-driven development (MDD) of embedded systems based on UML 2, in which UML 2 state machines are used to specify component behavior. We provide a definition of conformance which slightly extends those found in the literature and reduce the conformance check to a state space exploration. We describe a tool implementing the approach using the Java PathFinder software model checker and the MDD tool IBM Rational RoseRT, discuss its application to three case studies, and show how the tool repeatedly allowed us to find unexpected conformance errors with encouraging performance. We conclude that the approach is promising for supporting the modular development of embedded components in the context of industrial applications of MDD.","1939-3520","","10.1109/TSE.2013.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6482140","Component-based software engineering;behavioral interface specifications;software modeling;model-driven development;formal specification and verification;software model checking","Unified modeling language;Protocols;Ports (Computers);Software;Safety;Context;Java","embedded systems;formal verification;object-oriented programming;Unified Modeling Language","protocol conformance verification;software model checking;model-driven development;embedded system;protocol conformance checking problem;UML 2 state machines;Unified Modeling Language;state space exploration;Java PathFinder software model checker;IBM Rational RoseRT MDD tool;MDD industrial application","","2","","47","","19 Mar 2013","","","IEEE","IEEE Journals"
"Construction and Validation of an Instrument for Measuring Programming Skill","G. R. Bergersen; D. I. K. Sjøberg; T. Dybå","Department of Informatics, University of Oslo, Oslo, Norway; Department of Informatics, University of Oslo, Oslo, Norway; Department of Informatics, University of Oslo and SINTEF, Norway","IEEE Transactions on Software Engineering","12 Dec 2014","2014","40","12","1163","1184","Skilled workers are crucial to the success of software development. The current practice in research and industry for assessing programming skills is mostly to use proxy variables of skill, such as education, experience, and multiple-choice knowledge tests. There is as yet no valid and efficient way to measure programming skill. The aim of this research is to develop a valid instrument that measures programming skill by inferring skill directly from the performance on programming tasks. Over two days, 65 professional developers from eight countries solved 19 Java programming tasks. Based on the developers' performance, the Rasch measurement model was used to construct the instrument. The instrument was found to have satisfactory (internal) psychometric properties and correlated with external variables in compliance with theoretical expectations. Such an instrument has many implications for practice, for example, in job recruitment and project allocation.","1939-3520","","10.1109/TSE.2014.2348997","Research Laboratory and the Research Council of Norway through; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6882243","Skill;programming;performance;instrument;measurement;empirical software engineering","Programming profession;Software development;Personnel;Software quality;Software design","Java;personnel;software development management","programming skill measurement;skilled workers;software development;proxy variables;multiple-choice knowledge tests;programming tasks;professional developers;Java programming tasks;Rasch measurement model;psychometric properties;job recruitment;project allocation","","22","","130","","22 Aug 2014","","","IEEE","IEEE Journals"
"Coordination Breakdowns and Their Impact on Development Productivity and Software Failures","M. Cataldo; J. D. Herbsleb","Robert Bosch LLC; Carnegie Mellon University, Pittsburgh","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","343","360","The success of software development projects depends on carefully coordinating the effort of many individuals across the multiple stages of the development process. In software engineering, modularization is the traditional technique intended to reduce the interdependencies among modules that constitute a system. Reducing technical dependencies, the theory argues, results in a reduction of work dependencies between teams developing interdependent modules. Although that research stream has been quite influential, it considers a static view of the problem of coordination in engineering activities. Building on a dynamic view of coordination, we studied the relationship between socio-technical congruence and software quality and development productivity. In order to investigate the generality of our findings, our analyses were performed on two large-scale projects from two companies with distinct characteristics in terms of product and process maturity. Our results revealed that the gaps between coordination requirements and the actual coordination activities carried out by the developers significantly increased software failures. Our analyses also showed that higher levels of congruence are associated with improved development productivity. Finally, our results showed the congruence between dependencies and coordinative actions is critical both in mature development settings as well as in novel and dynamic development contexts.","1939-3520","","10.1109/TSE.2012.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6205767","Metrics/measurement;productivity;organizational management and coordination;quality analysis and evaluation","Productivity;Programming;Software quality;Context;Complexity theory;Organizations","software metrics;software quality;software reliability","coordination breakdowns;development productivity;software failures;software development projects;development process;software engineering;modularization;technical dependency;work dependency;interdependent modules;engineering activity;socio-technical congruence;software quality;large-scale projects;product maturity;process maturity;coordination requirements;coordination activity;dynamic development contexts","","60","","78","","29 May 2012","","","IEEE","IEEE Journals"
"On the Effectiveness of Contracts as Test Oracles in the Detection and Diagnosis of Functional Faults in Concurrent Object-Oriented Software","W. Araujo; L. C. Briand; Y. Labiche","Juniper Networks, 1194 N Mathilda Ave, Sunnyvale, CA 94089; SnT Centre, University of Luxembourg, 6, rue Richard Coudenhove-Kalergi, L-1359 Luxembourg-Kirchberg, Luxembourg; Systems and Computer Engineering Department, Carleton University, 1125 Colonel By Drive, Ottawa, Canada","IEEE Transactions on Software Engineering","9 Oct 2014","2014","40","10","971","992","Design by contract (DbC) is a software development methodology that focuses on clearly defining the interfaces between components to produce better quality object-oriented software. Though there exists ample support for DbC for sequential programs, applying DbC to concurrent programs presents several challenges. Using Java as the target programming language, we tackle such challenges by augmenting the Java Modelling Language (JML) and modifying the JML compiler (jmlc) to generate runtime assertion checking code to support DbC in concurrent programs. We applied our solution in a carefully designed case study on a highly concurrent industrial software system from the telecommunications domain to assess the effectiveness of contracts as test oracles in detecting and diagnosing functional faults in concurrent software. Based on these results, clear and objective requirements are defined for contracts to be effective test oracles for concurrent programs whilst balancing the effort to design them. Effort is measured indirectly through the contract complexity measure (CCM), a measure we define. Main results include that contracts of a realistic level of completeness and complexity can detect around 76 percent of faults and reduce the diagnosis effort for such faults tenfold. We, therefore, show that DbC can be applied to concurrent software and can be a valuable tool to improve the economics of software engineering.","1939-3520","","10.1109/TSE.2014.2339829","Juniper Networks; Luxembourg's National Research Fund; NSERC Discovery; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6857355","Software/Program Verification¿Programming by contract;Software Quality/SQA¿Measurement applied to SQA and V&V;Concurrent programming;object-oriented programming","Contracts;Java;Concurrent computing;Programming;Software;Message systems;Interference","concurrency control;contracts;fault diagnosis;Java;object-oriented methods;parallel programming;program compilers;program testing;software quality;software reliability","design by contract;software development methodology;object-oriented software quality;DbC;sequential programs;concurrent programs;target programming language;Java modelling language;JML compiler;JMLC;runtime assertion checking code;concurrent industrial software system;telecommunication domain;test oracles;functional fault diagnosing;functional fault detection;concurrent software;contract complexity measure;CCM;software engineering","","7","","39","","16 Jul 2014","","","IEEE","IEEE Journals"
"A Survey on Load Testing of Large-Scale Software Systems","Z. M. Jiang; A. E. Hassan","Department of Electrical Engineering and Computer ScienceSoftware Construction, AnaLytics and Evaluation (SCALE) Lab, York University, Toronto, ON, Canada; Software Analysis and Intelligence (SAIL) Lab, School of Computing, Kingston, ON, Canada","IEEE Transactions on Software Engineering","10 Nov 2015","2015","41","11","1091","1118","Many large-scale software systems must service thousands or millions of concurrent requests. These systems must be load tested to ensure that they can function correctly under load (i.e., the rate of the incoming requests). In this paper, we survey the state of load testing research and practice. We compare and contrast current techniques that are used in the three phases of a load test: (1) designing a proper load, (2) executing a load test, and (3) analyzing the results of a load test. This survey will be useful for load testing practitioners and software engineering researchers with interest in the load testing of large-scale software systems.","1939-3520","","10.1109/TSE.2015.2445340","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7123673","Software Testing;Load Testing;Software Quality;Software testing;load testing;software quality;large-scale software systems;survey","Testing;Stress;Computer bugs;Robustness;Software systems;Stress measurement","program testing;software quality","load testing;large-scale software systems;concurrent requests;load testing research;contrast current techniques;software engineering researchers","","45","","196","","15 Jun 2015","","","IEEE","IEEE Journals"
"On the Evolution of Services","V. Andrikopoulos; S. Benbernou; M. P. Papazoglou","IAAS, University of Stuttgart, Stuttgart; Université Paris Descartes, Paris; ERISS, Tilburg University, Tilburg","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","609","628","In an environment of constant change and variation driven by competition and innovation, a software service can rarely remain stable. Being able to manage and control the evolution of services is therefore an important goal for the Service-Oriented paradigm. This work extends existing and widely adopted theories from software engineering, programming languages, service-oriented computing, and other related fields to provide the fundamental ingredients required to guarantee that spurious results and inconsistencies that may occur due to uncontrolled service changes are avoided. The paper provides a unifying theoretical framework for controlling the evolution of services that deals with structural, behavioral, and QoS level-induced service changes in a type-safe manner, ensuring correct versioning transitions so that previous clients can use a versioned service in a consistent manner.","1939-3520","","10.1109/TSE.2011.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5728828","Services engineering;service evolution;versioning;service compatibility.","XML;Guidelines;Protocols;Business;Availability;Quality of service;Software","service-oriented architecture;Web services","software service;service-oriented paradigm;software engineering;programming languages;service-oriented computing","","75","","55","","10 Mar 2011","","","IEEE","IEEE Journals"
"Does Software Process Improvement Reduce the Severity of Defects? A Longitudinal Field Study","D. E. Harter; C. F. Kemerer; S. A. Slaughter","Syracuse University, Syracuse; University of Pittsburgh, Pittsburgh and King Abdul Aziz University, Saudi Arabia; Georgia Institute of Technology, Atlanta","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","810","827","As firms increasingly rely on information systems to perform critical functions, the consequences of software defects can be catastrophic. Although the software engineering literature suggests that software process improvement can help to reduce software defects, the actual evidence is equivocal. For example, improved development processes may only remove the “easier” syntactical defects, while the more critical defects remain. Rigorous empirical analyses of these relationships have been very difficult to conduct due to the difficulties in collecting the appropriate data on real systems from industrial organizations. This field study analyzes a detailed data set consisting of 7,545 software defects that were collected on software projects completed at a major software firm. Our analyses reveal that higher levels of software process improvement significantly reduce the likelihood of high severity defects. In addition, we find that higher levels of process improvement are even more beneficial in reducing severe defects when the system developed is large or complex, but are less beneficial in development when requirements are ambiguous, unclear, or incomplete. Our findings reveal the benefits and limitations of software process improvement for the removal of severe defects and suggest where investments in improving development processes may have their greatest effects.","1939-3520","","10.1109/TSE.2011.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928358","Software complexity;defect severity;requirements ambiguity;software process;CMM","Complexity theory;Production;Coordinate measuring machines;Testing;Software quality;Programming","program debugging;software process improvement","software process improvement;longitudinal field study;information systems;software defects;software engineering literature;syntactical defects;critical defects;severe defects","","29","","68","","23 Jun 2011","","","IEEE","IEEE Journals"
"Embedding, Evolution, and Validation of Model-Driven Spreadsheets","J. Cunha; J. P. Fernandes; J. Mendes; J. Saraiva","Universidade Nova de Lisboa, Portugal, and HASLab / INESC TEC, Portugal; (rel)ease/Universidade da Beira Interior, Portugal, and HASLab / INESC TEC, Portugal; Universidade do Minho & ESTGF, Instituto Politécnico do Porto, Portugal, and HASLab / INESC TEC, Portugal; Universidade do Minho, Portugal, and HASLab / INESC TEC, Portugal","IEEE Transactions on Software Engineering","11 Mar 2015","2015","41","3","241","263","This paper proposes and validates a model-driven software engineering technique for spreadsheets. The technique that we envision builds on the embedding of spreadsheet models under a widely used spreadsheet system. This means that we enable the creation and evolution of spreadsheet models under a spreadsheet system. More precisely, we embed ClassSheets, a visual language with a syntax similar to the one offered by common spreadsheets, that was created with the aim of specifying spreadsheets. Our embedding allows models and their conforming instances to be developed under the same environment. In practice, this convenient environment enhances evolution steps at the model level while the corresponding instance is automatically co-evolved. Finally, we have designed and conducted an empirical study with human users in order to assess our technique in production environments. The results of this study are promising and suggest that productivity gains are realizable under our model-driven spreadsheet development setting.","1939-3520","","10.1109/TSE.2014.2361141","European Regional Development; FCT; cão para a Ciência e a Tecnologia; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6915751","Spreadsheets;Models;ClassSheets;Embedding;Evolution;Empirical Validation;Spreadsheets;models;ClassSheets;embedding;evolution;empirical validation","Data models;Visualization;Atmospheric modeling;Business;Software;Unified modeling language;Syntactics","software development management;spreadsheet programs;visual languages","model driven software engineering technique;spreadsheet model embedding;spreadsheet system;spreadsheet model evolution;ClassSheets;visual language;syntax;model-driven spreadsheet development;spreadsheet model validation","","10","","66","","2 Oct 2014","","","IEEE","IEEE Journals"
"BLISS: Improved Symbolic Execution by Bounded Lazy Initialization with SAT Support","N. Rosner; J. Geldenhuys; N. M. Aguirre; W. Visser; M. F. Frias","Department of Computer Science, FCEyN, Universidad de Buenos Aires, Buenos Aires, Argentina; Department of Computer Science, University of Stellenbosch, Stellenbosch, South Africa; Department of Computer Science, FCEFQyN, Universidad Nacional de Rio Cuarto, and CONICET, Río Cuarto, Argentina; Department of Computer Science, University of Stellenbosch, Stellenbosch, South Africa; Department of Software Engineering, Instituto Tecnológico de Buenos Aires, and CONICET, Buenos Aires, Argentina","IEEE Transactions on Software Engineering","14 Jul 2015","2015","41","7","639","660","Lazy Initialization (LI) allows symbolic execution to effectively deal with heap-allocated data structures, thanks to a significant reduction in spurious and redundant symbolic structures. Bounded lazy initialization (BLI) improves on LI by taking advantage of precomputed relational bounds on the interpretation of class fields in order to reduce the number of spurious structures even further. In this paper we present bounded lazy initialization with SAT support (BLISS), a novel technique that refines the search for valid structures during the symbolic execution process. BLISS builds upon BLI, extending it with field bound refinement and satisfiability checks. Field bounds are refined while a symbolic structure is concretized, avoiding cases that, due to the concrete part of the heap and the field bounds, can be deemed redundant. Satisfiability checks on refined symbolic heaps allow us to prune these heaps as soon as they are identified as infeasible, i.e., as soon as it can be confirmed that they cannot be extended to any valid concrete heap. Compared to LI and BLI, BLISS reduces the time required by LI by up to four orders of magnitude for the most complex data structures. Moreover, the number of partially symbolic structures obtained by exploring program paths is reduced by BLISS by over 50 percent, with reductions of over 90 percent in some cases (compared to LI). BLISS uses less memory than LI and BLI, which enables the exploration of states unreachable by previous techniques.","1939-3520","","10.1109/TSE.2015.2389225","NPRP; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7004061","Symbolic execution;lazy initialization;tight field bounds;Symbolic PathFinder","Concrete;Binary trees;Java;Periodic structures;Software","computability;data structures;program verification","BLISS;symbolic execution;bounded lazy initialization with SAT support;heap-allocated data structures;symbolic structures;relational bounds;class fields;field bound refinement;satisfiability check;symbolic heap;program path","","10","","26","","7 Jan 2015","","","IEEE","IEEE Journals"
"How Effectively Does Metamorphic Testing Alleviate the Oracle Problem?","H. Liu; F. Kuo; D. Towey; T. Y. Chen","Australia-India Centre for Automation Software Engineering, RMIT University, Melbourne 3001 VIC, Australia; Faculty of Information and Communication Technologies, Swinburne University of Technology, Hawthorn 3122 VIC, Australia; Division of Computer Science, The University of Nottingham, Ningbo, China; Faculty of Information and Communication Technologies, Swinburne University of Technology, Hawthorn 3122 VIC, Australia","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","1","4","22","In software testing, something which can verify the correctness of test case execution results is called an oracle. The oracle problem occurs when either an oracle does not exist, or exists but is too expensive to be used. Metamorphic testing is a testing approach which uses metamorphic relations, properties of the software under test represented in the form of relations among inputs and outputs of multiple executions, to help verify the correctness of a program. This paper presents new empirical evidence to support this approach, which has been used to alleviate the oracle problem in various applications and to enhance several software analysis and testing techniques. It has been observed that identification of a sufficient number of appropriate metamorphic relations for testing, even by inexperienced testers, was possible with a very small amount of training. Furthermore, the cost-effectiveness of the approach could be enhanced through the use of more diverse metamorphic relations. The empirical studies presented in this paper clearly show that a small number of diverse metamorphic relations, even those identified in an ad hoc manner, had a similar fault-detection capability to a test oracle, and could thus effectively help alleviate the oracle problem.","1939-3520","","10.1109/TSE.2013.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613484","Software testing;test oracle;oracle problem;metamorphic testing;metamorphic relation","Computer crashes;Software;Educational institutions;Software testing;Training;Benchmark testing","program diagnostics;program testing;software fault tolerance;software quality","metamorphic testing;oracle problem;software testing;metamorphic relations;software properties;program correctness;software analysis;fault-detection capability","","91","","42","","27 Sep 2013","","","IEEE","IEEE Journals"
"Bidirectional Symbolic Analysis for Effective Branch Testing","M. Baluda; G. Denaro; M. Pezzè","Secure Software Engineering Group, Fraunhofer SIT, Darmstadt, Germany; Department of Informatics, Systems and Communication, Università di Milano-Bicocca, Milano, Italy; Faculty of Informatics, Università della Svizzera italiana, Lugano, Switzerland","IEEE Transactions on Software Engineering","12 May 2016","2016","42","5","403","426","Structural coverage metrics, and in particular branch coverage, are popular approaches to measure the thoroughness of test suites. Unfortunately, the presence of elements that are not executable in the program under test and the difficulty of generating test cases for rare conditions impact on the effectiveness of the coverage obtained with current approaches. In this paper, we propose a new approach that combines symbolic execution and symbolic reachability analysis to improve the effectiveness of branch testing. Our approach embraces the ideal definition of branch coverage as the percentage of executable branches traversed with the test suite, and proposes a new bidirectional symbolic analysis for both testing rare execution conditions and eliminating infeasible branches from the set of test objectives. The approach is centered on a model of the analyzed execution space. The model identifies the frontier between symbolic execution and symbolic reachability analysis, to guide the alternation and the progress of bidirectional analysis towards the coverage targets. The experimental results presented in the paper indicate that the proposed approach can both find test inputs that exercise rare execution conditions that are not identified with state-of-the-art approaches and eliminate many infeasible branches from the coverage measurement. It can thus produce a modified branch coverage metric that indicates the amount of feasible branches covered during testing, and helps team leaders and developers in estimating the amount of not-yet-covered feasible branches. The approach proposed in this paper suffers less than the other approaches from particular cases that may trap the analysis in unbounded loops.","1939-3520","","10.1109/TSE.2015.2490067","SNF; AVATAR; Italian PRIN; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7296670","Structural testing;branch coverage;program analysis;symbolic execution;symbolic reachability analysis","Analytical models;Testing;Reachability analysis;Valves;Computational modeling;Measurement;Concrete","program diagnostics;program testing","bidirectional symbolic analysis;branch testing;structural coverage metrics;branch coverage;test suite thoroughness measure;test case generation;symbolic execution;symbolic reachability analysis;test objectives;coverage measurement","","10","","137","","12 Oct 2015","","","IEEE","IEEE Journals"
"Dynamic Testing for Deadlocks via Constraints","Y. Cai; Q. Lu","State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing, China; Technology Center of Software Engineering, Institute of Software, Chinese Academy of Sciences, Beijing, China","IEEE Transactions on Software Engineering","15 Sep 2016","2016","42","9","825","842","Existing deadlock detectors are either not scalable or may report false positives when suggesting cycles as potential deadlocks. Additionally, they may not effectively trigger deadlocks and handle false positives. We propose a technique called ConLock+, which firstly analyzes each cycle and its corresponding execution to identify a set of scheduling constraints that are necessary conditions to trigger the corresponding deadlock. The ConLock+ technique then performs a second run to enforce the set of constraints, which will trigger a deadlock if the cycle is a real one. Or if not, ConLock+ reports a steering failure for that cycle and also identifies other similar cycles which would also produce steering failures. For each confirmed deadlock, ConLock+ performs a static analysis to identify conflicting memory access that would also contribute to the occurrence of the deadlock. This analysis is helpful to enable developers to understand and fix deadlocks. ConLock+ has been validated on a suite of real-world programs with 16 real deadlocks. The results show that across all 811 cycles, ConLock+ confirmed all of the 16 deadlocks with a probability of ≥80 percent. For the remaining cycles, ConLock+ reported steering failures and also identified that five deadlocks also involved conflicting memory accesses.","1939-3520","","10.1109/TSE.2016.2537335","National Basic Research (973) Program of China; National Science Foundation of China (NSFC); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7423814","Deadlock triggering;scheduling;should-happen-before relation;constraint;reliability;verification","System recovery;Instruction sets;Schedules;Testing;Synchronization;Detectors;Probabilistic logic","concurrency control;program diagnostics;program testing;scheduling","static analysis;memory access;real-world programs;steering failure;scheduling constraints;ConLock+;deadlock detectors;dynamic testing","","10","","55","","2 Mar 2016","","","IEEE","IEEE Journals"
"An Industrial Survey of Safety Evidence Change Impact Analysis Practice","J. L. de la Vara; M. Borg; K. Wnuk; L. Moonen","Computer Science Department, Carlos III University of Madrid, Avda. de la Universidad 30, 28911 Leganes, Madrid, Spain; Software and Systems Laboratory, SICS Swedish ICT AB, Ideon Science Park, Building Beta 2, Scheelevägen 17, Lund, Sweden; Software Engineering Research Lab, Blekinge Institute of Technology, Karlskrona, Sweden; Certus Centre for Software V&V, Simula Research Laboratory, P.O. Box 134, Lysaker, Norway","IEEE Transactions on Software Engineering","8 Dec 2016","2016","42","12","1095","1117","Context. In many application domains, critical systems must comply with safety standards. This involves gathering safety evidence in the form of artefacts such as safety analyses, system specifications, and testing results. These artefacts can evolve during a system's lifecycle, creating a need for change impact analysis to guarantee that system safety and compliance are not jeopardised. Objective. We aim to provide new insights into how safety evidence change impact analysis is addressed in practice. The knowledge about this activity is limited despite the extensive research that has been conducted on change impact analysis and on safety evidence management. Method. We conducted an industrial survey on the circumstances under which safety evidence change impact analysis is addressed, the tool support used, and the challenges faced. Results. We obtained 97 valid responses representing 16 application domains, 28 countries, and 47 safety standards. The respondents had most often performed safety evidence change impact analysis during system development, from system specifications, and fully manually. No commercial change impact analysis tool was reported as used for all artefact types and insufficient tool support was the most frequent challenge. Conclusion. The results suggest that the different artefact types used as safety evidence co-evolve. In addition, the evolution of safety cases should probably be better managed, the level of automation in safety evidence change impact analysis is low, and the state of the practice can benefit from over 20 improvement areas.","1939-3520","","10.1109/TSE.2016.2553032","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7450627","Safety-critical system;safety evidence;change impact analysis;state of the practice;survey research","Safety;Market research;Best practices;Industries;Standards;Certification","safety-critical software;software standards","industrial survey;safety evidence change impact analysis;SECIA;safety-critical system;safety standard","","30","","71","","11 Apr 2016","","","IEEE","IEEE Journals"
"Quantitative Evaluation of Model-Driven Performance Analysis and Simulation of Component-Based Architectures","F. Brosig; P. Meier; S. Becker; A. Koziolek; H. Koziolek; S. Kounev","Department of Computer Science, University of Würzburg, Am Hubland, Würzburg, Germany; Codecentric AG, Elsenheimerstr. 55a, München, Germany; Department of Software Engineering, University of Paderborn, Zukunftsmeile 1, Paderborn, Germany; Karlsruhe Institute of Technology (KIT), Am Fasanengarten 5, Karlsruhe, Germany; ABB Corporate Research, Wallstadter Str. 59, Ladenburg, Germany; Department of Computer Science, University of Würzburg, Am Hubland, Würzburg, Germany","IEEE Transactions on Software Engineering","10 Feb 2015","2015","41","2","157","175","During the last decade, researchers have proposed a number of model transformations enabling performance predictions. These transformations map performance-annotated software architecture models into stochastic models solved by analytical means or by simulation. However, so far, a detailed quantitative evaluation of the accuracy and efficiency of different transformations is missing, making it hard to select an adequate transformation for a given context. This paper provides an in-depth comparison and quantitative evaluation of representative model transformations to, e.g., queueing petri nets and layered queueing networks. The semantic gaps between typical source model abstractions and the different analysis techniques are revealed. The accuracy and efficiency of each transformation are evaluated by considering four case studies representing systems of different size and complexity. The presented results and insights gained from the evaluation help software architects and performance engineers to select the appropriate transformation for a given context, thus significantly improving the usability of model transformations for performance prediction.","1939-3520","","10.1109/TSE.2014.2362755","DFG; Collaborative Research Center “On-The-Fly Computing”; DFG; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6920061","D.2.11 Software architectures;D.2.10.h Quality analysis and evaluation;D.2.2 Design tools and techniques;Software architectures;quality analysis and evaluation;design tools and techniques","Unified modeling language;Analytical models;Predictive models;Phase change materials;Accuracy;Stochastic processes;Software architecture","object-oriented programming;software architecture;software performance evaluation;stochastic processes","quantitative evaluation;model-driven performance analysis;component-based architectures;performance predictions;transformations map performance-annotated software architecture models;stochastic models;representative model transformations;semantic gaps;source model abstractions","","37","","50","","13 Oct 2014","","","IEEE","IEEE Journals"
"Nopol: Automatic Repair of Conditional Statement Bugs in Java Programs","J. Xuan; M. Martinez; F. DeMarco; M. Clément; S. L. Marcote; T. Durieux; D. Le Berre; M. Monperrus","State Key Lab of Software Engineering, School of Computer, Wuhan University, Wuhan, China; Faculty of Informatics, University of Lugano, Lugano, Switzerland; University of Buenos Aires, Buenos Aires, Argentina; Department of Computer Science, University of Lille, Lille, France; University of Buenos Aires, Buenos Aires, Argentina; Department of Computer Science, University of Lille, Lille, France; University of Artois & CNRS, Lens, France; University of Lille & INRIA, Lille, France","IEEE Transactions on Software Engineering","9 Jan 2017","2017","43","1","34","55","We propose Nopol, an approach to automatic repair of buggy conditional statements (i.e., if-then-else statements). This approach takes a buggy program as well as a test suite as input and generates a patch with a conditional expression as output. The test suite is required to contain passing test cases to model the expected behavior of the program and at least one failing test case that reveals the bug to be repaired. The process of Nopol consists of three major phases. First, Nopol employs angelic fix localization to identify expected values of a condition during the test execution. Second, runtime trace collection is used to collect variables and their actual values, including primitive data types and objected-oriented features (e.g., nullness checks), to serve as building blocks for patch generation. Third, Nopol encodes these collected data into an instance of a Satisfiability Modulo Theory (SMT) problem; then a feasible solution to the SMT instance is translated back into a code patch. We evaluate Nopol on 22 real-world bugs (16 bugs with buggy if conditions and six bugs with missing preconditions) on two large open-source projects, namely Apache Commons Math and Apache Commons Lang. Empirical analysis on these bugs shows that our approach can effectively fix bugs with buggy if conditions and missing preconditions. We illustrate the capabilities and limitations of Nopol using case studies of real bug fixes.","1939-3520","","10.1109/TSE.2016.2560811","INRIA Internship program; INRIA postdoctoral research fellowship; CNRS delegation program; National Natural Science Foundation of China; Young Talent Development Program of the China Computer Federation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7463060","Automatic repair;patch generation;SMT;fault localization","Maintenance engineering;Computer bugs;Runtime;Java;Encoding;Open source software;Indexes","computability;Java;object-oriented programming;program debugging;public domain software;software fault tolerance;software maintenance","Nopol;automatic conditional statement bug repairing;Java programs;buggy program;conditional expression;angelic fix localization;test execution;runtime trace collection;objected-oriented features;patch generation;satisfiability modulo theory problem;SMT problem;code patch;buggy IF conditions;open-source projects;Apache Commons Math;Apache Commons Lang","","100","","56","","29 Apr 2016","","","IEEE","IEEE Journals"
"Metamorphic Testing for Software Quality Assessment: A Study of Search Engines","Z. Q. Zhou; S. Xiang; T. Y. Chen","School of Computing and Information Technology, University of Wollongong, Wollongong, NSW, Australia; School of Computing and Information Technology, University of Wollongong, Wollongong, NSW, Australia; Department of Computer Science and Software Engineering, Swinburne University of Technology, Hawthorn, Victoria, Australia","IEEE Transactions on Software Engineering","11 Mar 2016","2016","42","3","264","284","Metamorphic testing is a testing technique that can be used to verify the functional correctness of software in the absence of an ideal oracle. This paper extends metamorphic testing into a user-oriented approach to software verification, validation, and quality assessment, and conducts large scale empirical studies with four major web search engines: Google, Bing, Chinese Bing, and Baidu. These search engines are very difficult to test and assess using conventional approaches owing to the lack of an objective and generally recognized oracle. The results are useful for both search engine developers and users, and demonstrate that our approach can effectively alleviate the oracle problem and challenges surrounding a lack of specifications when verifying, validating, and evaluating large and complex software systems.","1939-3520","","10.1109/TSE.2015.2478001","Australian Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7254235","Software quality;verification;validation;quality assessment;oracle problem;lack of system specification;metamorphic testing;user-oriented testing;search engine;Software quality;verification;validation;quality assessment;oracle problem;lack of system specification;metamorphic testing;user-oriented testing;search engine","Search engines;Testing;Web pages;Google;Software algorithms;Software quality","Internet;program testing;program verification;search engines;software quality;user interfaces","metamorphic testing;software quality assessment;user-oriented approach;software verification;software validation;Web search engines;Google;Chinese Bing;Baidu","","53","","53","","10 Sep 2015","","","IEEE","IEEE Journals"
"Overcoming the Equivalent Mutant Problem: A Systematic Literature Review and a Comparative Experiment of Second Order Mutation","L. Madeyski; W. Orzeszyna; R. Torkar; M. Józala","Institute of Informatics, Wroclaw University of Technology, Wyb. Wyspianskiego 27, Poland; Institute of Informatics, Wroclaw University of Technology, Poland; Division of Software Engineering , Department of Computer Science and Engineering, Chalmers University of Technology , SE-41296, Sweden; Institute of Informatics, Wroclaw University of Technology, Wyb. Wyspianskiego 27, Poland","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","1","23","42","Context. The equivalent mutant problem (EMP) is one of the crucial problems in mutation testing widely studied over decades. Objectives. The objectives are: to present a systematic literature review (SLR) in the field of EMP; to identify, classify and improve the existing, or implement new, methods which try to overcome EMP and evaluate them. Method. We performed SLR based on the search of digital libraries. We implemented four second order mutation (SOM) strategies, in addition to first order mutation (FOM), and compared them from different perspectives. Results. Our SLR identified 17 relevant techniques (in 22 articles) and three categories of techniques: detecting (DEM); suggesting (SEM); and avoiding equivalent mutant generation (AEMG). The experiment indicated that SOM in general and JudyDiffOp strategy in particular provide the best results in the following areas: total number of mutants generated; the association between the type of mutation strategy and whether the generated mutants were equivalent or not; the number of not killed mutants; mutation testing time; time needed for manual classification. Conclusions . The results in the DEM category are still far from perfect. Thus, the SEM and AEMG categories have been developed. The JudyDiffOp algorithm achieved good results in many areas.","1939-3520","","10.1109/TSE.2013.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613487","Mutation testing;equivalent mutant problem;higher order mutation;second order mutation","Testing;Systematics;Educational institutions;Databases;Libraries;Java;Informatics","digital libraries;program testing","JudyDiffOp strategy;SEM;DEM;AEMG;avoiding equivalent mutant generation;suggesting;detecting;FOM;first order mutation;SOM strategies;digital libraries;SLR;mutation testing;EMP;second order mutation;comparative experiment;systematic literature review;equivalent mutant problem","","80","","79","","27 Sep 2013","","","IEEE","IEEE Journals"
"Detecting, Tracing, and Monitoring Architectural Tactics in Code","M. Mirakhorli; J. Cleland-Huang","Department of Software Engineering, Rochester, NY; School of Computing, Chicago, IL","IEEE Transactions on Software Engineering","11 Mar 2016","2016","42","3","205","220","Software architectures are often constructed through a series of design decisions. In particular, architectural tactics are selected to satisfy specific quality concerns such as reliability, performance, and security. However, the knowledge of these tactical decisions is often lost, resulting in a gradual degradation of architectural quality as developers modify the code without fully understanding the underlying architectural decisions. In this paper we present a machine learning approach for discovering and visualizing architectural tactics in code, mapping these code segments to tactic traceability patterns, and monitoring sensitive areas of the code for modification events in order to provide users with up-to-date information about underlying architectural concerns. Our approach utilizes a customized classifier which is trained using code extracted from fifty performance-centric and safety-critical open source software systems. Its performance is compared against seven off-the-shelf classifiers. In a controlled experiment all classifiers performed well; however our tactic detector outperformed the other classifiers when used within the larger context of the Hadoop Distributed File System. We further demonstrate the viability of our approach for using the automatically detected tactics to generate viable and informative messages in a simulation of maintenance events mined from Hadoop's change management system.","1939-3520","","10.1109/TSE.2015.2479217","US National Science Foundation; Research Experience for Undergraduates; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7270338","Architecture;traceability;tactics;traceability information models;Architecture;traceability;tactics;traceability information models","Heart beat;Monitoring;Detectors;Reliability;Biomedical monitoring;Authentication","learning (artificial intelligence);pattern classification;program diagnostics;public domain software;software architecture;system monitoring","code architectural tactics monitoring;code architectural tactics detection;code architectural tactics tracing;machine learning;code architectural tactics visualization;tactic traceability patterns;performance-centric software systems;safety-critical open source software systems;off-the-shelf classifiers;Hadoop Distributed File System;Hadoops change management system","","32","","73","","16 Sep 2015","","","IEEE","IEEE Journals"
"Finding and Evaluating the Performance Impact of Redundant Data Access for Applications that are Developed Using Object-Relational Mapping Frameworks","T. Chen; W. Shang; Z. M. Jiang; A. E. Hassan; M. Nasser; P. Flora","Software Analysis and Intelligence Lab, School of Computing, Queen's University, Kingston, ON, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada; Department of Electrical Engineering and Computer Science, York University, Toronto, ON, Canada; Software Analysis and Intelligence Lab, School of Computing, Queen's University, Kingston, ON, Canada; BlackBerry, Waterloo, ON, Canada; BlackBerry, Waterloo, ON, Canada","IEEE Transactions on Software Engineering","8 Dec 2016","2016","42","12","1148","1161","Developers usually leverage Object-Relational Mapping (ORM) to abstract complex database accesses for large-scale systems. However, since ORM frameworks operate at a lower-level (i.e., data access), ORM frameworks do not know how the data will be used when returned from database management systems (DBMSs). Therefore, ORM cannot provide an optimal data retrieval approach for all applications, which may result in accessing redundant data and significantly affect system performance. Although ORM frameworks provide ways to resolve redundant data problems, due to the complexity of modern systems, developers may not be able to locate such problems in the code; hence, may not proactively resolve the problems. In this paper, we propose an automated approach, which we implement as a Java framework, to locate redundant data problems. We apply our framework on one enterprise and two open source systems. We find that redundant data problems exist in 87 percent of the exercised transactions. Due to the large number of detected redundant data problems, we propose an automated approach to assess the impact and prioritize the resolution efforts. Our performance assessment result shows that by resolving the redundant data problems, the system response time for the studied systems can be improved by an average of 17 percent.","1939-3520","","10.1109/TSE.2016.2553039","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7451264","Performance;object-relational mapping (ORM);program analysis;database","Databases;System performance;Java;Computer bugs;Complexity theory;Time factors;Object tracking","database management systems;Java;program diagnostics;public domain software;software performance evaluation","performance impact evaluation;redundant data access;object-relational mapping framework;ORM framework;database abstraction;database management system;DBMS;Java framework;open source system;program analysis","","15","","84","","12 Apr 2016","","","IEEE","IEEE Journals"
"Toward Software Technology 2050","C. Ebert; S. Counsell",Vector Consulting Services; Brunel University,"IEEE Software","11 Jul 2017","2017","34","4","82","88","Software defines the future perhaps more than any other discipline. This special installment of the Software Technology department celebrates 200 issues of IEEE Software and looks ahead. Where are innovative software and IT technologies, products, and services heading? What major future trends can we envisage?","1937-4194","","10.1109/MS.2017.100","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974716","future technology;software development;software engineering","Software development;Complexity theory;Business;Technological innovation","software engineering","software technology;IEEE Software","","6","","5","","11 Jul 2017","","","IEEE","IEEE Magazines"
"A Lightweight Innovation Process for Software-Intensive Product Development","T. Gorschek; S. Fricker; K. Palm; S. Kunsman","Blekinge Institute of Technology , Ronneby; University of Zurich and ABB Switzerland Ltd., Zurich; DanaherMotion Särö AB, Göteborg; ABB Substation Automation Products , Allentown","IEEE Software","31 Dec 2009","2010","27","1","37","45","An innovation process using face-to-face screening and idea refinement with heterogeneous audition teams can enhance the longterm perspective of product planning and development.","1937-4194","","10.1109/MS.2009.164","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5278658","Technology and software product management;requirements engineering;software engineering;product and process innovation model;industry trials;empirical;technology product management;market-driven requirements engineering","Technological innovation;Product development;Refining;Process planning","innovation management;project management;software engineering","lightweight innovation process;software-intensive product development;product planning;heterogeneous audition teams;project management","","33","","23","","6 Oct 2009","","","IEEE","IEEE Magazines"
"Creating Software Product Value in China","S. Barney; G. Hu; A. Aurum; C. Wohlin",Blekinge Institute of Technology; University of New South Wales; University of New South Wales; Blekinge Institute of Technology,"IEEE Software","19 Jun 2009","2009","26","4","84","90","China has become a formidable player and continues to experience strong growth in a dynamic global market for software development. This highly competitive environment makes maximizing the creation of software product value both difficult and important. When looking at a software product, different stakeholder groups-purchasers, users, software managers, and developers-have different notions of value. This study examines the stakeholder perspectives and criteria used to select and prioritize software release requirements in three groups of software development companies: Chinese companies with a domestic market, Chinese companies with an international market, and Western companies operating in China. The results are similar for all three groups, except for after-sales support, which was a significantly greater concern for Chinese companies with an international market.","1937-4194","","10.1109/MS.2009.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076465","China;planning;market-driven software development;requirements analysis;requirements prioritization;requirements selection;scope definition;value-based requirements engineering;value-based software engineering","Costs;Europe;North America;Pricing;Customer satisfaction;Calendars;Software maintenance;Availability;Educational products;Marketing and sales","globalisation;international trade;software engineering;software houses","software product value;China;global market;software development;international market","","11","","14","","19 Jun 2009","","","IEEE","IEEE Magazines"
"How API Documentation Fails","G. Uddin; M. P. Robillard",McGill University; McGill University,"IEEE Software","30 Jun 2015","2015","32","4","68","75","Formal documentation can be a crucial resource for learning to how to use an API. However, producing high-quality documentation can be nontrivial. Researchers investigated how 10 common documentation problems manifested themselves in practice. The results are based on two surveys of a total of 323 professional software developers and analysis of 179 API documentation units. The three severest problems were ambiguity, incompleteness, and incorrectness of content. The respondents often mentioned six of the 10 problems as ""blockers""' that forced them to use another API.","1937-4194","","10.1109/MS.2014.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140676","API;documentation;user study;software engineering;software development","Documentation;Software development;Application programming interfaces;Uniform resource locators;Standards;Databases","application program interfaces;learning (artificial intelligence);software engineering;system documentation","formal documentation;crucial resource;learning;API documentation unit","","58","","6","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Toward Evidence-Based Organizations: Lessons from Embedded Systems, Online Games, and the Internet of Things","J. Bosch; H. H. Olsson",Chalmers University; Malmö University,"IEEE Software","22 Sep 2017","2017","34","5","60","66","More and more software-intensive companies are adopting data-driven development. Across domains, companies increasingly collect and use data to support development and decision-making activities. Case studies investigated how companies in three domains transition toward data-driven development practices in which continuous collection and analysis of data inform R&D and management. The companies in the online-games and Internet-of-Things domains perform more advanced data collection and analysis, but these practices are also rapidly gaining momentum in the companies in the embedded-systems domain. A proposed model details the levels that software-intensive companies typically move through as they evolve from an opinion-based to an evidence-based organization, in which data informs all the company's processes.","1937-4194","","10.1109/MS.2017.3571569","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048636","evidence-based development;data-driven development;data collection;data analysis;decision making;Stairway to Heaven;software engineering;software development","Companies;Data collection;Data analysis;Manuals;Measurement;Decision making","business data processing;computer games;data analysis;decision making;embedded systems;Internet of Things;software engineering","evidence-based organizations;embedded systems;online games;Internet of Things;software-intensive companies;data-driven development;decision-making activities;data analysis","","1","","15","","22 Sep 2017","","","IEEE","IEEE Magazines"
"The Theory of Relative Dependency: Higher Coupling Concentration in Smaller Modules","A. G. Koru; K. El Emam","University of Maryland, Baltimore County; University of Ottawa","IEEE Software","25 Feb 2010","2010","27","2","81","89","Our observations on several large-scale software products has consistently shown that smaller modules are proportionally more defect prone. These findings, challenge the common recommendations from the literature suggesting that quality assurance (QA) and quality control (QC) resources should focus on larger modules. Those recommendations are based on the unfounded assumption that a monotonically increasing linear relationship exists between module size and defects. Given that complexity is correlated with the size.","1937-4194","","10.1109/MS.2010.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420801","software metrics and measurement;product metrics;software science;restructuring;reverse engineering;software maintainability;software quality;SQA;software quality assurance;validation and verification;software engineering","Large-scale systems;Quality assurance;Quality control","modules;quality assurance;quality control;software engineering;software quality","relative dependency theory;higher coupling concentration;large-scale software products;small modules;quality assurance;quality control;large modules;linear relationship;module size","","7","","25","","25 Feb 2010","","","IEEE","IEEE Magazines"
"Process Mass Customization in a Global Software Firm","L. Mathiassen; A. B. Sandberg",Georgia State University; Ericsson AB,"IEEE Software","7 Nov 2014","2014","31","6","62","69","International software firms face particular software process challenges in terms of competing interests and process variations across organizational units and geographical sites. To address this, Ericsson developers applied a general industrial approach to mass customization that focused on four key tactics: adaptive, cosmetic, transparent, and collaborative mass customization. On the basis of this experience, they discovered the strengths, weaknesses, and best deployment conditions for each tactic, and learned several lessons along the way.","1937-4194","","10.1109/MS.2014.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6728934","software engineering;software processes;software tailoring;mass customization","Software development;Mass customization;Product development;Business;Collaboration;Process planning","DP industry;product customisation;software engineering","process mass customization;global software firm;international software firms;software process challenges;Ericsson developers;adaptive mass customization;cosmetic mass customization;transparent mass customization;collaborative mass customization","","4","","8","","30 Jan 2014","","","IEEE","IEEE Magazines"
"Why is Stack Overflow Failing? Preserving Sustainability in Community Question Answering","I. Srba; M. Bielikova",Slovak University of Technology in Bratislava; Slovak University of Technology in Bratislava,"IEEE Software","23 Jun 2016","2016","33","4","80","89","Enormous amounts of knowledge sharing occur every day in community question answering (CQA) sites, some of which (for example, Stack Overflow or Ask Ubuntu) have become popular with software developers and users. In spite of these systems' overall success, problems are emerging in some of them - increased failure and churn rates. To investigate this trend, researchers conducted a case study of Stack Overflow. First, they evaluated the community perception that the emerging problems are heavily related to the growing amount of low-quality content created by undesired groups of users (help vampires, noobs, and reputation collectors). Reproducible data analyses of content and community evolution supported these findings. Suggestions to deal with the emerging problems include providing users with responder-oriented adaptive support that involves a whole community in QA. Such approaches represent an eminent attitude change regarding QA support, with the aim to preserve CQA ecosystems' long-term sustainability.","1937-4194","","10.1109/MS.2016.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7412622","community question answering;question-answering systems;knowledge sharing;computer-supported cooperative work;software engineering;software development","Knowledge discovery;Ecosystems;Software;Market research;Information exchange;Data analysis;Linear regression","data analysis;question answering (information retrieval);social networking (online);software engineering","stack overflow;community question answering sites;CQA sites;failure rates;churn rates;low-quality content;responder-oriented adaptive support;CQA ecosystem long-term sustainability;reproducible data analysis;knowledge sharing","","22","","13","","18 Feb 2016","","","IEEE","IEEE Magazines"
"Searching under the Streetlight for Useful Software Analytics","P. M. Johnson",University of Hawaii at Manoa,"IEEE Software","26 Jun 2013","2013","30","4","57","63","For more than 15 years, researchers at the Collaborative Software Development Laboratory at the University of Hawaii at Manoa have looked for analytics that help developers understand and improve development processes and products. This article reviews that research and discusses the trade-off between studying easily obtained analytics and studying richer analytics with higher overhead.","1937-4194","","10.1109/MS.2013.69","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6509376","software engineering;measurement;software quality;software quality assurance;software analytics","Software development;Data collection;Analytical models;Software metrics;Software measurement;Software quality;Data analysis;Collaboration","software engineering","software analytics;Collaborative Software Development Laboratory;University of Hawaii;Manoa","","10","","13","","26 Apr 2013","","","IEEE","IEEE Magazines"
"DevOps","C. Ebert; G. Gallardo; J. Hernantes; N. Serrano",Vector Consulting Services; University of Navarra; University of Navarra; University of Navarra,"IEEE Software","25 Apr 2016","2016","33","3","94","100","Building on lean and agile practices, DevOps means end-to-end automation in software development and delivery. Hardly anybody will be able to approach it with a cookbook-style approach, but most developers will benefit from better connecting the previously isolated silos of development and operations. Many DevOps tools exist that can help them do this.","1937-4194","","10.1109/MS.2016.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458761","DevOps;apache Ant;Maven;Gradle;Jenkins;TeamCity;Bamboo;Puppet;Chef;Ansible;Logging;Loggly;Graylog2;Nagios;New Relic;Cacti;AWS;Amazon Web Services;microservices;continuous integration;configuration management;software development;software engineering","Java;Monitoring;Cloud computing;DSL;Automation;Production","software engineering","DevOps;software development;software delivery;cookbook-style approach","","131","","3","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Worlds Apart: Industrial and Academic Focus Areas in Software Testing","V. Garousi; M. Felderer",Hacettepe University; University of Innsbruck,"IEEE Software","22 Sep 2017","2017","34","5","38","45","To determine how industry and academia approach software testing, researchers compared the titles of presentations from selected conferences in each of the two communities. The results shed light on the root cause of low industry-academia collaboration and led to suggestions on how to improve this situation.","1937-4194","","10.1109/MS.2017.3641116","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048625","software engineering;software testing;software conferences;industry–academia collaboration;qualitative analysis;software development","Software testing;Industries;Automatic testing;Mobile communication;Software development","educational institutions;organisational aspects;program testing;research initiatives;software engineering","industrial focus areas;academic focus areas;software testing;industry-academia collaboration","","9","","18","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Commodification of Industrial Software: A Case for Open Source","F. van der Linden; B. Lundell; P. Marttiin",Philips Healthcare; University of Skövde; Nokia Siemens Networks,"IEEE Software","19 Jun 2009","2009","26","4","77","83","As open source development's acceptance has increased, many companies have incorporated it into heterogeneous development, which creates products by combining software that's from many sources and built with many different processes. To be effective, heterogeneous development must bridge the gap between industrial and open source software (OSS) development practices. One aspect of this approach is inner-source development, which aims to deploy key aspects of OSS development within a limited scope - for example, a division, a company, or even a consortium. So, industrial software development must be extended with knowledge of how to cooperate in open source and inner-source communities. To compete successfully, software-intensive companies will need to adopt new forms of collaborative development involving open source software.","1937-4194","","10.1109/MS.2009.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076464","open source;commodification of software;software engineering;software management;computers and society;information systems","Computer industry;Open source software;Companies;Collaborative software;Programming;Navigation;Subcontracting;Collaboration;Costs;Database systems","DP industry;groupware;public domain software;software engineering","industrial software commodification;open source software development;heterogeneous software development;OSS development;industrial software development;software-intensive company;collaborative software development","","43","","15","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Innovation-Driven Software Development: Leveraging Small Companies' Product-Development Capabilities","R. Eito-Brun; M. Sicilia",Universidad Carlos III; University of Alcalá,"IEEE Software","24 Aug 2016","2016","33","5","38","46","A proposed innovation activity model for small companies is based on the relevant literature, an ISO/IEC standard, and the experience of successful small companies. It comprises activities, outcomes, tasks, and work products and establishes interfaces with software development processes.","1937-4194","","10.1109/MS.2016.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7436650","innovation management;software process improvement;product development;software development;software engineering","Technological innovation;Innovation management;Innovation management;Sofware engineering;Standards;Systematics;Software development","business data processing;innovation management;small-to-medium enterprises;software engineering","innovation-driven software development;product development capabilities;ISO-IEC standard;software development process;innovation activity model;small companies","","1","","17","","18 Mar 2016","","","IEEE","IEEE Magazines"
"Language Design with the Spoofax Language Workbench","G. H. Wachsmuth; G. D. P. Konat; E. Visser",Delft University of Technology; Delft University of Technology; Delft University of Technology,"IEEE Software","15 Sep 2014","2014","31","5","35","43","IDEs are essential for programming language developers, and state-of-the-art IDE support is mandatory for programming languages to be successful. Although IDE features for mainstream programming languages are typically implemented manually, this often isn't feasible for programming languages that must be developed with significantly fewer resources. The Spoofax language workbench is a platform for developing textual programming languages with state-of-the-art IDE support. Spoofax is a comprehensive environment that integrates syntax definition, name binding, type analysis, program transformation, code generation, and declarative specification of IDE components. It also provides high-level languages for each of these aspects. These languages are highly declarative, abstracting over the implementation of IDE features and letting engineers focus on language design.","1937-4194","","10.1109/MS.2014.100","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898704","software engineering;integrated environments;design languages;programming languages;programming environments;construction tools;integrated development environments;IDE;Spoofax","Syntactics;Programming;Computer languages;Production;Design methodology;DSL","high level languages;software engineering","language design;Spoofax language workbench;textual programming languages;IDE support;high-level languages","","9","","18","","15 Sep 2014","","","IEEE","IEEE Magazines"
"A Roadmap to the Programmable World: Software Challenges in the IoT Era","A. Taivalsaari; T. Mikkonen",Nokia Technologies; Mozilla,"IEEE Software","16 Jan 2017","2017","34","1","72","80","The Internet of Things (IoT) represents the next significant step in the evolution of the Internet and software development. Although most IoT research focuses on data acquisition, analytics, and visualization, a subtler but equally important transition is underway. Hardware advances are making it possible to embed fully fledged virtual machines and dynamic language runtimes virtually everywhere, leading to a Programmable World in which all our everyday things are connected and programmable dynamically. The emergence of millions of remotely programmable devices in our surroundings will pose significant software development challenges. A roadmap from today's cloud-centric, data-centric IoT systems to the Programmable World highlights the technical challenges that deserve to be part of developer education and deserve deeper investigation beyond those IoT topics that receive the most attention today.","1937-4194","","10.1109/MS.2017.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819416","Internet of Things;IoT;edge computing;Programmable World;software engineering;software architecture;software development","Internet of things;Software development;Visualization;Data analysis;Software architecture","cloud computing;data acquisition;data analysis;data visualisation;Internet of Things;software engineering;virtual machines","Internet of Things;software development;data acquisition;data visualization;data analytics;virtual machines;dynamic language runtimes;remotely programmable devices;cloud-centric data-centric IoT systems","","71","","20","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Researcher Bias: The Use of Machine Learning in Software Defect Prediction","M. Shepperd; D. Bowes; T. Hall","Brunel University, Uxbridge, Middlesex, United Kingdom; Science and Technology Research Institute, University of Hertfordshire, Hatfield, Hertfordshire, United Kingdom; Brunel University, Uxbridge, Middlesex, United Kingdom","IEEE Transactions on Software Engineering","16 Jun 2014","2014","40","6","603","616","Background. The ability to predict defect-prone software components would be valuable. Consequently, there have been many empirical studies to evaluate the performance of different techniques endeavouring to accomplish this effectively. However no one technique dominates and so designing a reliable defect prediction model remains problematic. Objective. We seek to make sense of the many conflicting experimental results and understand which factors have the largest effect on predictive performance. Method. We conduct a meta-analysis of all relevant, high quality primary studies of defect prediction to determine what factors influence predictive performance. This is based on 42 primary studies that satisfy our inclusion criteria that collectively report 600 sets of empirical prediction results. By reverse engineering a common response variable we build a random effects ANOVA model to examine the relative contribution of four model building factors (classifier, data set, input metrics and researcher group) to model prediction performance. Results. Surprisingly we find that the choice of classifier has little impact upon performance (1.3 percent) and in contrast the major (31 percent) explanatory factor is the researcher group. It matters more who does the work than what is done. Conclusion. To overcome this high level of researcher bias, defect prediction researchers should (i) conduct blind analysis, (ii) improve reporting protocols and (iii) conduct more intergroup studies in order to alleviate expertise issues. Lastly, research is required to determine whether this bias is prevalent in other applications domains.","1939-3520","","10.1109/TSE.2014.2322358","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6824804","Software defect prediction;meta-analysis;researcher bias","Software;Predictive models;Correlation;Data models;Buildings;Software engineering;Measurement","learning (artificial intelligence);object-oriented programming;reverse engineering;software metrics;software performance evaluation;statistical analysis","machine learning;software defect prediction;defect-prone software component prediction;performance evaluation;reverse engineering;common response variable;random effects ANOVA model;model building factors;classifier factor;data set factor;input metrics factor;researcher group factor;researcher bias;blind analysis;reporting protocol improvement;intergroup studies","","139","","53","","3 Jun 2014","","","IEEE","IEEE Journals"
"What Makes a Good Bug Report?","T. Zimmermann; R. Premraj; N. Bettenburg; S. Just; A. Schroter; C. Weiss","Microsoft Research, Redmond; Vrije Universiteit Amsterdam, Amsterdam; Queen's University, Kingston; Saarland University, Saarbruecken; University of Victoria, Victoria; University of Zurich, Zürich","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","618","643","In software development, bug reports provide crucial information to developers. However, these reports widely differ in their quality. We conducted a survey among developers and users of APACHE, ECLIPSE, and MOZILLA to find out what makes a good bug report. The analysis of the 466 responses revealed an information mismatch between what developers need and what users supply. Most developers consider steps to reproduce, stack traces, and test cases as helpful, which are, at the same time, most difficult to provide for users. Such insight is helpful for designing new bug tracking tools that guide users at collecting and providing more helpful information. Our CUEZILLA prototype is such a tool and measures the quality of new bug reports; it also recommends which elements should be added to improve the quality. We trained CUEZILLA on a sample of 289 bug reports, rated by developers as part of the survey. The participants of our survey also provided 175 comments on hurdles in reporting and resolving bugs. Based on these comments, we discuss several recommendations for better bug tracking systems, which should focus on engaging bug reporters, better tool support, and improved handling of bug duplicates.","1939-3520","","10.1109/TSE.2010.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5487527","Testing and debugging;distribution;maintenance;and enhancement;human factors;management;measurement.","Computer bugs;Programming;Prototypes;Software engineering;Information analysis;Software testing;Debugging;Software maintenance;Human factors;Engineering management","program debugging;program testing;software quality","software development;APACHE;ECLIPSE;MOZILLA;CUEZILLA prototype;bug tracking tools","","126","","66","","17 Jun 2010","","","IEEE","IEEE Journals"
"An Eye-Tracking Study of Java Programmers and Application to Source Code Summarization","P. Rodeghero; C. Liu; P. W. McBurney; C. McMillan","Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN; Department of Computer Science and Engineering, University of Notre Dame, Notre Dame, IN","IEEE Transactions on Software Engineering","10 Nov 2015","2015","41","11","1038","1054","Source Code Summarization is an emerging technology for automatically generating brief descriptions of code. Current summarization techniques work by selecting a subset of the statements and keywords from the code, and then including information from those statements and keywords in the summary. The quality of the summary depends heavily on the process of selecting the subset: a high-quality selection would contain the same statements and keywords that a programmer would choose. Unfortunately, little evidence exists about the statements and keywords that programmers view as important when they summarize source code. In this paper, we present an eye-tracking study of 10 professional Java programmers in which the programmers read Java methods and wrote English summaries of those methods. We apply the findings to build a novel summarization tool. Then, we evaluate this tool. Finally, we further analyze the programmers' method summaries to explore specific keyword usage and provide evidence to support the development of source code summarization systems.","1939-3520","","10.1109/TSE.2015.2442238","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7118751","Source code summaries;program comprehension;Source code summaries;program comprehension","Java;Software;Documentation;Navigation;XML;Software engineering","Java;program compilers;source code (software)","eye-tracking study;Java programmer;source code summarization;code generation","","15","","75","","5 Jun 2015","","","IEEE","IEEE Journals"
"Evolutionary Optimization of Software Quality Modeling with Multiple Repositories","Y. Liu; T. M. Khoshgoftaar; N. Seliya","Georgia College & State University, Milledgeville, GA; Florida Atlantic University, Boca Raton, FL; University of Michigan-Dearborn, Dearborn, MI","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","852","864","A novel search-based approach to software quality modeling with multiple software project repositories is presented. Training a software quality model with only one software measurement and defect data set may not effectively encapsulate quality trends of the development organization. The inclusion of additional software projects during the training process can provide a cross-project perspective on software quality modeling and prediction. The genetic-programming-based approach includes three strategies for modeling with multiple software projects: Baseline Classifier, Validation Classifier, and Validation-and-Voting Classifier. The latter is shown to provide better generalization and more robust software quality models. This is based on a case study of software metrics and defect data from seven real-world systems. A second case study considers 17 different (nonevolutionary) machine learners for modeling with multiple software data sets. Both case studies use a similar majority-voting approach for predicting fault-proneness class of program modules. It is shown that the total cost of misclassification of the search-based software quality models is consistently lower than those of the non-search-based models. This study provides clear guidance to practitioners interested in exploiting their organization's software measurement data repositories for improved software quality modeling.","1939-3520","","10.1109/TSE.2010.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5467094","Genetic programming;optimization;software quality;defects;machine learning;software measurement.","Software quality;Software measurement;Predictive models;Software metrics;Electronic mail;Genetic programming;Robustness;Costs;Machine learning;Software engineering","genetic algorithms;software management;software metrics;software quality","evolutionary optimization;software quality modeling;multiple software project repository;genetic programming;baseline classifier;validation classifier;validation-and-voting classifier;robust software quality model;software metrics;machine learner;software data set;search-based software quality model;software measurement data repository","","78","","48","","20 May 2010","","","IEEE","IEEE Journals"
"Pointcut Rejuvenation: Recovering Pointcut Expressions in Evolving Aspect-Oriented Software","R. Khatchadourian; P. Greenwood; A. Rashid; G. Xu","Ohio State University, Columbus; Lancaster University, Lancaster; Lancaster University, Lancaster; Ohio State University, Columbus","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","642","657","Pointcut fragility is a well-documented problem in Aspect-Oriented Programming; changes to the base code can lead to join points incorrectly falling in or out of the scope of pointcuts. In this paper, we present an automated approach that limits fragility problems by providing mechanical assistance in pointcut maintenance. The approach is based on harnessing arbitrarily deep structural commonalities between program elements corresponding to join points selected by a pointcut. The extracted patterns are then applied to later versions to offer suggestions of new join points that may require inclusion. To illustrate that the motivation behind our proposal is well founded, we first empirically establish that join points captured by a single pointcut typically portray a significant amount of unique structural commonality by analyzing patterns extracted from 23 AspectJ programs. Then, we demonstrate the usefulness of our technique by rejuvenating pointcuts in multiple versions of three of these programs. The results show that our parameterized heuristic algorithm was able to accurately and automatically infer the majority of new join points in subsequent software versions that were not captured by the original pointcuts.","1939-3520","","10.1109/TSE.2011.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5710951","Software development environments;software maintenance;software tools.","Software;Fuels;Software engineering;Observers;Robustness;Programming;Proposals","aspect-oriented programming","pointcut rejuvenation;pointcut expression recovery;aspect-oriented software;pointcut fragility;aspect-oriented programming;pointcut maintenance;deep structural commonalities harnessing;program elements;join points;pattern analysis;AspectJ programs;parameterized heuristic algorithm","","3","","43","","10 Feb 2011","","","IEEE","IEEE Journals"
"Work Item Tagging: Communicating Concerns in Collaborative Software Development","C. Treude; M. Storey","University of Victoria, Victoria; University of Victoria, Victoria","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","19","34","In collaborative software development projects, work items are used as a mechanism to coordinate tasks and track shared development work. In this paper, we explore how “tagging,” a lightweight social computing mechanism, is used to communicate matters of concern in the management of development tasks. We present the results from two empirical studies over 36 and 12 months, respectively, on how tagging has been adopted and what role it plays in the development processes of several professional development projects with more than 1,000 developers in total. Our research shows that the tagging mechanism was eagerly adopted by the teams, and that it has become a significant part of many informal processes. Different kinds of tags are used by various stakeholders to categorize and organize work items. The tags are used to support finding of tasks, articulation work, and information exchange. Implicit and explicit mechanisms have evolved to manage the tag vocabulary. Our findings indicate that lightweight informal tool support, prevalent in the social computing domain, may play an important role in improving team-based software development practices.","1939-3520","","10.1109/TSE.2010.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5611552","Tagging;collaboration;software development;task management;articulation work;work items.","Tagging;Programming;Collaboration;Software engineering;Data mining","groupware;information retrieval;software development management","work item tagging;collaborative software development project;social computing mechanism;tag vocabulary;lightweight informal tool support;team-based software development practice","","34","","44","","28 Oct 2010","","","IEEE","IEEE Journals"
"A Feature-Based Classification of Model Repair Approaches","N. Macedo; T. Jorge; A. Cunha","High-Assurance Software Laboratory (HASLab)INESC TEC; European Space Agency (ESA), Paris, France; High-Assurance Software Laboratory (HASLab)INESC TEC","IEEE Transactions on Software Engineering","14 Jul 2017","2017","43","7","615","640","Consistency management, the ability to detect, diagnose and handle inconsistencies, is crucial during the development process in Model-driven Engineering (MDE). As the popularity and application scenarios of MDE expanded, a variety of different techniques were proposed to address these tasks in specific contexts. Of the various stages of consistency management, this work focuses on inconsistency handling in MDE, particularly in model repair techniques. This paper proposes a feature-based classification system for model repair techniques, based on an systematic literature review of the area. We expect this work to assist developers and researchers from different disciplines in comparing their work under a unifying framework, and aid MDE practitioners in selecting suitable model repair approaches.","1939-3520","","10.1109/TSE.2016.2620145","North Portugal Regional Operational Programme; European Regional Development Fund (ERDF); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7605502","Model-driven engineering, consistency management, inconsistency handling, model repair","Maintenance engineering;Unified modeling language;Taxonomy;Context;Feature extraction;Software engineering;Systematics","pattern classification;software maintenance","model repair approach;consistency management;model-driven engineering;MDE;feature-based classification system","","4","","91","","21 Oct 2016","","","IEEE","IEEE Journals"
"A Systematic Survey of Program Comprehension through Dynamic Analysis","B. Cornelissen; A. Zaidman; A. van Deursen; L. Moonen; R. Koschke","Delft University of Technology, The Netherlands; Delft University of Technology, The Netherlands; Delft University of Technology, The Netherlands; Simula Research Laboratory, Norway; University of Bremen, Germany","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","684","702","Program comprehension is an important activity in software maintenance, as software must be sufficiently understood before it can be properly modified. The study of a program's execution, known as dynamic analysis, has become a common technique in this respect and has received substantial attention from the research community, particularly over the last decade. These efforts have resulted in a large research body of which currently there exists no comprehensive overview. This paper reports on a systematic literature survey aimed at the identification and structuring of research on program comprehension through dynamic analysis. From a research body consisting of 4,795 articles published in 14 relevant venues between July 1999 and June 2008 and the references therein, we have systematically selected 176 articles and characterized them in terms of four main facets: activity, target, method, and evaluation. The resulting overview offers insight in what constitutes the main contributions of the field, supports the task of identifying gaps and opportunities, and has motivated our discussion of several important research directions that merit additional consideration in the near future.","1939-3520","","10.1109/TSE.2009.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815280","Survey;program comprehension;dynamic analysis.","Computer Society;Software maintenance;Software systems;Documentation;Software engineering;Data analysis;Information analysis;Availability;Runtime;Virtual machining","reverse engineering;software maintenance;system monitoring","program comprehension;dynamic analysis;software maintenance;systematic literature survey","","214","1","154","","17 Apr 2009","","","IEEE","IEEE Journals"
"The Probabilistic Program Dependence Graph and Its Application to Fault Diagnosis","G. K. Baah; A. Podgurski; M. J. Harrold","Georgia Institute of Technology, Atlanta; Case Western Reserve University, Cleveland; Georgia Institute of Technology, Atlanta","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","528","545","This paper presents an innovative model of a program's internal behavior over a set of test inputs, called the probabilistic program dependence graph (PPDG), which facilitates probabilistic analysis and reasoning about uncertain program behavior, particularly that associated with faults. The PPDG construction augments the structural dependences represented by a program dependence graph with estimates of statistical dependences between node states, which are computed from the test set. The PPDG is based on the established framework of probabilistic graphical models, which are used widely in a variety of applications. This paper presents algorithms for constructing PPDGs and applying them to fault diagnosis. The paper also presents preliminary evidence indicating that a PPDG-based fault localization technique compares favorably with existing techniques. The paper also presents evidence indicating that PPDGs can be useful for fault comprehension.","1939-3520","","10.1109/TSE.2009.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5374423","Probabilistic graphical models;machine learning;fault diagnosis;program analysis.","Fault diagnosis;Graphical models;Application software;Testing;Software engineering;Automatic control;Information analysis;Runtime;Probability distribution;Computer Society","fault diagnosis;graph theory;probability;program diagnostics;reasoning about programs;uncertainty handling","probabilistic program dependence graph;fault diagnosis;probabilistic analysis;reasoning;uncertain program behavior;fault localization technique;probabilistic graphical models","","54","6","31","","8 Jan 2010","","","IEEE","IEEE Journals"
"A Comparison of Tabular Expression-Based Testing Strategies","X. Feng; D. L. Parnas; T. H. Tse; T. O'Callaghan","University of Limerick, Limerick and United International College, Zhuhai, Guangdong; University of Limerick, Limerick; The University of Hong Kong, Hong Kong; University of Limerick, Limerick","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","616","634","Tabular expressions have been proposed as a notation to document mathematically precise but readable software specifications. One of the many roles of such documentation is to guide testers. This paper 1) explores the application of four testing strategies (the partition strategy, decision table-based testing, the basic meaningful impact strategy, and fault-based testing) to tabular expression-based specifications, and 2) compares the strategies on a mathematical basis through formal and precise definitions of the subsumption relationship. We also compare these strategies through experimental studies. These results will help researchers improve current methods and will enable testers to select appropriate testing strategies for tabular expression-based specifications.","1939-3520","","10.1109/TSE.2011.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5975175","Tabular expression;test case constraint;subsume;unconditionally subsume;conditionally subsume.","Testing;Redundancy;Documentation;Software quality;Software engineering;Electronic mail","formal specification;program testing;system documentation","tabular expression-based testing strategies;readable software specifications;partition strategy;decision table-based testing;meaningful impact strategy;fault-based testing","","7","","49","","4 Aug 2011","","","IEEE","IEEE Journals"
"Software Dependencies, Work Dependencies, and Their Impact on Failures","M. Cataldo; A. Mockus; J. A. Roberts; J. D. Herbsleb","Research and Technology Center, Robert Bosch LLC, Pittsburgh; Avaya Labs Research, Basking Ridge; Duquesne University, Pittsburgh; Carnegie Mellon University, Pittsburgh","IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","864","878","Prior research has shown that customer-reported software faults are often the result of violated dependencies that are not recognized by developers implementing software. Many types of dependencies and corresponding measures have been proposed to help address this problem. The objective of this research is to compare the relative performance of several of these dependency measures as they relate to customer-reported defects. Our analysis is based on data collected from two projects from two independent companies. Combined, our data set encompasses eight years of development activity involving 154 developers. The principal contribution of this study is the examination of the relative impact that syntactic, logical, and work dependencies have on the failure proneness of a software system. While all dependencies increase the fault proneness, the logical dependencies explained most of the variance in fault proneness, while workflow dependencies had more impact than syntactic dependencies. These results suggest that practices such as rearchitecting, guided by the network structure of logical dependencies, hold promise for reducing defects.","1939-3520","","10.1109/TSE.2009.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5166450","Distribution/maintenance/enhancement;metrics/measurement;organizational management and coordination;quality analysis and evaluation.","Software systems;Predictive models;Quality management;Software engineering;Humans;Software development management;Programming","software fault tolerance;software maintenance;software metrics;software quality","software dependencies;work dependencies;customer-reported software faults;quality analysis","","139","1","48","","17 Jul 2009","","","IEEE","IEEE Journals"
"Model Transformation Modularization as a Many-Objective Optimization Problem","M. Fleck; J. Troya; M. Kessentini; M. Wimmer; B. Alkhazi","TU Wien, Wien, Austria; Universidad de Sevilla, Sevilla, Spain; University of Michigan, Ann Arbor, MI; TU Wien, Wien, Austria; University of Michigan, Ann Arbor, MI","IEEE Transactions on Software Engineering","10 Nov 2017","2017","43","11","1009","1032","Model transformation programs are iteratively refined, restructured, and evolved due to many reasons such as fixing bugs and adapting existing transformation rules to new metamodels version. Thus, modular design is a desirable property for model transformations as it can significantly improve their evolution, comprehensibility, maintainability, reusability, and thus, their overall quality. Although language support for modularization of model transformations is emerging, model transformations are created as monolithic artifacts containing a huge number of rules. To the best of our knowledge, the problem of automatically modularizing model transformation programs was not addressed before in the current literature. These programs written in transformation languages, such as ATL, are implemented as one main module including a huge number of rules. To tackle this problem and improve the quality and maintainability of model transformation programs, we propose an automated search-based approach to modularize model transformations based on higher-order transformations. Their application and execution is guided by our search framework which combines an in-place transformation engine and a search-based algorithm framework. We demonstrate the feasibility of our approach by using ATL as concrete transformation language and NSGA-III as search algorithm to find a trade-off between different well-known conflicting design metrics for the fitness functions to evaluate the generated modularized solutions. To validate our approach, we apply it to a comprehensive dataset of model transformations. As the study shows, ATL transformations can be modularized automatically, efficiently, and effectively by our approach. We found that, on average, the majority of recommended modules, for all the ATL programs, by NSGA-III are considered correct with more than 84 percent of precision and 86 percent of recall when compared to manual solutions provided by active developers. The statistical analysis of our experiments over several runs shows that NSGA-III performed significantly better than multi-objective algorithms and random search. We were not able to compare with existing model transformations modularization approaches since our study is the first to address this problem. The software developers considered in our experiments confirm the relevance of the recommended modularization solutions for several maintenance activities based on different scenarios and interviews.","1939-3520","","10.1109/TSE.2017.2654255","Christian Doppler Forschungsgesellschaft; BMWFW; European Commission (FEDER); Spanish Government; CICYT project BELI; SEBASE; Andalusian Government project COPAS; Ford Motor Company; Ford Alliance Program; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7820199","Model transformation;modularization;ATL;NSGA-III;MDE;SBSE","Unified modeling language;Object oriented modeling;Adaptation models;Measurement;Algorithm design and analysis;Software engineering;Computer bugs","genetic algorithms;program debugging;search problems;software maintenance;software quality","model transformations modularization;model transformation modularization;model transformation programs;transformation languages;higher-order transformations;in-place transformation engine;concrete transformation language;ATL transformations;bug fixing;transformation rules;many-objective optimization problem;metamodels version;monolithic artifacts;automated search-based approach;NSGA-III;statistical analysis;maintenance activities","","6","","96","Traditional","17 Jan 2017","","","IEEE","IEEE Journals"
"Automatically Detecting and Tracking Inconsistencies in Software Design Models","A. Egyed","Johannes Kepler University, Linz","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","188","204","Software models typically contain many inconsistencies and consistency checkers help engineers find them. Even if engineers are willing to tolerate inconsistencies, they are better off knowing about their existence to avoid follow-on errors and unnecessary rework. However, current approaches do not detect or track inconsistencies fast enough. This paper presents an automated approach for detecting and tracking inconsistencies in real time (while the model changes). Engineers only need to define consistency rules-in any language-and our approach automatically identifies how model changes affect these consistency rules. It does this by observing the behavior of consistency rules to understand how they affect the model. The approach is quick, correct, scalable, fully automated, and easy to use as it does not require any special skills from the engineers using it. We evaluated the approach on 34 models with model sizes of up to 162,237 model elements and 24 types of consistency rules. Our empirical evaluation shows that our approach requires only 1.4 ms to reevaluate the consistency of the model after a change (on average); its performance is not noticeably affected by the model size and common consistency rules but only by the number of consistency rules, at the expense of a quite acceptable, linearly increasing memory consumption.","1939-3520","","10.1109/TSE.2010.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432227","Design tools and techniques;design.","Software design;Feedback;Design engineering;Maintenance engineering;Best practices;Software engineering;Programming profession","formal verification;software maintenance","consistency rules;automatic inconsistency tracking;automatic inconsistency detection;empirical evaluation;memory consumption;software design model;consistency checkers","","68","","40","","18 Mar 2010","","","IEEE","IEEE Journals"
"A Flexible Infrastructure for Multilevel Language Engineering","C. Atkinson; M. Gutheil; B. Kennel","University of Mannheim, Mannheim; itemis AG, Bonn; University of Mannheim, Mannheim","IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","742","755","Although domain-specific modeling tools have come a long way since the modern era of model-driven development started in the early 1990s and now offer an impressive range of features, there is still significant room for enhancing the flexibility they offer to end users and for combining the advantages of domain-specific and general-purpose languages. To do this, however, it is necessary to enhance the way in which the current generation of tools view metamodeling and support the representation of the multiple, ?ontological? classification levels that often exist in subject domains. State-of-the-art tools essentially allow users to describe the abstract and concrete syntaxes of a language in the form of metamodels and to make statements in that language in the form of models. These statements typically convey information in terms of types and instances in the domain (e.g., the classes and objects of UML), but not in terms of types of types (i.e., domain metaclasses), and types of types of types, and so on, across multiple classification levels. In essence, therefore, while they provide rich support for ?linguistic? metamodeling, the current generation of tools provides little if any built-in support for modeling ?ontological? classification across more than one type/instance level in the subject domain. In this paper, we describe a prototype implementation of a new kind of modeling infrastructure that, by providing built-in support for multiple ontological as well as linguistic classification levels, offers various advantages over existing language engineering approaches and tools. These include the ability to view a single model from the perspective of both a general-purpose and a domain-specific modeling language, the ability to define constraints across multiple ontological classification levels, and the ability to tie the rendering of model elements to ontological as well as linguistic types over multiple classification levels. After first outlining the key conceptual ingredients of this new infrastructure and presenting the main elements of our current realization, we show these benefits through two small examples.","1939-3520","","10.1109/TSE.2009.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907005","Language engineering;metamodeling;multilevel modeling.","Unified modeling language;Ontologies;Metamodeling;Concrete;Design engineering;Software tools;Prototypes;DSL;Production facilities;Software engineering","ontologies (artificial intelligence);software tools;Unified Modeling Language","multilevel language engineering;model-driven development;linguistic metamodeling;ontological classification levels;domain-specific modeling language;UML","","51","","37","","2 May 2009","","","IEEE","IEEE Journals"
"Software Plagiarism Detection with Birthmarks Based on Dynamic Key Instruction Sequences","Z. Tian; Q. Zheng; T. Liu; M. Fan; E. Zhuang; Z. Yang","Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), Department of Computer Science and Technology, Xi’an Jiaotong University, Xi’an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), Department of Computer Science and Technology, Xi’an Jiaotong University, Xi’an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), School of Electronic and Information Engineering, Xi’an Jiaotong University, Xi’an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), Department of Computer Science and Technology, Xi’an Jiaotong University, Xi’an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), Department of Computer Science and Technology, Xi’an Jiaotong University, Xi’an, China; Department of Computer Science, Western Michigan University, Kalamazoo, MI","IEEE Transactions on Software Engineering","8 Dec 2015","2015","41","12","1217","1235","A software birthmark is a unique characteristic of a program. Thus, comparing the birthmarks between the plaintiff and defendant programs provides an effective approach for software plagiarism detection. However, software birthmark generation faces two main challenges: the absence of source code and various code obfuscation techniques that attempt to hide the characteristics of a program. In this paper, we propose a new type of software birthmark called DYnamic Key Instruction Sequence (DYKIS) that can be extracted from an executable without the need for source code. The plagiarism detection algorithm based on our new birthmarks is resilient to both weak obfuscation techniques such as compiler optimizations and strong obfuscation techniques implemented in tools such as SandMark, Allatori and Upx. We have developed a tool called DYKIS-PD (DYKIS Plagiarism Detection tool) and conducted extensive experiments on large number of binary programs. The tool, the benchmarks and the experimental results are all publicly available.","1939-3520","","10.1109/TSE.2015.2454508","National Natural Science Foundation of China; Ministry of Education Innovation Research Team; Key Projects in the National Science and Technology Pillar Program of China; Fundamental Research Funds for the Central Universities; National Science Foundation (NSF); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7153572","Software plagiarism detection;software birthmark;Software plagiarism detection;software birthmark","Software engineering;Plagiarism;Licenses;Heuristic algorithms;Watermarking","fraud;program diagnostics;security of data","DYKIS plagiarism detection tool;DYKIS-PD;Upx;Allatori;SandMark;compiler optimization;code obfuscation;source code;software birthmark;dynamic key instruction sequences;software plagiarism detection","","29","","77","","9 Jul 2015","","","IEEE","IEEE Journals"
"Automated API Property Inference Techniques","M. P. Robillard; E. Bodden; D. Kawrykow; M. Mezini; T. Ratchford","McGill University, Montréal; Technische Universität Darmstadt, Darmstadt; McGill University, Montréal; Technische Universität Darmstadt, Darmstadt; McGill University, Montréal","IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","613","637","Frameworks and libraries offer reusable and customizable functionality through Application Programming Interfaces (APIs). Correctly using large and sophisticated APIs can represent a challenge due to hidden assumptions and requirements. Numerous approaches have been developed to infer properties of APIs, intended to guide their use by developers. With each approach come new definitions of API properties, new techniques for inferring these properties, and new ways to assess their correctness and usefulness. This paper provides a comprehensive survey of over a decade of research on automated property inference for APIs. Our survey provides a synthesis of this complex technical field along different dimensions of analysis: properties inferred, mining techniques, and empirical results. In particular, we derive a classification and organization of over 60 techniques into five different categories based on the type of API property inferred: unordered usage patterns, sequential usage patterns, behavioral specifications, migration mappings, and general information.","1939-3520","","10.1109/TSE.2012.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311409","API property;programming rules;specifications;protocols;interface;data mining;pattern mining;API evolution;API usage pattern","Itemsets;Context;Association rules;Protocols;Programming;Software engineering","application program interfaces;data mining;pattern classification","automated API property inference technique;application programming interfaces;properties inferred;mining techniques;empirical results;technique classification;unordered usage patterns;sequential usage patterns;behavioral specifications;migration mappings;general information","","82","","109","","24 Sep 2012","","","IEEE","IEEE Journals"
"Locating Software Faults Based on Minimum Debugging Frontier Set","F. Li; Z. Li; W. Huo; X. Feng","State Key Laboratory of Computer Architecture, Institute of Computing Technology, Chinese Academy of Sciences, Beijing, P.R.China; Department of Computer Science, Purdue University, West Lafayette, IN; Institute of Information Engineering, Chinese Academy of Sciences, Beijing, P.R.China; State Key Laboratory of Computer Architecture, Institute of Computing Technology, Chinese Academy of Sciences, Beijing, P.R.China","IEEE Transactions on Software Engineering","11 Aug 2017","2017","43","8","760","776","In this article, we propose a novel state-based fault-localization approach. Given an observed failure that is reproducible under the same program input, this new approach uses two main techniques to reduce the state exploration cost. Firstly, the execution trace to be analyzed for the observed failure is successively narrowed by making the set of trace points in each step a cut of the dynamic dependence graph. Such a cut divides the remaining trace into two parts and, based on the sparse symbolic exploration outcome, one part is removed from further exploration. This process continues until reaching where the fault is determined to be. Second, the cut in each step is chosen such that the union of the program states from the members of the cut is of the minimum size among all candidate cuts. The set of statement instances in the chosen cut is called a minimum debugging frontier set (MDFS). To evaluate our approach, we apply it to 16 real bugs from real world programs and compare our fault reports with those generated by state-of-the-art approaches. Results show that the MDFS approach obtains high quality fault reports for these test cases with considerably higher efficiency than previous approaches.","1939-3520","","10.1109/TSE.2016.2632122","National Natural Science Foundation of China; National High Technology Research and Development Program of China; National Science Foundation of United States; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7755837","Fault localization;minimum debugging frontier set;sparse symbolic exploration;dynamic dependence graph","Debugging;Computer aided software engineering;Computer bugs;Software;Computer architecture;Computers;Indexes","graph theory;program debugging;software fault tolerance","software faults location;minimum debugging frontier set;state-based fault-localization;state exploration cost;execution trace;trace points;dynamic dependence graph;sparse symbolic exploration;MDFS;program bugs","","4","","47","","23 Nov 2016","","","IEEE","IEEE Journals"
"A Multi-Objective Technique to Prioritize Test Cases","A. Marchetto; M. M. Islam; W. Asghar; A. Susi; G. Scanniello",independent researchers; independent researchers; independent researchers; Fondazione Bruno Kessler; DiMIE - University of Basilicata,"IEEE Transactions on Software Engineering","13 Oct 2016","2016","42","10","918","940","While performing regression testing, an appropriate choice for test case ordering allows the tester to early discover faults in source code. To this end, test case prioritization techniques can be used. Several existing test case prioritization techniques leave out the execution cost of test cases and exploit a single objective function (e.g., code or requirements coverage). In this paper, we present a multi-objective test case prioritization technique that determines the ordering of test cases that maximize the number of discovered faults that are both technical and business critical. In other words, our new technique aims at both early discovering faults and reducing the execution cost of test cases. To this end, we automatically recover links among software artifacts (i.e., requirements specifications, test cases, and source code) and apply a metric-based approach to automatically identify critical and fault-prone portions of software artifacts, thus becoming able to give them more importance during test case prioritization. We experimentally evaluated our technique on 21 Java applications. The obtained results support our hypotheses on efficiency and effectiveness of our new technique and on the use of automatic artifacts analysis and weighting in test case prioritization.","1939-3520","","10.1109/TSE.2015.2510633","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7362042","Regression testing;requirements;testing;test case prioritization","Software;Fault diagnosis;Testing;Software engineering;Business;Electronic mail;Optimization","formal specification;formal verification;program testing;regression analysis;software fault tolerance;software metrics;source code (software);systems analysis","multiobjective technique;test case prioritization;regression testing;source code fault;software artifact;requirements specification;metric-based approach","","30","","64","","22 Dec 2015","","","IEEE","IEEE Journals"
"An Enhanced Bailout Protocol for Mixed Criticality Embedded Software","I. Bate; A. Burns; R. I. Davis","Department of Computer Science, University of York, York, United Kingdom; Department of Computer Science, University of York, York, United Kingdom; Department of Computer Science, University of York, York, United Kingdom","IEEE Transactions on Software Engineering","14 Apr 2017","2017","43","4","298","320","To move mixed criticality research into industrial practice requires models whose run-time behaviour is acceptable to systems engineers. Certain aspects of current models, such as abandoning lower criticality tasks when certain situations arise, do not give the robustness required in application domains such as the automotive and aerospace industries. In this paper a new bailout protocol is developed that still guarantees high criticality software but minimises the negative impact on lower criticality software via a timely return to normal operation. We show how the bailout protocol can be integrated with existing techniques, utilising both offline slack and online gain-time to further improve performance. Static analysis is provided for schedulability guarantees, while scenario-based evaluation via simulation is used to explore the effectiveness of the protocol.","1939-3520","","10.1109/TSE.2016.2592907","ESPRC; MCC; EU FP7 IP PROXIMA; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7516652","Real-time systems;mixed criticality;fixed priority scheduling;mode changes","Protocols;Standards;Software;Analytical models;Job shop scheduling;Software engineering;Safety","embedded systems;safety-critical software;scheduling","scenario-based evaluation;schedulability guarantees;online gain-time;lower criticality software;high criticality software;mixed criticality embedded software;enhanced bailout protocol","","12","","44","","19 Jul 2016","","","IEEE","IEEE Journals"
"Efficient Software Verification: Statistical Testing Using Automated Search","S. Poulding; J. A. Clark","University of York, York; University of York, York","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","763","777","Statistical testing has been shown to be more efficient at detecting faults in software than other methods of dynamic testing such as random and structural testing. Test data are generated by sampling from a probability distribution chosen so that each element of the software's structure is exercised with a high probability. However, deriving a suitable distribution is difficult for all but the simplest of programs. This paper demonstrates that automated search is a practical method of finding near-optimal probability distributions for real-world programs, and that test sets generated from these distributions continue to show superior efficiency in detecting faults in the software.","1939-3520","","10.1109/TSE.2010.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406530","Software/program verification;testing strategies;test coverage of code;optimization.","Statistical analysis;Software testing;Automatic testing;Probability distribution;Software engineering;Fault detection;Sampling methods;Software algorithms;Application software;Flow graphs","program testing;program verification;statistical distributions;statistical testing","software verification;statistical testing;automated search;software fault detection;dynamic testing;random testing;structural testing;test data;near-optimal probability distribution","","31","","48","","5 Feb 2010","","","IEEE","IEEE Journals"
"Facilitating Performance Predictions Using Software Components","J. Happe; H. Koziolek; R. Reussner",SAP Research; ABB Corporate Research; Karlsruhe Institute of Technology,"IEEE Software","25 Apr 2011","2011","28","3","27","33","Component-based software engineering (CBSE) poses challenges for predicting and evaluating software performance but also offers several advantages. Software performance engineering can benefit from CBSE ideas and concepts. The MediaStore, a fictional system, demonstrates how to achieve compositional reasoning about software performance.","1937-4194","","10.1109/MS.2011.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5719590","software performance engineering;component-based software architecture;quality assessment","Resource management;Software performance;Servers;Computer architecture;Predictive models;Throughput","software engineering","component-based software engineering;software components;software performance;MediaStore system;compositional reasoning","","19","","16","","24 Feb 2011","","","IEEE","IEEE Magazines"
"Software Architects in Large-Scale Distributed Projects: An Ericsson Case Study","R. Britto; D. Smite; L. Damm",Blekinge Institute of Technology; Blekinge Institute of Technology; Ericsson,"IEEE Software","28 Oct 2016","2016","33","6","48","55","Software architects are key assets for successful development projects. However, not much research has investigated the challenges they face in large-scale distributed projects. So, researchers investigated how architects at Ericsson were organized, their roles and responsibilities, and the effort they spent guarding and governing a large-scale legacy product developed by teams at multiple locations. Despite recent trends such as microservices and agile development, Ericsson had to follow a more centralized approach to deal with the challenges of scale, distribution, and monolithic architecture of a legacy software product. So, the architectural decisions were centralized to a team of architects. The team extensively used code reviews to not only check the code's state but also reveal defects that could turn into maintainability problems. The study results also suggest that the effort architects spend designing architecture, guarding its integrity and evolvability, and mentoring development teams is directly related to team maturity. In addition, significant investment is needed whenever new teams and locations are onboarded.","1937-4194","","10.1109/MS.2016.146","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725230","software architects;global software engineering;large-scale software development;software development;software engineering","Software architecture;Computer architecture;Complexity theory;Mentoring;Atmospheric measurements;Particle measurements;Product development","distributed processing;personnel;software architecture;software development management;software maintenance","software architects;large-scale distributed projects;Ericsson;legacy software product;microservices trend;agile development trend","","16","","20","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Integrating Software Product Line Engineering and Agile Development","K. Mohan; B. Ramesh; V. Sugumaran","The City University of New York, New York; Georgia State University, Atlanta; Oakland University, Rochester","IEEE Software","19 Apr 2010","2010","27","3","48","55","A software product line is a set of software-intensive systems sharing a common, managed set of features, developed from reusable core assets and incorporating variations to derive product variants. This involves identifying commonality and variability in the product family and implementing shared artifacts while preserving the ability to implement required variability. Software development organizations that recognize market opportunities for products that share a significant number of common elements, but that also exhibit variations, can reap significant economic benefits with SPLE. Agile methods emphasize improvisation over conventional development approaches. These methods focus on quick development in an uncertain, ill-understood environment in which requirements rapidly evolve. These methods also view people, rather than formal documentation, as a project's most important element.","1937-4194","","10.1109/MS.2010.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406496","software product line engineering;agile software development;complex adaptive systems;software engineering;software construction;software engineering process;software process models","Software reusability;Asset management;Software development management;Programming;Market opportunities;Environmental economics;Documentation","product development;software prototyping;software reusability","software product line engineering;agile development;software-intensive system;software development","","19","","16","","5 Feb 2010","","","IEEE","IEEE Magazines"
"Effective Quality Management: Value- and Risk-Based Software Quality Management","A. Poth; A. Sunyaev",Technical University of Berlin; University of Cologne,"IEEE Software","7 Nov 2014","2014","31","6","79","85","Software quality management (SQM) must effectively deploy resources for quality assurance activities to reflect the achieved product quality. So, quality managers should exploit their creative freedom to direct their courses of action within the economic constraints. Effective Quality Management can increase SQM effectiveness. This value- and risk-based method is applicable for software developers, their customers, and users. This is due to its product function orientation and the independence of the software development procedures.","1937-4194","","10.1109/MS.2013.138","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6654156","quality management;verification and validation;value-based software engineering;risk management;supplier management;software engineering","Quality assessment;Product design;Software quality;Context modeling;Product development","product quality;quality assurance;software management;software quality","value-based software quality management;risk-based software quality management;quality assurance activity;product quality;economic constraint;SQM effectiveness;value-based method;risk-based method;software developer;product function orientation;software development procedure","","17","","11","","4 Nov 2013","","","IEEE","IEEE Magazines"
"Overcoming Barriers to Self-Management in Software Teams","N. B. Moe; T. Dingsøyr; T. Dybå",SINTEF Information and Communication Technology; SINTEF Information and Communication Technology; SINTEF Information and Communication Technology,"IEEE Software","16 Oct 2009","2009","26","6","20","26","The basic work unit in innovative software organizations is the team rather than the individual. Such teams consist of ""a small number of people with complementary skills who are committed to a common purpose, set of performance goals, and approach for which they hold themselves mutually accountable"". Work teams have many advantages, such as increased productivity, innovation, and employee satisfaction. However, their implementation doesn't always result in organizational success. It isn't enough to put individuals together and expect that they'll automatically know how to work effectively as a team. Lack of redundancy and conflict between team and individual autonomy are key issues when transforming from traditional command-and-control management to collaborative self-managing teams.","1937-4194","","10.1109/MS.2009.182","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287005","ethnographic studies;case study;empirical software engineering;self-management;organizational management and coordination;organizational change;software process improvement;software engineering;agile software development","Productivity;Technological innovation;Collaborative work","employee welfare;software development management;team working","software team;innovative software organization;basic work unit;complementary skill;performance goal set;work team;innovation;employee satisfaction;increased productivity;redundancy;team conflict;command-and-control management;collaborative self-managing team","","63","","13","","16 Oct 2009","","","IEEE","IEEE Magazines"
"What Do We Know about Agile Software Development?","T. Dyba; T. Dingsoyr",SINTEF Information and Communication Technology; SINTEF Information and Communication Technology,"IEEE Software","25 Aug 2009","2009","26","5","6","9","Agile software development has had a huge impact on how software is developed worldwide. We can view agile methods such as Extreme Programming (XP) and Scrum as a reaction to plan-based or traditional methods, which emphasize a ""rationalized, engineering-based approach, incorporating extensive planning, codified processes, and rigorous reuse. In contrast, agile methods address the challenge of an unpredictable world, emphasizing the value competent people and their relationships bring to software development. To clarify the effectiveness of agile methods, we reviewed the agile development literature and conducted a systematic study of what we know empirically about its benefits and limitations.","1937-4194","","10.1109/MS.2009.145","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222784","empirical software engineering;evidence-based software engineering;research synthesis;agile software development;XP;extreme programming;scrum;lean software development","Programming;Collaborative software;Humans;Social factors;Software development management;ISO standards;Communication system control;Environmental management;Innovation management;Application software","project management;software development management;software reusability","agile software development;extreme programming;Scrum;agile project management;rationalized engineering-based approach;rigorous reuse;extensive planning;codified process","","101","","11","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Architects as Service Providers","R. Faber",Siemens,"IEEE Software","25 Feb 2010","2010","27","2","33","40","Architects provide those system qualities as values to their customers, communicating and implementing them in close cooperation with developers. In this way, architects also can and should play an important role in agile development projects. As a service to application developers, architects participate in coding activities and sustain the architecture's effectiveness throughout a project's lifetime.","1937-4194","","10.1109/MS.2010.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420793","software architecture;agile development;software engineering;management;development teams;software engineering process;software process models","Encoding;Software architecture;Service oriented architecture;Documentation;Prototypes","encoding;software architecture;software development management","service providers;system qualities;application developers;architects;coding activities;agile development projects","","12","","8","","25 Feb 2010","","","IEEE","IEEE Magazines"
"What's the True Hourly Cost of Offshoring?","D. Smite; R. van Solingen",Blekinge Institute of Technology; Delft University of Technology,"IEEE Software","24 Aug 2016","2016","33","5","60","70","Most companies have learned that cost calculations for offshore outsourcing shouldn't be limited to hourly wages. Looking at salaries alone, you could naively hope for cost reductions of up to 90 percent. However, don't underestimate the cost of knowledge transfer, travel, attrition, miscommunication, and so on. But does an opportunity for cost reduction still exist? To answer this question, researchers delved into the collaboration between a Dutch software company and an Indian vendor. They gathered evidence for direct costs and quantified perceptions of indirect costs associated with an in-house team in the Netherlands and the outsourced offshore team in India. The offshore team's true hourly costs took three years to become comparable with those of the in-house team. Getting close to the break-even point took five years. Learning costs due to offshore employee turnover were the primary cost factor to get under control.","1937-4194","","10.1109/MS.2015.82","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7106389","global software engineering;outsourcing;offshoring;offshore outsourcing;costs;cost savings;attrition;retention;learning curves;software development;software engineering","Outsourcing;Collaboration;Software development;Training;Remuneration;Outsourcing;Cost benefit analysis","cost reduction;outsourcing;salaries;software houses","offshoring hourly cost;offshore outsourcing;hourly wages;salaries;cost reduction;knowledge transfer;travel;attrition;miscommunication;Dutch software company;Indian vendor;indirect cost;Netherlands;learning cost;offshore employee turnover","","11","","10","","13 May 2015","","","IEEE","IEEE Magazines"
"Practical Combinatorial Interaction Testing: Empirical Findings on Efficiency and Early Fault Detection","J. Petke; M. B. Cohen; M. Harman; S. Yoo","Computer Science Department, University College London, London, United Kingdom; Computer Science & Engineering Department, University of Nebraska-Lincoln, Lincoln, Nebraska, United States; Computer Science Department, University College London, London, United Kingdom; Computer Science Department, University College London, London, United Kingdom","IEEE Transactions on Software Engineering","15 Sep 2015","2015","41","9","901","924","Combinatorial interaction testing (CIT) is important because it tests the interactions between the many features and parameters that make up the configuration space of software systems. Simulated Annealing (SA) and Greedy Algorithms have been widely used to find CIT test suites. From the literature, there is a widely-held belief that SA is slower, but produces more effective tests suites than Greedy and that SA cannot scale to higher strength coverage. We evaluated both algorithms on seven real-world subjects for the well-studied two-way up to the rarely-studied six-way interaction strengths. Our findings present evidence to challenge this current orthodoxy: real-world constraints allow SA to achieve higher strengths. Furthermore, there was no evidence that Greedy was less effective (in terms of time to fault revelation) compared to SA; the results for the greedy algorithm are actually slightly superior. However, the results are critically dependent on the approach adopted to constraint handling. Moreover, we have also evaluated a genetic algorithm for constrained CIT test suite generation. This is the first time strengths higher than 3 and constraint handling have been used to evaluate GA. Our results show that GA is competitive only for pairwise testing for subjects with a small number of constraints.","1939-3520","","10.1109/TSE.2015.2421279","National Science Foundation; Air Force Office of Scientific Research; Engineering and Physical Sciences Research Council; DAASE: Dynamic Adaptive Automated Software Engineering; GISMO: Genetic Improvement of Software for Multiple Objectives; CREST: Centre for Research on Evolution, Search and Testing; DAASE; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081752","Combinatorial Interaction Testing;Prioritisation;Empirical Studies;Software Testing;Combinatorial interaction testing;prioritisation;empirical studies;software testing","Testing;Simulated annealing;Genetic algorithms;Fault detection;Greedy algorithms;Turning;Flexible printed circuits","genetic algorithms;greedy algorithms;program testing;simulated annealing;software fault tolerance","combinatorial interaction testing;early fault detection;software system configuration space;simulated annealing;SA;greedy algorithm;CIT test suite generation;constraint handling;pairwise testing;genetic algorithm","","50","","37","","8 Apr 2015","","","IEEE","IEEE Journals"
"Regression Testing, Spoken Language, Crash-Inducing Commits, UML, and Legal Policy","J. C. Carver; J. Cabot; L. L. Minku; M. Torchiano",University of Alabama; Interdisciplinary Internet Institute; University of Leicester; Politecnico di Torino,"IEEE Software","26 Feb 2016","2016","33","2","26","28","This month's column reports on papers from the 2015 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement, the 11th International Conference on Predictive Models and Data Analytics in Software Engineering, and the 2015 ACM/IEEE International Conference on Model Driven Engineering Languages and Systems. The paper topics include regression testing, language policies, crash-inducing commits, UML, and model-based development.","1937-4194","","10.1109/MS.2016.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420467","regression testing;language policies;crash-inducing commits;UML;model-based development;software engineering;software development","","","","","","","5","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Repairing Games at Runtime or, How We Learned to Stop Worrying and Love Emergence","C. Lewis; J. Whitehead","University of California, Santa Cruz; University of California, Santa Cruz","IEEE Software","18 Aug 2011","2011","28","5","53","59","Games must be emergent, constantly surprising players by the possibilities they offer. However, emergence creates unpredictability, preventing developers from verifying that their games won't lead to undesirable states. Worse still, even when a bug is found, finding out how it occurred can be a significant challenge. The authors present Mayet, a system for monitoring software at runtime, and use it to repair a game as it executes. This capability lets developers focus on creating excellent gaming experiences and not worry about edge cases and untraceable bugs.","1937-4194","","10.1109/MS.2011.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5953580","games;reliability;error handling and recovery","Games;Maintenance engineering;Software engineering;Error analysis;Computer bugs;Runtime;Software reliability","computer games;software engineering","game repair;Mayet system;runtime software monitoring","","5","","9","","14 Jul 2011","","","IEEE","IEEE Magazines"
"Software Development Effort Estimation: Formal Models or Expert Judgment?","M. Jørgensen; B. Boehm; S. Rifkin",Simula Research Laboratory; University of Southern California; Master Systems,"IEEE Software","24 Feb 2009","2009","26","2","14","19","Which is better for estimating software project resources: formal models, as instantiated in estimation tools, or expert judgment? Two luminaries, debate this question in this paper. For this debate, they're taking opposite sides and trying to help software project managers figure out when, and under what conditions, each method would be best.","1937-4194","","10.1109/MS.2009.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786946","software project estimation;estimation tools;expert judgment;software development;process improvement","Programming;Software tools;Project management;Resource management;Software engineering;Predictive models;Computer industry;Research initiatives;Electric breakdown","software engineering","software development effort estimation;formal models;expert judgment;software project managers","","57","","15","","24 Feb 2009","","","IEEE","IEEE Magazines"
"What Do Developers Use the Crowd For? A Study Using Stack Overflow","R. Abdalkareem; E. Shihab; J. Rilling","Concordia University, Montreal; Concordia University, Montreal; Concordia University, Montreal","IEEE Software","28 Mar 2017","2017","34","2","53","60","Stack Overflow relies on the crowd to construct quality developer-related knowledge. To determine what developers use this knowledge for, researchers analyzed 1,414 Stack Overflow-related code commits. The developers used this knowledge to support development tasks and collect user feedback. The researchers also studied Stack Overflow posts' helpfulness and timeliness. The crowd was the most helpful on topics such as development tools and programming languages. The questions that took the longest to resolve were related to Web frameworks. The study findings can help developers better understand how to effectively use Stack Overflow, can help Stack Overflow designers improve their platform, and can help the research community understand Stack Overflow's strengths and weaknesses as a development tool. This article is part of a special issue on Crowdsourcing for Software Engineering.","1937-4194","","10.1109/MS.2017.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888410","crowdsourcing;Stack Overflow;analyzing commits;software development;software engineering","Computer bugs;Software development;Knowledge engineering;Delays;Browsers;Computer languages;Programming","crowdsourcing;programming;software development management;Web sites","software engineering;crowdsourcing;Stack Overflow designers;Web frameworks;programming languages;development tools;user feedback collection;development task support;Stack Overflow-related code;quality developer-related knowledge","","21","","14","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Dynamic and Automatic Feedback-Based Threshold Adaptation for Code Smell Detection","H. Liu; Q. Liu; Z. Niu; Y. Liu","School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China; School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China; School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China; School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China","IEEE Transactions on Software Engineering","10 Jun 2016","2016","42","6","544","558","Most code smell detection tools expose thresholds to engineers for customization because code smell detection is essentially subjective and application specific. Another reason why engineers should customize these thresholds is that they have different working schedules and different requirements on software quality. They have their own unique need on precision and recall in smell detection. This unique need should be fulfilled by adjusting thresholds of smell detection tools. However, it is difficult for software engineers, especially inexperienced ones, to adjust often contradicting and related thresholds manually. One of the possible reasons is that engineers do not know the exact quantitative relation between threshold values and performance, e.g., precision. In this paper, we propose an approach to adapting thresholds automatically and dynamically. Engineers set a target precision manually according to their working schedules and quality requirements. With feedback from engineers, the proposed approach then automatically searches for a threshold setting to maximize recall while having precision close to the target precision. The proposed approach has been evaluated on open-source applications. Evaluation results suggest that the proposed approach is effective.","1939-3520","","10.1109/TSE.2015.2503740","National Natural Science Foundation of China; Program for New Century Excellent Talents in University; Beijing Higher Education Young Elite Teacher Project; National Natural Science Foundation of China; National Strategic Basic Research Program (“973” Program); Ministry of Science and Technology of China; The 111 Project of Beijing Institute of Technology; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7337457","Software Refactoring;Code Smells;Feedback Control;Smell Identification;Software refactoring;code smells;feedback control;smell identification","Software;Detection algorithms;Cloning;Genetic algorithms;Schedules;Algorithm design and analysis;Measurement","software maintenance;software quality","feedback-based threshold adaptation;code smell detection;software quality;software engineering;open-source applications","","14","1","56","","25 Nov 2015","","","IEEE","IEEE Journals"
"Test Automation: Not Just for Test Execution","V. Garousi; F. Elberzhager",Hacettepe University; Fraunhofer Institute for Experimental Software Engineering,"IEEE Software","28 Mar 2017","2017","34","2","90","96","To work more efficiently and effectively, test engineers must be aware of various automated-testing strategies and tools that assist test activities other than test execution. However, automation doesn't come for free, so it must be carefully implemented.","1937-4194","","10.1109/MS.2017.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888399","test automation;software testing;test-case design;test scripting;test execution;test evaluation;test result reporting;test management;test engineering;software development;software engineering","Automation;Software testing;Software development;Automatic testing;Computer bugs","automatic testing;program testing","automated-testing strategies;test activities;test execution;test automation;software testing","","17","1","24","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Probing Questions, Participatory Democracy, Quality Assurance, and Customer Data","J. C. Carver; M. Paasivaara; B. Penzenstadler","University of Alabama; Aalto University; California State University, Long Beach","IEEE Software","24 Aug 2016","2016","33","5","12","14","This month's column reports on papers from the 38th International Conference on Software Engineering and the 17th International Conference on Agile Software Development. The topics covered include using requirements knowledge to stimulate architectural thinking, software support for participatory democracy, Scrum and quality assurance, and sharing customer data.","1937-4194","","10.1109/MS.2016.122","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548906","agile development;Extreme Programming;software requirements;Scrum;quality assurance;customer data;SafeScrum;AppCivist-PB;participatory democracy;software development;software engineering","","","","","","","4","","24 Aug 2016","","","IEEE","IEEE Magazines"
"An Empirical Evaluation of Web-Based Fingerprinting","A. F. Khademi; M. Zulkernine; K. Weldemariam",Queen's University; Queen's University; IBM Research--Africa,"IEEE Software","30 Jun 2015","2015","32","4","46","52","Adversaries employ sophisticated fingerprinting techniques to identify Web users and record their browsing history and Web interactions. Fingerprinting leaves no footprint on the browser and is invisible to general Web users, who often lack basic knowledge of it. An analysis of fingerprinting techniques and tools revealed the fingerprinting workflow. This helped define fine-grained properties that precisely model the workflow, allowing development of a client-side fingerprinting-detection tool. This article is part of a special issue on Security and Privacy on the Web.","1937-4194","","10.1109/MS.2015.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7106402","Fybrid;iFybrid;fingerprinting;user identification;Web privacy;software development;software engineering","Browsers;Fingerprint recognition;Entropy;Software development;Navigation;Privacy;Web services;Software engineering","data privacy;fingerprint identification;Internet","empirical evaluation;Web based fingerprinting;Web users;Web record;browsing history;Web interactions;fingerprinting techniques;fingerprinting tools;fingerprinting workflow;fine grained properties;client side fingerprinting detection tool","","6","","16","","13 May 2015","","","IEEE","IEEE Magazines"
"Coderetreats: Reflective Practice and the Game of Life","D. Parsons; A. Mathrani; T. Susnjak; A. Leist",Massey University; Massey University; Massey University; Massey University,"IEEE Software","13 Jun 2014","2014","31","4","58","64","A coderetreat is an event where software developers gather to spend a day exploring their craft in an informal yet intellectually challenging environment. It encourages reflective practice by addressing a single programming problem from different perspectives, with multiple coding partners, freed from the daily pressures of deadlines and the need to deliver completed artifacts. This article describes an experiment in which a coderetreat was run with a group of final-year undergraduates studying software architecture. The authors gathered qualitative and quantitative data to explore the ways in which the activity contributed to the participants' reflective practice. The results suggest that coderetreats are an excellent vehicle for reflective practice in software development, providing a context within which multiple aspects of self-reflection and motivation can be developed. The Web extra at http://youtu.be/racyZfkbgnQ is an audio recording in which author David Parsons expands on the article ""Coderetreats: Reflective Practice and the Game of Life,"" discussing how coderetreats can encourage self-reflection in software engineers.","1937-4194","","10.1109/MS.2014.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6756713","software psychology;coding tools and techniques;test design;self-assessment;software engineering;pervasive computing;project management","Software development;Software engineering;Information technology;Programming profession;Reflection;Electronic mail","","","","2","","10","","5 Mar 2014","","","IEEE","IEEE Magazines"
"Examining the Rating System Used in Mobile-App Stores","I. J. Mojica Ruiz; M. Nagappan; B. Adams; T. Berger; S. Dienst; A. E. Hassan","McAfee; Rochester Institute of Technology; École Polytechnique de Montréal; University of Waterloo; University of Leipzig; Queen's University, Canada","IEEE Software","28 Oct 2016","2016","33","6","86","92","Unlike products on Amazon.com, mobile apps are continuously evolving, with new versions rapidly replacing the old ones. Nevertheless, many app stores still use an Amazon-style rating system, which aggregates every rating ever assigned to an app into one store rating. To examine whether the store rating captures the changing user satisfaction levels regarding new app versions, researchers mined the store ratings of more than 10,000 mobile apps in Google Play, every day for a year. Even though many apps' version ratings rose or fell, their store rating was resilient to fluctuations once they had gathered a substantial number of raters. The conclusion is that current store ratings aren't dynamic enough to capture changing user satisfaction levels. This resilience is a major problem that can discourage developers from improving app quality.","1937-4194","","10.1109/MS.2015.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7045413","mobile apps;Android;Google Play;review systems;rating;software development;software engineering","Mobile communication;Google;Androids;Humanoid robots;Computer applications;Software engineering","customer satisfaction;mobile computing","mobile-app stores;mobile applications;Amazon-style rating system;user satisfaction level;app versions;Google Play;app quality","","22","","10","","19 Feb 2015","","","IEEE","IEEE Magazines"
"Onboarding in Open Source Projects","F. Fagerholm; A. Sanchez Guinea; J. Borenstein; J. Münch",University of Helsinki; University of Helsinki; Stanford University and Facebook; University of Helsinki,"IEEE Software","7 Nov 2014","2014","31","6","54","61","In today's world, many companies turn to open source projects as a method to increase productivity and innovation. A major challenge with managing this kind of development is the onboarding of new developers into the virtual teams that drive such projects. There's little guidance on how to initiate new members into such teams and how to overcome the learning curve. This case study on open source software projects shows that mentoring can have a significant impact on onboarding new members into virtual software development teams.","1937-4194","","10.1109/MS.2014.107","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6879055","onboarding;open source software projects;virtual teams;mentoring;global software development;distributed software development;case study;software engineering","Virtual groups;Open source software;Open systems;Software engineering;Programming;Computer languages;Project management","public domain software;software development management","open source software project;virtual software development team;productivity;innovation","","21","","7","","15 Aug 2014","","","IEEE","IEEE Magazines"
"Using Defect Taxonomies for Testing Requirements","M. Felderer; A. Beer",University of Innsbruck; Beer Test Consulting,"IEEE Software","23 Apr 2015","2015","32","3","94","101","Systematic defect management based on bug-tracking systems such as Bugzilla is well established and has been successfully used in many software organizations. Defect management weights the failures observed during test execution according to their severity and forms the basis for effective defect taxonomies. In practice, most defect taxonomies are used only for the a posteriori allocation of testing resources to prioritize failures for debugging. Thus, these taxonomies' full potential to control and improve all the steps of testing has remained unexploited. This is especially the case for testing a system's user requirements. System-level defect taxonomies can improve the design of requirements-based tests, the tracing of defects to requirements, the quality assessment of requirements, and the control of the relevant defect management. So, we developed requirements-based testing with defect taxonomies (RTDT). This approach is aligned with the standard test process and uses defect taxonomies to support all phases of testing requirements. To illustrate this approach and its benefits, we use an example project (which we call Project A) from a public health insurance institution.","1937-4194","","10.1109/MS.2014.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6799150","requirements-based testing;defect taxonomy;test management;requirements validation;software quality;software engineering","Taxonomy;Software testing;Graphical user interfaces;Requirements engineering;Software engineering;Syntactics","program testing;software quality","systematic defect management;bug-tracking system;Bugzilla;a posteriori allocation;requirements quality assessment;requirements-based testing;defect taxonomies;RTDT","","6","","11","","16 Apr 2014","","","IEEE","IEEE Magazines"
"The Effectiveness of Pair Programming: Software Professionals' Perceptions","W. Sun; G. Marakas; M. Aguirre-Urreta",Washburn University; Florida International University; Texas Tech University,"IEEE Software","23 Jun 2016","2016","33","4","72","79","Researchers surveyed software professionals on their views regarding the effectiveness of pair programming compared to traditional solo programming. The survey produced three main findings. First, the respondents believed that project complexity and pair composition (the individual programmers' expertise and pair-programming experience) affect pair programming's effectiveness in terms of the effort, defect rate, knowledge transfer, and overall project cost. Second, respondents with pair-programming experience viewed pair programming more positively than those without it. Finally, the more pair-programming experience the respondents had, the more favorably they viewed pair programming.","1937-4194","","10.1109/MS.2015.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7274252","pair programming;solo programming;project complexity;pair composition;effort;defect rate;knowledge transfer;software engineering;software development","Programming profession;Complexity theory;Knowledge transfer;Software engineering;Programming;Organizations","programming;project management;software management;software prototyping","pair programming;software professional perception;knowledge transfer;project cost","","5","","9","","23 Sep 2015","","","IEEE","IEEE Magazines"
"The Top 10 Adages in Continuous Deployment","C. Parnin; E. Helms; C. Atlee; H. Boughton; M. Ghattas; A. Glover; J. Holman; J. Micco; B. Murphy; T. Savor; M. Stumm; S. Whitaker; L. Williams",North Carolina State University; Red Hat Software; Mozilla; IBM; Cisco Systems; Netflix; SAS; Google; Microsoft; Facebook; University of Toronto; LexisNexis; North Carolina State University,"IEEE Software","15 May 2017","2017","34","3","86","95","Continuous deployment involves automatically testing incremental software changes and frequently deploying them to production environments. With it, developers' changes can reach customers in days or even hours. Such ultrafast changes create a new reality in software development. To understand the emerging practices surrounding continuous deployment, researchers facilitated a one-day Continuous Deployment Summit at the Facebook campus in July 2015, at which participants from 10 companies described how they used continuous deployment. From the resulting conversation, the researchers derived 10 adages about continuous-deployment practices. These adages represent a working set of approaches and beliefs that guide current practice and establish a tangible target for empirical validation by the research community.","1937-4194","","10.1109/MS.2017.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927896","continuous deployment;rapid release;telemetry;software engineering;software development","Software testing;Telemetry;Software engineering;Software development;Software measurement","automatic testing;continuous improvement;program testing;social networking (online);software quality","automatic incremental software testing;production environments;software development;Continuous Deployment Summit;Facebook campus;research community","","21","","13","","15 May 2017","","","IEEE","IEEE Magazines"
"Verification and Validation for Trustworthy Software Systems","J. B. Michael; D. Drusinsky; T. W. Otani; M. Shing",Naval Postgraduate School; Naval Postgraduate School; Naval Postgraduate School; Naval Postgraduate School,"IEEE Software","20 Oct 2011","2011","28","6","86","92","A continuous and proactive process for conducting verification and validation of systems involves using scenario-based testing to validate whether formal assertions correctly capture the intent of the natural language requirements. The process is automated through the use of statechart assertions and runtime execution monitoring. The statechart assertions can be used as part of a system reference model in support of independent verification and validation of trustworthy systems.","1937-4194","","10.1109/MS.2011.151","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6055664","requirements;specification;validation;software;program;verification;assertion checker;assertion languages;performance;formal methods;software engineering","Software development;Formal verification;Software engineering;Programming;Validation;Performance evaluation","formal verification;program testing;safety-critical software","trustworthy software systems;software system verification;software system validation;scenario-based testing;natural language requirement;statechart assertion;runtime execution monitoring","","12","","17","","20 Oct 2011","","","IEEE","IEEE Magazines"
"Are We There Yet?: Simple Language Implementation Techniques for the 21st Century","S. Marr; T. Pape; W. De Meuter","Inria Lille--Nord Europe; Hasso Plattner Institute, University of Potsdam; Vrije Universiteit Brussel","IEEE Software","15 Sep 2014","2014","31","5","60","67","Research on language implementation techniques has regained importance with the rise of domain-specific languages (DSLs). Although DSLs can help manage a domain's complexity, building highly optimizing compilers or virtual machines is rarely affordable. So, performance remains an issue. Ideally, you would implement a simple interpreter and still be able to achieve acceptable performance. RPython and Truffle are implementation techniques based on simple interpreters; they promise to perform at the same order of magnitude as highly optimizing virtual machines. This case study compares the two techniques to identify their similarities, weaknesses, and areas for further research.","1937-4194","","10.1109/MS.2014.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898728","language implementation;virtual machines;compilers;interpreters;software engineering;programming languages;computer programming;RPython;Truffle;domain-specific languages","Programming;Computer applications;Computer languages;Java;Syntactics;Optimizing compilers;Software engineering","high level languages;operating systems (computers);program compilers;virtual machines","simple language implementation techniques;21st century;domain specific languages;DSL;virtual machines;optimizing compilers;RPython;Truffle","","6","","12","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Oh Dear, We Bought Our Competitor: Integrating Similar Software Systems","R. Land; I. Crnković",Mälardalen University; Mälardalen University,"IEEE Software","28 Feb 2011","2011","28","2","75","82","A look at 10 case studies addresses the technological, personnel, and organizational challenges. The 10 cases involved seven organizations in different business sectors. Our data collection methods included our participation in projects, several rounds of interviews with project leaders and software architects, and several rounds of questionnaires with software architects and project managers, as well as project and product documentation. 2 Companies we studied included ABB, Bombardier, Ericsson, Saab, and Westinghouse. However, we can't disclose detailed information or relate case descriptions to specific companies or systems. Our observations regarding cultural influences might be skewed because all the organizations involved Sweden and other European or North American countries.","1937-4194","","10.1109/MS.2010.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5467014","software engineering;interoperability;process implementation;project management","Software engineering;Software maintenance;Project management;Engineering management;Distributed computing;Software systems;Management information systems;Corporate acquisitions;Software architecture","business data processing;organisational aspects;project management;question answering (information retrieval);software architecture;system documentation","software system;organizational challenge;business sector;data collection method;project leader;software architects;questionnaires;project managers;product documentation","","","","11","","20 May 2010","","","IEEE","IEEE Magazines"
"Test Better by Exploring: Harnessing Human Skills and Knowledge","J. Itkonen; M. V. Mäntylä; C. Lassenius",Aalto University; University of Oulu; Aalto University,"IEEE Software","23 Jun 2016","2016","33","4","90","96","Users continue to stumble upon software bugs, despite developers' efforts to build and test high-quality software. Although traditional testing and quality assurance techniques are extremely valuable, software testing should pay more attention to exploration. Exploration can directly apply knowledge and learning to the core of industrial software testing, revealing more relevant bugs earlier. This article describes exploration's characteristics, knowledge's role in software testing, and the three levels of exploratory-testing practices. Academics and practitioners should focus on exploiting exploration's strengths in software testing and on reporting existing practices and benefits in different academic and industrial contexts.","1937-4194","","10.1109/MS.2015.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7155417","validation;testing strategies;test design;test management;software quality assurance;verification and validation;exploratory testing;session-based test management;confirmatory testing;software engineering;software development;software testing","Software testing;Computer bugs;Human factors;Automation;Documentation;Validation;Software engineering;Design methodology","program debugging;program testing;software quality","software bugs;high-quality software testing;quality assurance techniques;industrial software testing;software development;interactive systems","","3","","12","","13 Jul 2015","","","IEEE","IEEE Magazines"
"Non-functional Requirements in Architectural Decision Making","D. Ameller; C. Ayala; J. Cabot; X. Franch",BarcelonaTech—Universitat Politècnica de Catalunya; BarcelonaTech—Universitat Politècnica de Catalunya; École des Mines de Nantes; BarcelonaTech—Universitat Politècnica de Catalunya,"IEEE Software","25 Feb 2013","2013","30","2","61","67","Software architects often must work with incomplete or ill-specified non-functional requirements (NFRs) and use them to make decisions. Through this process, existing NFRs are refined or modified and new ones emerge. Although much research has centered on how software architects treat NFRs, no empirical studies have investigated the state of the practice. A survey based on interviews with 13 software architects addressed two fundamental issues: how do architects face NFRs from an engineering perspective, and how do NFRs influence their decision-making? The survey revealed that architects usually elicit NFRs themselves in an iterative process; they usually don't document the NFRs and only partially validate them.","1937-4194","","10.1109/MS.2012.176","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6381398","nonfunctional requirements;non-functional requirements;NFR;quality requirements;architectural decisions;software engineering;software architecturecontent type","Software devlopment;Documentation;Software architecture;Decision making;Software engineering;Specifications","decision making;formal verification;software architecture","nonfunctional requirements;architectural decision making;software architects;NFR;engineering perspective","","38","","13","","13 Dec 2012","","","IEEE","IEEE Magazines"
"Achieving and Maintaining CMMI Maturity Level 5 in a Small Organization","D. Falessi; M. Shaw; K. Mullen",Fraunhofer CESE; Fraunhofer CESE; Keymind,"IEEE Software","15 Sep 2014","2014","31","5","80","86","CMMI (Capability Maturity Model Integration) models are collections of best practices that help organizations improve their processes. This article reports on the authors' experience in achieving and maintaining CMMI Maturity Level 5 in a small organization. Economic achievements, success factors, and lessons learned are reported by using real-life examples from almost 10 years of improvement process. This article could be a valuable and unique reference for practitioners intending to pursue high-maturity CMMI level, particularly in small organization settings. The importance of this topic and lack of similar experience reports make it a valuable contribution to the state of the practice. The first Web extra at http://youtu.be/HMbgNSFxkpE is an audio recording in which IEEE Software Multimedia Editor Davide Falessi speaks with Shane Oleson and Shannon Taylor of Keymind about how the organization achieved and maintained CMMI Maturity Level 5. The second Web extra at http://youtu.be/RKpKBo7roZI is an audio recording in which author Kathy Mullen introduces a custom Web-based tool called the Keymind Measurement Reporting Tool.","1937-4194","","10.1109/MS.2014.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6728932","process improvement;CMMI;experience report;case study;software engineering","Organizations;Standards organizations;Best practices;Reliability;Capability maturity model;Process control;Software engineering","Capability Maturity Model;Internet;organisational aspects","CMMI maturity level;capability maturity model integration;small organization;economic achievements;success factors;improvement process;Web-based tool;Keymind Measurement Reporting Tool","","15","","10","","30 Jan 2014","","","IEEE","IEEE Magazines"
"Operational and Strategic Learning in Global Software Development","A. Boden; B. Nett; V. Wulf","University of Siegen, Siegen; University of Siegen, Siegen; University of Siegen, Siegen","IEEE Software","14 Oct 2010","2010","27","6","58","65","In this paper, distributed software development is discussed. With increasing globalization, distributed software teams have become fairly common. Usually, companies that offshore their software development expect a reduction of costs and access to new markets. However, distributed teams often face problems related to globally distributed work's spatial, temporal, and cultural barriers. This paper also illustrates some of the challenges in organizational learning faced by small and medium enterprises engaged in offshore software development.","1937-4194","","10.1109/MS.2009.113","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5204064","management;software engineering;project and people management;management of computing and information systems;computing milieux;software development;offshoring;SME;software","Programming;Information systems;Project management;Engineering management;Software engineering;Distributed computing;Management information systems;Globalization;Costs;Cultural differences","globalisation;groupware;learning (artificial intelligence);outsourcing;small-to-medium enterprises;software cost estimation;software development management;team working","operational learning;strategic learning;global software development;distributed software development;cost reduction;organizational learning;small enterprise;medium enterprise;offshore software development","","9","","19","","18 Aug 2009","","","IEEE","IEEE Magazines"
"What Do Mobile App Users Complain About?","H. Khalid; E. Shihab; M. Nagappan; A. E. Hassan",Shopify; Concordia University; Rochester Institute of Technology; Queen's University,"IEEE Software","23 Apr 2015","2015","32","3","70","77","Mobile-app quality is becoming an increasingly important issue. These apps are generally delivered through app stores that let users post reviews. These reviews provide a rich data source you can leverage to understand user-reported issues. Researchers qualitatively studied 6,390 low-rated user reviews for 20 free-to-download iOS apps. They uncovered 12 types of user complaints. The most frequent complaints were functional errors, feature requests, and app crashes. Complaints about privacy and ethical issues and hidden app costs most negatively affected ratings. In 11 percent of the reviews, users attributed their complaints to a recent app update. This study provides insight into the user-reported issues of iOS apps, along with their frequency and impact, which can help developers better prioritize their limited quality assurance resources.","1937-4194","","10.1109/MS.2014.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6762802","mobile applications;software quality;user reviews;quality assurance;software engineering","Computer crashes;Privacy;Mobile communication;Tagging;Computer applications;Software quality;Quality assurance;Software engineering","mobile computing;operating systems (computers)","mobile App users;mobile app quality;app stores;iOS apps;user complaints;frequent complaints;functional errors;feature requests;app crashes;ethical issues;privacy issues;quality assurance resources","","168","","6","","10 Mar 2014","","","IEEE","IEEE Magazines"
"Microservices in Practice, Part 1: Reality Check and Service Design","C. Pautasso; O. Zimmermann; M. Amundsen; J. Lewis; N. Josuttis","University of Lugano; University of Applied Sciences of Eastern Switzerland, Rapperswil; API Academy; ThoughtWorks; NA","IEEE Software","16 Jan 2017","2017","34","1","91","98","Service-oriented architecture (SOA) and microservices insiders Mike Amundsen, James Lewis, and Nicolai Josuttis share their experiences and predictions with department editors Cesare Pautasso and Olaf Zimmermann.","1937-4194","","10.1109/MS.2017.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819415","microservices;service-oriented architecture;SOA;domain-driven design;DDD;Conway's law;Extreme Programming;XP;Mike Amundsen;James Lewis;Nicolai Josuttis;software engineering;software development","Service-oriented architecture;Software engineering;Semiconductor optical amplifiers;Computer architecture;Context modeling;Writing;Software development","service-oriented architecture","software architecture;software development;service-oriented architecture;microservices;service design;SOA","","47","","25","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Application-Screen Masking: A Hybrid Approach","A. Goldsteen; K. Kveler; T. Domany; I. Gokhman; B. Rozenberg; A. Farkash",IBM Research--Haifa; Technion--Israel Institute of Technology; Intensix; IBM Research--Haifa; IBM Research--Haifa; IBM Research--Haifa,"IEEE Software","30 Jun 2015","2015","32","4","40","45","Large organizations often face difficult tradeoffs in balancing the need to share information with the need to safeguard sensitive data. A prominent way to deal with this tradeoff is on-the-fly screen masking of sensitive data in applications. A proposed hybrid approach for masking Web application screens combines the advantages of the context available at the presentation layer with the flexibility and low overhead of masking at the network layer. This solution can identify sensitive information in the visual context of the application screen and then automatically generate the masking rules to enforce at run time. This approach supports the creation of highly expressive masking rules, while keeping rule authoring easy and intuitive, resulting in an easy to use, effective system. This article is part of a special issue on Security and Privacy on the Web. The Web extra at https://youtu.be/4u2FLqjaIiI is a short demonstration of a proposed hybrid approach for masking Web application screens that combines the advantages of the context available at the presentation layer with the flexibility and low overhead of masking at the network layer. The second Web extra at https://youtu.be/-Hz3P_H0UnU is a full-length demonstration of a proposed hybrid approach for masking Web application screens that combines the advantages of the context available at the presentation layer with the flexibility and low overhead of masking at the network layer.","1937-4194","","10.1109/MS.2015.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7106392","Web security;Web privacy;screen masking;data masking;context-based rules;Web applications;Web apps;software engineering;software development","Visualization;Computer security;Web services;Browsers;Context modeling;Security;HTML;Software engineering;Software developmnet","authorisation;data privacy;information management;Internet","application-screen masking;information sharing;sensitive data masking;presentation layer;network layer;rule authoring;data security;data privacy;Web application screens","","4","","7","","13 May 2015","","","IEEE","IEEE Magazines"
"Guidelines for Managing Requirements Rationales","A. K. Thurimella; M. Schubanz; A. Pleuss; G. Botterweck",Harman and Technical University of Munich; Brandenburg University of Technology Cottbus-Senftenberg; Lero; Lero,"IEEE Software","16 Jan 2017","2017","34","1","82","90","Requirements are identified and elaborated on the basis of stakeholders' decisions. The reasoning behind those decisions can be expressed as rationales. Systematic rationale management offers both short-term benefits, such as clearer requirements leading to fewer defects, and long-term benefits, such as simplified requirements evolution. However, little guidance exists for managing requirements rationales. This article presents guidelines to pragmatically capture, trace, maintain, and reuse such rationales. A list of questions augments the guidelines, improving their usability.","1937-4194","","10.1109/MS.2015.157","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7325184","requirements engineering;rationale;knowledge management;software evolution;software development;software engineering","Stakeholders;Requirements engineering;Organizations;Software engineering;Systematics","formal specification;formal verification;software maintenance;software reusability","requirements rationale management;requirements rationale reusability;requirements rationale maintainability;requirements rationale traceability","","3","","13","","11 Nov 2015","","","IEEE","IEEE Magazines"
"Components in the Pipeline","I. Gorton; A. Wynne; Y. Liu; J. Yin",Pacific Northwest National Laboratory; Pacific Northwest National Laboratory; Pacific Northwest National Laboratory; Pacific Northwest National Laboratory,"IEEE Software","25 Apr 2011","2011","28","3","34","40","State-of-the-art scientific instruments and simulations routinely produce massive datasets requiring intensive processing to disclose key features of the artifact or model under study. Scientists commonly call these data-processing pipelines, which are structured according to the pipe and-filter architecture pattern.1 Different stages typically communicate using files; each stage is an executable program that performs the processing needed at that point in the pipeline.The MeDICi (Middleware for Data-Intensive Computing) Integration Framework supports constructing complex software pipelines from distributed heterogeneous components and controlling qualities of service to meet performance, reliability and communication requirements.","1937-4194","","10.1109/MS.2011.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5719591","scientific software;pipelines;components;software engineering","Software engineering;Quality of service;Protocols;Data preprocessing","middleware;pipeline processing;software quality;software reliability","state-of-the-art scientific instruments;massive datasets;data-processing pipelines;pipe-and-filter architecture;MeDICi integration framework;qualities of service;reliability;middleware for data-intensive computing","","12","","8","","24 Feb 2011","","","IEEE","IEEE Magazines"
"Creating Self-Adapting Mobile Systems with Dynamic Software Product Lines","N. Gámez; L. Fuentes; J. M. Troya",University of Malaga; University of Malaga; University of Malaga,"IEEE Software","10 Mar 2015","2015","32","2","105","112","Mobile systems must cope with continuous context changes, making them an ideal fit with dynamic software product lines (DSPLs), which enable product adaptation at run time. In this DSPL-based process, devices upload only a small reconfiguration plan rather than the entire variability model, and providers manage diversity without disrupting the base model.","1937-4194","","10.1109/MS.2014.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6730834","dynamic reconfiguration;software product lines;mobile systems;software engineering","Context modeling;Adaptation models;Mobile communication;Unified modeling language;Runtime;Load modeling;Software engineering","mobile computing;software product lines","creating self-adapting mobile systems;dynamic software product lines;DSPL based process;product adaptation;variability model","","8","","13","","3 Feb 2014","","","IEEE","IEEE Magazines"
"Arguing Conformance","P. Graydon; I. Habli; R. Hawkins; T. Kelly; J. Knight",University of York; University of York; University of York; University of York; University of Virginia,"IEEE Software","20 Apr 2012","2012","29","3","50","57","Conformance to software standards plays an essential role in establishing confidence in high-integrity software systems. However, standards conformance suffers from uncertainty about its meaning for three reasons: because requirements of the standard must be interpreted to fit the specifics of the application; because standards can deliberately leave options for developers; and because goal-based software standards exist that simply specify the high-level principles of software assurance without prescribing a specific means of compliance. The overall effect of these issues is that when conformance to a software assurance standard is claimed, there can be a lack of clarity as to exactly what the claim entails. This article draws on principles and practice from the domain of safety argument construction to describe the use of explicit and structured conformance arguments to help address this problem.","1937-4194","","10.1109/MS.2012.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155712","standards;software and system safety;software engineering","Software;IEC standards;Safety;Educational institutions;Software engineering;Context","safety-critical software","arguing conformance;software standards;high integrity software systems;goal based software standards;software assurance;safety argument construction;safety-critical software","","34","","9","","21 Feb 2012","","","IEEE","IEEE Magazines"
"What Differentiates Chilean Niche Software Companies: Business Knowledge and Reputation","S. F. Ochoa; R. Robbes; M. Marques; L. Silvestre; A. Quispe",University of Chile; University of Chile; University of Chile; University of Chile; University of Chile,"IEEE Software","15 May 2017","2017","34","3","96","103","Chilean small software companies suffer a high mortality rate. Focus groups with 20 entrepreneurs and project managers from such companies shed light on what makes niche software companies more likely to survive. The extensive knowledge allowed by specializing in a niche increases the odds of success. Consequently, a company's improved reputation lets it better negotiate contracts and improve its financial situation.","1937-4194","","10.1109/MS.2017.64","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927917","small software companies;niche software companies;startup sustainability;software engineering;software development;Chilean software companies","Business;Software engineering;Contracts;Knowledge engineering;Encoding;Market opportunities;Market research","business data processing;contracts;financial management;project management;software houses;software management","Chilean small software companies;mortality rate;contracts;financial situation;business reputation;business knowledge;software company success","","2","","14","","15 May 2017","","","IEEE","IEEE Magazines"
"Achieving Reliable High-Frequency Releases in Cloud Environments","L. Zhu; D. Xu; A. B. Tran; X. Xu; L. Bass; I. Weber; S. Dwarakanathan",NICTA; NICTA; NICTA; NICTA; NICTA; NICTA; NICTA,"IEEE Software","10 Mar 2015","2015","32","2","73","80","Continuous delivery and deployment are dramatically shortening release cycles from months to hours. Cloud applications with high-frequency releases often rely heavily on automated tools and cloud infrastructure APIs to deploy new software versions. The authors report on reliability issues and how these tools and APIs contribute to them. They also analyze the trade-offs between using heavily baked and lightly baked virtual-image approaches, on the basis of experiments with Amazon Web Service OpsWorks APIs and the Chef configuration management tool. Finally, they propose error-handling practices for continuous-delivery facilities.","1937-4194","","10.1109/MS.2015.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006340","release engineering;continuous delivery;continuous deployment;DevOps;system administration;software engineering","Continuous production;Software reliability;Software development;Cloud computing;Virtual machining;Software engineering","application program interfaces;cloud computing;software reliability","achieving reliable high frequency releases;cloud environments;cloud applications;automated tools;cloud infrastructure API;software versions;virtual image approaches;Amazon Web Service OpsWorks API;chef configuration management tool","","11","","5","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Embedding Reflection and Learning into Agile Software Development","J. Babb; R. Hoda; J. Nørbjerg",West Texas A&M University; University of Auckland; Aalborg University,"IEEE Software","13 Jun 2014","2014","31","4","51","57","The theoretical underpinnings of agile methods emphasize regular reflection as a means to sustainable development pace and continuous learning, but in practice, high iteration pressure can diminish reflection opportunities. The Reflective Agile Learning Model (REALM) combines insights and results from studies of agile development practices in India, New Zealand, and the US with Schön's theory of reflective practice to embed reflection in everyday agile practices.","1937-4194","","10.1109/MS.2014.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6785921","reflective practice;agile software development;reflection-in-action;reflection-on-action;learning teams;learning organizations;software engineering;pervasive computing;project management","Software engineering;Software development;Reflection;Learning systems;Project management;Pervasive computing","learning (artificial intelligence);software prototyping;sustainable development","agile software development;theoretical underpinnings;sustainable development;continuous learning;high iteration pressure;reflective agile learning model;REALM;India;New Zealand;US","","20","","12","","9 Apr 2014","","","IEEE","IEEE Magazines"
"Tangible and Screen-Based Interfaces for End-User Workflow Modeling","A. Boden; C. Dörner; S. Draxler; V. Pipek; G. Stevens; V. Wulf",University of Siegen and Fraunhofer FIT; University of Siegen and Fraunhofer FIT; University of Siegen and Fraunhofer FIT; University of Siegen and Fraunhofer FIT; University of Siegen and Fraunhofer FIT; University of Siegen and Fraunhofer FIT,"IEEE Software","13 Jun 2014","2014","31","4","65","71","Bridging the gap between business needs and IT solutions is a major challenge in service-oriented computing, and recent research emphasizes the importance of including end users in service-based application development. An analysis of two different approaches - tangible and screen-based versions of tools - demonstrates how users can participate in the development of technical workflow models based on their perception of business processes.","1937-4194","","10.1109/MS.2013.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6515478","organizational management and coordination;human factors in software design;process infrastructure;software engineering;pervasive computing;project management","Software engineering;Computational modeling;Software development;User interfaces;Ports (Computers);Computers;Workflow management software","service-oriented architecture;user interfaces;workflow management software","tangible interface;screen-based interface;end-user workflow modeling;service-oriented computing;service-based application development;business process","","","","15","","13 May 2013","","","IEEE","IEEE Magazines"
"Secure Automotive Software: The Next Steps","L. Pike; J. Sharp; M. Tullsen; P. C. Hickey; J. Bielman",Galois; Galois; Galois; Galois; Galois,"IEEE Software","15 May 2017","2017","34","3","49","55","Previous research revealed pervasive software vulnerabilities in modern automobiles. This article presents a rejoinder to that research, discussing four general approaches to secure automotive software systems: compile-time assurance, runtime protection, automated testing, and architectural security. The authors discuss these approaches in the context of previous automotive exploits and the authors' work to build secure cyber-physical systems.","1937-4194","","10.1109/MS.2017.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927919","automotive software;security;software assurance;HACMS;High-Assurance Cyber Military Systems;software development;software engineering","Software engineering;Software testing;Automotive engineering;Cryptography;Computer security;Military communication","automotive engineering;cyber-physical systems;security of data","secure cyber-physical systems;architectural security;automated testing;runtime protection;compile-time assurance;automotive software system security","","3","","27","","15 May 2017","","","IEEE","IEEE Magazines"
"Projecting a Modular Future","M. Voelter; J. Warmer; B. Kolb",independent consultant; independent consultant; itemis,"IEEE Software","21 Aug 2015","2015","32","5","46","52","Two innovations are enhancing programming languages' capabilities. First, modularity lets you combine independently developed languages without changing their respective definitions. A language is no longer a fixed quantity; you can extend it with domain-specific constructs as needed. Second, projectional editing lets you build editors and IDEs that don't require parsers. Such editors and IDEs support a range of tightly integrated notations, including textual, symbolic, tabular, and graphical notations. In addition, by avoiding parsers, they avoid grammar composition's well-known limitations. Three examples illustrate how these two innovations affect programming-language design. A set of modular extensions of C for embedded programming enables efficient code generation and formal analysis. A language for requirements engineering flexibly combines structured and unstructured (prose) data. Finally, a language for defining insurance rules uses mathematical notation. These examples all rely on the open source JetBrains MPS (Meta Programming System) language workbench. This article is part of a special issue on Software Architecture.","1937-4194","","10.1109/MS.2014.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6866847","language engineering;language workbenches;projectional editing;domain-specific languages;programming languages;software engineering;MPS;Meta Programming System;mbeddr;software development","Syntactics;Generators;Embedded software;Programming;Computer languages;Software engineering;Software development","C language;formal specification;formal verification;program compilers;public domain software","requirements engineering;unstructured data;structured data;insurance rules;projectional editing;IDEs;graphical notations;tabular notations;symbolic notations;textual notations;grammar composition;programming-language design;C modular extensions;embedded programming;code generation;formal analysis;mathematical notation;open source JetBrains MPS;meta programming system language workbench;software architecture","","8","","8","","28 Jul 2014","","","IEEE","IEEE Magazines"
"Challenges to and Solutions for Refactoring Adoption: An Industrial Perspective","T. Sharma; G. Suryanarayana; G. Samarthyam",Siemens Technology and Services Private Limited; Siemens Technology and Services Private Limited; independent consultant and corporate trainer,"IEEE Software","28 Oct 2015","2015","32","6","44","51","Refactoring is a key approach for managing technical debt. In the past few years, refactoring techniques and tools have received considerable attention from researchers and tool vendors. However, several practical challenges must be overcome to facilitate the adoption of refactoring in industrial contexts. Results from a survey at the Siemens Corporate Development Center India highlight common challenges to refactoring adoption. The article also outlines ways to address these challenges and describes key initiatives the development center is planning and launching. This article is part of a special issue on Refactoring.","1937-4194","","10.1109/MS.2015.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7274239","refactoring;software design;design tools and techniques;quality analysis and evaluation;software engineering;software development","Software development;Code refractoring;Organizations;Technological innovation;Programming;Software engineering;Project management","DP industry;software maintenance;software tools","refactoring technique;refactoring tool;technical debt management;industrial context;Siemens Corporate Development Center India","","9","","16","","23 Sep 2015","","","IEEE","IEEE Magazines"
"Collaborative Repositories in Model-Driven Engineering [Software Technology]","J. Di Rocco; D. Di Ruscio; L. Iovino; A. Pierantonio",University of L'Aquila; University of L'Aquila; University of L'Aquila; University of L'Aquila,"IEEE Software","23 Apr 2015","2015","32","3","28","34","Recently proposed model repositories aim to support specific needs--for example, collaborative modeling, the ability to use different modeling tools in software life-cycle management, tool interoperability, increased model reuse, and the integration of heterogeneous models.","1937-4194","","10.1109/MS.2015.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093036","model-driven engineering;MDE;model repositories;software engineering;software development;MDEForge","Unified modeling language;Software engineering;Adaptation models;Collaboration;Model driven engineering;Interoperability;Software development","open systems;software development management;software reusability","collaborative repositories;model-driven engineering;collaborative modeling;software life-cycle management;tool interoperability;model reuse;heterogeneous model integration","","27","","7","","23 Apr 2015","","","IEEE","IEEE Magazines"
"A Reference Architecture and Knowledge-Based Structures for Smart Manufacturing Networks","M. P. Papazoglou; W. van den Heuvel; J. E. Mascolo",Tilburg University; Tilburg University; Fiat Research Center,"IEEE Software","23 Apr 2015","2015","32","3","61","69","Smart manufacturing networks describe a production chain as a marketplace that delivers products on demand. In this chain, partners collaborate in product work routings that connect dispersed service-enabled systems with resources, materials, human expertise, and operation-equipment combinations. Researchers have developed a reference architecture for developing a highly connected, knowledge-enabled manufacturing network that decentralizes production control. This network will enable collaborative manufacturing of new products and response to product demand, allowing for greater production flexibility and product variability.","1937-4194","","10.1109/MS.2015.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093038","smart manufacturing networks;reference architecture for manufacturing;manufacturing lifecycle methods;knowledge-based model for smart manufacturing;manufacturing analytics;resource integration and interoperation;automotive systems;software engineering;software development","Manufacturing;Software variability;Computer architecture;Service-oriented architecture;Knowledge management;Automotive engineering;Automotive engineering;Software engineering","knowledge based systems;manufacturing systems","product variability;production flexibility;collaborative manufacturing;production control;knowledge-enabled manufacturing network;operation-equipment combinations;dispersed service-enabled systems;product work routings;production chain;smart manufacturing networks;knowledge-based structures;reference architecture","","35","","7","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Vroom: Faster Build Processes for Java","J. Bell; E. Melski; M. Dattatreya; G. E. Kaiser",Columbia University; Electric Cloud; Electric Cloud; Columbia University,"IEEE Software","10 Mar 2015","2015","32","2","97","104","Build processes are too slow. Because most of the build time for Java projects is spent executing tests, researchers have focused on speeding up testing. They've integrated two complementary approaches into a system that seamlessly supports Ant and Maven JUnit build processes. The first approach, unit test virtualization, isolates in-memory dependencies among test cases, which otherwise are isolated inefficiently by restarting the Java Virtual Machine (JVM) before every test. The system supports just-in-time reinitialization of only the small portion of memory needed by the next test, reusing a single JVM. The implementation of this approach is called VMVM (Virtual Machine in the Virtual Machine, pronounced ""vroom vroom""). In addition, simple setup and tear-down resource management methods designed for sequential execution lead to conflicts when the resources are accessed concurrently. So, the second approach, virtualized unit test virtualization, isolates external dependencies such as files and network ports while long-running tests execute in parallel. For this, the system distributes testing jobs in round-robin manner among OS-level virtual machines. The result is, on average, a 51 percent speedup of application build times. The implementation of this approach is called VMVMVM (Virtual Machine in a Virtual Machine on a Virtual Machine ""vroom vroom vroom"").","1937-4194","","10.1109/MS.2015.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006344","test execution;testing tools;software engineering","Software development;Java;Virtual machining;Ports (Computers);Open source software;Continuous production;Software testing;Software engineering","Java;operating systems (computers);resource allocation;virtual machines;virtualisation","Java projects;Ant and Maven JUnit build processes;unit test virtualization;in-memory dependencies;Java virtual machine;JVM;just-in-time reinitialization;VMVM;tear-down resource management methods;virtualized unit test virtualization;long-running tests;round-robin manner;OS-level virtual machines;vroom vroom vroom;virtual machine in a virtual machine on a virtual machine","","4","","5","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Chaos Engineering","A. Basiri; N. Behnam; R. de Rooij; L. Hochstein; L. Kosewski; J. Reynolds; C. Rosenthal",Netflix; Netflix; Netflix; Netflix; Netflix; Netflix; Netflix,"IEEE Software","25 Apr 2016","2016","33","3","35","41","Modern software-based services are implemented as distributed systems with complex behavior and failure modes. Many large tech organizations are using experimentation to verify such systems' reliability. Netflix engineers call this approach chaos engineering. They've determined several principles underlying it and have used it to run experiments. This article is part of a theme issue on DevOps.","1937-4194","","10.1109/MS.2016.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7436642","chaos engineering;Chaos Monkey;Netflix;DevOps;software development;software engineering","Chaos theory;Streaming media;Production processes;Steady-state;Software engineering;Organizations","chaos;distributed processing;software reliability;systems analysis","software-based services;distributed systems;system reliability;Netflix engineers;chaos engineering;DevOps","","43","","11","","18 Mar 2016","","","IEEE","IEEE Magazines"
"A Test Framework for Communications-Critical Large-Scale Systems","M. A. Nabulsi; R. M. Hierons",Brunel University; Brunel University,"IEEE Software","23 Apr 2015","2015","32","3","86","93","Today's large-scale systems couldn't function without the reliable availability of a range of network communications capabilities. Software, hardware, and communications technologies have been advancing throughout the past two decades. However, the methods that industry commonly uses to test large-scale systems that incorporate critical communications interfaces haven't kept pace. The need exists for a specifically tailored framework to achieve effective, precise testing of communications-critical large-scale systems. A proposed test framework offers an alternative to the current generic approaches that lead to inefficient, costly testing in industry. A case study illustrates its benefits, which can also be realized with other comparable systems.","1937-4194","","10.1109/MS.2014.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6785925","testing;test framework;communications-critical large-scale systems;IT systems;test case prioritization;requirements prioritization;software engineering","Software testing;Large-scale systems;Requirements engineering;Software engineering;Information technology;ISO standards","program testing;safety-critical software","communications-critical large-scale systems;network communication capability;formal software test methodology;communication technology;software technology;hardware technology","","","","8","","9 Apr 2014","","","IEEE","IEEE Magazines"
"Automated Synthesis of Service Choreographies","M. Autili; P. Inverardi; M. Tivoli",University of L'Aquila; University of L'Aquila; University of L'Aquila,"IEEE Software","4 Feb 2015","2015","32","1","50","57","Future Internet research promotes the production of a distributed-computing environment that will be increasingly surrounded by a virtually infinite number of software services that can be composed to meet user needs. Services will be increasingly active entities that, communicating peer-to-peer, can proactively make decisions and autonomously perform tasks. Service choreography is a form of decentralized service composition that describes peer-to-peer message exchanges among participant services from a global perspective. In a distributed setting, obtaining the coordination logic required to realize a choreography is nontrivial and error prone. So, automatic support for realizing choreographies is needed. For this purpose, researchers developed a choreography synthesis tool. The Web extra at http://www.di.univaq.it/marco.autili/synthesis/shortdemo/demo.htm is a short demonstration of CHOReOSynt, a choreography synthesis tool.","1937-4194","","10.1109/MS.2014.131","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6915593","Future Internet;service choreographies;automated synthesis;distributed coordination;software engineering","Software engineering;Business;Peer-to-peer computing;Collaboration;Internet;XML;Distributed processing","Internet;peer-to-peer computing","service choreography automated synthesis;future Internet research;distributed-computing environment;software services;peer-to-peer communication;decentralized service composition;peer-to-peer message exchange;coordination logic;CHOReOSynt","","23","","10","","2 Oct 2014","","","IEEE","IEEE Magazines"
"Responsibility-Driven Architecture","S. Blair; R. Watt; T. Cull",Outformations; Outformations; Thedwick,"IEEE Software","25 Feb 2010","2010","27","2","26","32","Responsibility-driven architecture (RDA) explores when, how, and who should make architectural decisions. The author's research attempts to answer these questions from an agile perspective and proposes a framework to improve architectural design. It has also provided an opportunity to reframe the role and relevancy of the architect in agile development.","1937-4194","","10.1109/MS.2010.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420795","agile;software architecture;economics;software engineering process","Computer architecture;Security;Economics;Agile manufacturing;Programming;Software engineering","decision making;software architecture;software prototyping","responsibility driven architecture;architectural decision;agile development;architectural design","","8","","6","","25 Feb 2010","","","IEEE","IEEE Magazines"
"Diagnosing Energy Efficiency and Performance for Mobile Internetware Applications","Y. Liu; C. Xu; S. Cheung",The Hong Kong University of Science and Technology; Nanjing University; The Hong Kong University of Science and Technology,"IEEE Software","4 Feb 2015","2015","32","1","67","75","Many smartphone applications' smart services are realized in a way that wastes energy or degrades performance, seriously affecting the user experience. What's worse, developers lack powerful tools to combat such problems, curbing the growth of Internet-based mobile computing. Research communities and industries have issued a strong call for effective techniques to diagnose energy and performance bugs in smartphone applications. This article describes bug characteristics, discusses diagnostic challenges, and reviews state-of-the-art diagnostic techniques. A case study shows how a representative tool analyzed commercial Android applications and the Samsung Mobile Software Developer's Kit, providing useful diagnostic information.","1937-4194","","10.1109/MS.2015.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030255","smartphone applications;energy efficiency;performance bugs;automated diagnosis;Android;Internet;Internetware;software engineering","Computer bugs;Global Positioning System;Sensors;Smart phones;Batteries;Graphical user interfaces;Software engineering;Internet;Androids;Energy efficiency","energy conservation;Internet;mobile computing;program debugging;smart phones","energy efficiency diagnosis;performance bugs;mobile Internetware applications;smartphone application smart services;Internet-based mobile computing;bug characteristics;commercial Android applications;Samsung Mobile Software Developer Kit","","18","","15","","4 Feb 2015","","","IEEE","IEEE Magazines"
"Run-Time Variability for Context-Aware Smart Workflows","A. Murguzur; S. Trujillo; H. Truong; S. Dustdar; Ó. Ortiz; G. Sagardui",IK4-Ikerlan; IK4-Ikerlan; Vienna University of Technology; Vienna University of Technology; Technical University of Madrid; Mondragon University,"IEEE Software","23 Apr 2015","2015","32","3","52","60","In variant-rich workflow-based systems, a major concern for process variability is the context-aware configuration of the variants. This means that context information, not users, drives process configuration. To support context-aware process configuration in a dynamic environment, in which context information is available only at run time, smart workflows must be customized at run time. The LateVa (Late Variability for Context-Aware Smart Workflows) framework lets developers model and manage process variability by composing base models, fragments, and variability models and by deferring binding to run time. Base models and fragments are reusable, thereby reducing the modeling effort for developing variants. LateVa also includes an automated run-time-variability mechanism for context-aware smart workflows.","1937-4194","","10.1109/MS.2015.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093015","reuse models;current awareness systems;late binding;process variability;workflow-based systems;software engineering","Software variability;Context modeling;Data models;Workflow management software;Adaptation models;Software engineering","software development management;software reusability;ubiquitous computing;workflow management software","context-aware smart workflows;variant-rich workflow-based systems;context-aware configuration;process configuration;LateVa framework;late variability for context-aware smart workflows;process variability;automated run-time-variability mechanism","","4","","7","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Scalable-Application Design for the IoT","J. Venkatesh; B. Aksanli; C. S. Chan; A. S. Akyürek; T. S. Rosing","University of California, San Diego; San Diego State University; University of California, San Diego; University of California, San Diego; University of California, San Diego","IEEE Software","16 Jan 2017","2017","34","1","62","70","The Internet of Things envisions a Web-connected infrastructure of sensing and actuation devices. However, the current state of the art presents another reality: monolithic end-to-end applications tightly coupled to a limited set of sensors and actuators. Growing such applications with new devices or behaviors, or extending the existing infrastructure with new applications, involves redesign and deployment. A proposed approach breaks these applications up into an equivalent set of functional units called context engines, whose I/O transformations are driven by general-purpose machine learning. This approach decreases computational redundancy and complexity with a minimal impact on accuracy. Researchers evaluated this approach's scalability--how the context engines' overhead grows as the input data and number of computational nodes increase. In a large-scale case study of residential smart-grid control, this approach provided better accuracy and scaling than the state-of-the-art single-stage approach.","1937-4194","","10.1109/MS.2017.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819406","context-aware computing;Internet of Things;software engineering;software development;smart grid;smart-grid control;context engines","Internet of things;Scalability;Context awareness;Software engineering;Smart grids","Internet;Internet of Things;learning (artificial intelligence);power engineering computing;smart power grids","scalable-application design;IoT applications;functional units;context engines;I/O transformations;machine learning;Web-connected infrastructure;sensing devices;actuation devices;computational nodes;input data;residential smart-grid control;Internet of Things","","12","","14","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Toward Data-Driven Requirements Engineering","W. Maalej; M. Nayebi; T. Johann; G. Ruhe",University of Hamburg; University of Calgary; University of Hamburg; University of Calgary,"IEEE Software","29 Dec 2015","2016","33","1","48","54","Nowadays, users can easily submit feedback about software products in app stores, social media, or user groups. Moreover, software vendors are collecting massive amounts of implicit feedback in the form of usage data, error logs, and sensor data. These trends suggest a shift toward data-driven user-centered identification, prioritization, and management of software requirements. Developers should be able to adopt the requirements of masses of users when deciding what to develop and when to release. They could systematically use explicit and implicit user data in an aggregated form to support requirements decisions. The goal is data-driven requirements engineering by the masses and for the masses.","1937-4194","","10.1109/MS.2015.153","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7325177","app reviews;decision support;requirements engineering;software analytics;usage data;software engineering;software development","Requirements engineering;Software engineering;Stakeholders;Media;Feature extraction;Market research","formal specification;software management","data-driven requirements engineering;user feedback;software products;software vendors;usage data;error logs;sensor data;data-driven user-centered software requirement identification;data-driven user-centered software requirement prioritization;data-driven user-centered software requirement management;explicit user data;implicit user data","","93","","19","","11 Nov 2015","","","IEEE","IEEE Magazines"
"Writing Code to Prototype, Ideate, and Discover","J. Brandt; P. J. Guo; J. Lewenstein; M. Dontcheva; S. R. Klemmer",Stanford University; Stanford University; GoodGuide.com; Adobe Systems; Stanford University,"IEEE Software","25 Aug 2009","2009","26","5","18","24","People often write code to prototype, ideate, and discover. To do this, they work opportunistically, emphasizing speed and ease of development over code robustness and maintainability. Quickly hacking a program together can provide both practical and learning benefits for novices and experts: professional programmers and designers prototype to explore and communicate ideas, scientists program laboratory instruments, and entrepreneurs assemble complex spreadsheets to better understand their business. Their diverse activities share an emphasis on speed and ease of development over robustness and maintainability.","1937-4194","","10.1109/MS.2009.147","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222789","opportunistic programming;prototyping;debugging;software engineering","Writing;Prototypes;Programming profession;Hardware;Software prototyping;Software engineering;HTML;Java;Interleaved codes;Compressors","computer crime;software maintenance;software prototyping","opportunistic programming;code writing;code robustness;maintainability;hacking","","18","","12","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Analyzing Ad Library Updates in Android Apps","I. J. Mojica Ruiz; M. Nagappan; B. Adams; T. Berger; S. Dienst; A. E. Hassan",McAfee; Rochester Institute of Technology; Ecole Polytechnique de Montreal; University of Waterloo; University of Leipzig; Queen's University,"IEEE Software","26 Feb 2016","2016","33","2","74","80","Because more than 90 percent of mobile apps are free, advertising on them is a key revenue source for their developers. Advertisements are served on apps through embedded specialized code called ad libraries. Unlike with other types of libraries, app developers can't ignore new ad libraries or new versions of embedded ad libraries without risking revenue loss. However, updating ad libraries incurs costs, which can become problematic as these updates become more frequent. Researchers investigated the costs of updating ad libraries and explored the frequency of ad library updates in Android apps. An analysis of numerous versions of Android apps over 12 months showed that almost half underwent ad library updates (an ad library was added, removed, or updated). Moreover, in nearly 14 percent of the app updates with at least one ad library update, no changes to the app's API occurred. This suggests that maintaining the ad libraries entailed substantial additional effort for the developers.","1937-4194","","10.1109/MS.2014.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420512","mobile apps;advertisement libraries;software maintenance;Android;Google Play;software engineering;software development","Computer applications;Mobile communication;Software maintenance;Software engineering;Androids;Humanoid robots","advertising;Android (operating system);application program interfaces;mobile computing;software libraries","advertisement library update analysis;Android application;mobile applications;revenue loss;library addition;application API;library removal","","14","","17","","26 Feb 2016","","","IEEE","IEEE Magazines"
"The Road Ahead for Architectural Languages","P. Lago; I. Malavolta; H. Muccini; P. Pelliccione; A. Tang",VU University Amsterdam; Gran Sasso Science Institute; Università dellAquila; Chalmers University of Technology and University of Gothenburg; Swinburne University of Technology,"IEEE Software","4 Feb 2015","2015","32","1","98","105","Despite the huge number of architectural languages that have been proposed in the last two decades, evidence today shows that industry-ready, well-accepted, and recognized languages for producing architecture descriptions are still lacking. This article explores the usability requirements of architectural languages from the perspectives of language definition, language mechanisms, and tool support. With a better understanding of architectural-language requirements, the authors explore the use of model-driven engineering to realize next-generation architectural languages, as well as its limitations.","1937-4194","","10.1109/MS.2014.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6756703","software architecture;architectural language;model-driven engineering;MDE;software engineering","Software architecture;Unified modeling language;Computer languages;Software engineering;Computer applications","software architecture;software tools;Unified Modeling Language","next-generation architectural languages;usability requirements;language definition;language mechanisms;tool support;model-driven engineering;UML-based notation","","18","","11","","5 Mar 2014","","","IEEE","IEEE Magazines"
"Infrastructure as a Service and Cloud Technologies","N. Serrano; G. Gallardo; J. Hernantes",University of Navarra; University of Navarra; University of Navarra,"IEEE Software","10 Mar 2015","2015","32","2","30","36","To choose the most appropriate cloud-computing model for your organization, you must analyze your IT infrastructure, usage, and needs. To help with this, this article describes cloud computing's current status.","1937-4194","","10.1109/MS.2015.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057553","infrastructure as a service;IaaS;public clouds;private clouds;hybrid clouds;software engineering;software development;cloud computing;Amazon Web Services;AWS;Microsoft Azure;Rackspace;Google Compute Engine;HP Cloud Compute;IBM Cloud;Eucalyptus;OpenStack;CloudStack;VMware","Cloud computing;Computer security;Servers;Software engineering;Google;Computer architecture","cloud computing","infrastructure as a service;cloud technologies;cloud computing model;IT infrastructure","","26","","7","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Access Control in JavaScript","R. Toledo; E. Tanter",University of Chile; University of Chile,"IEEE Software","18 Aug 2011","2011","28","5","76","84","ZAC is a practical lightweight library for access control in JavaScript based on aspect orientation. Its access control architecture is stack based, similar to those of Java and C#. However, ZAC integrates other features for more expressive access control. First, access control policies can be enforced at the level of objects, which permits more fine-grained control over resource access. Second, policies in ZAC can base their decisions on scripts' execution history. This lets developers express policies that are impossible to define using other models, such as bounded-time execution.","1937-4194","","10.1109/MS.2010.154","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645644","language constructs and features;scripting languages;semantics;software;software engineering","Access control;Java;Computer architecture;Performance analysis;Semantics;Computer languages;Software engineering","aspect-oriented programming;authorisation;Java;software libraries","JavaScript;ZAC;aspect orientation;access control architecture;access control policies;script execution history","","2","1","8","","29 Nov 2010","","","IEEE","IEEE Magazines"
"Developing, Verifying, and Maintaining High-Quality Automated Test Scripts","V. Garousi; M. Felderer",Hacettepe University; University of Innsbruck,"IEEE Software","25 Apr 2016","2016","33","3","68","75","With the increasing importance, size, and complexity of automated test suites, the need exists for suitable methods and tools to develop, assess the quality of, and maintain test code (scripts) in parallel with regular production (application) code. A recent review paper called this subarea of software testing software test code engineering (STCE). This article summarizes STCE tools, techniques, and guidelines. It also presents specific quantitative examples in this area based on experience in projects and raises important issues practitioners and researchers must address to further advance this field.","1937-4194","","10.1109/MS.2016.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7412621","software engineering;software testing;test automation;software test code engineering;test scripts;test code","Software engineering;Production processes;Quality assessment;Maintenance engineering;Software testing;Test automation","program testing;program verification;software maintenance","automated test script development;automated test script verification;automated test script maintenance;software testing;software test code engineering;STCE","","21","","18","","18 Feb 2016","","","IEEE","IEEE Magazines"
"Benefit Points: The Best Part of the Story","J. E. Hannay; H. C. Benestad; K. Strand",Simula Research Laboratory; Expertware; PROMIS,"IEEE Software","15 May 2017","2017","34","3","73","85","Delivering valuable software to your customer is the first priority in agile management and development. The product owner is involved along the way, and backlogs are prioritized, with the best of intentions to maximize business value early and eliminate waste. Yet in many IT development projects, bewilderment remains as to how to express business value in process decisions and the delivered system. Also, projects continue to implement functionality that's off the mark or never used. This situation occurs because there isn't sufficient methodological support to determine and monitor business value or to link business value decisions to the development project's mechanics. However, researchers have developed a bundle of easy-to-use core practices that help systematize a project's evolving knowledge. Although these practices are simple, they provide powerful support for monitoring project progress on both the realized business value and the realized costs.","1937-4194","","10.1109/MS.2017.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927918","return on investment;MISHRI;Model for Integrating Soft and Hard Return on Investment;satisficing;business value;agile management;benefit points;software development;software engineering","Software engineering;Stakeholders;Planning;Productivity;Management;Information technology;Agile computing","project management;software prototyping","agile management;agile development;product owner;business value maximization;waste elimination;IT development projects;project progress monitoring","","4","","28","","15 May 2017","","","IEEE","IEEE Magazines"
"A Survey on Open Source Software Trustworthiness","V. del Bianco; L. Lavazza; S. Morasca; D. Taibi",OpenSoftEngineering; Università degli Studi dell'Insubria; Università degli Studi dell'Insubria; Università degli Studi dell'Insubria,"IEEE Software","18 Aug 2011","2011","28","5","67","75","Trustworthiness is a crucial characteristic when it comes to evaluating any product, even more so for open source software, which is now becoming widely used. The authors conducted a survey to identify the reasons and motivations that lead software companies to adopt or reject open source software; they then ranked, according to importance, the specific trust factors used when selecting an open source software component or product. The motivations and importance ranking of factors might be useful for both developers of open source software (to make their products and components more useful for other stakeholders) and to future prospective open source software users.","1937-4194","","10.1109/MS.2011.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984797","open source software;trustworthiness;internal software qualities;external software qualities;pragmatic software engineering","Open source software;Software reliability;Reliability;Software engineering","public domain software;security of data","open source software trustworthiness;software companies;open source software users","","30","","9","","18 Aug 2011","","","IEEE","IEEE Magazines"
"On the Value of Ensemble Effort Estimation","E. Kocaguneli; T. Menzies; J. W. Keung","West Virginia University, Morgantown; West Virginia University, Morgantown; The Hong Kong Polytechnic University, Hong Kong","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1403","1416","Background: Despite decades of research, there is no consensus on which software effort estimation methods produce the most accurate models. Aim: Prior work has reported that, given M estimation methods, no single method consistently outperforms all others. Perhaps rather than recommending one estimation method as best, it is wiser to generate estimates from ensembles of multiple estimation methods. Method: Nine learners were combined with 10 preprocessing options to generate 9 × 10 = 90 solo methods. These were applied to 20 datasets and evaluated using seven error measures. This identified the best n (in our case n = 13) solo methods that showed stable performance across multiple datasets and error measures. The top 2, 4, 8, and 13 solo methods were then combined to generate 12 multimethods, which were then compared to the solo methods. Results: 1) The top 10 (out of 12) multimethods significantly outperformed all 90 solo methods. 2) The error rates of the multimethods were significantly less than the solo methods. 3) The ranking of the best multimethod was remarkably stable. Conclusion: While there is no best single effort estimation method, there exist best combinations of such effort estimation methods.","1939-3520","","10.1109/TSE.2011.111","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6081882","Software cost estimation;ensemble;machine learning;regression trees;support vector machines;neural nets;analogy;k-NN","Costs;Software performance;Measurement uncertainty;Taxonomy;Machine learning;Regression tree analysis;Support vector machines;Neural networks","software development management","ensemble effort estimation;software effort estimation;single method;multiple estimation method;error measures","","124","","82","","15 Nov 2011","","","IEEE","IEEE Journals"
"Determining the Cause of a Design Model Inconsistency","A. Reder; A. Egyed","Johannes Kepler University Linz, Linz; Johannes Kepler University Linz, Linz","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1531","1548","When a software engineer finds an inconsistency in a model, then the first question is why? What caused it? Obviously, there must be an error. But where could it be? Or is the design rule erroneous and if yes then which part? The cause of an inconsistency identifies the part of the model or design rule where the error must be. We believe that the visualization of an inconsistency ought to visualize the cause. Understanding the cause is of vital importance before a repair can even be formulated. Indeed, any automation (e.g., code generation, refactoring) has to be considered with caution if it involves model elements that cause inconsistencies. This paper analyzes the basic structure of inconsistent design rules as well as their behavior during validation and presents an algorithm for computing its cause. The approach is fully automated, tool supported, and was evaluated on 14,111 inconsistencies across 29 design models. We found that our approach computes correct causes for inconsistencies, these causes are nearly always a subset of the model elements investigated by the design rules' validation (a naive cause computation approximation), and the computation is very fast (99.8 percent of the causes are computable in <; 100 ms).","1939-3520","","10.1109/TSE.2013.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6560054","Design tools and techniques;programming environments/construction tools;validation","Unified modeling language;Computational modeling;Context;Maintenance engineering;Visualization;Context modeling;Light emitting diodes","software development management","design model inconsistency;software engineer;code generation;refactoring;model elements;inconsistent design rules","","15","","33","","16 Jul 2013","","","IEEE","IEEE Journals"
"Where Should We Fix This Bug? A Two-Phase Recommendation Model","D. Kim; Y. Tao; S. Kim; A. Zeller","The Hong Kong University of Science and Technology, Hong Kong; The Hong Kong University of Science and Technology, Hong Kong; The Hong Kong University of Science and Technology, Hong Kong; Saarland University, Saarland","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1597","1610","To support developers in debugging and locating bugs, we propose a two-phase prediction model that uses bug reports' contents to suggest the files likely to be fixed. In the first phase, our model checks whether the given bug report contains sufficient information for prediction. If so, the model proceeds to predict files to be fixed, based on the content of the bug report. In other words, our two-phase model ""speaks up"" only if it is confident of making a suggestion for the given bug report; otherwise, it remains silent. In the evaluation on the Mozilla ""Firefox"" and ""Core"" packages, the two-phase model was able to make predictions for almost half of all bug reports; on average, 70 percent of these predictions pointed to the correct files. In addition, we compared the two-phase model with three other prediction models: the Usual Suspects, the one-phase model, and BugScout. The two-phase model manifests the best prediction performance.","1939-3520","","10.1109/TSE.2013.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6517844","Bug reports;machine learning;patch file prediction","Predictive models;Feature extraction;Computer bugs;Software;Computational modeling;Data mining;Noise","formal verification;program debugging","two-phase recommendation model;debugging;two-phase prediction model;bug report;two-phase model;speaks up;Mozilla packages;Firefox packages;Core packages;BugScout","","65","1","66","","21 May 2013","","","IEEE","IEEE Journals"
"Matching and Merging of Variant Feature Specifications","S. Nejati; M. Sabetzadeh; M. Chechik; S. Easterbrook; P. Zave","Simula Research Laboratory, Lysaker; Simula Research Laboratory, Lysaker; University of Toronto, Toronto; University of Toronto, Toronto; AT&T Laboratories-Research, Florham Park","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1355","1375","Model Management addresses the problem of managing an evolving collection of models by capturing the relationships between models and providing well-defined operators to manipulate them. In this paper, we describe two such operators for manipulating feature specifications described using hierarchical state machine models: Match, for finding correspondences between models, and Merge, for combining models with respect to known or hypothesized correspondences between them. Our Match operator is heuristic, making use of both static and behavioral properties of the models to improve the accuracy of matching. Our Merge operator preserves the hierarchical structure of the input models, and handles differences in behavior through parameterization. This enables us to automatically construct merges that preserve the semantics of hierarchical state machines. We report on tool support for our Match and Merge operators, and illustrate and evaluate our work by applying these operators to a set of telecommunication features built by AT&T.","1939-3520","","10.1109/TSE.2011.112","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6086550","Model management;match;merge;hierarchical state machines;statecharts;behavior preservation;variability modeling;parameterization","Computational modeling;Semantics;Hierarchical systems;Pragmatics;Parameterization;Electronic mail;Voice mail","finite state machines;formal specification","variant feature specification;model management;hierarchical state machine model;match operator;static property;behavioral property;merge operator;hierarchical structure;tool support;telecommunication feature","","16","","83","","22 Nov 2011","","","IEEE","IEEE Journals"
"Dealing with Burstiness in Multi-Tier Applications: Models and Their Parameterization","G. Casale; N. Mi; L. Cherkasova; E. Smirni","Imperial College London, London; Northeastern University, Boston; Hewlett-Packard Laboratories, Palo Alto; College of William and Mary, Williamsburg","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1040","1053","Workloads and resource usage patterns in enterprise applications often show burstiness resulting in large degradation of the perceived user performance. In this paper, we propose a methodology for detecting burstiness symptoms in multi-tier applications but, rather than identifying the root cause of burstiness, we incorporate this information into models for performance prediction. The modeling methodology is based on the index of dispersion of the service process at a server, which is inferred by observing the number of completions within the concatenated busy times of that server. The index of dispersion is used to derive a Markov-modulated process that captures burstiness and variability of the service process at each resource well and that allows us to define queueing network models for performance prediction. Experimental results and performance model predictions are in excellent agreement and argue for the effectiveness of the proposed methodology under both bursty and nonbursty workloads. Furthermore, we show that the methodology extends to modeling flash crowds that create burstiness in the stream of requests incoming to the application.","1939-3520","","10.1109/TSE.2011.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311395","Capacity planning;multi-tier applications;bursty workload;bottleneck switch;index of dispersion","Servers;Indexes;Dispersion;Switches;Predictive models;Estimation","client-server systems;Markov processes;queueing theory;resource allocation;software architecture","multitier applications;resource usage patterns;workload patterns;enterprise applications;user performance degradation;burstiness symptom detection;burstiness root cause identification;performance prediction model;server busy times;Markov-modulated process;service process variability;queueing network models;nonbursty workloads;flash crowd model","","29","","25","","24 Sep 2012","","","IEEE","IEEE Journals"
"Featured Transition Systems: Foundations for Verifying Variability-Intensive Systems and Their Application to LTL Model Checking","A. Classen; M. Cordy; P. Schobbens; P. Heymans; A. Legay; J. Raskin","University of Namur (FUNDP), Namur; University of Namur (FUNDP), Namur; University of Namur (FUNDP), Namur; University of Namur (FUNDP), Namur and INRIA Lille-Nord Europe, France; IRISA/INRIA Rennes, France Université de Liège, Rennes Liège; Université Libre de Bruxelles (ULB), Brussels","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1069","1089","The premise of variability-intensive systems, specifically in software product line engineering, is the ability to produce a large family of different systems efficiently. Many such systems are critical. Thorough quality assurance techniques are thus required. Unfortunately, most quality assurance techniques were not designed with variability in mind. They work for single systems, and are too costly to apply to the whole system family. In this paper, we propose an efficient automata-based approach to linear time logic (LTL) model checking of variability-intensive systems. We build on earlier work in which we proposed featured transitions systems (FTSs), a compact mathematical model for representing the behaviors of a variability-intensive system. The FTS model checking algorithms verify all products of a family at once and pinpoint those that are faulty. This paper complements our earlier work, covering important theoretical aspects such as expressiveness and parallel composition as well as more practical things like vacuity detection and our logic feature LTL. Furthermore, we provide an in-depth treatment of the FTS model checking algorithm. Finally, we present SNIP, a new model checker for variability-intensive systems. The benchmarks conducted with SNIP confirm the speedups reported previously.","1939-3520","","10.1109/TSE.2012.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6389685","Formal methods;model checking;verification;variability;features;software product lines","Unified modeling language;Semantics;Software;Labeling;Automata;Quality assurance","automata theory;formal logic;formal verification;software quality","featured transition systems;variability-intensive system verification;LTL model checking;software product line engineering;quality assurance techniques;automata-based approach;linear time logic model checking;mathematical model;FTS model checking algorithm;SNIP;model checker","","105","","74","","20 Dec 2012","","","IEEE","IEEE Journals"
"Quality-Aware Service Selection for Service-Based Systems Based on Iterative Multi-Attribute Combinatorial Auction","Q. He; J. Yan; H. Jin; Y. Yang","Services Computing Technology and System Lab, Cluster and Grid Computing Lab, School of Computer Science and Technology, Huazhong University of Science and Technology, Wuhan, China; School of Information Systems and Technology, University of Wollongong, Wollongong, Australia; Services Computing Technology and System Lab, Cluster and Grid Computing Lab, School of Computer Science and Technology, Huazhong University of Science and Technology, Wuhan, China; School of Computer Science and Technology, Anhui University, Hefei, China","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","2","192","215","The service-oriented paradigm offers support for engineering service-based systems (SBSs) based on service composition where existing services are composed to create new services. The selection of services with the aim to fulfil the quality constraints becomes critical and challenging to the success of SBSs, especially when the quality constraints are stringent. However, none of the existing approaches for quality-aware service composition has sufficiently considered the following two critical issues to increase the success rate of finding a solution: 1) the complementarities between services; and 2) the competition among service providers. This paper proposes a novel approach called combinatorial auction for service selection (CASS) to support effective and efficient service selection for SBSs based on combinatorial auction. In CASS, service providers can bid for combinations of services and apply discounts or premiums to their offers for the multi-dimensional quality of the services. Based on received bids, CASS attempts to find a solution that achieves the SBS owner's optimisation goal while fulfilling all quality constraints for the SBS. When a solution cannot be found based on current bids, the auction iterates so that service providers can improve their bids to increase their chances of winning. This paper systematically describes the auction process and the supporting mechanisms. Experimental results show that by exploiting the complementarities between services and the competition among service providers, CASS significantly outperforms existing quality-aware service selection approaches in finding optimal solutions and guaranteeing system optimality. Meanwhile, the duration and coordination overhead of CASS are kept at satisfactory levels in scenarios on different scales.","1939-3520","","10.1109/TSE.2013.2297911","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6702520","Service-based system;combinatorial auction;quality of service;service composition;service selection;web services;integer programming","Scattering;Quality of service;Optimization;Contracts;Abstracts;Time factors","combinatorial mathematics;iterative methods;quality of service;service-oriented architecture;software quality;Web services","system optimality;optimal solutions;auction mechanisms;auction process;service providers;service quality;CASS approach;quality-aware service composition;quality constraints;service creation;SBS;service-oriented paradigm;iterative multiattribute combinatorial auction;service-based systems;quality-aware service selection","","63","","61","","9 Jan 2014","","","IEEE","IEEE Journals"
"Bristlecone: Language Support for Robust Software Applications","B. Demsky; S. Sundaramurthy","University of California, Irvine, Irvine; University of California, Irvine, Irvine","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","4","23","We present Bristlecone, a programming language for robust software systems. Bristlecone applications have two components: a high-level organization specification that describes how the application's conceptual operations interact and a low-level operational specification that describes the sequence of instructions that comprise an individual conceptual operation. Bristlecone uses the high-level organization specification to recover the software system from an error to a consistent state and to reason how to safely continue the software system's execution after the error. We have implemented a compiler and runtime for Bristlecone. We have evaluated this implementation on three benchmark applications: a Web crawler, a Web server, and a multiroom chat server. We developed both a Bristlecone version and a Java version of each benchmark application. We used injected failures to evaluate the robustness of each version of the application. We found that the Bristlecone versions of the benchmark applications more successfully survived the injected failures. The Bristlecone compiler contains a static analysis that operates on the organization specification to generate a set of diagrams that graphically present the task interactions in the application. We have used the analysis to help understand the high-level structure of three Bristlecone applications: a game server, a Web server, and a chat server.","1939-3520","","10.1109/TSE.2010.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416725","Software robustness.","Robustness;Application software;Software systems;Switches;Runtime;Computer languages;Costs;Web server;Java;Software tools","Java;program compilers;program diagnostics;programming languages;software fault tolerance;specification languages","language support;robust software applications;programming language;robust software systems;high-level organization specification;low-level operational specification;runtime;benchmark applications;Web crawler;Web server;multiroom chat server;Java version;injected failures;Bristlecone compiler;static analysis;task interactions;high-level structure;game server","","6","","48","","18 Feb 2010","","","IEEE","IEEE Journals"
"Compositional Dependability Evaluation for STATEMATE","E. Bode; M. Herbstritt; H. Hermanns; S. Johr; T. Peikenkamp; R. Pulungan; J. Rakow; R. Wimmer; B. Becker","OFFIS Institute for Information Technology, Oldenburg; Albert-Ludwigs-University, Freiburg im Breisgau; Saarland University, Saarbrücken; Saarland University, Saarbrücken; OFFIS Institute for Information Technology, Oldenburg; Saarland University, Saarbrücken; Carl von Ossietzky University, Oldenburg; Albert-Ludwigs-University, Freiburg im Breisgau; Albert-Ludwigs-University, Freiburg im Breisgau","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","274","292","Software and system dependability is getting ever more important in embedded system design. Current industrial practice of model-based analysis is supported by state-transition diagrammatic notations such as Statecharts. State-of-the-art modelling tools like STATEMATE support safety and failure-effect analysis at design time, but restricted to qualitative properties. This paper reports on a (plug-in) extension of STATEMATE enabling the evaluation of quantitative dependability properties at design time. The extension is compositional in the way the model is augmented with probabilistic timing information. This fact is exploited in the construction of the underlying mathematical model, a uniform continuous-time Markov decision process, on which we are able to check requirements of the form: ""The probability to hit a safety-critical system configuration within a mission time of 3 hours is at most 0.01."" We give a detailed explanation of the construction and evaluation steps making this possible, and report on a nontrivial case study of a high-speed train signalling system where the tool has been applied successfully.","1939-3520","","10.1109/TSE.2008.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4711060","Real-time and embedded systems;Fault tolerance;Modeling techniques;Reliability;availability;and serviceability;Model checking;Reliability;Design notations and documentation;State diagrams;Real-time and embedded systems;Fault tolerance;Modeling techniques;Reliability;availability;and serviceability;Model checking;Reliability;Design notations and documentation;State diagrams","Embedded system;Stochastic processes;Safety;Failure analysis;Timing;Mathematical model;Communication system signaling;Fault tolerant systems;Availability;Documentation","decision theory;embedded systems;failure analysis;fault tolerance;formal specification;Markov processes;probability;safety-critical software;software performance evaluation;system monitoring","compositional dependability evaluation;embedded system design;model-based analysis;state-transition diagrammatic notation;failure-effect analysis;probabilistic timing information;uniform continuous-time Markov decision process;safety-critical system configuration;model checking;fault tolerance;statemate;functional specification","","24","","43","","12 Dec 2008","","","IEEE","IEEE Journals"
"Variability Mining: Consistent Semi-automatic Detection of Product-Line Features","C. Kästner; A. Dreiling; K. Ostermann","School of Computer Science, Carnegie Mellon University; University of Magdeburg and Deutsche Bank AG, Germany; Department of Mathematics and ComputerScience at Philipps University Marburg, Germany","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","1","67","82","Software product line engineering is an efficient means to generate a set of tailored software products from a common implementation. However, adopting a product-line approach poses a major challenge and significant risks, since typically legacy code must be migrated toward a product line. Our aim is to lower the adoption barrier by providing semi-automatic tool support-called variability mining -to support developers in locating, documenting, and extracting implementations of product-line features from legacy code. Variability mining combines prior work on concern location, reverse engineering, and variability-aware type systems, but is tailored specifically for the use in product lines. Our work pursues three technical goals: (1) we provide a consistency indicator based on a variability-aware type system, (2) we mine features at a fine level of granularity, and (3) we exploit domain knowledge about the relationship between features when available. With a quantitative study, we demonstrate that variability mining can efficiently support developers in locating features.","1939-3520","","10.1109/TSE.2013.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6613490","Variability;reverse engineering;mining;feature;software product line;LEADT;feature location","Feature extraction;Software;Context;Data mining;Java;Companies;Educational institutions","data mining;reverse engineering;software product lines","variability mining;consistent semi automatic detection;product line features;software product line engineering;product line approach;legacy code;semi automatic tool support;reverse engineering;variability aware type systems","","33","","60","","27 Sep 2013","","","IEEE","IEEE Journals"
"A decentralized self-adaptation mechanism for service-based applications in the cloud","V. Nallur; R. Bahsoon","University of Birmingham, Birmingham; University of Birmingham, Birmingham","IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","591","612","Cloud computing, with its promise of (almost) unlimited computation, storage, and bandwidth, is increasingly becoming the infrastructure of choice for many organizations. As cloud offerings mature, service-based applications need to dynamically recompose themselves to self-adapt to changing QoS requirements. In this paper, we present a decentralized mechanism for such self-adaptation, using market-based heuristics. We use a continuous double-auction to allow applications to decide which services to choose, among the many on offer. We view an application as a multi-agent system and the cloud as a marketplace where many such applications self-adapt. We show through a simulation study that our mechanism is effective for the individual application as well as from the collective perspective of all applications adapting at the same time.","1939-3520","","10.1109/TSE.2012.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6249687","Self-adaptation;market based;multi-agent systems","Quality of service;Pricing;Reliability;Resource management;Measurement;Adaptation models;Cloud computing","cloud computing;electronic commerce;multi-agent systems;quality of service","decentralized self-adaptation mechanism;service-based applications;cloud computing;QoS requirements;market-based heuristics;continuous double-auction;multiagent system","","52","","56","","26 Jul 2012","","","IEEE","IEEE Journals"
"Monitoring Data Usage in Distributed Systems","D. Basin; M. Harvan; F. Klaedtke; E. Zalinescu","ETH Zurich, Zurich; ETH Zurich, Zurich; ETH Zurich, Zurich; ETH Zurich, Zurich","IEEE Transactions on Software Engineering","25 Sep 2013","2013","39","10","1403","1426","IT systems manage increasing amounts of sensitive data and there is a growing concern that they comply with policies that regulate data usage. In this paper, we use temporal logic to express policies and runtime monitoring to check system compliance. While well-established methods for monitoring linearly ordered system behavior exist, a major challenge is monitoring distributed and concurrent systems where actions are locally observed in the different system parts. These observations can only be partially ordered, while policy compliance may depend on the actions' actual order of appearance. Technically speaking, it is in general intractable to check compliance of partially ordered traces. We identify fragments of our policy specification language for which compliance can be checked efficiently, namely, by monitoring a single representative trace in which the observed actions are totally ordered. Through a case study we show that the fragments are capable of expressing nontrivial policies and that monitoring representative traces is feasible on real-world data.","1939-3520","","10.1109/TSE.2013.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6493331","Monitors;temporal logic;verification;distributed systems;regulation","Monitoring;Cost accounting;Periodic structures;Semantics;Distributed databases;Standards;Finite element analysis","concurrency control;formal verification;specification languages;temporal logic","data usage monitoring;distributed systems;IT systems;information technology systems;data usage regulation;temporal logic;runtime monitoring;system compliance;concurrent systems;policy compliance;policy specification language","","16","","34","","3 Apr 2013","","","IEEE","IEEE Journals"
"Performance Specification and Evaluation with Unified Stochastic Probes and Fluid Analysis","R. A. Hayden; J. T. Bradley; A. Clark","Imperial College London, London; Imperial College London, London; University of Edinburgh, Edinburgh","IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","97","118","Rapid and accessible performance evaluation of complex software systems requires two critical features: the ability to specify useful performance metrics easily and the capability to analyze massively distributed architectures, without recourse to large compute clusters. We present the unified stochastic probe, a performance specification mechanism for process algebra models that combines many existing ideas: state and action-based activation, location-based specification, many-probe specification, and immediate signaling. These features, between them, allow the precise and compositional construction of complex performance measurements. The paper shows how a subset of the stochastic probe language can be used to specify common response-time measures in massive process algebra models. The second contribution of the paper is to show how these response-time measures can be analyzed using so-called fluid techniques to produce rapid results. In doing this, we extend the fluid approach to incorporate immediate activities and a new type of response-time measure. Finally, we calculate various response-time measurements on a complex distributed wireless network of O(10129) states in size.","1939-3520","","10.1109/TSE.2012.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6133297","Performance modeling;performance evaluation tools;stochastic process algebra;measurement probes;fluid approximation;passage-time analysis","Probes;Stochastic processes;Analytical models;Algebra;Computational modeling;Semantics;Syntactics","formal specification;process algebra;software metrics;software performance evaluation","performance specification mechanism;performance evaluation mechanism;unified stochastic probes;fluid analysis;software system;performance metrics;process algebra model;state-based activation;action-based activation;location-based specification;many-probe specification;immediate signaling;stochastic probe language;common response-time measure;complex distributed wireless network","","13","","29","","17 Jan 2012","","","IEEE","IEEE Journals"
"Model Checking Semantically Annotated Services","I. Di Pietro; F. Pagliarecci; L. Spalazzi","Università Politecnica delle Marche, Ancona; Università Politecnica delle Marche, Ancona; Università Politecnica delle Marche, Ancona","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","592","608","Model checking is a formal verification method widely accepted in the web service world because of its capability to reason about service behavior at process level. It has been used as a basic tool in several scenarios such as service selection, service validation, and service composition. The importance of semantics is also widely recognized. Indeed, there are several solutions to the problem of providing semantics to web services, most of them relying on some form of Description Logic. This paper presents an integration of model checking and semantic reasoning technologies in an efficient way. This can be considered the first step toward the use of semantic model checking in problems of selection, validation, and composition. The approach relies on a representation of services at process level that is based on semantically annotated state transition systems (asts) and a representation of specifications based on a semantically annotated version of computation tree logic (anctl). This paper proves that the semantic model checking algorithm is sound and complete and can be accomplished in polynomial time. This approach has been evaluated with several experiments.","1939-3520","","10.1109/TSE.2011.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680919","Formal methods;model checking;temporal logic;description logic;intelligent web services;semantic web;web services.","Web services;Semantics;Ontologies;Switches;Computational modeling;Biological system modeling;Syntactics","computational complexity;formal verification;semantic Web;temporal logic;trees (mathematics);Web services","formal verification method;Web service;description logic;semantic reasoning technologies;semantic model checking;annotated state transition systems;computation tree logic;polynomial time;temporal logic;semantically annotated services","","17","","63","","6 Jan 2011","","","IEEE","IEEE Journals"
"Assessing Software Service Quality and Trustworthiness at Selection Time","N. Limam; R. Boutaba","POSTECH-Pohang University of Science and Technology, Pohang; University of Waterloo, Waterloo","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","559","574","The integration of external software in project development is challenging and risky, notably because the execution quality of the software and the trustworthiness of the software provider may be unknown at integration time. This is a timely problem and of increasing importance with the advent of the SaaS model of service delivery. Therefore, in choosing the SaaS service to utilize, project managers must identify and evaluate the level of risk associated with each candidate. Trust is commonly assessed through reputation systems; however, existing systems rely on ratings provided by consumers. This raises numerous issues involving the subjectivity and unfairness of the service ratings. This paper describes a framework for reputation-aware software service selection and rating. A selection algorithm is devised for service recommendation, providing SaaS consumers with the best possible choices based on quality, cost, and trust. An automated rating model, based on the expectancy-disconfirmation theory from market science, is also defined to overcome feedback subjectivity issues. The proposed rating and selection models are validated through simulations, demonstrating that the system can effectively capture service behavior and recommend the best possible choices.","1939-3520","","10.1109/TSE.2010.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383370","Software as a service (SaaS);software selection;service utility;review and rating;trust and reputation;risk management;SLA monitoring.","Software quality;Risk management;Software maintenance;Costs;Software performance;Project management;Feedback;Monitoring;Business;Computer industry","quality of service;risk management;software architecture;software quality;software selection","software service quality;selection time;project development;software provider;SaaS model;reputation-aware software service selection;automated rating model;expectancy-disconfirmation theory;software service trustworthiness","","79","2","30","","15 Jan 2010","","","IEEE","IEEE Journals"
"Learning Assumptions for CompositionalVerification of Timed Systems","S. Lin; É. André; Y. Liu; J. Sun; J. S. Dong","Temasek Laboratories, National University of Singapore, 5A, Engineering Drive 1, #09-02, Singapore; Université Paris 13, Sorbonne Paris Cité, Laboratoire d’Informatique de Paris-Nord (LIPN), A204, Institut Galilée, 99 avenue Jean-Baptiste Clément, 93430 Villetaneuse, CNRS, UMR 7030, Villetaneuse, France; School of Computer Engineering , Nanyang Technological University, 50 Nanyang Avenue, Singapore; Singapore University of Technology and Design, BLK1, Level 3, West Wing, Room 9, 20 Dover Drive, Singapore; Computer Science Department, School of Computing, National University of Singapore, 13 Computing Drive, Singapore","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","2","137","153","Compositional techniques such as assume-guarantee reasoning (AGR) can help to alleviate the state space explosion problem associated with model checking. However, compositional verification is difficult to be automated, especially for timed systems, because constructing appropriate assumptions for AGR usually requires human creativity and experience. To automate compositional verification of timed systems, we propose a compositional verification framework using a learning algorithm for automatic construction of timed assumptions for AGR. We prove the correctness and termination of the proposed learning-based framework, and experimental results show that our method performs significantly better than traditional monolithic timed model checking.","1939-3520","","10.1109/TSE.2013.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6682903","Automatic assume-guarantee reasoning;model checking;timed systems","Model checking;Educational institutions;Explosions;Learning automata;Atomic clocks;Cognition","formal verification;inference mechanisms;learning (artificial intelligence)","monolithic timed model checking;learning-based framework;timed assumptions;learning algorithm;state space explosion problem;AGR techniques;assume-guarantee reasoning techniques;timed systems;compositional verification framework;learning assumptions","","13","","37","","12 Dec 2013","","","IEEE","IEEE Journals"
"Tuning Temporal Features within the Stochastic π-Calculus","L. Pauleve; M. Magnin; O. Roux","IRCCyN, École Centrale de Nantes; IRCCyN, École Centrale de Nantes; IRCCyN, École Centrale de Nantes","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","858","871","The stochastic π-calculus is a formalism that has been used for modeling complex dynamical systems where the stochasticity and the delay of transitions are important features, such as in the case of biochemical reactions. Commonly, durations of transitions within stochastic π-calculus models follow an exponential law. The underlying dynamics of such models are expressed in terms of continuous-time Markov chains, which can then be efficiently simulated and model-checked. However, the exponential law comes with a huge variance, making it difficult to model systems with accurate temporal constraints. In this paper, a technique for tuning temporal features within the stochastic π-calculus is presented. This method relies on the introduction of a stochasticity absorption factor by replacing the exponential distribution with the Erlang distribution, which is a sum of exponential random variables. This paper presents a construction of the stochasticity absorption factor in the classical stochastic π-calculus with exponential rates. Tools for manipulating the stochasticity absorption factor and its link with timed intervals for firing transitions are also presented. Finally, the model-checking of such designed models is tackled by supporting the stochasticity absorption factor in a translation from the stochastic π-calculus to the probabilistic model checker PRISM.","1939-3520","","10.1109/TSE.2010.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5611556","Temporal parameters;\pi-calculus;model-checking;Markov processes;stochastic processes.","Stochastic processes;Exponential distribution;Random variables;Analytical models","exponential distribution;formal verification;pi calculus;stochastic processes","temporal feature tuning;stochastic π-calculus;complex dynamical system modeling;biochemical reactions;continuous-time Markov chains;stochasticity absorption factor;exponential distribution;Erlang distribution;exponential random variables;probabilistic model checker;PRISM","","2","","36","","28 Oct 2010","","","IEEE","IEEE Journals"
"Specification and Verification of Normative Texts Using C-O Diagrams","G. Díaz; M. E. Cambronero; E. Martínez; G. Schneider","Department of Computer Science , University of Castilla-La Mancha, Albacete, Spain; Department of Computer Science , University of Castilla-La Mancha, Albacete, Spain; Department of Computer Science , University of Castilla-La Mancha, Albacete, Spain; Department of Computer Science and Engineering, Chalmers | University of Gothenburg, Sweden","IEEE Transactions on Software Engineering","8 Aug 2014","2014","40","8","795","817","C-O diagrams have been introduced as a means to have a more visual representation of normative texts and electronic contracts, where it is possible to represent the obligations, permissions and prohibitions of the different signatories, as well as the penalties resulting from non-fulfillment of their obligations and prohibitions. In such diagrams we are also able to represent absolute and relative timing constraints. In this paper we present a formal semantics for C-O diagrams based on timed automata extended with information regarding the satisfaction and violation of clauses in order to represent different deontic modalities. As a proof of concept, we apply our approach to two different case studies, where the method presented here has successfully identified problems in the specification.","1939-3520","","10.1109/TSE.2013.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6657668","Normative documents;electronic contracts;deontic logic;formal verification;visual models;timed automata;C-O diagrams","Automata;Clocks;Contracts;Semantics;Cost accounting;Synchronization;Formal languages","automata theory;formal specification;formal verification;text analysis","normative texts;formal specification;formal verification;C-O diagrams;visual representation;electronic contracts;timing constraints;formal semantics;timed automata;deontic modalities","","5","","33","","7 Nov 2013","","","IEEE","IEEE Journals"
"A Quantitative Approach to Input Generation in Real-Time Testing of Stochastic Systems","L. Carnevali; L. Ridi; E. Vicario","Università degli Studi di Firenze, Firenze; Università degli Studi di Firenze, Firenze; Università degli Studi di Firenze, Firenze","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","292","304","In the process of testing of concurrent timed systems, input generation identifies values of temporal parameters that let the Implementation Under Test (IUT) execute selected cases. However, when some parameters are not under control of the driver, test execution may diverge from the selected input and produce an inconclusive behavior. We formulate the problem on the basis of an abstraction of the IUT which we call partially stochastic Time Petri Net (psTPN), where controllable parameters are modeled as nondeterministic values and noncontrollable parameters as random variables with general (GEN) distribution. With reference to this abstraction, we derive the analytical form of the probability that the IUT runs along a selected behavior as a function of choices taken on controllable parameters. In the applicative perspective of real-time testing, this identifies a theoretical upper limit on the probability of a conclusive result, thus providing a means to plan the number of test repetitions that are necessary to guarantee a given probability of test-case coverage. It also provides a constructive technique for an optimal or suboptimal approach to input generation and a way to characterize the probability of conclusive testing under other suboptimal strategies.","1939-3520","","10.1109/TSE.2012.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226426","Real-time testing;input generation;Time Petri Nets;non-Markovian Stochastic Petri Nets;stochastic processes;Difference Bound Matrix","Stochastic processes;Timing;Real time systems;Testing;Tin;Vectors;Automata","Petri nets;program testing;real-time systems","quantitative approach;input generation;real-time testing;stochastic systems;concurrent timed systems;temporal parameters;implementation under test;IUT;test execution;inconclusive behavior;partially stochastic Time Petri Net;psTPN;controllable parameters;nondeterministic values;GEN distribution","","3","","44","","26 Jun 2012","","","IEEE","IEEE Journals"
"The Impact of API Change- and Fault-Proneness on the User Ratings of Android Apps","G. Bavota; M. Linares-Vásquez; C. E. Bernal-Cárdenas; M. D. Penta; R. Oliveto; D. Poshyvanyk","Department of Computer Science, Free University of Bozen-Bolzano, Bolzano, Italy; Department of Computer Science, The College of William and Mary, Williamsburg, VA; Department of Computer Science, The College of William and Mary, Williamsburg, VA; Department of Engineering, University of Sannio, Benevento, Italy; Department of Bioscience and Territory, University of Molise, Pesche (IS), Italy; Department of Computer Science, The College of William and Mary, Williamsburg, VA","IEEE Transactions on Software Engineering","14 Apr 2015","2015","41","4","384","407","The mobile apps market is one of the fastest growing areas in the information technology. In digging their market share, developers must pay attention to building robust and reliable apps. In fact, users easily get frustrated by repeated failures, crashes, and other bugs; hence, they abandon some apps in favor of their competition. In this paper we investigate how the fault- and change-proneness of APIs used by Android apps relates to their success estimated as the average rating provided by the users to those apps. First, in a study conducted on 5,848 (free) apps, we analyzed how the ratings that an app had received correlated with the fault- and change-proneness of the APIs such app relied upon. After that, we surveyed 45 professional Android developers to assess (i) to what extent developers experienced problems when using APIs, and (ii) how much they felt these problems could be the cause for unfavorable user ratings. The results of our studies indicate that apps having high user ratings use APIs that are less fault- and change-prone than the APIs used by low rated apps. Also, most of the interviewed Android developers observed, in their development experience, a direct relationship between problems experienced with the adopted APIs and the users' ratings that their apps received.","1939-3520","","10.1109/TSE.2014.2367027","NSF; NSF; NSF; European Commission; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6945855","Mining software repositories;empirical studies;android;API changes;Mining software repositories;empirical studies;android;API changes","Androids;Humanoid robots;Software;History;Computer bugs;Educational institutions;Electronic mail","application program interfaces;data mining;mobile computing;program debugging;software fault tolerance;system recovery","API change-proneness;API fault-proneness;user ratings;Android Apps;mobile Apps market;information technology;software repository mining","","86","","70","","4 Nov 2014","","","IEEE","IEEE Journals"
"Reasoning about the Reliability of Diverse Two-Channel Systems in Which One Channel Is ""Possibly Perfect""","B. Littlewood; J. Rushby","City University, London; SRI International, Menlo Park","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1178","1194","This paper refines and extends an earlier one by the first author [1]. It considers the problem of reasoning about the reliability of fault-tolerant systems with two “channels” (i.e., components) of which one, A, because it is conventionally engineered and presumed to contain faults, supports only a claim of reliability, while the other, B, by virtue of extreme simplicity and extensive analysis, supports a plausible claim of “perfection.” We begin with the case where either channel can bring the system to a safe state. The reasoning about system probability of failure on demand (pfd) is divided into two steps. The first concerns aleatory uncertainty about 1) whether channel A will fail on a randomly selected demand and 2) whether channel B is imperfect. It is shown that, conditional upon knowing pA (the probability that A fails on a randomly selected demand) and pB (the probability that channel B is imperfect), a conservative bound on the probability that the system fails on a randomly selected demand is simply pA X pB. That is, there is conditional independence between the events “A fails” and “B is imperfect.” The second step of the reasoning involves epistemic uncertainty, represented by assessors' beliefs about the distribution of (pA, pB), and it is here that dependence may arise. However, we show that under quite plausible assumptions, a conservative bound on system pfd can be constructed from point estimates for just three parameters. We discuss the feasibility of establishing credible estimates for these parameters. We extend our analysis from faults of omission to those of commission, and then combine these to yield an analysis for monitored architectures of a kind proposed for aircraft.","1939-3520","","10.1109/TSE.2011.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5975177","Software reliability;software fault tolerance;program correctness;assurance case;software diversity","Uncertainty;Software;Phase frequency detector;Cognition;Software reliability;Safety","aircraft;probability;reasoning about programs;software fault tolerance;uncertainty handling","diverse two-channel system;fault tolerant system;reasoning about the reliability;aleatory uncertainty;randomly selected demand;conditional independence;epistemic uncertainty;assessors belief;PFD;aircraft;probability of failure on demand","","21","","47","","4 Aug 2011","","","IEEE","IEEE Journals"
"Ranking and Clustering Software Cost Estimation Models through a Multiple Comparisons Algorithm","N. Mittas; L. Angelis","Aristotle University of Thessaloniki, Thessaloniki; Aristotle University of Thessaloniki, Thessaloniki","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","537","551","Software Cost Estimation can be described as the process of predicting the most realistic effort required to complete a software project. Due to the strong relationship of accurate effort estimations with many crucial project management activities, the research community has been focused on the development and application of a vast variety of methods and models trying to improve the estimation procedure. From the diversity of methods emerged the need for comparisons to determine the best model. However, the inconsistent results brought to light significant doubts and uncertainty about the appropriateness of the comparison process in experimental studies. Overall, there exist several potential sources of bias that have to be considered in order to reinforce the confidence of experiments. In this paper, we propose a statistical framework based on a multiple comparisons algorithm in order to rank several cost estimation models, identifying those which have significant differences in accuracy, and clustering them in nonoverlapping groups. The proposed framework is applied in a large-scale setup of comparing 11 prediction models over six datasets. The results illustrate the benefits and the significant information obtained through the systematic comparison of alternative methods.","1939-3520","","10.1109/TSE.2012.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6235961","Cost estimation;management;metrics/measurement;statistical methods","Predictive models;Estimation;Accuracy;Measurement uncertainty;Prediction algorithms;Clustering algorithms;Systematics","pattern clustering;software cost estimation;software development management;statistical analysis","software cost estimation model;multiple comparisons algorithm;software project;project management;statistical framework;software cost estimation ranking;software cost estimation clustering","","73","","54","","10 Jul 2012","","","IEEE","IEEE Journals"
"Integer Linear Programming-Based Property Checking for Asynchronous Reactive Systems","S. Leue; W. Wei","University of Konstanz, Konstanz; SAP AG, Darmstadt","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","216","236","Asynchronous reactive systems form the basis of a wide range of software systems, for instance in the telecommunications domain. It is highly desirable to rigorously show that these systems are correctly designed. However, traditional formal approaches to the verification of these systems are often difficult because asynchronous reactive systems usually possess extremely large or even infinite state spaces. We propose an integer linear program (ILP) solving-based property checking framework that concentrates on the local analysis of the cyclic behavior of each individual component of a system. We apply our framework to the checking of the buffer boundedness and livelock freedom properties, both of which are undecidable for asynchronous reactive systems with an infinite state space. We illustrate the application of the proposed checking methods to Promela, the input language of the SPIN model checker. While the precision of our framework remains an issue, we propose a counterexample guided abstraction refinement procedure based on the discovery of dependences among control flow cycles. We have implemented prototype tools with which we obtained promising experimental results on real-life system models.","1939-3520","","10.1109/TSE.2011.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680910","Software verification;formal methods;property checking;integer linear programming;static analysis;abstraction;refinement;counterexamples;asynchronous communication;buffer boundedness;livelock freedom;control flow cycles;cycle dependences;UML;Promela","Unified modeling language;Complexity theory;Analytical models;Message passing;Integer linear programming;Mathematical model;Cost accounting","data structures;formal languages;formal verification;integer programming;linear programming;program diagnostics;state-space methods","integer linear programming-based property checking;asynchronous reactive systems;software systems;telecommunications domain;formal approaches;infinite state spaces;ILP solving-based property checking framework;cyclic behavior;individual component;buffer boundedness;livelock freedom properties;Promela;SPIN model checker input language;counterexample guided abstraction refinement procedure;control flow cycles;real-life system models","","","","73","","6 Jan 2011","","","IEEE","IEEE Journals"
"Deriving a Slicing Algorithm via FermaT Transformations","M. P. Ward; H. Zedan","De Montfort University, Leicester; De Montfort University, Leicester","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","24","47","In this paper, we present a case study in deriving an algorithm from a formal specification via FermaT transformations. The general method (which is presented in a separate paper) is extended to a method for deriving an implementation of a program transformation from a specification of the program transformation. We use program slicing as an example transformation since this is of interest outside the program transformation community. We develop a formal specification for program slicing in the form of a WSL specification statement which is refined into a simple slicing algorithm by applying a sequence of general purpose program transformations and refinements. Finally, we show how the same methods can be used to derive an algorithm for semantic slicing. The main novel contributions of this paper are: 1) developing a formal specification for slicing, 2) expressing the definition of slicing in terms of a WSL specification statement, and 3) by applying correctness preserving transformations to the specification, we can derive a simple slicing algorithm.","1939-3520","","10.1109/TSE.2010.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401170","Program slicing;program transformations;formal methods;algorithm derivation.","Formal specifications;Logic;Software algorithms;Reverse engineering;Assembly;High level languages","formal specification;program slicing","slicing algorithm;FermaT transformations;program transformation;program slicing;WSL specification statement;semantic slicing","","6","","73","","29 Jan 2010","","","IEEE","IEEE Journals"
"Specifying and Validating Data-Aware Temporal Web Service Properties","S. Halle; R. Villemaire; O. Cherkaoui","University of California, Santa Barbara, Santa Barbara; Université du Québec à Montréal, Montréal; Université du Québec à Montréal, Montréal","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","669","683","Most works that extend workflow validation beyond syntactical checking consider constraints on the sequence of messages exchanged between services. These constraints are expressed only in terms of message names and abstract away their actual data content. We provide examples of real-world ""data-aware"" Web service constraints where the sequence of messages and their content are interdependent. To this end, we present CTL-FO+, an extension over computation tree logic that includes first-order quantification on message content in addition to temporal operators. We show how CTL-FO+ is adequate for expressing data-aware constraints, give a sound and complete model checking algorithm for CTL-FO+, and establish its complexity to be PSPACE-complete. A ""naive"" translation of CTL-FO+ into CTL leads to a serious exponential blowup of the problem that prevents existing validation tools to be used. We provide an alternate translation of CTL-FO+ into CTL, where the construction of the workflow model depends on the property to validate. We show experimentally how this translation is significantly more efficient for complex formulas and makes model checking of data-aware temporal properties on real-world Web service workflows tractable using off-the-shelf tools.","1939-3520","","10.1109/TSE.2009.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4907003","Web services;software/program verification;model checking;temporal logic.","Web services;Logic;Formal languages;Computer Society;Web and internet services;Guidelines;Contracts;Terminology;Simple object access protocol","computational complexity;formal specification;program verification;temporal logic;trees (mathematics);Web services","data-aware temporal Web service property;workflow validation;syntactical checking;messages exchange;CTL-FO+;computation tree logic;first-order quantification;model checking algorithm complexity;PSPACE-complete;formal specification","","23","","47","","2 May 2009","","","IEEE","IEEE Journals"
"Finding Bugs in Web Applications Using Dynamic Test Generation and Explicit-State Model Checking","S. Artzi; A. Kiezun; J. Dolby; F. Tip; D. Dig; A. Paradkar; M. D. Ernst","Thomas J. Watson Research Center, Hawthorne; Women's Hospital/Harvard Medical School, Boston; Thomas J. Watson Research Center, Hawthorne; Thomas J. Watson Research Center, Hawthorne; University of Illinois at Urbana-Champaign, Urbana; Thomas J. Watson Research Center, Hawthorne; University of Washington, Seattle","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","474","494","Web script crashes and malformed dynamically generated webpages are common errors, and they seriously impact the usability of Web applications. Current tools for webpage validation cannot handle the dynamically generated pages that are ubiquitous on today's Internet. We present a dynamic test generation technique for the domain of dynamic Web applications. The technique utilizes both combined concrete and symbolic execution and explicit-state model checking. The technique generates tests automatically, runs the tests capturing logical constraints on inputs, and minimizes the conditions on the inputs to failing tests so that the resulting bug reports are small and useful in finding and fixing the underlying faults. Our tool Apollo implements the technique for the PHP programming language. Apollo generates test inputs for a Web application, monitors the application for crashes, and validates that the output conforms to the HTML specification. This paper presents Apollo's algorithms and implementation, and an experimental evaluation that revealed 673 faults in six PHP Web applications.","1939-3520","","10.1109/TSE.2010.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416728","Software testing;Web applications;dynamic analysis;PHP;reliability;verification.","Computer bugs;Vehicle crash testing;Automatic testing;Logic testing;Computer crashes;Usability;Internet;Concrete;Computer languages;HTML","program debugging;program testing;program verification;software tools","dynamic test generation;explicit state model checking;Web script;Web pages;Apollo tool;PHP programming language;HTML specification;PHP Web applications;bugs;Internet","","61","5","48","","18 Feb 2010","","","IEEE","IEEE Journals"
"Centroidal Voronoi Tessellations- A New Approach to Random Testing","A. Shahbazi; A. F. Tappenden; J. Miller","University of Alberta, Edmonton; The King's University College, Edmonton; University of Alberta, Edmonton","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","163","183","Although Random Testing (RT) is low cost and straightforward, its effectiveness is not satisfactory. To increase the effectiveness of RT, researchers have developed Adaptive Random Testing (ART) and Quasi-Random Testing (QRT) methods which attempt to maximize the test case coverage of the input domain. This paper proposes the use of Centroidal Voronoi Tessellations (CVT) to address this problem. Accordingly, a test case generation method, namely, Random Border CVT (RBCVT), is proposed which can enhance the previous RT methods to improve their coverage of the input space. The generated test cases by the other methods act as the input to the RBCVT algorithm and the output is an improved set of test cases. Therefore, RBCVT is not an independent method and is considered as an add-on to the previous methods. An extensive simulation study and a mutant-based software testing investigation have been performed to demonstrate the effectiveness of RBCVT against the ART and QRT methods. Results from the experimental frameworks demonstrate that RBCVT outperforms previous methods. In addition, a novel search algorithm has been incorporated into RBCVT reducing the order of computational complexity of the new approach. To further analyze the RBCVT method, randomness analysis was undertaken demonstrating that RBCVT has the same characteristics as ART methods in this regard.","1939-3520","","10.1109/TSE.2012.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6165316","Adaptive random testing;centroidal Voronoi tessellation;P-measure;random testing;software testing;test case generation;test strategies","Subspace constraints;Software testing;Generators;Software algorithms;Power capacitors;Runtime","computational complexity;computational geometry;program testing","centroidal Voronoi tessellations;adaptive random testing method;ART method;quasi-random testing method;QRT method;test case generation method;random border CVT;RBCVT algorithm;mutant-based software testing;search algorithm;computational complexity;randomness analysis;software defects","","34","","68","","6 Mar 2012","","","IEEE","IEEE Journals"
"Comments on “Researcher Bias: The Use of Machine Learning in Software Defect Prediction”","C. Tantithamthavorn; S. McIntosh; A. E. Hassan; K. Matsumoto","Graduate School of Information Science, Nara Institute of Science and Technology, Nara, Japan; Department of Electrical and Computer Engineering, McGill University, Montreal, QC, Canada; School of Computing, Queen's University, Kingston, ON, Canada; Graduate School of Information Science, Nara Institute of Science and Technology, Nara, Japan","IEEE Transactions on Software Engineering","10 Nov 2016","2016","42","11","1092","1094","Shepperd et al. find that the reported performance of a defect prediction model shares a strong relationship with the group of researchers who construct the models. In this paper, we perform an alternative investigation of Shepperd et al.'s data. We observe that (a) research group shares a strong association with other explanatory variables (i.e., the dataset and metric families that are used to build a model); (b) the strong association among these explanatory variables makes it difficult to discern the impact of the research group on model performance; and (c) after mitigating the impact of this strong association, we find that the research group has a smaller impact than the metric family. These observations lead us to conclude that the relationship between the research group and the performance of a defect prediction model are more likely due to the tendency of researchers to reuse experimental components (e.g., datasets and metrics). We recommend that researchers experiment with a broader selection of datasets and metrics to combat any potential bias in their results.","1939-3520","","10.1109/TSE.2016.2553030","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7450669","Software quality assurance;defect prediction;researcher bias","Measurement;Interference;Analysis of variance;Predictive models;Analytical models;NASA;Data models","learning (artificial intelligence);software fault tolerance;software quality","researcher bias;machine learning;software defect prediction;software quality assurance","","29","","18","","11 Apr 2016","","","IEEE","IEEE Journals"
"Detecting Memory Leaks Statically with Full-Sparse Value-Flow Analysis","Y. Sui; D. Ye; J. Xue","Programming Language and Compilers Group, School of Computer Science and Engineering, University of New South Wales, Sydney, Australia; Programming Language and Compilers Group, School of Computer Science and Engineering, University of New South Wales, Sydney, Australia; Programming Language and Compilers Group, School of Computer Science and Engineering, University of New South Wales, Sydney, Australia","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","2","107","122","We introduce a static detector, Saber, for detecting memory leaks in C programs. Leveraging recent advances on sparse pointer analysis, Saber is the first to use a full-sparse value-flow analysis for detecting memory leaks statically. Saber tracks the flow of values from allocation to free sites using a sparse value-flow graph (SVFG) that captures def-use chains and value flows via assignments for all memory locations represented by both top-level and address-taken pointers. By exploiting field-, flow- and context-sensitivity during different phases of the analysis, Saber detects memory leaks in a program by solving a graph reachability problem on its SVFG. Saber, which is fully implemented in Open64, is effective at detecting 254 leaks in the 15 SPEC2000 C programs and seven applications, while keeping the false positive rate at 18.3 percent. Saber compares favorably with several static leak detectors in terms of accuracy (leaks and false alarms reported) and scalability (LOC analyzed per second). In particular, compared with Fastcheck (which analyzes allocated objects flowing only into top-level pointers) using the 15 SPEC2000 C programs, Saber detects 44.1 percent more leaks at a slightly higher false positive rate but is only a few times slower.","1939-3520","","10.1109/TSE.2014.2302311","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6720116","Memory Leaks;sparse value-flow analysis;static analysis;pointer analysis","Detectors;Resource management;Accuracy;Scalability;Abstracts;Standards;Sensitivity","C language;program diagnostics;reachability analysis;storage management","memory leaks detection;full-sparse value-flow analysis;Saber static detector;sparse pointer analysis;sparse value-flow graph;SVFG;def-use chains;value flows;memory locations;top-level pointers;address-taken pointers;field-sensitivity;flow-sensitivity;context-sensitivity;graph reachability problem;Open64;SPEC2000 C programs;false positive rate;static leak detectors;Fastcheck","","32","","38","","23 Jan 2014","","","IEEE","IEEE Journals"
"Technical Debt: From Metaphor to Theory and Practice","P. Kruchten; R. L. Nord; I. Ozkaya","University of British Columbia, Vancouver; Software Engineering Institute; Software Engineering Institute","IEEE Software","22 Oct 2012","2012","29","6","18","21","The metaphor of technical debt in software development was introduced two decades ago to explain to nontechnical stakeholders the need for what we call now ""refactoring."" As the term is being used to describe a wide range of phenomena, this paper proposes an organization of the technical debt landscape, and introduces the papers on technical debt contained in the issue.","1937-4194","","10.1109/MS.2012.167","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6336722","technical debt;software quality;refactoring;evolvability;maintainability","Software quality;Investments;Risk management;Sofware testing;Software maintenance","","","","245","6","10","","22 Oct 2012","","","IEEE","IEEE Magazines"
"Clearing the Way for Software Product Line Success","L. G. Jones; L. M. Northrop","Software Engineering Institute, Carnegie Mellon University; Software Engineering Institute, Carnegie Mellon University","IEEE Software","19 Apr 2010","2010","27","3","22","28","We mostly see two strategic pitfalls across the board: failure to recognize that a SPL approach is both a business and a technical strategy, and failure to manage the product-line-unique aspects of both governance and roll-out appropriately. How would you know if your organization suffers from either or both? These two pitfalls lead naturally to four high-level diagnostic questions, the answers to which are best discovered by answers to subordinate questions. Rather than describe a set of symptoms, we'll begin by letting you be your own doctor and consider a series of self-diagnostic questions based on what we've found lacking.","1937-4194","","10.1109/MS.2010.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452145","software product lines;software product line adoption","Organizations;Product development;Computer architecture;Production facilities;Software","business data processing;product development;software reusability","SPL;software product line;business strategy;technical strategy","","8","","8","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Scientific Software Testing: Analysis with Four Dimensions","D. Kelly; S. Thorsteinson; D. Hook",Royal Military College; Royal Military College; Engineering Seismology Group Solutions,"IEEE Software","25 Apr 2011","2011","28","3","84","90","By analyzing our testing exercise through the four dimensions of context, goals, techniques, and adequacy, we developed a better understanding of how to effectively test a piece of scientific software. Once we considered the scientist-tester as part of the testing system, the exercise evolved in a way that made use of and increased his knowledge of the software. One result was an approach to software assessment that combines inspection with code execution. An other result was the suppression of process-driven testing in favor of goal centric approaches. The combination of software engineer working with scientist was success ful in this case. The software engineer brings a toolkit of ideas, and the scientist chooses and fashions the tools into some thing that works for a specific situation. Unlike many other types of software systems, scientific software includes the scientist as an integral part of the system. The tools that support the scientist must include the scientist's knowledge and goals in their design. This represents a different way of considering the juxtaposition of software engineering with scientific software development.","1937-4194","","10.1109/MS.2010.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5467013","scientific software;software testing;multidisciplinary team","Software testing;Software engineering;System testing;Cultural differences;Application software;Time to market","natural sciences computing;program testing","scientific software testing;software assessment;code execution inspection;process-driven testing;software systems;software design;software engineering;scientific software development","","15","","8","","20 May 2010","","","IEEE","IEEE Magazines"
"The Awareness Network, To Whom Should I Display My Actions? And, Whose Actions Should I Monitor?","C. R. B. de Souza; D. F. Redmiles","IBM Brazil, Sã o Paulo; University of California, Irvine, Irvine","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","325","340","The concept of awareness plays a pivotal role in research in Computer-Supported Cooperative Work. Recently, software engineering researchers interested in the collaborative nature of software development have explored the implications of this concept in the design of software development tools. A critical aspect of awareness is the associated coordinative work practices of displaying and monitoring actions. This aspect concerns how colleagues monitor one another's actions to understand how these actions impact their own work and how they display their actions in such a way that others can easily monitor them while doing their own work. In this paper, we focus on an additional aspect of awareness: the identification of the social actors who should be monitored and the actors to whom their actions should be displayed. We address this aspect by presenting software developers' work practices based on ethnographic data from three different software development teams. In addition, we illustrate how these work practices are influenced by different factors, including the organizational setting, the age of the project, and the software architecture. We discuss how our results are relevant for both CSCW and software engineering researchers.","1939-3520","","10.1109/TSE.2011.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5710950","Computer-supported cooperative work;organizational management and coordination;programming environments;programming teams;tools.","Software;Programming;Monitoring;Interviews;Collaboration;Servers","groupware;software architecture","awareness network;computer-supported cooperative work;software development;social actor;ethnographic data;organizational setting;project age;software architecture;CSCW","","35","","57","","10 Feb 2011","","","IEEE","IEEE Journals"
"Start with the Most Difficult Part","D. Spinellis",Athens University of Economics and Business,"IEEE Software","24 Feb 2009","2009","26","2","70","71","Any development project involves elements that we don't know at the beginning and discover as we progress. In this paper, the author discusses the advantages of starting with the most difficult part of a software development process.","1937-4194","","10.1109/MS.2009.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786956","process;design;bottom-up;top-down;agility","Wikipedia;Encoding;Data structures;HTML;Sockets;Fitting;Assembly;Uncertainty;Humans;Meeting planning","software engineering","software development process","","","","","","24 Feb 2009","","","IEEE","IEEE Magazines"
"Does Involving Users in Software Development Really Influence System Success?","U. Abelein; H. Sharp; B. Paech",University of Heidelberg; The Open University; University of Heidelberg,"IEEE Software","28 Oct 2013","2013","30","6","17","23","Researchers have studied how best to involve users in software development for a long time, primarily in the area of information systems and human-computer interaction. The authors consider the effects of both user participation and user involvement, which they abbreviate to UPI. Existing research describes several benefits of UPI, such as improved quality due to more precise requirements, the prevention of unneeded and expensive features, and an increase in user satisfaction, which leads to higher system use. But even though some researchers consider it to be essential to system success, other studies have found contradicting results. Furthermore, it's not a common practice in today's IT projects to involve users to a large extent. To clarify UPI's effects on system success and to get a deeper understanding of the differences between user participation and user involvement, the authors reviewed the existing UPI literature in software development and conducted a systematic mapping study.","1937-4194","","10.1109/MS.2013.124","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648584","user participation;user involvement;software development;systematic mapping study;literature review;meta analysis","User centered design;Software development;Prototypes;Time measurement;Software systems","software engineering;software management;user centred design","software development;user involvement;information systems;human-computer interaction;user satisfaction;IT projects;system success;user participation;UPI literature","","19","","11","","28 Oct 2013","","","IEEE","IEEE Magazines"
"Unmasking Your Software's Ethical Risks","D. Gotterbarn; K. W. Miller",East Tennessee State University; University of Illinois at Springfield,"IEEE Software","31 Dec 2009","2010","27","1","12","13","It's difficult to fully address all our professional obligations as software engineers. Our training focuses on avoiding technical failures, but unfortunately our systems sometimes have unintended consequences. We need to develop products to avoid unintended negative impacts on society, people, and the environment. Professional responsibility requires that we identify the morally salient features of a situation. Some issues are relatively easy to spot; for example, we shouldn't lie to clients, we shouldn't bribe inspectors, and we should respect people's privacy. But some ethical and social risks are harder to recognize. Even developers with the best intentions have walked into ethical traps. When we study technical problems, we apply the project's constraints and priorities to find acceptable possible solutions and choose among them. Here are four suggestions for considering ethical constraints during that process, they are: look for human values in technical decision; identifying who will be affected; examining how stakeholders' right and obligation will be affectedl; and reviewing relevant professional standards to help identify issues.","1937-4194","","10.1109/MS.2010.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370758","Ethics;risks;ethics code;stakeholder rights","Privacy;Humans","ethical aspects;software engineering","software ethical risk;professional obligation;software engineer;unintended negative impact prevention;professional responsibility;projects constraint;human value;technical decision;relevant professional standard","","2","","3","","31 Dec 2009","","","IEEE","IEEE Magazines"
"The Software behind Moore's Law","R. Wester; J. Koster",ASML; ASML,"IEEE Software","10 Mar 2015","2015","32","2","37","40","Moore's law describes exponential productivity in the semiconductor industry. It depends on rapid hardware and software development. Many hardware modules will be replaced in new products, while the total system software must remain consistent and high performing. This brings unique challenges, and this article discusses software development strategies.","1937-4194","","10.1109/MS.2015.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057609","Moore's law;software development;lines of code;ASML;computer chips;TWINSCAN","Software development;Productivity;Ultraviolet sources;Optical sensors;Lithography;Technological innovation;Optical imaging;Semiconductor devices;Moore's Law","software engineering","Moore's law;semiconductor industry;hardware development;software development","","3","","3","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Cyber Dumpster Diving: Creating New Software Systems for Less","I. Gorton",Pacific Northwest National Laboratory,"IEEE Software","3 Jan 2013","2013","30","1","9","13","This is the first article we're fortunate to have from the SATURN 2012 conference. This issue highlights a compelling story of crisis, larceny, and, of course, Fortran-the first programming language I learned, which I did by teaching it to undergrad engineering students. Because I never saw those engineers after they left my class, it's heartening to see that others like them learned some good lessons and developed useful insights. I'm sure you will enjoy reading this architectural tale.","1937-4194","","10.1109/MS.2013.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401107","software architecture;software reuse;scientific user environments","Software architecture;Data models;Licenses;Computer architecture;Numerical models","FORTRAN;software engineering","cyber dumpster diving;software systems creation;SATURN conference;Fortran programming language;undergrad engineering students","","2","","2","","3 Jan 2013","","","IEEE","IEEE Magazines"
"Designing in the Future","R. J. Wirfs-Brock",Wirfs-Brock Associates,"IEEE Software","22 Dec 2008","2009","26","1","18","19","The consequences of poorly structured requirements obviously have enormous consequences on design. Given that problems rarely are well formed, what responsibility should we designers take to bring clarity to the problem? Whether this is official design work or not, I keep backing up to clarify problems in order to bring clarity to my design. If I don't, coming up with simple, comprehensive solutions on the fly is difficult. Messy problems don't lead to clean design. And small refactorings don't always collectively add up to appropriate design abstractions. I hope the future will yield better techniques for understanding and structuring problems as well as design solutions.","1937-4194","","10.1109/MS.2009.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721176","software design;up-front design;design-as-you-go;design rhythms","Programming profession;Artificial intelligence;Humans;Marine vehicles;Manufacturing;Costs;Process design;Testing","software engineering","software design","","","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Software in an Evolving Train Traffic Control System","K. Tomita; K. Ito",Hitachi; East Japan Railway Company,"IEEE Software","28 Feb 2011","2011","28","2","19","21","This contribution is rather different from the other articles we're run in this department to date. Here, software volume isn't an issue as there is only one Tokyo-instead, we look at the incremental development of a network of systems controlling railway lines, which requires adding value without disruption. This particular scenario contains many interesting facets, including the use of COTS and refactoring. We're indebted to Takao Futagami for facilitating this contribution.","1937-4194","","10.1109/MS.2011.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5720708","Impact;long-term development;reliability;autonomous decentralized system;refactoring","Servers;Railway communication;Traffic control;Rail transportation;Computer architecture;Maintenance engineering;Real time systems;Intelligent transportation systems","railway engineering;software engineering;traffic engineering computing","railway;software development;COTS;train traffic control system","","6","","","","28 Feb 2011","","","IEEE","IEEE Magazines"
"Agile Requirements Can We Have Our Cake and Eat It Too?","N. Maiden; S. Jones",City University London; City University London,"IEEE Software","19 Apr 2010","2010","27","3","87","88","Over the last decade, software development has seen a substantial growth in the use of agile techniques. Agile emerged as an alternative way to develop software and manage projects. Unlike traditional methods that focus on modelling and analysis, agile encourages communication and collaboration with end users to develop software without the need for modelling. Documentation that is large, paper-based, and difficult-to-read becomes the enemy because it empedes effective communication among people in projects.","1937-4194","","10.1109/MS.2010.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452150","Requirements;agile techniques;requirements documentation","Collaborative software;Programming;Project management;Software development management;Documentation;Communication effectiveness","software engineering","agile requirements;software development;agile techniques","","4","","4","","19 Apr 2010","","","IEEE","IEEE Magazines"
"The Benefit of Patterns","L. Rising",independent consultant,"IEEE Software","19 Aug 2010","2010","27","5","15","17","This article talks about the role of design patterns in the software development. It discusses about the new and interesting object-oriented designs, vision patterns and mediator design pattern. The real power of patterns is not to hand us exotic solutions, but to give us a way to remember the simple, ordinary, basic solutions that we know but forget.","1937-4194","","10.1109/MS.2010.127","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551013","patterns;architecture;design;decision-making;team size","Pattern recognition;Decision making;Computer architecture;Design methodology","object-oriented methods;software engineering","software development;object oriented design;vision pattern;mediator design pattern","","2","","4","","19 Aug 2010","","","IEEE","IEEE Magazines"
"Developing in the Cloud","D. Spinellis",Athens University of Economics and Business,"IEEE Software","17 Mar 2014","2014","31","2","41","43","Many affordable cloud-based offerings that cover software development needs, like version control, issue tracking, remote application monitoring, localization, deployment, payment processing, and continuous integration, do away with the setup, maintenance, and user support costs and complexity associated with running such systems in-house. The most important risks of cloud-based tools concern control of the data stored and the services an organization uses. On the other hand, cloud-based tools dramatically lower the capital requirements and setup costs of a software development organization. They also help organizations adopt best practices in each domain simply by registering with the corresponding service. Using a cloud-based service also means fewer worries regarding scalability, while from the customers' perspective delivering a service through the cloud allows an organization to have a much closer relationship with them. Through cloud-based services the development infrastructure is becoming increasingly homogeneous allowing developers to use the same tools across diverse projects and employers, transferring knowledge and skills from one job to the next, and offering a deeper talent pool of experienced developers. The Web extra at http://youtu.be/szfwWLr30qk is an audio podcast of author Diomidis Spinellis reading his Tools of the Trade column, in which he discusses how cloud-based services are making the software development infrastructure increasingly homogeneous by allowing developers to use the same tools across diverse projects and employers, transferring knowledge and skills from one job to the next, and offering a deeper talent pool of experienced developers.","1937-4194","","10.1109/MS.2014.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774357","cloud;platform as a service;tools;PaaS","Software development;Cloud computing","cloud computing;software engineering","cloud-based offerings;cloud-based tools;software development organization;cloud-based service;software development infrastructure","","1","","","","17 Mar 2014","","","IEEE","IEEE Magazines"
"Five Facts on the Adoption of Open Source Software","C. P. Ayala; D. Cruzes; Ø. Hauge; R. Conradi",Technical University of Catalunya; Norwegian University of Science and Technology; CapGemini Norge AS; Norwegian University of Science and Technology,"IEEE Software","28 Feb 2011","2011","28","2","95","99","Across the spectrum of software organizations-from traditional software houses to service providers, in both public and private sectors-open source software (OSS) is changing the way they develop, acquire, use, and commercialize software. However, con flicting views about exactly what the OSS phenomenon is remain common. Furthermore, the professional literature doesn't clarify as much as it could-not only because empirical studies are still sparse but also because the studies that do exist reflect different perspectives.","1937-4194","","10.1109/MS.2011.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5720716","software development;open source","Standards;Open source software;Licenses;Software development management","public domain software;software engineering;software houses","open source software;software organizations;software houses;service providers;OSS;commercialize software","","17","","12","","28 Feb 2011","","","IEEE","IEEE Magazines"
"Designing with an Agile Attitude","R. J. Wirfs-Brock",Wirfs-Brock Associates,"IEEE Software","24 Feb 2009","2009","26","2","68","69","In this article, we investigate what does it take to be an effective software designer in an agile development environment. An agile design does demand teamwork and cooperation. Agile designers need to sharpen their communication and collaboration skills as well as their technical practices. They should value collaboration and collective understanding as much as good design and development practices. It's a matter of attitude more than any specific technique or process.","1937-4194","","10.1109/MS.2009.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786955","agile software design;pair programming;reflection meetings","Project management;Process design;Software design;IEEE Press;Programming;Testing;Productivity;Meeting planning;Teamwork;Delay","groupware;software engineering","software designer;agile development environment;teamwork;collaboration skills","","1","","","","24 Feb 2009","","","IEEE","IEEE Magazines"
"The Responsible Designer","R. J. Wirfs-Brock",Wirfs-Brock Associates,"IEEE Software","16 Oct 2009","2009","26","6","9","10","Successful software systems often live far longer than their original designers anticipated. And over their lifetime, most of those systems evolve. Developers who make modifications, fix bugs, and add new features to long-lived systems have an easier time of it if they keep the code base habitable (""Creating Sustainable Designs,"" Rebecca Wirfs-Brock, IEEE Software, May/June 2009) and preserve design integrity. But even so, maintenance can be painful when new requirements invalidate initial design assumptions. This paper discussed about methods and techniques on how to achieve software's flexible design. Flexible design is the byproduct of preparation and continued attention to detail. Where there's a lot of variability in a design problem, a flexible solution will incorporate appropriate design hooks that allow for developers to predictably add planned extensions. Once they've established ways to support specific variations, developers can follow predefined extension recipes rather than hacking in new features that are similar to existing ones.","1937-4194","","10.1109/MS.2009.190","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287000","responsible design;agile development;flexibility;commonality-variability analysis","Software systems;Computer bugs;Computer crime","software engineering","software modification;software debugging;design integrity;software maintenance;software flexible design;software developer;software extension","","","","","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Toward Unweaving Streams of Thought for Reflection in Professional Software Design","K. Nakakoji; Y. Yamamoto; N. Matsubara; Y. Shirai",Software Research Associates; Tokyo Institute of Technology; Software Research Associates; NTT Corporation,"IEEE Software","22 Dec 2011","2012","29","1","34","38","Software designers make decisions covering a wide variety of aspects of the software to be designed through nested, intertwined processes. Some of these dependencies among design decisions might not be obvious, especially for people who didn't start with the project at the beginning of the design process. Extending or altering an existing design decision without fully understanding its dependencies might result in a deterioration of the quality of the software design. Design practice streams (DPS) tools help designers browse the segments of video data relevant to a particular topic by specifying a region on a whiteboard or by choosing a few terms used in a meeting transcript to further investigate the point of interest effectively.","1937-4194","","10.1109/MS.2011.125","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6035659","software design support;design meeting record viewer;interaction design;DPS (Design Practice Streams)","Software design;Product development;Streaming media;Motion pictures;Video signal processing","software engineering","professional software design;software design quality;design practice streams tool;whiteboard","","3","","8","","6 Oct 2011","","","IEEE","IEEE Magazines"
"Creative Requirements Conversations","M. R. Cook; N. Maiden","NA; City Univ. London, London, UK","IEEE Software","25 Feb 2010","2010","27","2","90","91","Uscreates projects show that capturing requirements to inform the design of products, services, and systems must involve truly engaging people in conversation. This is a creative process that has to be designed to suit the people involved in the discussion. It's easy to speak to the willing, but often these aren't the people from which the information is needed. Uscreates is often commissioned to reach ""hard to reach"" groups. No group of people is hard to reach if the research and designing is done in the right environments and methods to speak to them. The high levels of technology are necessary to gather information and requirements for human centered projects. It's more about the design of the space and the people facilitating the conversation; spaces that encourage creative conversation are low in technology, but high in facilitation.","1937-4194","","10.1109/MS.2010.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420802","design;creativity;collaboration;behavior change;requirements;engineering","Space technology;Product design;Humans","software engineering;user centred design","Uscreates projects;software designing;people conversation;human-centered project;product design;system design;services;creative requirements conversations","","3","","","","25 Feb 2010","","","IEEE","IEEE Magazines"
"When Robert Rules","P. Kruchten",University of British Columbia,"IEEE Software","22 Dec 2008","2009","26","1","20","21","This paper discuses how software development is often more about people - collaboration, communication, and coordination - than technology, developing ""soft skills"" such as meeting-management techniques is becoming more important. The author recommends to many people to learn more about Robert's Rules of Order, to take a class or a workshop, to read a book about it, and to go beyond the surface and the funny jargon to transpose what they learn about formal debates to the more informal meetings that now make up a large chunk of a software practitioner's life. Besides, your hockey club, Parent-Teacher Association, or your local IEEE Computer Society chapter will love you for your useful facilitator skills. The author suggests that all software practitioners learn more about Robert's rules.","1937-4194","","10.1109/MS.2009.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721177","Meeting conduct;Robert's Rule of Order","Software;Programming;Books;Career development;Focusing;Lead;Chapters","software engineering","software development;collaboration;communication;coordination;meeting-management techniques","","","","2","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Going Underground","M. van Malkenhorst; L. Mollinger",Shell; Shell,"IEEE Software","20 Apr 2012","2012","29","3","17","20","Software for oil exploration and production has been a topic for software R&D for decades, and Shell is one of the main players. The role of such applications can't be underestimated. For example, what's the cost of a defect if you drill in the wrong place as a result of a software bug, knowing that without software you wouldn't have a clue where to start drilling? Shell, one of the largest companies in the world, is very specific about which software it wants to develop and which software it wants to buy elsewhere, even for a core competence like oil exploration and production.","1937-4194","","10.1109/MS.2012.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188597","software;oil;exploration;Shell;dynamic;modeling;IT;drilling;Dynamo;MoRes;Modular Reservoir Simulator;impact","Software;Reservoirs;Computational modeling;Production;Computer bugs;Generators;Physics","gas industry;petroleum industry;program debugging;software engineering","oil exploration;Shell;software bug;drilling;oil production;software R&D;software development","","6","","7","","20 Apr 2012","","","IEEE","IEEE Magazines"
"Process Management Tools","F. Garcia; A. Vizcaino; C. Ebert",University of Castilla-La Mancha; University of Castilla-La Mancha; Vector Consulting Services,"IEEE Software","28 Feb 2011","2011","28","2","15","18","Software development is complex, especially with many interacting people and teams. A variety of tools exist to model the development process and thus facilitate communication, automation, and collaboration. This installment looks to support tools for process modeling and their underlying methodologies.","1937-4194","","10.1109/MS.2011.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5720707","software process;tools;process modeling;collaboration","Process control;Unified modeling language;Business;Automation;Knowledge engineering;Collaboration;Software development management","software engineering","software development;process modeling","","8","","6","","28 Feb 2011","","","IEEE","IEEE Magazines"
"Context is King: What's Your Software's Operating Range?","F. Torres",GMV Aerospace and Defence,"IEEE Software","21 Aug 2015","2015","32","5","9","12","Unexpected responses to a study questionnaire led to the realization that the context in which software is being used is extremely important. One particular thing to keep in mind is the software's operating range; that is, the conditions in which the software works best.","1937-4194","","10.1109/MS.2015.121","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217770","software development;operating range;user interfaces;software configurability;context","Context awareness;Software development;User interfaces;Electronic mail;Mobile communication;Operating range;User interfaces","software engineering","software operating range","","3","","4","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Continuous Integration and Its Tools","M. Meyer",Travis CI,"IEEE Software","21 Apr 2014","2014","31","3","14","16","Continuous integration has been around for a while now, but the habits it suggests are far from common practice. Automated builds, a thorough test suite, and committing to the mainline branch every day sound simple at first, but they require a responsible team to implement and constant care. What starts with improved tooling can be a catalyst for long-lasting change in your company's shipping culture. Continuous integration is more than a set of practices, it's a mindset that has one thing in mind: increasing customer value. The Web extra at http://youtu.be/tDl_cHfrJZo is an audio podcast of the Tools of the Trade column discusses how continuous integration is more than a set of practices, it's a mindset that has one thing in mind: increasing customer value.","1937-4194","","10.1109/MS.2014.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6802994","continuous integration;continuous delivery;testing","Production;Servers;Monitoring;Software;Green products;Marine vehicles;Multimedia communication","Internet;program testing;software engineering;software tools;source code (software)","automated builds;test suite;software development;Web frameworks;source code;customer value;company shipping culture;continuous integration","","19","","","","21 Apr 2014","","","IEEE","IEEE Magazines"
"Service Design: It's All in the Brand","N. Maiden",City University London,"IEEE Software","19 Aug 2010","2010","27","5","18","19","This column argues that requirements analysts will soon need to deal with service design, and describes one service design method to demonstrate the challenges that analysts will face.","1937-4194","","10.1109/MS.2010.124","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551014","requirements;service design;brand innovation","Technological innovation;Presses;Design methodology;Usability;Cities and towns;Buildings","customer services;software engineering;user centred design","service design;service economy;customer experience","","2","","4","","19 Aug 2010","","","IEEE","IEEE Magazines"
"Bells, Whistles, Power, and the Requirements Process","T. DeMarco",Atlantic Systems Guild,"IEEE Software","26 Jun 2013","2013","30","4","104","104","As the software industry has matured, the requirements process has had to cope with unanticipated shifts of power, increasing complexity of the non-technological part of the work, and abandonment of some of the comforting myths of past century.","1937-4194","","10.1109/MS.2013.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547598","requirements;organizational politics;system analysis;specification","Software requirements;Software development;Technological innovation","software engineering","software industry;software requirement process","","1","","","","26 Jun 2013","","","IEEE","IEEE Magazines"
"Requirements Engineering's Next Top Model","O. Gotel; J. Cleland-Huang",NA; DePaul University,"IEEE Software","28 Oct 2013","2013","30","6","24","29","A game-show environment let a panel competitively explore the use of various requirements modeling techniques for specifying a complex problem. Although plain old text and rich pictures emerged as the winners, real-world problems are best modeled using a variety of techniques. The Web extra at http://youtu.be/6vfIwSauj5o is an audio podcast of author Jane Cleland-Huang providing an audio recording of her Requirements column, in which she discusses how a game-show environment at the 2013 European Software Engineering Conference let a panel competitively explore the use of various requirements modeling techniques for specifying a complex problem.","1937-4194","","10.1109/MS.2013.129","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648608","requirements;modeling","Unified modeling language;Games;Computational modeling;Adaptation models;Software engineering","","","","","","1","","28 Oct 2013","","","IEEE","IEEE Magazines"
"Software Agents in Industrial Automation Systems","S. Pech",BASF SE,"IEEE Software","18 Apr 2013","2013","30","3","20","24","Agent orientation is moving from its origins in computer science into applied automation systems engineering. The main benefit of using software agents in industrial automation is the combined application of agent-oriented software engineering with growing fields such as semantic technologies. Software agents also provide flexibility, which is often the key requirement for creating software system architectures that can evolve at runtime.","1937-4194","","10.1109/MS.2013.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6504882","software technologies;agents;software agents;industrial automation;systems engineering","Rail transportation;Automation;System-level design;System analysis and design;Software engineering;Software architecture","","","","5","","9","","18 Apr 2013","","","IEEE","IEEE Magazines"
"Test Management","P. Louridas",Greek Research and Technology Network,"IEEE Software","18 Aug 2011","2011","28","5","86","91","In many projects, testing consumes the single biggest amount of resources of all activities. Companies tend to collect test cases like stamps without clear strategy-just in case. Many companies suffer with insufficient quality, visibility and test progress management. This article introduces test management.","1937-4194","","10.1109/MS.2011.111","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984799","testing;test management;software;software engineering;defect removal efficiency","Software quality;Software measurement;Computer bugs;Software testing;Testing","program testing;project management;software management;software quality","test progress management;project management","","1","","3","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Trends in Agile: Perspectives from the Practitioners","R. Prikladnicki; C. Lassenius; E. Tian; J. C. Carver",Pontifical Catholic University of Rio Grande do Sul; Aalto University; Ericsson; University of Alabama,"IEEE Software","28 Oct 2016","2016","33","6","20","22","The Agile Conference is the largest global conference on agile software development, catering particularly to practitioners. Agile 2016 had a record 2,500 participants. This article reports on two keynotes and a new IEEE Software conference initiative.","1937-4194","","10.1109/MS.2016.152","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725226","agile development;Agile Conference;Agile 2016;managing for happiness;Modern Agile;Scrum;digital disruption;software practitioners;software engineering;software development;IEEE Software","","software prototyping","agile software development;Agile Conference","","1","","2","","28 Oct 2016","","","IEEE","IEEE Magazines"
"A Classification System for Testing, Part 2","R. L. Glass",Griffith University,"IEEE Software","22 Dec 2008","2009","26","1","104","104","This article looks at what happens when you combine the four goal-driven approaches to testing classification (requirements-driven, statistics-driven, and risk-driven) with the three phase-driven approaches (unit testing, integration testing, and system testing).","1937-4194","","10.1109/MS.2009.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721193","software engineering;software development;test case classification;goal-driven testing;phase-driven testing;software testing","System testing;Software testing;Permission;Life testing;Books;Libraries;Software quality;Software systems;Heart;Web server","program testing","software-testing classification system;2D testing classification matrix;goal-driven approach;requirements-driven testing;structure-driven testing;statistics-driven testing;risk-driven testing;software life cycle","","","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Better Selection of Software Providers through Trialsourcing","M. Jørgensen",Simula Research Laboratory,"IEEE Software","24 Aug 2016","2016","33","5","48","53","Software providers differ widely in productivity and quality, yet traditional performance evaluations fail to separate the competent from the incompetent. Trialsourcing- having multiple providers create sample pieces of software for evaluation-can help software clients select providers.","1937-4194","","10.1109/MS.2015.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006382","trialsourcing;provider selection;skill assessment;software development;software engineering","Software development;Sofware engineering;Telecommunications;Collaboration;Proposals;Context awareness;Complexity theory","software management","software provider selection;software provider productivity;software provider quality;trialsourcing;software clients","","5","","7","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Developments in Requirements Engineering","J. C. Carver",University of Alabama,"IEEE Software","11 Jul 2017","2017","34","4","8","10","This issue's column reports on papers from the 23rd International Working Conference on Requirements Engineering: Foundation for Software Quality. Topics include how to support natural-language requirements, collaboration on requirements, feature-relevant information extraction, detecting ambiguity, and detecting requirements defects.","1937-4194","","10.1109/MS.2017.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974678","International Working Conference on Requirements Engineering: Foundation for Software Quality;REFSQ;requirements engineering;natural language;natural-language requirements;collaboration;information extraction;ambiguity;requirements defects;software engineering;software development","","","","","","","","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Group-Based Behavior Adaptation Mechanisms in Object-Oriented Systems","P. Rein; S. Ramson; J. Lincke; T. Felgentreff; R. Hirschfeld","Hasso Plattner Institute, University of Potsdam; Hasso Plattner Institute, University of Potsdam; Hasso Plattner Institute, University of Potsdam; Hasso Plattner Institute, University of Potsdam; Hasso Plattner Institute, University of Potsdam","IEEE Software","13 Nov 2017","2017","34","6","78","82","Dynamic and distributed systems require behavior adaptations for groups of objects. Group-based behavior adaptation mechanisms scope adaptations to objects matching conditions beyond class membership. The specification of groups can be explicit or implicit.","1937-4194","","10.1109/MS.2017.4121224","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106885","group-based behavior adaptation;lively groups;ContextErlang;entity-component-system;predicated generic functions;active layers;reactive object queries;context groups;implied methods;object-oriented languages;software engineering;software development;contextual-variability modeling","Games;Programming;Context modeling;Software architecture;Adaptation models;Object oriented modeling","object-oriented programming","group-based behavior adaptation mechanisms;object-oriented systems;distributed systems;dynamic systems;object matching conditions;class membership","","","","9","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Improving Software Quality as Customers Perceive It","R. Hackbarth; A. Mockus; J. Palframan; R. Sethi",Avaya Labs Research; Avaya Labs Research; Avaya Labs Research; Avaya Labs Research,"IEEE Software","23 Jun 2016","2016","33","4","40","45","A proposed data-driven software quality improvement method has three elements. First, the downstream Customer Quality Metric (CQM) quantifies quality as customers perceive it. On the basis of data collected after systems are deployed, it measures how serious defects affect customers. Second, the upstream Implementation Quality Index (IQI) measures the effectiveness of error removal during development. IQI predicts future customer quality; it has a positive correlation with CQM. Finally, prioritization tools and techniques help focus limited development resources on the riskiest files in the code. This research is based on a multiyear program to improve the quality of delivered systems at Avaya, a global provider of business communication and collaboration systems. Regular reviews with Avaya's R&D Quality Council provided governance for the program.","1937-4194","","10.1109/MS.2015.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7106410","software quality method;customer perceived quality;data-driven software process improvement;software risk mitigation;case study;Customer Quality Metric;Implementation Quality Index;software quality assurance software engineering;software development","Software measurement;Software systems;Computational fluid dynamics;Predictive models;Customer services;Behavioral science","software metrics;software process improvement;software quality","data-driven software quality improvement;customer quality metric;implementation quality index","","6","","11","","13 May 2015","","","IEEE","IEEE Magazines"
"Randomly Right","G. J. Holzmann",Nimble Research,"IEEE Software","22 Sep 2017","2017","34","5","87","89","Game strategies used in tools such as Deep Blue and AlphaGo might be the key to improving and automating software verification.","1937-4194","","10.1109/MS.2017.3571567","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048626","software verification;Deep Blue;AlphaGo;FeaVer;feature verification;software verification;software testing;automated software testing;feature interaction problem;model checkers;software development;software engineering","Games;Testing;Search problems;Databases;Software reliability","program testing;program verification","software verification;software testing;model checking","","","","3","","22 Sep 2017","","","IEEE","IEEE Magazines"
"The Unplanned Journey of a Requirements Engineer in Industry: An Introduction","S. Gregory",Intel Corporation,"IEEE Software","22 Sep 2017","2017","34","5","16","19","New department editor Sarah Gregory tells how her professional introduction to requirements engineering both informs the work she does now and drives questions about the discipline that future installments of the Requirements department will explore.","1937-4194","","10.1109/MS.2017.3571561","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048630","requirements engineering;IEEE International Requirements Engineering Conference;software requirements;software development;software engineering","Professional communication;Requirements engineering;Engineering profession;Training","production engineering computing;systems analysis","requirements engineer;industry","","","","6","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Software Testing: The State of the Practice","M. Kassab; J. F. DeFranco; P. A. Laplante",Penn State Great Valley; Penn State Great Valley; Penn State Great Valley,"IEEE Software","22 Sep 2017","2017","34","5","46","52","A Web-based survey examined how software professionals used testing. The results offer opportunities for further interpretation and comparison to software testers, project managers, and researchers. The data includes characteristics of practitioners, organizations, projects, and practices.","1937-4194","","10.1109/MS.2017.3571582","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048665","software testing;software quality;agile;industrial survey;software development;software engineering","Surveys;Software testing;Project management;Performance evaluation","program testing;software quality","software testing;software quality;software development","","6","","14","","22 Sep 2017","","","IEEE","IEEE Magazines"
"GitHub, Technical Debt, Code Formatting, and More","J. C. Carver; J. Cabot; R. Capilla; H. Muccini",University of Alabama; Interdisciplinary Internet Institute; Rey Juan Carlos University of Madrid; University of L'Aquila,"IEEE Software","28 Mar 2017","2017","34","2","105","107","This issue's column reports on papers from the 19th International Conference on Model Driven Engineering Languages and Systems, the 2016 ACM SIGPLAN International Conference on Software Language Engineering, the 12th International ACM SIGSOFT Conference on the Quality of Software Architectures, and the 13th Working IEEE/IFIP Conference on Software Architecture. Topics discussed include GitHub and open source, technical debt in model-driven engineering, a universal code formatter, assuring architectural quality, and continuous architecting.","1937-4194","","10.1109/MS.2017.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888414","GitHub;open source;UML;technical debt;code smells;model-driven engineering;code formatting;machine learning;AQAF;Architecture Quality Assurance Framework;AADL;Architecture Analysis and Design Language;architectural quality;continuous architecting;CAFFEA;Continuous Architecture Framework for Embedded and Agile Software Development;software engineering;software development","","","","","","","","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Product Lines, Energy Conservation, Use Cases, Agile Development, and Infotainment","J. C. Carver; E. S. de Almeida; R. Capilla; L. L. Minku; H. Muccini; B. Penzenstadler","University of Alabama; Federal University of Bahia; Rey Juan Carlos University of Madrid; University of Leicester; University of L'Aquila; California State University, Long Beach","IEEE Software","25 Apr 2016","2016","33","3","29","31","This issue's column reports on the articles discussing different topics. Topics include software product lines, Android app, GUI energy consumption, use case changes, combining architecture with agile development, and car infotainment systems.","1937-4194","","10.1109/MS.2016.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458764","software product lines;software energy consumption;use cases;software architecture;agile development;infotainment;automotive software;software engineering;software development","","energy conservation;graphical user interfaces;green computing;mobile computing;software architecture;software product lines;software prototyping","software product lines;Android application;GUI energy consumption;graphical user interfaces;use case changes;software architecture;agile software development;car infotainment systems","","","","5","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Software Abundance in the Face of Economic Scarcity, Part 2","G. Booch",IBM,"IEEE Software","16 Oct 2009","2009","26","6","15","16","The paper is an editorial that discusses the economics aspect of software industry. The author states that we are in a period of global economic funk, by virtually every measure that we can take. The good news is that we've been here before over the years and we've always seemed to get by. Software is still the most fungible and liquid of resources, and its supply is limited only by human imagination and labor. For this reason, the author began to make the case that software-intensive systems are a necessary element in helping us operate, innovate, and even thrive in the face of lean economic times. There are many opportunities in IT for fueling business, ranging from issues of daily hygiene to opportunities for creating entirely new markets. Effective business strategies must involve some mixture of efficiency-based, innovation-based, and customer-intimacy-based efforts. Software development is an engineering activity. That means not reaching for a perfect solution, but rather evolving to a solution that optimally resolves the static and dynamic forces on that system. For software-intensive systems, these forces include the usual business ones (cost, schedule, and mission) but also development, environmental, operational, and legal/ethical/moral forces. The author also noted that the enterprise's architecture, is the collection of engineering decisions and artifacts that steer the fleet (the organization) through the forces acting upon it and guide it toward its mission. Architecture-as-an-artifact is a manifestation of technical intellectual property and thus serves as an artifact of control. The author concludes that software-intensive systems are an inescapable and necessary element in helping us operate, innovate, and even thrive in the face of lean economic times.","1937-4194","","10.1109/MS.2009.187","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287003","economics;software engineering;innovation;economic scarcity","Environmental economics;Fuel economy;Computer industry;Industrial economics;Humans;Programming;Costs;Job shop scheduling;Law;Legal factors","socio-economic effects;software architecture;software development management","software industry;software-intensive systems;IT business opportunities;software development;enterprise architecture;engineering decisions collection;economic scarcity;architecture-as-an-artifact manifestation;technical intellectual property","","","","","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Death, Taxes, & Scalability","L. Duboc; E. Letier; D. S. Rosenblum",University College London; University College London; University College London,"IEEE Software","14 Jun 2010","2010","27","4","20","21","The London Ambulance System and the online tax return system of Her Majesty's Revenue and Customs are two systems that have experienced significant problems of scalability. However, we've never seen a precise discussion of their scalability concerns. In this column we use those systems to illustrate how the scalability of software systems can be more precisely understood and characterized, and we describe recent research on goal-obstacle analysis that can help elaborate the scalability requirements of such systems, in an effort to mitigate scalability problems early in development.","1937-4194","","10.1109/MS.2010.97","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484110","KAOS;obstacles;requirements;scalability;software engineering","Finance;Scalability;Software systems","formal specification;formal verification;systems analysis","London Ambulance System;online tax return system;scalability;goal-obstacle analysis","","4","","6","","14 Jun 2010","","","IEEE","IEEE Magazines"
"Two-Layer Wrapping for COTS Software Integration: An Experience with Matlab","E. García-Roselló; J. G. Dacosta; M. J. Lado; A. J. Méndez; J. G. Perez-Schofield",University of Vigo; University of Vigo; University of Vigo; University of Vigo; University of Vigo,"IEEE Software","10 Aug 2012","2012","29","4","76","82","Although commercial-off-the-shelf (COTS) product integration presents clear advantages in a variety of engineering fields, several problems can arise in part due to their heterogeneous nature. Little research addresses the integration of particular COTS to specific domains. A University of Vigo project for reusable software development in the engineering domain adopted this approach. The underlying hypothesis was that making COTS integration easier would facilitate the development of domain-specific applications. The solution consists of a two-layer wrapping approach. The first layer captures the COTS domain model, facilitating integration of general-purpose functionality. A second layer provides better integration of more domain-specific functionality. Several real software development projects have used the proposed solution, and the results yielded notable effort savings, showing the approach's utility in reducing COTS integration efforts.","1937-4194","","10.1109/MS.2011.129","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6051413","software architectures;software engineering;COTS;reusable software","Computer languages;Mathematical model;Software architecture;Libraries;Programming;Software reliability;Software measurement","","","","","","15","","18 Oct 2011","","","IEEE","IEEE Magazines"
"Leah Buley: Toward Collaborative, Pragmatic User-Experience Work","J. Patton",ThoughtWorks,"IEEE Software","19 Jun 2009","2009","26","4","93","94","In an interview, Leah Buley of Adaptive Path discusses using design principles and black-hat sessions to foster responsible, collaborative user-experience work.","1937-4194","","10.1109/MS.2009.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076467","user experience;software engineering;black-hat session;design principles;software design;user-centered design","Collaborative work;TV;Collaborative software;Testing;Privacy;Robustness;Home appliances;Product design;Writing","computational linguistics;groupware","collaborative user-experience work;pragmatic user-experience work","","","","","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Darkitecture: The Reality Skirted by Architecture","B. Prasad",NA,"IEEE Software","16 Jan 2017","2017","34","1","103","105","Just as physicists infer dark matter's presence on the basis of its gravitational effects on visible matter, we can conceptualize a ""darkitecture"" that outlines visible software architectures.","1937-4194","","10.1109/MS.2017.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819405","software architect;darkitecture;shadow IT;software development;software engineering","Computer architecture;Pragmatics;Service-oriented architecture;Context modeling;Software architecture;Investment;Information technology","software architecture","darkitecture;visible software architectures","","","","1","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Team Performance in Software Development: Research Results versus Agile Principles","T. Dingsøyr; T. E. Fægri; T. Dybå; B. Haugset; Y. Lindsjørn",SINTEF; SINTEF; SINTEF; SINTEF; University of Oslo,"IEEE Software","23 Jun 2016","2016","33","4","106","110","This article reviews scientific studies of factors influencing colocated development teams' performance and proposes five factors that strongly affect performance. In the process, it compares these propositions with the Agile Manifesto's development principles. The Web extra at https://extras.computer.org/extra/mso2016040106s1.pdf details the sources and research methods the authors employed.","1937-4194","","10.1109/MS.2016.100","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498535","software;development teams;agile;Agile Manifesto;Scrum;team coordination;goal orientation;team cohesion;shared mental models;team learning;software development;software engineering","Software development;Cognitive science;Teamwork;Scrum teams;Programming;Agile computing;Collaboration","software prototyping;team working","software development;shared mental model;Agile Manifesto development principles;team performance","","15","","17","","23 Jun 2016","","","IEEE","IEEE Magazines"
"The Architect's Journey","G. Booch",IBM,"IEEE Software","25 Apr 2011","2011","28","3","10","11","When we grow a software-intensive system, we start with something that is deeply technical, something that is constrained by the laws of physics and the realities of information theory. We then shape it into something that is as invisible as it can be. This is, curiously, the polar opposite of what theoretical physicists do: they observe the fierce complexity of the cosmos, labor to tease apart the threads by which the cosmos is cunningly woven, then try to explain the warp and woof as well as the very nature of the strings themselves in as visible and as simple a language as possible. In the case of software-intensive systems, we start with some very simple concepts - specifically, bits and the nature of information. We then apply various human artifacts - namely, our hard ware and our software languages - to make these bits and information manifest, then we bundle them up in these massive, dripping hairballs of scattered and tangled complexity, drop them into the world, and labor mightily to make them disappear in the interstitial spaces, hidden from view. The most interesting technology is technology that doesn't appear to be there at all.","1937-4194","","10.1109/MS.2011.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5756290","architecture;software-intensive system;peopleware;software engineering","Computer architecture;Economics;Software architecture;Software development management;Technological innovation","software architecture","software-intensive system;information theory;software language;interstitial space","","1","","","","25 Apr 2011","","","IEEE","IEEE Magazines"
"Toward Architecture Knowledge Sustainability: Extending System Longevity","R. Capilla; E. Y. Nakagawa; U. Zdun; C. Carrillo",Rey Juan Carlos University of Madrid; University of São Paulo; University of Vienna; Polytechnic University of Madrid,"IEEE Software","28 Mar 2017","2017","34","2","108","111","Complex software systems often require continuous refactoring to ensure longevity in the face of changing requirements. Architects can exploit the concept of architecture knowledge sustainability to measure and increase their architectures' quality, longevity, and stability.","1937-4194","","10.1109/MS.2017.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888418","software architect;sustainability;stability;longevity;architecture knowledge;refactoring;design decisions;long-lived systems;software development;software engineering;architecture knowledge sustainability;architectural sustainability;software architecture","Computer architecture;Software measurement;Stability criteria;Software development;Unified modeling language;Complexity theory","software architecture;sustainable development","architecture knowledge sustainability;system longevity;complex software systems;continuous refactoring;architecture quality","","5","","10","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Trust in Distributed Teams: Support through Continuous Coordination","B. Al-Ani; D. Redmiles","University of California, Irvine; University of California, Irvine","IEEE Software","16 Oct 2009","2009","26","6","35","40","In this article we report on our investigation of trust in distributed development teams and the role that software tools can play in supporting teams. Our investigation shows that the continuous coordination paradigm tools Palantir, Ariadne, World View, and Workspace Activity Viewer help distributed teams develop trust by sharing information across boundaries through visualizations and in other ways. Our analysis provides insights into the role existing tools can play in developing trust and how future tools can promote trust.","1937-4194","","10.1109/MS.2009.192","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287007","trust;distributed teams;collaboration;coordination;tools;software engineering","Software tools;Visualization","DP management;software tools","distributed development teams;continuous coordination paradigm tools;Palantir tool;Ariadne tool;World View tool;Workspace Activity Viewer tool;information sharing;team trust development","","10","","22","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Trust Me, I'm an Analyst","N. Maiden",City University London,"IEEE Software","31 Dec 2009","2010","27","1","46","47","We often need to remind ourselves that, in the end, requirements projects are really all about people. Whatever new processes, techniques and software tools we come up with, it's still us folks who have to provide, analyze, and validate requirements. Success in requirements projects depends heavily on the domain knowledge and skills of the people involved, and the effective collaboration between them. After all, few requirements projects succeed without effective problem solving, collaboration, and negotiation.So let's remind ourselves requirements projects are about people. About people who do the right thing for their own requirements projects.","1937-4194","","10.1109/MS.2010.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370762","requirements;requirements projects;trust;software;software engineering","Collaboration;Software tools;Problem-solving","project management;systems analysis","requirements project;software tool;requirements validation;problem solving;team collaboration;requirements analysis","","2","","","","31 Dec 2009","","","IEEE","IEEE Magazines"
"Once upon a Time","G. Booch",IBM,"IEEE Software","28 Oct 2016","2016","33","6","8","10","The story of computing is the story of humanity. Civilization is filled with storytelling, which helps us understand our past, reconcile our present, and be intentional of our future. Similarly, as developers, we are the storytellers, using our software and our hardware as our brush and our canvas. The Web Extra at https://youtu.be/S06HKTobvVM is an audio podcast of author Grady Booch reading his column.","1937-4194","","10.1109/MS.2016.141","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725030","storytelling; history of computing; development;software development;software engineering;creation myths;mythology;computer games","History;Software development","social aspects of automation","computing myths;humanity;computing story","","","","9","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Software Abundance in the Face of Economic Scarcity, Part 1","G. Booch",IBM,"IEEE Software","25 Aug 2009","2009","26","5","12","13","The paper discusses the abundance of software products in the face of the economic scarcity. The author states that in the face of economic scarcity, the traditional response is to retreat, shrink, slash, and try not to panic. But there's another, more creative reaction to economic scarcity: to attack. While the velocity of money may have greatly decelerated and while credit might still be a scarce resource, human imagination is not similarly constrained. Software is the most fungible and liquid of resources. The supply of software is limited only by human imagination and labor. Software has no mass, it's remarkably malleable and wonderfully versatile, and it never wears out. This is why it also argue that software intensive systems are an inescapable and necessary element in helping software people operate, innovate, and even thrive.Undeniably, software-intensive systems, even in these lean economic times, are the force behind a sea change in communication and connectivity and a force that continues to propel innovation. Innovation in times of abundance is relatively easy; even just staying alive in lean times is a struggle. The thing about abundance is that, well, abundance feels a whole lot better than scarcity.","1937-4194","","10.1109/MS.2009.139","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222786","economics;software engineering;innovation;economic scarcity","Videos;Humans;Wikipedia;Technological innovation;YouTube;Computer architecture;Earth;Government;Costs;Protection","innovation management;socio-economic effects;software packages","software products abundance;economic scarcity;software intensive systems;human innovation","","","","12","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Software in MRI Scanners","L. Hofland; J. van der Linden",Philips Healthcare; Philips Healthcare,"IEEE Software","14 Jun 2010","2010","27","4","87","89","Software is key to commercial magnetic resonance imaging (MRI) scanners, the medical devices that make images of the living human body for clinical purposes.","1937-4194","","10.1109/MS.2010.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484114","medical imaging;MRI scanners;magnetic resonance imaging;software;software engineering;philips healthcare","Magnetic resonance imaging;Biomedical imaging;Humans","biomedical equipment;biomedical MRI;image scanners","MRI scanners;magnetic resonance imaging scanner;medical devices","","8","","2","","14 Jun 2010","","","IEEE","IEEE Magazines"
"Tiny Tools","G. J. Holzmann",Jet Propulsion Laboratory,"IEEE Software","29 Dec 2015","2016","33","1","24","28","Gerard Holzmann offers simple tools for developers who don't use IDEs but prefer to write code using their own screen editor and who do everything else with command-line tools.","1937-4194","","10.1109/MS.2016.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368034","Cscope;shell programming;Bash;tokenizer;C code;IDEs;software engineering;software development","Switches;Standards;Context;Software reliability;Software;Computers","software reliability","software reliability;command-line tool;IDE;tiny tool","","2","","3","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Mining Domain Knowledge [Requirements]","J. Cleland-Huang",DePaul University,"IEEE Software","23 Apr 2015","2015","32","3","16","19","Basic data-mining skills can be useful for processing domain documents early during requirements engineering. An example from the electronic-healthcare-records domain shows how. The Web extra at http://youtu.be/tHvi3pHEP8c is an audio podcast in which author Jane Cleland-Huang provides an audio recording of the Requirements column, in which she discusses how basic data-mining skills can be useful for processing domain documents early during requirements engineering.","1937-4194","","10.1109/MS.2015.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093055","data mining;software requirements;domain knowledge;document search;Wordle;topic modeling;electronic healthcare records;software engineering;software development","Data mining;Requirements engineering;Computational modeling;Frequency-domain analysis;Drugs;Medical information processing","data mining;document handling","domain knowledge mining;data mining skills;domain document processing;requirements engineering","","10","","1","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Making Program Refactoring Safer","G. Soares; R. Gheyi; D. Serey; T. Massoni","Federal University of Campina Grande, Campina Grande; Federal University of Campina Grande, Brazil; Federal University of Campina Grande, Campina Grande; Federal University of Campina Grande, Campina Grande","IEEE Software","14 Jun 2010","2010","27","4","52","57","Developers rely on compilation, test suites, and tools to preserve observable behavior during refactoring. However, most refactoring tools don't implement all the preconditions that guarantee refactoring correctness because formally identifying them is cost-prohibitive. Therefore, these tools could perform nonbehavior-preserving transformations. The authors present a tool for improving safety during refactoring that automatically generates a test suite suited for detecting behavioral changes. They used this tool to evaluate seven real case study refactorings (from 3 to 100 KLOC).","1937-4194","","10.1109/MS.2010.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5440166","refactoring;behavior preservation;unit testing;software engineering","Safety;Automatic testing","software maintenance","program refactoring;compilation;test suites;nonbehavior preserving transformations","","51","","14","","29 Mar 2010","","","IEEE","IEEE Magazines"
"Monitoring Software Quality Evolution for Defects","H. Zhang; S. Kim","Tsinghua University, Beijing; Hong Kong University of Science and Technology, Hong Kong","IEEE Software","14 Jun 2010","2010","27","4","58","64","Quality control charts, especially c-charts, can help monitor software quality evolution for defects over time. c-charts of the Eclipse and Gnome systems showed that for systems experiencing active maintenance and updates, quality evolution is complicated and dynamic. The authors identify six quality evolution patterns and describe their implications. Quality assurance teams can use c-charts and patterns to monitor quality evolution and prioritize their efforts.","1937-4194","","10.1109/MS.2010.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5453334","maintenance management;software quality;software quality assurance;quality evolution;statistical process control;software engineering","Monitoring;Software quality;Quality control;Quality assurance","quality assurance;software quality","software quality evolution monitoring;quality control charts;c-charts;quality assurance teams;quality evolution patterns;Eclipse;Gnome system","","18","","11","","22 Apr 2010","","","IEEE","IEEE Magazines"
"What Time Is It, Eccles?","N. Maiden",NA,"IEEE Software","23 Jun 2011","2011","28","4","84","85","Requirements analysts need a new toolbox with both the right tools and the instructions to use them including agile development and user-centered design for techniques such as analysis of Web analytics, wire-framing, and user stories. We can also look to the creativity literature and take techniques such as constraint removal, storytelling, and other worlds.","1937-4194","","10.1109/MS.2011.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929526","software engineering;requirements;techniques;agile;creativity;meaning carriers","Software development management;Research and development;User centered design;Agile manufacturing","","","","","","1","","23 Jun 2011","","","IEEE","IEEE Magazines"
"Learning from Failure, Part 1: Scoping and Requirements Woes","F. Buschmann",Siemens Corporate Technology,"IEEE Software","16 Oct 2009","2009","26","6","68","69","The paper is an editorial on software architecture. Software projects fail for the same reasons. The mistakes that can lead software projects to trouble before concrete architecture elaboration even begins include missing, wrong, or creeping system scope; and vague, unnecessary, or extreme nonfunctional requirements. These mistakes aren't the prime responsibility of architects, but architects are directly affected if they occur because without an appropriate system scope and correspondingly appropriate requirements, they can't define sustainable architectures. A system's scope defines its responsibilities, but also its boundaries. Failing to define a precise system scope can result in architectures that support the wrong functionality, too much functionality, too many functionality variations, too few functions, or poor quality. Architects should pay special attention to nonfunctional requirements that too often include vague or unnecessarily extreme specifications. Without precision, architects must guess which nonfunctional qualities are actually needed, and if they must guess, they'll likely guess wrong. An agile, incremental approach to software development define an initial system scope and set of requirements in a reasonable time and adjust this big picture step-wise until it has enough focus, substance, and clarity. Then, architects get concrete guidance for their work and can act rather than react when designing the system's architecture. Only then do architects receive a safety network that allows them to identify and correct design flaws in their own area of responsibility.","1937-4194","","10.1109/MS.2009.179","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287013","software architect;software architecture;software engineering;nonfunctional requirements;requirements engineering;system scope;functionality","Concrete;Computer architecture;Software architecture;Programming;Safety","software architecture;software development management","software architecture;system scope failure;nonfunctional requirements failure;software development incremental approach;software architects","","16","","7","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Software in Automotive Systems","J. Mössinger",Robert Bosch,"IEEE Software","25 Feb 2010","2010","27","2","92","94","We're happy to get on the road with the column. Be aware that you may be carrying 100 million lines of code with you the next time you take the car. Jiirgen Moessinger is vice president for automotive systems integration at Bosch and describes the challenges and opportunities that software brings to the automotive industry.","1937-4194","","10.1109/MS.2010.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420803","software engineering;standards;best practices;automotive systems","Software systems;Automotive engineering;Roads;Computer industry","automobile industry;production engineering computing","automotive industry;automotive systems","","21","","","","25 Feb 2010","","","IEEE","IEEE Magazines"
"Software Process Improvement in Very Small Organizations","X. Larrucea; R. V. O'Connor; R. Colomo-Palacios; C. Y. Laporte",Tecnalia; Dublin City University; Østfold University College; École de technologie supérieur,"IEEE Software","26 Feb 2016","2016","33","2","85","89","Software process improvement (SPI) offers obstacles and opportunities for very small entities (VSEs), which are organizations with 25 or fewer employees. To help with this, the International Organization for Standardization and the International Electrotechnical Commission jointly developed ISO/IEC 29110 as SPI guidelines for VSEs.","1937-4194","","10.1109/MS.2016.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420471","software process improvement;SPI;very small entities;VSEs;ISO/IEC 29110;experience factory;software engineering;software development","Software process improvement;IEC Standards;ISO Standards;Standards organizations;Business","IEC standards;ISO standards;organisational aspects;software process improvement","SPI guideline;ISO/IEC 29110;International Electrotechnical Commission;International Organization-for-Standardization;VSE;very small entity;SPI;software process improvement","","57","","11","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Points of Truth","G. J. Holzmann",NASA/JPL,"IEEE Software","30 Jun 2015","2015","32","4","18","21","The SPOT (Single Point of Truth) principle says that developers should specify key pieces of information in one and only one place in their code. Unfortunately, they frequently violate this principle.","1937-4194","","10.1109/MS.2015.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140686","single point of truth;software engineering;software development","Software development;Software reliability;Standards","software reliability","SPOT principle;single point of truth principle","","11","","2","","30 Jun 2015","","","IEEE","IEEE Magazines"
"The Big Questions","G. Booch",IBM,"IEEE Software","13 Jun 2014","2014","31","4","9","11","Explores how technology shapes the person and the ideas behind our decisions. From developer to architect, from business analyst to user, there are a number of big questions whose answers shape the systems with which we engage. As individuals, we each play many roles in our lives and as such there are some even bigger questions that haunt us in our journey: questions that transcend any specific role, questions that can't be answered by technology. The Web extra at http://youtu.be/elirN-WSq1g is an audio podcast of author Grady Booch reading his On Computing column, in which he discusses the big questions whose answers shape the systems with which we engage.","1937-4194","","10.1109/MS.2014.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834680","software engineering;developer;architect;analyst;user;human","Computer science;Philosophical considerations;Social factors;Technology;Decision making;Human factors;Ethical aspects","","","","","","","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Model-Based Testing","I. Schieferdecker",Fraunhofer Institute for Open Communication Systems,"IEEE Software","22 Dec 2011","2012","29","1","14","18","Model-based testing (MBT) strives to automatically and systematically generate test cases. In this column, Ina Schieferdecker introduces MBT technologies and methods.","1937-4194","","10.1109/MS.2012.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111361","model-based testing;software;engineering;technology;tools;methods Fokus!MBT;MBT","Software testing;Software design;Modeling;Testing;Model-based testing","program testing","model-based testing;MBT","","37","","6","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Green Software: Greening What and How Much?","K. Sierszecki; T. Mikkonen; M. Steffens; T. Fogdal; J. Savolainen",Danfoss Power Electronics; Tampere University of Technology; Danfoss Power Electronics; Danfoss Power Electronics; Danfoss Power Electronics,"IEEE Software","21 Apr 2014","2014","31","3","64","68","In applications in which embedded devices cooperate with ICT (information and communication technology) systems to make industrial processes more efficient, reduce waste or raw materials, and save the environment, the concept of green software becomes increasingly complex. To deal with this issue, the green-software community has introduced the concepts of greening ICT or greening through ICT.","1937-4194","","10.1109/MS.2014.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6802991","green software;green systems;variable-speed drives;embedded control systems;greening information and communication technology;greening ICT;greening through information and communication technology;greening through ICT;software engineering","Software;Green products;Power demand;Energy consumption;Power electronics;Electric motors;Torque","green computing;power aware computing","embedded devices;ICT;information and communication technology systems;industrial processes;waste reduction;raw materials;green-software community","","5","","6","","21 Apr 2014","","","IEEE","IEEE Magazines"
"Developing Software for a Mobile Service in India","B. Seetharam",Vodafone Solutions,"IEEE Software","10 Aug 2012","2012","29","4","34","39","There is a demand in India for venues for purchasing music for mobile phones via means other than the Internet. Although two-thirds of mobile users in India are already listening to music on their mobile devices, often illegally or through unaffiliated vendors, there are more than 700 million mobile phone users that music sales cannot reach through the Internet. This article presents ideas for reaching such users.","1937-4194","","10.1109/MS.2012.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6180162","mobile Internet;offline Internet access;handheld devices;software engineering","Supply and demand;India;Mobile communication;Supply and demand;Smart phones;Handheld devices;Music;Computer applications","","","","2","","10","","10 Apr 2012","","","IEEE","IEEE Magazines"
"Safety Stories in Agile Development","J. Cleland-Huang",University of Notre Dame,"IEEE Software","11 Jul 2017","2017","34","4","16","19","Safety stories specify safety requirements, using the EARS (Easy Requirements Specification) format. Software practitioners can use them in agile projects at lower levels of safety criticality to deal effectively with safety concerns.","1937-4194","","10.1109/MS.2017.108","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974701","safety stories;safety-critical software;safety assurance cases;EARS;Easy Requirements Specification;software requirements;agile software development;software development;software engineering","Hazards;Drones;Software systems;Batteries;Safety","formal specification;safety-critical software;software prototyping","agile development;EARS;easy requirements specification;safety criticality","","4","","6","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Gardening Your Architecture, Part 2: Reengineering and Rewriting","F. Buschmann",Siemens Corporate Technology,"IEEE Software","18 Aug 2011","2011","28","5","21","23","Reengineering and rewriting are two common approaches for improving system quality-in addition to refactoring, which the last installment of this column explored. Reengineering is a systematic approach to evolve existing software to exhibit new behavior, features, and operational quality. Refactoring and reengineering aren't the same, and they're also different from rewriting-the most radical change-which involves wiping the slate clean and starting over.","1937-4194","","10.1109/MS.2011.97","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984792","refactoring;reengineering;rewriting;functional quality;developmental quality;operational quality;software;software engineering","Computer architecture;Software measurement;Software architecture;Business process re-engineering","software architecture;software maintenance;software quality;systems re-engineering","reengineering;rewriting;system quality improvement;operational quality","","2","","3","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Robotic Testing of Mobile Apps for Truly Black-Box Automation","K. Mao; M. Harman; Y. Jia",University College London; University College London; University College London,"IEEE Software","28 Mar 2017","2017","34","2","11","16","Robots are widely used for many repetitive tasks. Why not software testing? Robotic testing could give testers a new form of testing that's inherently more black-box than anything witnessed previously. Toward that end, researchers developed Axiz, a robotic-test generator for mobile devices.","1937-4194","","10.1109/MS.2017.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888396","robotic testing;automated software testing;software testing;mobile devices;mobile apps;black-box testing;Axiz;Android;Google Calculator;software development;software engineering","Robots;Software testing;Mobile communication;Robot sensing systems;Computer applications","automatic testing;control engineering computing;mobile computing;program testing;robots","robotic testing;mobile application;truly black-box automation;software testing;robotic-test generator;simulation-based test automation;Axiz;Google Calculator application","","17","","15","","28 Mar 2017","","","IEEE","IEEE Magazines"
"A Paradigm Shift for the CAPTCHA Race: Adding Uncertainty to the Process","S. Kwon; S. Cha",Korea University; Korea University,"IEEE Software","28 Oct 2016","2016","33","6","80","85","CAPTCHA (Completely Automated Public Turing Test to Tell Computers and Humans Apart) challenges are often correctly solved by software but have increasingly become too difficult for humans to pass. If the correct response to a challenge remains the same, robots can gather invaluable information from accidental successes and will easily defeat future challenges through heuristic learning. Introducing uncertainty to the challenges will fundamentally change the rules of image-based CAPTCHA systems. This new approach temporarily excludes some images from a challenge's results, assigning them a neutral role. However, future challenges might include these images. So, successful responses might differ between challenges even though the challenges use the same images, thereby eliminating the threat of heuristic attacks. To further reduce the chance of robots accidently passing a challenge, this approach analyzes the decisions made on neutral images. If the outcome would have been different had the challenge results included the neutral images, those images are added to a ""trap"" database and included in future challenges. In experiments, this approach almost always defeated powerful robots (for example, robots using heuristic learning or a search engine), but humans could still easily pass the challenges.","1937-4194","","10.1109/MS.2016.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7412614","automated Turing test;CAPTCHA;heuristic attack;software engineering;software development","Robots;CAPTCHAs;Databases;Search engines;Heuristic algorithms;Logic gates","control engineering computing;cryptography;image processing;learning (artificial intelligence);robots;search engines","paradigm shift;completely automated public turing test to tell computers and humans apart;heuristic learning;uncertainty process;image-based CAPTCHA systems;heuristic attacks;neutral images;search engine","","3","","7","","18 Feb 2016","","","IEEE","IEEE Magazines"
"Learning Contextual-Variability Models","P. Temple; M. Acher; J. Jézéquel; O. Barais",University of Rennes 1 and IRISA; University of Rennes 1 and IRISA; University of Rennes 1 and IRISA; University of Rennes 1 and IRISA,"IEEE Software","13 Nov 2017","2017","34","6","64","70","This approach described in this article uses machine learning to execute and observe a sample of software configurations within a sample of contexts. It then learns what factors of each context will likely discard or activate some of the software's features.","1937-4194","","10.1109/MS.2017.4121211","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106868","contextual variability;machine learning;software engineering;software development;contextual-variability modeling","Machine learning;Context modeling;Noise level;Computational modeling;Numerical models;Feature extraction;Cameras","learning (artificial intelligence)","software configurations;machine learning;contextual-variability models","","","","7","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Software Architecture in a Changing World","E. Woods",Endava,"IEEE Software","28 Oct 2016","2016","33","6","94","97","As software systems have evolved, so has software architecture, with practices growing to meet each era's new challenges. The next phase of evolution--intelligent connected systems--promises to be an exciting time for software architects.","1937-4194","","10.1109/MS.2016.149","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725217","history of computing;software architect;software engineering;software development;Internet of Things;cloud;artificial intelligence","Computer architecture;Software architecture;Internet;Heuristic algorithms;Market research;Software systems","software architecture","software architecture;intelligent connected systems","","13","","13","","28 Oct 2016","","","IEEE","IEEE Magazines"
"When Software Impacts the Economy and Environment","E. S. de Moura; M. R. Herrera; L. Santos; T. Conte; M. van Genuchten; L. Hatton",Federal University of Amazonas; Neemu; Neemu; Federal University of Amazonas; NA; NA,"IEEE Software","28 Oct 2016","2016","33","6","23","26","When customers visit a Brazilian e-commerce site and search for a product, they're likely using software developed by Neemu, a start-up created in Manaus, a city in the heart of the Amazon rainforest. Nowadays, millions of people throughout Brazil use this software, which demonstrates alternative economic development in Amazonia that has low impact on the environment.","1937-4194","","10.1109/MS.2016.135","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725221","Neemu;Brazil;Brazilian software industry;e-commerce;search software;search algorithms;faceted search;Linx;Choardics;autocompletion;software development;software engineering","Software development;Web search;Electronic commerce;Algorithm design and analysis;Search problems;Navigation;Query processing","electronic commerce;social aspects of automation;Web sites","Brazilian e-commerce site;Amazon rainforest;economic development","","","","4","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Where Are We? Handling Context","N. Maiden",City University London,"IEEE Software","25 Aug 2009","2009","26","5","75","76","These requirements were often enough for the architects to design the application. But now, technological advances mean that such requirement statements are just not enough. Mobile devices change everything. Suddenly a simple system requirement on a mobile application to support navigation, such as the application shall display a local street map at all times is rendered ambiguous and incomplete by the mobility of the device running the application.","1937-4194","","10.1109/MS.2009.146","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222798","Requirements specifications;software requirements;software engineering","Displays;Computational efficiency;Printers;Temperature;Noise level;Availability;Computer networks;Vehicles;Cities and towns;Character generation","formal specification;mobile computing","context handling;mobile device;system requirement;requirements specification","","","","5","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Accessible Software Verification with Dafny","K. R. M. Leino",Microsoft Research,"IEEE Software","13 Nov 2017","2017","34","6","94","97","Formal software verification includes specifications, tools, and interactivity with the developer. By combining these key components into a programming language and a familiar programming environment with high automation, Dafny makes verification more easily accessible to programmers and students.","1937-4194","","10.1109/MS.2017.4121212","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106874","software verification;Dafny;IDE;imperative procedures;lemma proofs;software engineering;software development;Reliable Code","Formal verification;Software reliability;Software development;Encoding;Cognition","formal specification;program verification;programming environments;programming languages;software tools","software verification;Dafny;formal specifications;software tools;interactivity;programming language;programming environment","","1","","10","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Implementing Functional Safety","C. Ebert",Vector Consulting Services,"IEEE Software","21 Aug 2015","2015","32","5","84","89","For software-related companies to deliver safe products and to cope with emerging product liability risks, significant improvements to technology and processes are necessary. This column presents industry experiences in adapting product development to conform to safety standards.","1937-4194","","10.1109/MS.2015.126","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217771","product safety;product liability;software engineering;functional safety;ISO standards;safety-critical systems;safety standards","Safety;Software;ISO Standards;Industries;Vehicles;Hardware","DP industry;product development;risk management;safety;software standards","functional safety implementation;software-related companies;product safety;product liability risk;product development;safety standards","","4","","4","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Dead Programs","G. J. Holzmann",Nimble Research,"IEEE Software","11 Jul 2017","2017","34","4","89","91","“Dead programmes” were programs stored in write-only memory. To protect program code, PTERA let users block write access to parts of the drum, using a small plugboard. The term “dead” came back also in references to the plugboard itself as providing “dead registers” that the program couldn't modify.","1937-4194","","10.1109/MS.2017.107","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974705","function calls;call stack;computer science history;EDVAC;Willem van der Poel;PTERA;software development;software engineering;computer science pioneers","Computers;Algorithms;Computer science;Reliability engineering;Data structures;History","program diagnostics","dead programs;write-only memory","","","","10","","11 Jul 2017","","","IEEE","IEEE Magazines"
"A tale of three programs","G. J. Holzmann",Nimble Research,"IEEE Software","15 May 2017","2017","34","3","23","26","A look at the generation of prime numbers offers a cautionary tale about the perils of premature optimization. We can code this in any reasonable programming language, and in quite a few unreasonable ones as well. It can be fun to express the algorithm in Python, C, C++, Scala, or Go, or even in scripting languages such as Tcl or Awk. And, yes, I confess that I've tried most of these, including Awk. Each language offers different features that can simplify the job or make it more interesting. For our current purpose, it'll suffice to stick to just plain old C.In a first attempt, we might come up with the version in Figure 1, which assumes that we provide the value of N in some other way-for example, with a macro directive to the C compiler.","1937-4194","","10.1109/MS.2017.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927921","prime numbers;recursion;Sieve of Eratosthenes;software development;software engineering;programming;Robert Morris Sr.","Mathematics;Encoding","C language;program compilers","programming language;scripting languages;C language;C compiler","","","","1","","15 May 2017","","","IEEE","IEEE Magazines"
"Pattern-Based Architecture Reviews","N. Harrison; P. Avgeriou",Utah Valley University; University of Groningen,"IEEE Software","20 Oct 2011","2011","28","6","66","71","Software architecture reviews are effective in identifying potential problems in architectures, however, are expensive, time-consuming, and generally rely on extensive architecture documentation. An architecture review that accommodates projects with very short development cycles, minimal documentation, or frequently changing requirements could be useful if it identifies important architectural issues. We developed a useful, inexpensive architecture review method that uses the architecture patterns in a system to identify important issues in the achievement of quality attributes.","1937-4194","","10.1109/MS.2010.156","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5661759","Software Architecture;Patterns;Software Engineering Process;Review and Evaluation","Computer architecture;Pattern recognition;Software architecture;Software development;Product life cycle management","software architecture","pattern-based architecture reviews;software architecture review method;quality attributes achievement","","16","","14","","10 Dec 2010","","","IEEE","IEEE Magazines"
"Design for Test","R. J. Wirfs-Brock",Wirfs-Brock Associates,"IEEE Software","25 Aug 2009","2009","26","5","92","93","As developers, we're expected to turn out implementations proven by tests that we or others have written. Doing otherwise is considered unprofessional. But does code that's designed to be testable differ fundamentally from code that isn't? What does it mean to design for test? Advocates of test-driven development (TDD) write tests before implementing any other code. They take to heart Tom Peters' credo, ""Test fast, fail fast, adjust fast."" Testing guides their design as they implement in short, rapid-fire ""write test code - fail the test - write enough code to pass - then pass the test"" cycles. Regardless of whether you adhere to TDD design rhythms, writing unit tests forces you to articulate pesky edge cases and clean up your design.","1937-4194","","10.1109/MS.2009.125","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222803","software engineering;software design;unit tests;debugging;test-driven design","Software testing;System testing;Writing;Collaboration;Wiring;Assembly;Software performance;Heart;Rhythm;Feathers","program testing","design for test;program testing;test-driven development","","1","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Healthy Routes in the Smart City: A Context-Aware Mobile Recommender","F. Casino; C. Patsakis; E. Batista; F. Borràs; A. Martínez-Balleste",Universitat Rovira i Virgili; University of Piraeus; Universitat Rovira i Virgili; Universitat Rovira i Virgili; Universitat Rovira i Virgili,"IEEE Software","13 Nov 2017","2017","34","6","42","47","A context-aware recommender system offers personalized recommendations of exercise routes to people according to their medical condition and real-time information from the smart city. Experiments with a simulated dataset and real data verified the system's usefulness.","1937-4194","","10.1109/MS.2017.4121209","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106878","smart health;mobile health;recommender systems;collaborative filtering;context-aware systems;software engineering;software development;context-aware and smart healthcare","Context awareness;Medical services;Real-time systems;Sensors;Smart cities;Recommender systems;Mobile communication","medical information systems;recommender systems;smart cities;ubiquitous computing","smart city;context-aware recommender system;personalized recommendations;exercise routes;medical condition;real-time information;healthy routes;simulated dataset;system usefulness","","5","","14","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Point/Counterpoint","G. D. Everett; B. Meyer",American Software Testing Qualifications Board; ETH Zurich,"IEEE Software","19 Jun 2009","2009","26","4","62","65","Bertrand Meyer recently proposed seven principles of software testing. Other sets of principles embraced by testing professionals worldwide suggest that Meyer's list can be improved. One such set is the International Software Testing Qualifications Board Certified Tester Foundation Level Syllabus.","1937-4194","","10.1109/MS.2009.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076460","software testing;International Software Testing Qualifications Board;static testing;dynamic testing;software engineering","Software testing;Automatic testing;Qualifications;Terminology;Vehicle crash testing;Psychology;Quality assurance;Process planning;System testing;Condition monitoring","program testing","software testing principle;international software testing qualifications board;certified tester foundation level syllabus","","1","","3","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Code Clarity","G. J. Holzmann",NASA/JPL,"IEEE Software","26 Feb 2016","2016","33","2","22","25","Naming conventions affect the readability of your code and the ease with which you can find your way around when you're reviewing that code. Naming conventions aren't meant to help the compiler. A compiler has no trouble distinguishing names, no matter how long, short, or obscure they are. But to us humans, they can matter a great deal.","1937-4194","","10.1109/MS.2016.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420491","C language;Linux;function names;identifier names;programming;software development;software engineering","Linux;Standards;Market research;Encoding;White spaces;Software reliability","program compilers;Unix","Unix code clarity;code readability;compiler","","3","","1","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Functional Size Estimation Technologies for Software Maintenance","C. Ebert; H. Soubra",Vector Consulting Services; ESTACA--Engineering School,"IEEE Software","7 Nov 2014","2014","31","6","24","29","Estimating functional software size is the key input for building software models. Unlike direct effort estimates, software size estimation gives a measure of the software product itself and can be used to build objective estimation models for predicting project effort and duration, estimating defects for quality and service cost predictions, and obtaining software development productivity ratios. Although maintenance dominates software projects, the underlying technologies for estimation have been rather poorly described to date. Here, the authors examine estimation technologies based on the COSMIC (Common Software Measurement International Consortium) method as it's applied to maintenance projects.","1937-4194","","10.1109/MS.2014.138","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949529","benchmark;metric;standards;measurement;software engineering","Software reliability;Estimation;Size measurement;Software measurement;Maintenance engineering;Productivity;Project management","project management;software cost estimation;software development management;software maintenance;software quality","software maintenance;functional software size estimation technologies;software models;effort estimates;software product measurement;objective estimation models;project effort;project duration;defects estimation;quality;service cost predictions;software development productivity ratios;software projects;COSMIC;Common Software Measurement International Consortium;maintenance projects","","6","","6","","7 Nov 2014","","","IEEE","IEEE Magazines"
"How Software Is Changing the Automotive Landscape","H. Aerts; H. Schaminée",TomTom Automotive; NA,"IEEE Software","13 Nov 2017","2017","34","6","7","12","In the Impact department article in the July/August 2011 IEEE Software, Hans Aerts and Han Schaminée described how TomTom was a volume leader in consumer navigation systems and how TomTom applied that volume leadership when it entered the automotive market. Here, Aerts and Schaminée present what has occurred over the past six years and predict what will happen in the automotive industry.","1937-4194","","10.1109/MS.2017.4121219","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106884","automotive software;navigation software;TomTom;static analysis;software development productivity;agile software development;connectivity;software development;software engineering;Impact","Navigation;Software development;Automotive engineering;Companies","automobile industry;traffic engineering computing","automotive industry;automotive market;volume leadership;consumer navigation systems;TomTom;IEEE Software;automotive landscape","","1","","3","","13 Nov 2017","","","IEEE","IEEE Magazines"
"""The Golden Age of Software Architecture"" Revisited","P. Clements; M. Shaw",Carnegie Mellon University; Carnegie Mellon University,"IEEE Software","19 Jun 2009","2009","26","4","70","72","In ""The Golden Age of Software Architecture"" Paul Clements and Mary Shaw reviewed the emergence of software architecture as the principled understanding of the large-scale structures of software systems. Here they reflect on progress since that article, updating the state of practice and reassessing some of the opportunities.","1937-4194","","10.1109/MS.2009.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076462","software architecture;software design;software development;software system;system organization;history of software engineering;technology maturation","Software architecture;Computer architecture;Service oriented architecture;Object oriented programming;Algorithms;Certification;Engineering profession;Documentation;Employee welfare;Application software","software architecture","software architecture;large-scale structure;software system","","23","","12","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Why They Just Don't Get It: Communicating about Architecture with Business Stakeholders","J. Schulenklopper; E. Rommes",Xebia; M&I/Partners,"IEEE Software","25 Apr 2016","2016","33","3","13","19","Following certain best practices for visual communication can help bridge the gap between IT architects and business stakeholders. These practices stem from disciplines such as psychology, graphic design, communication science, and cartooning. They're intended to aid all architecture stakeholders in understanding, analysis, and discussion.","1937-4194","","10.1109/MS.2016.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458757","software architecture;software development;software engineering;collaboration;IT;IT architecture;business stakeholders;effective communication;visualization techniques;visual communication","Visualization;Stakeholders;Image color analysis;Computer architecture;Psychology;Software architecture;Information technology","software architecture","software architecture;business stakeholders;best practices;visual communication","","6","","2","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Choice of Software Development Methodologies: Do Organizational, Project, and Team Characteristics Matter?","L. R. Vijayasarathy; C. W. Butler",Colorado State University; Colorado State University,"IEEE Software","24 Aug 2016","2016","33","5","86","94","Organizations can choose from software development methodologies ranging from traditional to agile approaches. Researchers surveyed project managers and other team members about their choice of methodologies. The results indicate that although agile methodologies such as Agile Unified Process and Scrum are more prevalent than 10 years ago, traditional methodologies, including the waterfall model, are still popular. Organizations are also taking a hybrid approach, using multiple methodologies on projects. Furthermore, their choice of methodologies is associated with certain organizational, project, and team characteristics.","1937-4194","","10.1109/MS.2015.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006383","software development methodologies;agile methodologies;traditional methodologies;waterfall model;hybrid software development;project characteristics;team characteristics;organizational characteristics;software development;software engineering","Software development;Industries;Organizations;Information systems;Agile software development","project management;software development management;software prototyping;team working","software development methodologies;organizational characteristics;project characteristics;team characteristics;project managers;team members;agile methodologies;agile unified process;Scrum;waterfall model","","48","","7","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Business Roles in the Emerging Open-Data Ecosystem","J. Lindman; T. Kinnari; M. Rossi",Hanken School of Economics; Aalto University School of Business; Aalto University School of Business,"IEEE Software","24 Aug 2016","2016","33","5","54","59","Software specialists know the merits of information visualizations, mashups, and other types of open-data enrichments that serve customers' needs. Commercial services based on these enrichments hold great potential as new businesses. A proposed model categorizes the roles of businesses in enriching open data. This model could help entrepreneurs looking for business opportunities and professionals in companies with underused data resources.","1937-4194","","10.1109/MS.2015.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006350","data;databases;business computer applications;software development;software engineering","Computer applications;Data models;Software development;Data mining;Data visualization;Mobile communication","business data processing;data handling","business role;open-data ecosystem;information visualization;software specialists;customer needs;data resources","","12","","14","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Dynamically Adaptable Software Is All about Modeling Contextual Variability and Avoiding Failures","I. de Sousa Santos; M. L. de Jesus Souza; M. L. Luciano Carvalho; T. Alves Oliveira; E. S. de Almeida; R. M. de Castro Andrade",Federal University of Ceará; Federal University of Bahia; Federal University of Bahia; Federal University of Ceará; Federal University of Bahia; Federal University of Ceará,"IEEE Software","13 Nov 2017","2017","34","6","72","77","eCFM is an extension of context-aware feature modeling (CFM) that improves contextual variability's expressiveness. eCFM combined with model checking provides a systematic way to model dynamically adaptable software and avoid failures in it.","1937-4194","","10.1109/MS.2017.4121205","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106890","dynamically adaptable software;contextual-variability modeling;dynamic variability;design faults;model checking;context-aware feature modeling;CFM;extended context-aware feature modeling;eCFM;software engineering;software development","Adaptation models;Context modeling;Model checking;Analytical models;Computational modeling;Runtime","failure analysis;formal verification;software reliability;ubiquitous computing","model checking;contextual variability expressiveness;context-aware feature modeling;eCFM;failure avoidance;contextual variability modelling","","","","14","","13 Nov 2017","","","IEEE","IEEE Magazines"
"My Autobiography","G. Booch",IBM,"IEEE Software","21 Aug 2015","2015","32","5","13","15","The story of computing is the story of humanity. This is a story of ambition, invention, creativity, vision, avarice, and serendipity, powered by a refusal to accept the limits of our bodies and minds. The Web extra at http://youtu.be/j3RI3dkPCvY is an audio podcast of this column.","1937-4194","","10.1109/MS.2015.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217779","software engineering;computing;history;future","Business;History;Computers;Technology;Computational modeling;Programming;Computer applications","humanities","autobiography;humanity;ambition;invention;creativity;vision;avarice;serendipity","","","","","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Code Craft","G. J. Holzmann",Nimble Research,"IEEE Software","28 Mar 2017","2017","34","2","18","21","Errors in safety-critical software can have disastrous consequences. However, tools exist that developers can use to thoroughly analyze software subsystems for critical safety properties.","1937-4194","","10.1109/MS.2017.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888377","software engineering;Spin;Therac-25;hardware interlocks;race conditions;data corruption;software development","Safety;Software testing;Error analysis;Integrated circuit modeling;Software reliability;Analytical models","safety-critical software","software developers;software errors;critical safety properties;software subsystems;disastrous consequences;safety-critical software;code craft","","","","3","","28 Mar 2017","","","IEEE","IEEE Magazines"
"No Free Lunch for Software after All","A. Rutkowski; M. van Genuchten; L. Hatton",Tilburg University; VitalHealth Software; Oakwood Computing Associates,"IEEE Software","22 Sep 2017","2017","34","5","13","15","Software's lack of reproduction costs provides benefits to not just legitimate developers but also people who want to use software for criminal purposes. The software community must address this issue or risk disenfranchising the users on whom the software industry depends.","1937-4194","","10.1109/MS.2017.3571570","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048627","software security;General Data Protection Regulation;GDPR;software development;software engineering","Software development;Computer bugs;Law;Computer crime","computer crime;DP industry;DP management;software cost estimation","software cost reproduction;criminal purposes;software community;risk disenfranchising;software industry","","1","","13","","22 Sep 2017","","","IEEE","IEEE Magazines"
"10 MLOC in Your Office Copier","Y. Tsuchitoi; H. Sugiura",NA; NA,"IEEE Software","20 Oct 2011","2011","28","6","93","95","Amid the obvious volume of digital copiers and multifunction printers, the system size is in the millions of lines of code with functionality creep into several overlapping areas-a theme of many modern systems.","1937-4194","","10.1109/MS.2011.133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6055665","multifunction printer;mfp;model-driven development;mdd;unified modeling language;uml;highly accelerated and yield software testing;hayst;software;engineering;development","Digital images;Printers;Digital printing","photocopying;systems software","office copier;digital copiers;multifunction printers","","4","","1","","20 Oct 2011","","","IEEE","IEEE Magazines"
"Five Considerations for Software Architecture, Part 2","F. Buschmann; K. Henney",Siemens Corporate Technology; consultant,"IEEE Software","14 Jun 2010","2010","27","4","12","14","What are the top five properties that make a software design elegant? In this column we follow on from the previous column, exploring the remaining two properties: symmetry and emergence. Symmetry offers a form of simplification through regularity. Emergence allows complex behaviors to be governed by simple rules.","1937-4194","","10.1109/MS.2010.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484107","architecture;symmetry;emergence;software;software engineering","Software architecture;Software design","software architecture;symmetry","software architecture;software design;symmetry;emergence","","6","","4","","14 Jun 2010","","","IEEE","IEEE Magazines"
"Component Stacks for Enterprise Applications","P. Louridas",Athens University of Economics and Business,"IEEE Software","26 Feb 2016","2016","33","2","93","98","Until relatively recently, the tools used to develop Web applications followed a well-established architecture called the LAMP stack. Recently, the MEAN stack has taken the Web developer world by storm and is replacing LAMP.","1937-4194","","10.1109/MS.2016.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420497","MEAN;LAMP;Linux;Apache;MySQL;PHP;JavaScript;MongoDB;NoSQL;SQL;Express;Jode.js;AngularJS;relational databases;software development;software engineering","Servers;Databases;HTML;Browsers;Programming;Software;Linux","business data processing","component stacks;enterprise applications;Web applications;LAMP stack;MEAN stack","","6","","1","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Harnessing the Power of Architectural Design Principles","E. Woods",Endava,"IEEE Software","23 Jun 2016","2016","33","4","15","17","Architecture principles epitomize architecture's function: to clearly define the necessary constraints on a system's design without prescriptively defining all the design details. A good set of principles can provide context and justification for design decisions and can foster team collaboration and communication.","1937-4194","","10.1109/MS.2016.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498534","software architecture;design;project management;software development;software engineering","Computer architecture;Standards;Context modeling;Software development","architecture;groupware;team working","architectural design principles;architecture function;system design;team collaboration;team communication","","1","","3","","23 Jun 2016","","","IEEE","IEEE Magazines"
"An Architecture-Driven Modernization Tool for Calculating Metrics","J. Canovas; J. G. Molina","Universidad de Murcia, Murcia; Universidad de Murcia , Murcia","IEEE Software","14 Jun 2010","2010","27","4","37","43","Model-driven software development (MDD) is gaining increasing acceptance, mainly because it can raise the level of abstraction and automation in software construction. MDD techniques (see the sidebar ""MDD Basic Concepts""), such as metamodeling and model transformation, not only apply to the creation of new software systems but also can be used to evolve existing systems. These techniques can help reduce software evolution costs by automating many basic activities in software change processes, such as representing source code at a higher level of abstraction, providing information to analyze the impact of the changes, or automatically generating software artifacts of the evolved system. Several experiences of applying MDD in platform migration scenarios have recently been published,1'2 but they define ad hoc metamodels that hinder interoperability.","1937-4194","","10.1109/MS.2010.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5440163","domain-specific architectures;process implementation and change;specialized application languages;software engineering;model-driven development","Programming;Automation;Metamodeling;Software systems;Costs;Information analysis","software architecture","architecture driven modernization tool;metrics calculation;model driven software development;MDD;software construction;MDD basic concepts;model transformation;software artifacts;ad hoc metamodels","","26","","5","","29 Mar 2010","","","IEEE","IEEE Magazines"
"The Evolution of Flight Management Systems","D. Avery",Honeywell,"IEEE Software","20 Dec 2010","2011","28","1","11","13","Flight management systems (FMSs) have become an essential component of almost every aircraft's cockpit. The FMS is the pilot's primary interface for flight planning operations on the airplane and contains a worldwide aeronautical navigation database for controlled flight into any airport. It optimizes routing to save fuel and time and increases safety by providing a flight plan display and airplane control without the need for costly ground-based infrastructure.","1937-4194","","10.1109/MS.2011.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5672514","flight management system;Electronic Flight Instrument System;Honeywell;software failure;software engineering;communications","Aircraft;Safety;Certification;FAA;Trajectory;Aerospace control","aerospace computing;aircraft control;database management systems","flight management systems;FMS;aircraft cockpit;flight planning operations;aeronautical navigation database;flight plan display;airplane control","","10","","","","20 Dec 2010","","","IEEE","IEEE Magazines"
"Operational: The Forgotten Architectural View","E. Woods",Endava,"IEEE Software","25 Apr 2016","2016","33","3","20","23","Most software architecture books focus on building new systems. However, successful systems spend much more time running in their production environment than being initially developed. That's why the DevOps movement's recent emergence is so heartening. It emphasizes development and operations staff working together as early as possible-sharing tools, processes, and practices to smooth the path to production. DevOps requires embracing new, often unfamiliar technologies and ideas. Architectural thinking and design can help clarify who the stakeholders are, what concerns they have, and how those concerns are being met.","1937-4194","","10.1109/MS.2016.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458767","software architecture;operational viewpoint;production;project management;DevOps;software development;software engineering","Project management;Software architecture;Stakeholders;Computer architecture;Software development;Pragmatics;Production processes","software architecture","software architecture;operational view;DevOps;architectural thinking;architectural design","","8","","6","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Multiparadigm Data Storage for Enterprise Applications","D. Ghosh",Anshin Software,"IEEE Software","19 Aug 2010","2010","27","5","57","60","Regardless of the paradigm used to model the application domain, most enterprise applications use the relational model for data storage. Relational database technology is mature, widely understood, and successfully deployed in countless applications. However, its dominance has also had some undesirable consequences for application development. For an application that models the business logic in an object-oriented way, the developer faces an impedance mismatch between the application's object model and the data's relational model. Object-relational mapping (ORM) frameworks exist to bridge this divide, but ORMs aren't trivial to use and often introduce more complexity than the problem they solve.","1937-4194","","10.1109/MS.2010.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5467015","data management;database;messaging;software engineering","Memory;Object oriented modeling;Application software;Relational databases;Impedance;Engines;Books;H infinity control;Poles and towers;Object oriented databases","business data processing;information storage;relational databases;storage management","multiparadigm data storage;enterprise applications;relational model;relational database technology;business logic;object relational mapping frameworks","","9","1","9","","20 May 2010","","","IEEE","IEEE Magazines"
"Code Documentation","D. Spinellis",Athens University of Economics and Business,"IEEE Software","14 Jun 2010","2010","27","4","18","19","The basic principles of good code documentation include the avoidance of repetition, the coexistence of code and its documentation, the documentation of all artifacts, and a preference for clear code and automated processes to explanatory documentation. Existing tools can help us by extracting documentation from specially formatted comments and by formatting code listed in documents. We can also automate the generation of bespoke documentation with a custom-made tool. When you document code, strive for completeness, consistency, effortless accessibility, and an automated low-overhead generation process.","1937-4194","","10.1109/MS.2010.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484109","comments;documentation;principles;tools;best practices;javadoc;POD;software engineering","Documentation;Job production systems","system documentation","code documentation;explanatory documentation;bespoke documentation","","4","","","","14 Jun 2010","","","IEEE","IEEE Magazines"
"Mobile Content as a Service A Blueprint for a Vendor-Neutral Cloud of Mobile Devices","M. Raatikainen; T. Mikkonen; V. Myllärniemi; N. Mäkitalo; T. Männistö; J. Savolainen",Aalto University; Tampere University of Technology; Aalto University; Tampere University of Technology; Aalto University; Danfoss Power Electronics,"IEEE Software","10 Aug 2012","2012","29","4","28","32","Mobile devices have become a commodity: we use several devices for various purposes. Although we carry only some of our devices with us, we still want to access content originating from any device. To overcome this issue, device users often upload content into a hosting service available in the cloud. However, cloud-based hosting can alienate the control and ownership of the content. A proposed architecture views development of a cloud computing service for mobile devices from a different angle. This approach maintains the content in the device where it was first created. The resulting design leads to a mobile device cloud that treats devices, together with the content and resources they host, as first-class cloud citizens. A proof-of-concept implementation is based on standard Web protocols. The underlying design can be configured for various contexts, such as individuals having several mobile devices, social communities interested in sharing content, or companies.","1937-4194","","10.1109/MS.2012.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6185528","mobile cloud;mobile data;mobile devices;content management;software engineering","Mobile handsets;Servers;Content management;Mobile communication;Cloud computing;Computer architecture","","","","3","1","8","","17 Apr 2012","","","IEEE","IEEE Magazines"
"Buzz: A Programming Language for Robot Swarms","C. Pinciroli; G. Beltrame",École Polytechnique de Montréal; École Polytechnique de Montréal,"IEEE Software","23 Jun 2016","2016","33","4","97","100","From drones to self-driving cars, robot swarms are becoming pervasive and are used in many kinds of applications. However, common ""swarm libraries"" for software development do not yet exist, and reusing code is difficult owing to the lack of swarm-centric development platforms. Buzz, a programming language for heterogeneous robot swarms, aims to address these problems.","1937-4194","","10.1109/MS.2016.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498536","Buzz;robot swarms;robotics;software engineering;software development;programming languages","Robot kinematics;Service robots;Particle swarm optimization;Robot sensing systems;Computer languages;Biological system modeling","control engineering computing;multi-robot systems;programming languages;robot programming;swarm intelligence","Buzz;programming language;robot swarm","","7","","7","","23 Jun 2016","","","IEEE","IEEE Magazines"
"An Information and Tracking System for Inland Shipping","T. van der Burgt; A. Baronner",Rijkswaterstaat; Rijkswaterstaat,"IEEE Software","15 May 2017","2017","34","3","105","110","The Information and Tracking System for Inland Shipping (in Dutch, abbreviated as IVS90) functions in one of the busiest areas of inland shipping in the Netherlands. Because the large locks, bridges, and vessel-traffic-service centers operate 24/7 and the occurrence of incidents is unpredictable, IVS90 requires high availability and 24/7 support.","1937-4194","","10.1109/MS.2017.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927904","inland shipping;Information and Tracking System for Inland Shipping;IVS90;Rijkswaterstaat;river information systems;software development;transportation;software engineering","Software development;Marine vehicles;Rivers;Tracking;Information services","goods distribution","information-and-tracking system;inland shipping;Dutch;IVS90;Netherlands","","","","11","","15 May 2017","","","IEEE","IEEE Magazines"
"Machine-to-Machine Communication","M. Weyrich; J. Schmidt; C. Ebert",University of Stuttgart; University of Stuttgart; Vector Consulting Services,"IEEE Software","13 Jun 2014","2014","31","4","19","23","Imagine a widespread manufacturing plant equipped with smart machinery and RFID-enabled technology. All machines are interconnected and communicate through their sensors and actuators as they work their way through the manufacturing process. Operators use wireless pads and connect to production systems for diagnostics and manufacturing oversight. Machine load, status, and diagnosis data are further aggregated in enterprise systems for resource planning and production optimization. The machines receive usage feedback to adjust production schemes and therefore optimize cost and quality. The machines also communicate with their own manufacturers to request repairs or order new parts to avoid costly outages. Agent-based systems allocate load to machines in a distributed, often global, production setup to optimize supply chain cost. This is a growing reality in what we call the smart factory. The smart factory of the future is far more agile than the approaches in today's flexible manufacturing. The smart factory connects the machines, devices, logistics, and humans to perform the necessary coordination ubiquitously and ad hoc.","1937-4194","","10.1109/MS.2014.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834707","wireless technology;machine-to-machine;smart factory;software engineering;embedded systems;green computing","Wireless communication;Communication system security;Wireless sensor networks;Machine-to-machine communication;Ad hoc networks;Production facilities","enterprise resource planning;factory automation;optimised production technology;production engineering computing;supply chain management","machine-to-machine communication;M2M communication;smart machinery;enterprise systems;resource planning;production optimization;supply chain cost optimization;smart factory","","16","","","","13 Jun 2014","","","IEEE","IEEE Magazines"
"IEEE Software's 25th-Anniversary Top Picks","",,"IEEE Software","22 Dec 2008","2009","26","1","9","11","Over the past 25 years, IEEE Software has published more than 1,200 peer-reviewed full-length articles. As part of its 25th-anniversary celebration, Software's editorial and advisory boards have examined this content from several perspectives to distill its top picks—a recommended reading list of 35 articles. The list includes title, author, issue, year, topic, and category.","1937-4194","","10.1109/MS.2009.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721173","software engineering reading list;overview;experience report;survey;essay;cutting-edge research","Software quality;Software reusability;Computer architecture;Reflection;Reliability engineering;Project management;Testing;Programming profession;Object oriented programming","","","","","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Flight Control Software: Mistakes Made and Lessons Learned","Y. Jeppu",Moog India Technology Centre,"IEEE Software","18 Apr 2013","2013","30","3","67","72","Aerospace or flight control systems software development follows a rigorous process according to the RTCA DO-178B standard, yet software errors still occur. A review of the mistakes found during flight control test activities spanning 23 years reveals that the same mistakes tend to recur repeatedly. Moreover, we haven't yet learned everything about the mistakes that can be made in flight controls; new mistakes continue to pop up.","1937-4194","","10.1109/MS.2013.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6471712","software and system safety;test design;certification;software engineering;safety-critical software","Aerospace control;Software reliability;Digital filters;Air traffic control;Safety;Mathematical model;Air safety","","","","5","","4","","7 Mar 2013","","","IEEE","IEEE Magazines"
"Constraint-Based Object-Oriented Programming","P. Hofstedt",Brandenburg University of Technology Cottbus,"IEEE Software","19 Aug 2010","2010","27","5","53","56","The application and importance of constraint programming (CP) has grown remarkably in the past two decades. Developers widely use constraints for many planning, scheduling, and optimization tasks.Both the OO and constraint-based paradigms have advantages for certain application fields and programming techniques. Imperative OO languages such as Java and C++ let us model precisely and efficiently the behavior of state-changing systems.","1937-4194","","10.1109/MS.2010.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473202","Multiparadigm programming;programming languages;object-oriented languages;constraints;software engineering","Object oriented programming;Arithmetic;Object oriented modeling;Java;Production planning;Constraint optimization;Airplanes;Marine vehicles;Assembly;Personnel","constraint handling;object-oriented languages;object-oriented programming","constraint programming;object oriented language;java;C++;object-oriented programming","","1","","5","","27 May 2010","","","IEEE","IEEE Magazines"
"Aligning Requirements and Testing: Working Together toward the Same Goal","E. Bjarnason; M. Borg",Lund University; SICS Swedish ICT,"IEEE Software","16 Jan 2017","2017","34","1","20","23","The proper alignment of requirements engineering and testing (RET) can be key to software's success. Three practices can provide effective RET alignment: using test cases as requirements, harvesting trace links, and reducing distances between requirements engineers and testers. The Web extra https://youtu.be/M65ZKxfxqME is an audio podcast of author Elizabeth Bjarnason reading the the Requirements column she cowrote with Markus Borg.","1937-4194","","10.1109/MS.2017.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819382","software requirements;software testing;requirements engineering;software engineering;software development;requirements engineering and testing;RET;test cases;trace links","Requirements engineering;Software testing;Collaboration;Software development;Testing","formal specification;program testing;software prototyping","requirements engineering and testing;RET alignment;trace links;agile software development","","4","","5","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Infusing Architectural Thinking into Organizations","A. J. Lattanze",Carnegie Mellon University,"IEEE Software","22 Dec 2011","2012","29","1","19","22","As an architectural consultant, the author spends a great deal of time helping organizations fully utilize software architecture to create better products and be more competitive. Here, he explains some of the mistakes he's made and the key lessons learned over the past 10 years working with architects primarily in the consumer electronics and embedded software industries.","1937-4194","","10.1109/MS.2012.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111362","software architecture;software design;software engineering","Software architecture;Software design;Product development","organisational aspects;software architecture","architectural thinking;architectural consultant;software architecture;consumer electronics industry;embedded software industry;organization","","3","","2","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Multi-DSL Applications with Ruby","S. Günther",University of Magdeburg,"IEEE Software","19 Aug 2010","2010","27","5","25","30","Exploiting Ruby's support for the imperative, functional, and object-oriented paradigms, several DSLs' integrated and interwoven multiparadigm expressions can express all concerns, application layers, and artifacts of an application.","1937-4194","","10.1109/MS.2010.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473204","programming languages;multiparadigm languages;specialized application languages;Internet applications;software engineering","DSL;Application software;Computer languages;HTML;Cascading style sheets;Twitter;Functional programming;Object oriented programming;Java;Computer science","object-oriented languages","domain-specific languages;multiDSL applications;Ruby;object-oriented paradigms;application layers","","4","","6","","27 May 2010","","","IEEE","IEEE Magazines"
"The Best Software Development Teams Might be Temporary","R. Prikladnicki; M. G. Perin; S. Marczak; A. C. S. Dutra",Pontifícia Universidade Católica do Rio Grande do Sul; Pontifícia Universidade Católica do Rio Grande do Sul; Pontifícia Universidade Católica do Rio Grande do Sul; Pontifícia Universidade Católica do Rio Grande do Sul,"IEEE Software","28 Mar 2017","2017","34","2","22","25","A study of a large company's software development projects indicates that quality often suffers if team members have worked together previously. Thus, in many cases, temporary teams might be best.","1937-4194","","10.1109/MS.2017.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888427","software development;software development teams;major releases;minor releases;software engineering","Software development;Computer science;Maintenance engineering;Performance evaluation;Computer crashes;Software quality","project management;software development management;team working","software development teams;software development projects;team members;temporary teams","","","","3","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Web 2.0 for Practitioners","N. Serrano; J. M. Torres",University of Navarra Engineering School; University of Navarra Engineering School,"IEEE Software","19 Apr 2010","2010","27","3","11","15","Web 2.0 has been a buzzword ever since software engineers started connecting different applications and data on the Internet. What are the most promising technologies for applying Web 2.0 in your IT? What tools go beyond gimmicks to help professional developers? Authors Nicolas Serrano and Jose Manuel Torres introduce the major open technologies and show how to integrate them in a professional application. Needless to say, we can't dive into all the interesting details, such as security or performance engineering. We'll have to leave those for later columns.","1937-4194","","10.1109/MS.2010.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452143","World Wide Web;software engineering","Data engineering;Joining processes;Application software;Internet;Security","Internet;public domain software;software tools","Web 2.0;software engineers;Internet;open technologies","","9","","5","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Dominant Design","G. Booch",IBM,"IEEE Software","28 Feb 2011","2011","28","2","8","9","The article is discussing architecture of software-intensive systems and its application in road traffic management.","1937-4194","","10.1109/MS.2011.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5720705","architecture;software-intensive system;dominant design;punctuated equilibrium;software engineering;history of computing;standards;best practices","Design methodology;Computer architecture;Technological innovation;Economics;Innovation management;Technological innovation","road traffic;software architecture;traffic engineering computing","software intensive system;system architecture;road traffic management;dominant design","","","","","","28 Feb 2011","","","IEEE","IEEE Magazines"
"Software on a Comet: The Philae Lander's Central Onboard Computer","A. Baksa; A. Balázs; Z. Pálos; P. Spányi; S. Szalai; L. Várhalmi",Wigner Research Centre for Physics; Wigner Research Centre for Physics; Wigner Research Centre for Physics; Wigner Research Centre for Physics; SGF Ltd.; Wigner Research Centre for Physics,"IEEE Software","26 Feb 2016","2016","33","2","81","84","For the Philae lander to land on a comet after 10 years of space travel, its software had to meet rigorous requirements.","1937-4194","","10.1109/MS.2016.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420510","Philae lander;Rosetta;space exploration;fault-tolerant software;software engineering;software development","Space research;Comets;Mars;Computers;Fault tolerance;Fault tolerant systems;Space vehicles","aerospace computing;comets;formal specification","central onboard computer;comet;space travel;software requirement","","2","","3","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Architecture as a Shared Hallucination","G. Booch",IBM,"IEEE Software","31 Dec 2009","2010","27","1","96","96","This paper present the architecture of a software intensive system. An architecture is just a collective hunch, a shared hallucination, an assertion by a set of stakeholders about the nature of their observable world, be it a world that is or a world as they wish it to be. An architecture therefore serves as a means of anchoring an extended set of stakeholders to a common vision of that world, a vision around which they may rally, to which they are led, and for which they work collectively to make manifest. When I say that an architecture is a shared hallucination, I mean that an architecture-as-artifact is a naming of the mutually agreed-upon set of design decisions that shape a software-intensive system. While an architecture is just an abstraction of reality, an architecture-as-artifact is a declaration of that shared reality. In this way, that shared hallucination represents a common vision among a set of stakeholders as observed simultaneously through several different points of view and represented by a set of interlocking models.","1937-4194","","10.1109/MS.2010.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370767","software engineering;architecture;software architecture;modeling;stakeholders","Computer architecture;Software systems;Shape","software architecture;software management","software intensive system architecture;shared hallucination;interlocking models","","1","","","","31 Dec 2009","","","IEEE","IEEE Magazines"
"Software Retrofit in High-Availability Systems: When Uptime Matters","T. Ronzon",w3logistics AG,"IEEE Software","26 Feb 2016","2016","33","2","11","17","A software retrofit can address problems of business-critical systems that are no longer maintainable. This seven-step approach revises software while daily operations are going on. The goal is to reestablish a system that you can extend and maintain with state-of-the-art development and operations technologies.","1937-4194","","10.1109/MS.2016.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420474","software refit;logistics;software development;software engineering","Software;Servers;Companies;Hardware;Documentation;Databases","business data processing;software maintenance","software retrofitting;high-availability systems;business-critical systems;software development technology;software operation technology;software maintenance","","1","","10","","26 Feb 2016","","","IEEE","IEEE Magazines"
"A Framework for Managing Privacy-Enhancing Technology","D. Pelkola",KPMG Canada,"IEEE Software","20 Apr 2012","2012","29","3","45","49","The changing global business environment and continued introduction of new technologies are significantly affecting organizations' privacy practices. In this environment, privacy-enhancing technology (PET) often becomes a key to protecting personal information. A considerable amount of literature has discussed PET technologies and their benefits. However, the lack of clear organizational accountability can become a roadblock to effectively designing and implementing PET solutions. For organizations that don't employ these solutions, the result is increased regulatory and privacy risk and potential costs related to privacy breaches. Establishing a multidisciplinary privacy committee with clear roles and responsibilities assigned to various members is a possible approach to help address accountability.","1937-4194","","10.1109/MS.2012.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6175000","privacy-enhancing technology;privacy committee;software engineering","Privacy;Positron emission tomography;Organizations;Data privacy;Security;Process control","business data processing;data privacy","privacy-enhancing technology;global business environment;PET;personal information;clear organizational accountability;privacy risk and;privacy breaches;multidisciplinary privacy committee","","3","","5","","3 Apr 2012","","","IEEE","IEEE Magazines"
"Service Orchestration with Rundeck","D. Spinellis",Athens University of Economics and Business,"IEEE Software","13 Jun 2014","2014","31","4","16","18","Managing and controlling a service's provision is tricky, but tools for service orchestration, like Rundeck, can make our lives easier. Rundeck bridges the gap between software building and system configuration by allowing us to define tasks to deploy the software or configure its operation. After installing Rundeck, administrators typically define the characteristics of the computing nodes (hosts) where jobs will run, as well as the jobs themselves. Defining a job involves specifying its options and its workflow. Administrators define workflows in terms of node steps, which run on each node, or steps that execute once for the entire workflow. When a job is run, administrators have to enter its options and can control the nodes where it will execute. All job activity reports are stored in a queryable database. Sophisticated access control allows administrators to define groups and access control policies by project, group, or job. Rundeck's shiny graphical interface can make it appeal to a wide user base. The Web extra at http://youtu.be/oNJ8ejmfGyg is an audio podcast of the Tools of the Trade column in which author Diomidis Spinellis discusses how managing and controlling a service's provision is tricky, but tools for service orchestration, like Rundeck, can make our lives easier.","1937-4194","","10.1109/MS.2014.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834683","workflow automation;service orchestration;configuration management;Rundeck;software engineering","Contracts;Proposals;Service computing;Business;Process control","","","","1","","","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Exactly How Are Requirements Written?","N. Maiden",City University London,"IEEE Software","22 Dec 2011","2012","29","1","26","27","Few studies of actual requirements practices exist compared to the number of studies on how people program. Thus, we know relatively little about how people actually do requirements work. By considering a simple user story, we can begin to inform our understanding of the cognitive processes that good requirements work requires.","1937-4194","","10.1109/MS.2012.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111364","requirements;software engineering;cognitive process;analysis;analyst","Software design;Programming;Computer languages;Best practices;Cognitive science","formal specification;formal verification","user story;cognitive process;requirements practices;requirements work","","5","","4","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Future Automotive Architecture and the Impact of IT Trends","M. Traub; A. Maier; K. L. Barbehön",BMW; BMW; BMW,"IEEE Software","15 May 2017","2017","34","3","27","32","The transfer of IT and consumer-electronics technologies to the automotive domain will provide major opportunities. However, both these technologies and the automotive industry will require much adaptation. Architectures for automotive electronics are quickly changing. Energy efficiency is evolving the classic powertrain toward high-voltage hybrid and electric engines. Autonomous driving demands multisensor fusion away from functionally isolated control units. Connectivity and infotainment have transformed the car into a distributed IT system with cloud access; over-the-air functional upgrades; and high-bandwidth access to map services, media content, other vehicles, and the surrounding infrastructure.","1937-4194","","10.1109/MS.2017.69","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927914","E/E architecture;electrical and electronic architecture;automotive software;ECUs;electronic control units;SOA;service-oriented architecture;consumer electronics;IT;software engineering;software development","Computer architecture;Automotive engineering;Service-oriented architecture;Sensors;Servers","automotive electric vehicles;automotive electronics;automotive engineering;cloud computing;energy conservation;hybrid electric vehicles;power transmission (mechanical);sensor fusion","automotive architecture;automotive electronics;automotive domain;automotive industry;energy efficiency;high-voltage hybrid engines;electric engines;powertrain;multisensor fusion;functionally isolated control units;distributed IT system;cloud access;over-the-air functional upgrades;media content;IT transfer","","25","","2","","15 May 2017","","","IEEE","IEEE Magazines"
"Using a Line of Code Metric to Understand Software Rework","E. Morozoff","Medtronic, Inc. , Mounds View","IEEE Software","31 Dec 2009","2010","27","1","72","77","A simple method measuring new effective lines of code showed that between 19 and 40 percent of code written on three projects wasn't in the final release. Generally, productivity is a function of input effort and output size. A strong understanding of software productivity, coupled with a good estimate of software size, is key to predicting project effort and, ultimately, producing reliable project duration estimates, schedules, and resource needs. Project managers and engineers often measure or predict the size of released software-the volume of software in the marketed product. However, the final release doesn't include reworked code-code that was changed or deleted during development.","1937-4194","","10.1109/MS.2009.160","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5232799","lines of code;software productivity;software rework;software;software engineering","Productivity;Project management;Engineering management;Reliability engineering;Volume measurement;Size measurement;Software measurement","scheduling;software cost estimation;software metrics;systems re-engineering","line of code metric;software rework;software productivity;project duration estimation;project managers;scheduling;software project cost estimations","","3","","18","","4 Sep 2009","","","IEEE","IEEE Magazines"
"Value Stream Architecture","M. Kersten",Tasktop,"IEEE Software","22 Sep 2017","2017","34","5","10","12","This new department aims to elevate the discussion of software architecture beyond code to include all artifacts involved in the software delivery value stream. Here, “value stream” refers to the end-to-end feedback loop of flowing software to customers in a way that maximizes the business value delivered.","1937-4194","","10.1109/MS.2017.3571573","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048647","DevOps;software architecture;value stream;value stream architecture;software delivery;software engineering;software development","Software architecture;Computer architecture;Feedback loop","software architecture","value stream architecture;software architecture;software delivery value stream;end-to-end feedback loop;business value maximization","","","","3","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Using Documentation for Product Line Scoping","I. John","Fraunhofer IESE, Kaiserslautern","IEEE Software","19 Apr 2010","2010","27","3","42","47","The introduction of product line engineering must be well planned. This planning phase, where the product line's characteristics are determined, is called scoping. Product line scoping is the process of identifying and delimiting capabilities (products and features) and areas (subdomains and existing assets) of the product line where investment into reuse would be economical and beneficial to product development. It aims to dispel doubts and uncertainty in decisions about which products will become part of the product line and whether to invest into reuse. Scoping is based heavily on expert knowledge and information from meetings and workshops.","1937-4194","","10.1109/MS.2010.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5416671","product line engineering;product line scoping;user documentation;product line analysis;elicitation;elicitation methods;requirements/specifications;software engineering;domain engineering;reusable software","Documentation;Investments;Product development;Uncertainty","product development;production engineering;production planning;software reusability","product line scoping;product line engineering;product development;expert knowledge","","8","","13","","18 Feb 2010","","","IEEE","IEEE Magazines"
"Context-Aware Software Variability through Adaptable Interpreters","W. Cazzola; A. Shaqiri",Università degli Studi di Milano; Università degli Studi di Milano,"IEEE Software","13 Nov 2017","2017","34","6","83","88","A proposed approach moves variability support from the programming language to the language implementation level. This enables contextual variability in any application independently of whether the underlying language supports context-oriented programming. A Neverlang-based prototype implementation illustrates this approach.","1937-4194","","10.1109/MS.2017.4121222","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106869","context-oriented programming;dynamic language evolution;contextual variability;software development;software engineering;Neverlang;contextual-variability modeling","Context awareness;Semantics;Context modeling;Computer languages;Programming;Software development","object-oriented programming;programming languages;ubiquitous computing","contextual variability;underlying language;context-oriented programming;prototype implementation;context-aware software variability;variability support;programming language;language implementation level","","1","","16","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Code Evasion","G. J. Holzmann",NASA/JPL,"IEEE Software","21 Aug 2015","2015","32","5","77","80","Programs sometimes tend to lose their structure and clarity through the addition of error handling. Often, more than half of a code base ends up dedicated to various types of error detection and recovery, obscuring the nominal control flow that defines the basic structure. The challenge in writing reliable code is to find ways to remove code from an application by simplifying and generalizing, rather than continuing to add more.","1937-4194","","10.1109/MS.2015.112","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217766","software reliability;software engineering;software development;Unix;fault protection;error handling","Complexity theory;Computers;Software;Writing;Software reliability;Fault protection","error handling;source code (software);system recovery","code evasion;error handling;error detection;error recovery;nominal control flow","","1","","6","","21 Aug 2015","","","IEEE","IEEE Magazines"
"The Weakest Link","G. J. Holzmann",Jet Propulsion Laboratory,"IEEE Software","23 Jun 2016","2016","33","4","18","21","In interactive systems, what's the weakest link: the computer or the human? Explores issue involved with decision making via computer systems versus humans. Should we be more concerned with a computer overruling a human in key decisions, or vice versa?","1937-4194","","10.1109/MS.2016.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498548","critical systems;human-computer interaction;software engineering;software development;intelligent systems","Human factors;Decision making;Interactive systems;Software reliability;Safety","decision making;interactive systems","interactive systems;decision making;computer systems;humans","","","","3","","23 Jun 2016","","","IEEE","IEEE Magazines"
"A Critical Look at Software Capability Evaluations: An Update","T. Bollinger; C. McGowan",US Department of Defense; Noblis,"IEEE Software","25 Aug 2009","2009","26","5","80","83","Software capability evaluations (SCEs) were the prototype for what's now the standard CMMI appraisal method for process improvement. SCEs used 85 yes/no questions to determine organizations' maturity levels. This was an astonishingly sparse data set from which to assign a label that could bar an organization from bidding on federal contracts. CMMI is our current best answer for what are the set of necessary, but not sufficient, constraints we need to impose for the truly important software systems. We know we can usefully employ certain carefully selected manufacturing-based concepts, as well as well-established software measures. CMMI thus isn't in opposition to effective use of creativity in a project. Instead, it's a collection of reasonable practices that enable and encourage closer attention to the less quantifiable aspects of project success that require much more than just process adherence.","1937-4194","","10.1109/MS.2009.119","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222800","software engineering;SCE;CMM;CMMI;CMMI-DEV;Software Capability Evaluations;Software CMMI;Capability Maturity Model;Capability Maturity Model Integration;process adherence;software metrics","Coordinate measuring machines;Humans;Monitoring;Technological innovation;Testing;Scheduling;Quality control;Product safety;Qualifications","Capability Maturity Model;contracts;software metrics","software capability evaluation;standard CMMI appraisal method;software process improvement;federal contract;software measure","","1","","6","","25 Aug 2009","","","IEEE","IEEE Magazines"
"It's About Time to Take JavaScript (More) Seriously","H. M. Kienle",Malardalen University,"IEEE Software","19 Apr 2010","2010","27","3","60","62","JavaScript is a scripting language, of course. The drawbacks and benefits of scripting languages compared to full-fledged programming languages have been explored before. In a previous installment of this column, Diomidis Spinellis points out that with scripting languages, users can benefit from flexible syntax, loose type systems, powerful reflection mechanisms, and shorter build cycles. Scripting languages have proven their usefulness in various application areas. Unix relies heavily on shell scripting to accomplish many complex tasks. Visual Basic, in combination with ActiveX, provides a low-entry barrier into the world of component-based programming. Tcl/Tk is still popular to rapidly develop GUI-based applications. And then there's JavaScript, which has gained considerable importance in realizing clientside functionality on Web apps. In a survey on the most popular programming languages, JavaScript made it to the Top 10.","1937-4194","","10.1109/MS.2010.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452147","javascript;web 2.0;web browser;software engineering","Java;Computer languages;Reflection;Visual BASIC","authoring languages;object-oriented programming;Unix","JavaScript;scripting languages;programming languages;Unix;Visual Basic;component-based programming;Web apps","","8","","7","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Distributed Teams, Developer Participation, and More","J. C. Carver; H. Muccini; A. Yamashita",University of Alabama; University of L'Aquila; Yamashita Research,"IEEE Software","15 May 2017","2017","34","3","114","116","This instalment reports on two talks from the First International Workshop on Collaborative Modeling in MDE (model-driven engineering) and three papers from the 23rd International Conference on Software Analysis, Evolution, and Reengineering. The topics covered include model-driven engineering, forking and developer participation, FLOSS (free/libre and open source software) software projects, and perceptions of release practices.","1937-4194","","10.1109/MS.2017.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927920","MDE;model-driven engineering;FLOSS;forking;release practices;GenMyModel;COMMitMDE;SANER;software engineering;software development","","","","","1","","","","15 May 2017","","","IEEE","IEEE Magazines"
"Should Architects Code?","E. Woods",Endava,"IEEE Software","22 Sep 2017","2017","34","5","20","21","Should the people performing a system’s architecture work also develop some of the system’s production code? Involving architects in carefully selected implementation tasks, such as testing, refactoring, or architectural spikes, can yield positive returns on investment for both the architects and their teams.","1937-4194","","10.1109/MS.2017.3571574","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048649","software;software architecture;coding;software development;software engineering","Encoding;Computer architecture;Pragmatics;Software testing;Software architecture","","","","","","2","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Searching the Internet","M. Andrews",Microsoft,"IEEE Software","20 Feb 2012","2012","29","2","13","16","This column differs somewhat from previous ones in that the software itself isn't shipped-rather, the results of the software are shipped, and in huge numbers. Mike Andrews of Microsoft reveals some of the intricacies and enormous resources required for successful Web search with a fascinating glimpse into the Bing search engine.","1937-4194","","10.1109/MS.2012.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155137","bing;microsoft;search engine;web;internet scale;technology;servers;software engineering;hardware","Search engines;Information retrieval;Search problems;Web and internet services","Internet;search engines","Internet;software;Microsoft;Web search;Bing search engine","","10","","1","","20 Feb 2012","","","IEEE","IEEE Magazines"
"Future of Mining Software Archives: A Roundtable","M. W. Godfrey; A. E. Hassan; J. Herbsleb; G. C. Murphy; M. Robillard; P. Devanbu; A. Mockus; D. E. Perry; D. Notkin","University of Waterloo; Queen's University Canada; Carnegie Mellon University; University of British Columbia; McGill University; University of California, Davis; Avaya Labs; University of Texas at Austin; University of Washington","IEEE Software","22 Dec 2008","2009","26","1","67","70","When mining software archives, we want to learn from the past to shape the future. But what does the research so far tell us about the future of the field itself? For this special issue, we invited and collected statements from nine research leaders in the field. These statements show opportunities for data collection and exploitation (Michael Godfrey, Ahmad Hassan, and James Herbsleb), enhancing programmer productivity (Gail Murphy and Martin Robillard), examining the role of social networking (Prem Devanbu), leveraging data for industry (Audris Mockus), and answering open research questions (Dewayne Perry). David Notkin, though, warns against too much enthusiasm: ""Let us not mine for fool's gold."" Enjoy! -Nachiappan Nagappan, Andreas Zeller, and Thomas Zimmermann, Guest Editors ","1937-4194","","10.1109/MS.2009.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721185","software engineering;software development;test case classification;goal-driven testing;phase-driven testing;software testing","Context awareness;Software performance;Costs;Programming profession;Social network services;Psychology;Software development management;Project management;Job shop scheduling;Instruments","","","","6","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"IT Infrastructure-Monitoring Tools","J. Hernantes; G. Gallardo; N. Serrano",University of Navarra; University of Navarra; University of Navarra,"IEEE Software","30 Jun 2015","2015","32","4","88","93","Monitoring is critical to IT system health and thus to businesses' bottom line. This article discusses current tools that monitor networks to detect issues, ensure the components' availability, and measure the resources those components use.","1937-4194","","10.1109/MS.2015.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140697","IT infrastructure;IT infrastructure-monitoring tools;Nagios;Zabbix;Hyperic;SolarWinds;ManageEngine OpManager;HP Operations Manager;IBM Tivoli;WhatsUp Gold;software engineering;software development","Monitoring;Electronic mail;Information technology;Cloud computing;Maintenance engineering","reliability;system monitoring","IT infrastructure;monitoring tools;IT system health monitoring;component availability","","20","","3","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Crowd-Based Ambient Assisted Living to Monitor the Elderly’s Health Outdoors","A. C. Bicharra Garcia; A. S. Vivacqua; N. Sánchez-Pi; L. Martí; J. M. Molina",Federal University of the State of Rio de Janeiro; Federal University of Rio de Janeiro; Rio de Janeiro State University; Fluminense Federal University; Carlos III University of Madrid,"IEEE Software","13 Nov 2017","2017","34","6","53","57","The SafeNeighborhood approach combines data from multiple sources with collective intelligence. It merges mobile, ambient, and AI technologies with old-fashioned neighborhood ties to create safe outdoor spaces for the elderly. We're exploring AAL techniques in outdoor environments to increase the elderly's independence without them having to interact with technology. Current research in outdoor monitoring relies solely on sensor data.4 Our approach, which we call SafeNeigborhood (SN), crowdsources people in the neighborhood to revise the computer's inferences from contextual and sensor data. So, SN brings the community together to provide a safer environment for the elderly.","1937-4194","","10.1109/MS.2017.4121217","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106875","human-centered computing;handicapped persons;special needs;healthcare;care for the elderly;ambient assisted living;SafeNeighborhood;software engineering;software development;context-aware and smart healthcare","Senior citizens;Monitoring;Temperature sensors;Global Positioning System;Mobile communication;Assisted living;Biomedical monitoring;Smart devices","ambient intelligence;artificial intelligence;assisted living;geriatrics;health care","computer inferences;outdoor monitoring;outdoor environments;AAL techniques;AI technologies;SafeNeighborhood approach;elderly health outdoor monitoring;crowd-based ambient assisted living","","4","","10","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Excellence in Search: An Interview with David Chaiken","J. Favaro","Intecs SpA, Italy","IEEE Software","22 Dec 2011","2012","29","1","84","86","In June 2011, IEEE Software associate editor John Favaro interviewed search engine giant Yahoo's chief architect David Chaiken about algorithms and today's practitioner. Chaiken gave a keynote speech at SATURN 2011 on ""Architecture at Internet Scale"" that stressed a set of timeless principles that software engineers seemingly have to relearn continuously. Here, he describes the role algorithms play in the programmer's toolkit.","1937-4194","","10.1109/MS.2012.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111368","algorithms;software design;programming basics;software engineering","Interviews;Software architecture;Software algorithms","","","","","","","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Architectural Hoisting","G. Fairbanks",Google,"IEEE Software","13 Jun 2014","2014","31","4","12","15","Architectural hoisting is a design technique where the responsibility for enforcing an intentional design constraint is implemented in the code rather than by relying solely on the diligence of the developers. This can help teams to achieve a global system property by avoiding inconsistences and lapses in implementing design rules.","1937-4194","","10.1109/MS.2014.82","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834691","software engineering;software architecture;programming in the large;programming in the small;architectural hoisting;software;IEEE","Design engineering;Pragmatics;Computer architecture","","","","3","","1","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: What Kinds of Nails Need a Domain-Specific Hammer?","J. Sprinkle; M. Mernik; J. Tolvanen; D. Spinellis",University of Arizona; University of Maribor; MetaCase; Athens University of Economics and Business,"IEEE Software","19 Jun 2009","2009","26","4","15","18","Domain-specific techniques, languages, tools, and models, such as Fortran and Cobol can easily be viewed as domain-specific languages for scientific and business computing, respectively. Their domain is just very wide. What has changed is the technology for creating domain-specific languages (DSLs). Now it is easier to define languages and get tool support for narrower domains. Such focus offers increased abstraction, making development faster and easier. In domain-specific approaches, developers construct solutions from concepts representing things in the problem domain, not concepts of a given general-purpose programming language. Ideally, a DSL follows the domain abstractions and semantics as closely as possible, letting developers perceive themselves as working directly with domain concepts. The created specifications might then represent simultaneously the design, implementation, and documentation of the system, which can be generated directly from them. The mapping from the high-level domain concepts to implementation is possible because of the domain specificity: the language and code generators fit the requirements of a narrowly defined domain.","1937-4194","","10.1109/MS.2009.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076453","domain-specific modeling;domain-specific languages;software engineering","Nails;Domain specific languages;Computer languages;DSL;Documentation;Hardware design languages;Insurance;Home automation;Investments;Assembly","software tools;specification languages","domain abstraction;domain semantics;domain specific language and modelling","","56","","12","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Refactoring Myths","M. Hafiz; J. Overbey",Auburn University; Auburn University,"IEEE Software","28 Oct 2015","2015","32","6","39","43","Refactoring myths are popular misconceptions about tool-based refactoring-about the tools' intent, the principle they follow, their robustness, and support for them. This article is part of a special issue on Refactoring.","1937-4194","","10.1109/MS.2015.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310987","refactoring; refactoring tools; automatic programming; coding tools and techniques; distribution;maintenance;and enhancement; software engineering; software development","Software development;Code refractoring;Computer bugs;Robustness;Programming;Java","software maintenance","refactoring myth;tool-based refactoring;tools intent","","2","","14","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Web Application Tests with Selenium","A. Bruns; A. Kornstadt; D. Wichmann",C1 Workplace Solutions; C1 Workplace Solutions; C1 Workplace Solutions,"IEEE Software","25 Aug 2009","2009","26","5","88","91","Web applications tend to continuously evolve and thus need thorough, yet lean and automatic, regression testing. In this installment of Software Technology, Andreas Kornstadt and his colleagues describe automatic regression testing for Web applications that uses the Selenium testing framework. Selenium is portable open source software available for Windows, Linux, and Macintosh. Tests are written as HTML tables or in a number of programming languages and can run directly in most Web browsers. Andreas and his colleagues also provide many useful testing hints for practitioners. We look forward to hearing from both readers and prospective column authors about this column and the technologies we want to know more about.","1937-4194","","10.1109/MS.2009.144","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222802","rich internet applications;Ajax;acceptance tests;regression;software engineering","Application software;Java;Radio control;Software testing;HTML;Protocols;Software tools;Internet;Vocabulary;Fixtures","hypermedia markup languages;Internet;online front-ends;program testing;public domain software","Web application test;lean testing;automatic testing;regression testing;Selenium testing framework;portable open source software;HTML tables;programming languages;Web browsers;HyperText Markup Language","","29","","12","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Delivering Genuine Emails in an Ocean of Spam","L. Hatton; A. John",SendForensics; SendForensics,"IEEE Software","11 Jul 2017","2017","34","4","11","15","SendForensics has created a system that lets email senders analyze and optimize all outgoing email before sending it. This system aims to widen the gap between legitimate and illegitimate email in terms of the respective forensic footprints, ultimately making it far easier for existing and future filtering technologies to tell the difference.","1937-4194","","10.1109/MS.2017.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974706","email;spam;email filtering;spam filters;phishing;software security;deliverability;purity;forensic algorithms;SendForensics;software development;software engineering","Electronic mail;Postal services;Forensics;Computer security;Unsolicited electronic mail;Cloud computing;Digital forensics","unsolicited e-mail","genuine emails;software as a service","","1","","6","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Architecture Reviews","G. Booch",IBM,"IEEE Software","19 Apr 2010","2010","27","3","96","96","An architectural review serves several purposes: to gain confidence in the design, to reason about alternatives, to attend to architectural rot. The process of such a review involves the interplay of design decisions, scenarios, and forces on the system.","1937-4194","","10.1109/MS.2010.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452153","Software engineering;software;architecture review;architectural governance","Computer architecture;Unified modeling language;Software design;Software architecture;Performance analysis;Software development management;System analysis and design","","","","4","","","","19 Apr 2010","","","IEEE","IEEE Magazines"
"An Empirical Analysis of Business Process Execution Language Usage","M. Hertis; M. B. Juric","Laboratory for Integration of Information Systems, Faculty of Computer and Information Science, University of Ljubljana, Trzaska cesta 25, Ljubljana, Slovenia, and Seltron d.o.o., Trzaska cesta 85 a, Maribor; Faculty, of Computer and Information Science, Ljubljana, Slovenia","IEEE Transactions on Software Engineering","8 Aug 2014","2014","40","8","738","757","The current state of executable business process languages allows for and demands optimization of design practices and specifications. In this paper, we present the first empirical study that analyses Web Services Business Process Execution Language (WS-BPEL or BPEL) usage and characteristics of real world executable business processes. We have analysed 1,145 BPEL processes by measuring activity usage and process complexity. In addition, we investigated the occurrence of activity usage patterns. The results revealed that the usage frequency of BPEL activities varies and that some activities have a strong co-occurrence. BPEL activities often appear in activity patterns that are repeated in multiple processes. Furthermore, the current process complexity metrics have proved to be inadequate for measuring BPEL process complexity. The empirical results provide fundamental knowledge on how BPEL specification and process design practices can be improved. We propose BPEL design guidelines and BPEL language improvements for the design of more understandable and less complex processes. The results are of interest to business process language designers, business process tool developers, business process designers and developers, and software engineering researchers, and contribute to the general understanding of BPEL and service-oriented architecture.","1939-3520","","10.1109/TSE.2014.2322618","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6812231","WS-BPEL Analysis;complexity measure;service composition;process patterns;process complexity;process comprehension;empirical study","Complexity theory;Business;Measurement;Semantics;XML;Syntactics;Guidelines","service-oriented architecture;Web Services Business Process Execution Language","empirical analysis;design practices;design specifications;Web services business process execution language;WS-BPEL;executable business processes;activity usage;process complexity;BPEL activities;BPEL design guidelines;BPEL language improvements;service-oriented architecture","","14","","68","","8 May 2014","","","IEEE","IEEE Journals"
"Automated Synthesis of Mediators to Support Component Interoperability","A. Bennaceur; V. Issarny","Department of Computing, The Open University, United Kingdom; MiMove team, Inria, France","IEEE Transactions on Software Engineering","11 Mar 2015","2015","41","3","221","240","Interoperability is a major concern for the software engineering field, given the increasing need to compose components dynamically and seamlessly. This dynamic composition is often hampered by differences in the interfaces and behaviours of independently-developed components. To address these differences without changing the components, mediators that systematically enforce interoperability between functionally-compatible components by mapping their interfaces and coordinating their behaviours are required. Existing approaches to mediator synthesis assume that an interface mapping is provided which specifies the correspondence between the operations and data of the components at hand. In this paper, we present an approach based on ontology reasoning and constraint programming in order to infer mappings between components' interfaces automatically. These mappings guarantee semantic compatibility between the operations and data of the interfaces. Then, we analyse the behaviours of components in order to synthesise, if possible, a mediator that coordinates the computed mappings so as to make the components interact properly. Our approach is formally-grounded to ensure the correctness of the synthesised mediator. We demonstrate the validity of our approach by implementing the MICS (Mediator synthesis to Connect Components) tool and experimenting it with various real-world case studies.","1939-3520","","10.1109/TSE.2014.2364844","ERC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6936339","Interoperability;Constraint Programming;Automated Synthesis;Mediators;Protocols;Interoperability;constraint programming;automated synthesis;mediators;protocols","Ontologies;Semantics;Google;Interoperability;Cognition;Programming;Protocols","object-oriented programming;ontologies (artificial intelligence);open systems","automated mediator synthesis;component interoperability;dynamic composition;functionally compatible component;interface mapping;ontology reasoning;constraint programming;component interface;semantic compatibility;MICS;mediator synthesis to connect components","","28","","57","","24 Oct 2014","","","IEEE","IEEE Journals"
"Point Counterpoint","I. Gat; C. Ebert",Cutter Consortium; Vector Consulting Services,"IEEE Software","22 Oct 2012","2012","29","6","52","55","In his Point argument, ""Technical Debt as a Meaningful Metaphor for Code Quality,"" Israel Gat describes how technical debt changes the software engineering playing field from qualitative assessment of code quality to quantitative measurement. In his Counterpoint argument, ""A Useful Metaphor for Risk - Poorly Practiced,"" Christof Ebert argues that technical debt is a useful metaphor for risk and its economic impacts, but that it's often exaggerated and involves number crunching that distracts the target audience.","1937-4194","","10.1109/MS.2012.163","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6336726","technical debt;risk;qualitative assessment;measurement;benchmarks;product development","Risk management;Benchmarking;Product development;Software quality;Economics","software metrics;software quality","technical debt;meaningful metaphor;code quality;software engineering;quantitative measurement;economic impacts","","3","","1","","22 Oct 2012","","","IEEE","IEEE Magazines"
"Innovation Reconsidered","F. Buschmann",Siemens Corporate Technology,"IEEE Software","3 Jan 2013","2013","30","1","18","20","""Innovation"" and ""innovative architecture"" are topics of broad popularity in software engineering. Yet, the two terms appear to mean different things to different people-with interpretations of both driven more by personal interests than by their true meanings. It's therefore essential for architects to have a clear understanding of what ""innovation"" means in the context of their projects if they are to make the right design decisions and communicate the intended messages to project stakeholders.","1937-4194","","10.1109/MS.2013.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401110","innovation;software architecture;deliberate design practice","Software architecture;Technological innovation;Software design","innovation management;software architecture","innovation reconsideration;innovative architecture;software engineering;personal interests;right design decisions;intended message communication;project stakeholders","","1","","9","","3 Jan 2013","","","IEEE","IEEE Magazines"
"Point/Counterpoint","K. Wallnau; P. Kruchten",Carnegie Mellon University; University of British Columbia,"IEEE Software","25 Apr 2011","2011","28","3","56","59","We have the technology to produce software that has predictable behavior, but doing so requires a better understanding of the economics of confidence and better integration of architecting and programming. I have a long-standing interest in understanding how software components (for present purposes, implementations with interfaces) influence software design. From 2002 to 2008, several colleagues and I at the Software Engineering Institute explored how to combine software architecture and software components such that a system design specifies what architects must know and trust about the components, how this determines the kinds of architectural analyses they can perform, and what measure of confidence they can associate with the results. We referred to this combined capability as predictability by construction (PBC).","1937-4194","","10.1109/MS.2011.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5756295","software;architecture;components;engineering;predictability by construction;architecture description language;adl;assemblies;programming","Software architecture;Computer architecture;Cognition;Economics;Programming;Reliability","software architecture","predictability by construction;software components;software design;Software Engineering Institute;software architecture","","1","","2","","25 Apr 2011","","","IEEE","IEEE Magazines"
"Disbanding the ""Process Police"": New Visions for Assuring Compliance","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","20 Apr 2012","2012","29","3","3","6","This article presents a vision of future techniques and approaches for software assurance, based on interviews with researchers for NASA's Office of Safety and Mission Assurance, and their sense of research trends and future directions. Key components of this vision include a more constructive role for software assurance, based upon early and effective collaboration with software developers, techniques that aim to ensure the quality of software as it is being built rather than after the fact, and earlier feedback loops of the assessments of software quality.","1937-4194","","10.1109/MS.2012.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188592","software assurance;process assurance;software quality","NASA;Humans;Systems engineering and theory;Software quality;Standards;Safety","","","","","","","","20 Apr 2012","","","IEEE","IEEE Magazines"
"A Look at 25 Years of Data","N. Juristo; A. Moreno; S. Vegas; F. Shull","Universidad Politecnica de Madrid; Universidad Politecnica de Madrid; Universidad Politecnica de Madrid; Fraunhofer Center for Experimental Software Engineering, Maryland","IEEE Software","22 Dec 2008","2009","26","1","15","17","Is 25 years enough time to build up a coherent body of knowledge that can help point to useful principles? As a testbed for helping us answer this question, software testing techniques are a good place to start. Few software practices are as important as testing, and testing techniques are amenable to measurement and reasoning about their effectiveness. Because they're aimed at removing faults, measuring the number and type of such removed faults seems like a natural part of applying these techniques. To make sense of this data, Universidad Politecnica de Madrid researchers have spent some time worrying about how to put 25 years' worth of work together usefully.","1937-4194","","10.1109/MS.2009.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721175","software testing;data flow testing;control flow testing","Software testing;Programming;System testing;Software quality;Systems engineering and theory;Robustness;Costs;Scheduling;Guidelines;Runtime","program testing;reasoning about programs;software metrics","software testing;software practice;software development;software measurement;software effectiveness reasoning","","10","","10","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Portability: Goodies vs. the Hair Shirt","D. Spinellis",Athens University of Economics and Business,"IEEE Software","26 Jun 2013","2013","30","4","22","23","Deciding whether to write portable code or not should be the outcome of a cost-benefit analysis. The key reason to favor portable code is that it opens up the selection of resources available to our project. Diverse technology choices free us from vendor lock-in, allowing us to select the best technology in each area based on quality and price, and minimize technology risks. However, portable code can degrade functionality, expressiveness, and efficiency. A middle course involves drawing boundaries around the non-portable code to isolate it from the rest of the application. Another approach is to admit defeat and write code that gives the best native experience. In the long term, separately maintained code bases can be less complex than a unified one. The Web extra at http://youtu.be/Lgqu_9Kc2Sc is an audio podcast of author Diomidis Spinellis reading his Tools of the Trade column, in which he discusses how whether to write portable code or not should be the outcome of a cost-benefit analysis.","1937-4194","","10.1109/MS.2013.82","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547638","portability;platform-specific;compatibility;standards","Software development;Encoding;Software design;Software architecture;Software engineering","","","","","","","","26 Jun 2013","","","IEEE","IEEE Magazines"
"Short and Winding Road: Software in Car Navigation Systems","H. Schaminée; H. Aerts",TomTom's Business Unit Automotive; TomTom's Business Unit Automotive,"IEEE Software","23 Jun 2011","2011","28","4","19","21","Car navigation started as an embedded product in expensive cars. Then it became an independent box, sold aftermarket. The volume that companies like TomTom have been able to accumulate now allows them to pursue the automotive original equipment manufacturers market.","1937-4194","","10.1109/MS.2011.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929524","innovation speed;car navigation;agile;buffer management","Automotive engineering;Navigation;Traffic control;Risk management;Software engineering","automobile industry;computerised navigation;road vehicles;traffic engineering computing","car navigation system;TomTom company;automotive equipment manufacturers market","","7","","5","","23 Jun 2011","","","IEEE","IEEE Magazines"
"Tool Building on the Shoulders of Others","H. M. Kienle; A. Kuhn; K. Mens; M. van den Brand; R. Wuyts",University of Victoria; University of Bern; Université catholique de Louvain-la-Neuve; Eindhoven University of Technology; IMEC,"IEEE Software","22 Dec 2008","2009","26","1","22","23","At the first International Workshop on Advanced Software Development Tools and Techniques, four emerging trends in academic tool building were evident. First, tools are increasingly constructed on the basis of external code, reusing, for instance, existing frameworks and integrated development environments. Second, researchers often choose dynamic languages such as Smalltalk to implement prototype tools. Third, Web-based tools are starting to incorporate Web 2.0 technologies to improve user interaction. Finally, increasing computational resources allow tools to tackle larger, real-world code bases.","1937-4194","","10.1109/MS.2009.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721178","tool building;reuse;dynamic languages;Web-based user interfaces;scalability","Java;Software engineering;Visualization;Design engineering;Software prototyping;Object oriented programming;Software tools;Object oriented modeling;User interfaces;Libraries","human computer interaction;Internet;resource allocation;Smalltalk;software reusability;software tools","software development tool;academic tool building;software reusing;Web-based tool;Web 2.0 technology;user interaction;dynamic language;Smalltalk;computational resource","","2","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Reengineering Technologies","R. Perez-Castillo; I. G. d. Guzman; M. Piattini; C. Ebert",NA; NA; NA; NA,"IEEE Software","20 Oct 2011","2011","28","6","13","17","Software systems must continually evolve to meet ever changing needs. However, such systems often become legacy systems as a consequence of uncontrolled maintenance combined with obsolete technology. To control maintenance costs and preserve complex embedded business rules, companies must evolve their legacy systems. This article introduces technologies for software reengineering.","1937-4194","","10.1109/MS.2011.145","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6055657","reengineering;reengineering tools;modernization;ADM;legacy system","Software engineering;Business process re-engineering;Legacy systems","software cost estimation;software maintenance","software systems;software evolution;legacy systems;uncontrolled software maintenance;obsolete technology;maintenance cost control;complex embedded business rules;software reengineering","","8","","5","","20 Oct 2011","","","IEEE","IEEE Magazines"
"Formal Modeling and Verification of Safety-Critical Software","J. Yoo; E. Jee; S. Cha",Konkuk University; Korea Advanced Institute of Science and Technology; Korea University,"IEEE Software","17 Apr 2009","2009","26","3","42","49","Rigorous quality demonstration is important when developing safety-critical software such as a reactor protection system (RPS) for a nuclear power plant. Although using formal methods such as formal modeling and verification is strongly recommended, domain experts often reject formal methods for four reasons: there are too many candidate techniques, the notations appear complex, the tools often work only in isolation, and output is often too difficult for domain experts to understand. A formal-methods-based process that supports development, verification and validation, and safety analysis can help domain experts overcome these obstacles. Nuclear engineers can also use CASE tools to apply formal methods without having to know details of the underlying formalism. The authors spent more than seven years working with nuclear engineers in developing RPS software and applying formal methods. The engineers and regulatory personnel found the process effective and easy to apply with the integrated tool support.","1937-4194","","10.1109/MS.2009.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814957","modeling;verification;safety-critical software;formal methods;function block diagram (FBD)","Software safety;Programmable control;Failure analysis;US Department of Transportation;Computer aided software engineering;Logic testing;Embedded software;Software tools;Software testing;Control systems","formal verification;nuclear power stations;power engineering computing;safety-critical software","safety-critical software;formal modeling;formal verification;reactor protection system;nuclear power plant;formal methods;safety analysis;CASE tools","","25","1","12","","17 Apr 2009","","","IEEE","IEEE Magazines"
"Tests: The Architect's Best Friend","F. Buschmann",Siemens Corporate Technology,"IEEE Software","25 Apr 2011","2011","28","3","7","9","When explicitly considering the testability of software-centric systems, architects tend to be more conscious and thoughtful about their design decisions, be they related to modularization, interfaces, or design choices. The paper discusses how architects can use tests and test-driven development as a design tool. The goal is to avoid or discover architectural deficiencies before they're realized-when they're less costly to correct.","1937-4194","","10.1109/MS.2011.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5756289","test-driven development;testability;design for testability","Computer architecture;Software engineering;Legged locomotion;Programming;Testing;Feedback loop","program testing;software architecture","software-centric system testability;design decisions;design choice;design modularization;design interface;test-driven development","","3","","6","","25 Apr 2011","","","IEEE","IEEE Magazines"
"A Business Case for Feature-Oriented Requirements Engineering","A. Rudorfer; T. Stenzel; G. Herold",Siemens Healthcare Diagnostics; Siemens Healthcare; Siemens Healthcare,"IEEE Software","21 Aug 2012","2012","29","5","54","59","Owing to strong market growth for medical devices deployed in critical-care facilities, development organizations in medical engineering must continually look for opportunities to drive engineering efficiency and cost effectiveness. Furthermore, cycle time must decrease, the alignment of clinical workflow is breaking down departmental barriers, and an increased amount of product functionality is being realized in software. To help meet such challenges, adequate requirements engineering is necessary. Toward that end, Syngo (a business unit of the Imaging and Therapy division of Siemens) introduced Feature-Oriented Requirements Engineering (FORE) and developed a business case for using it in the context of a lean engineering program. FORE integrates with other engineering disciplines such as project management, software architecture, and test management. There was an error in the biographical information for Tobias Stenzel. Stenzel's biography should have indicated that he has an MS in industrial engineering and management from the University of Technology Karlsruhe, Germany.","1937-4194","","10.1109/MS.2012.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226342","requirements engineering;business case;software platform development;business benefits;lean software development;software development","Business;Medical diagnostic imaging;Software management;Medical treatment;Software engineering;Product life cycle management;Software development;Agile manufacturing","formal specification;medical computing;software architecture","feature-oriented requirements engineering;medical devices;critical-care facilities;medical engineering;development organization;clinical workflow alignment;product functionality;Syngo;business unit;FORE;lean engineering program;project management;software architecture;test management;biographical information;University of Technology Karlsruhe;Germany;industrial engineering and management;therapy division;imaging division","","1","","7","","26 Jun 2012","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Mining Software Archives","N. Nagappan; A. Zeller; T. Zimmermann",Microsoft Research; Saarland University; Microsoft Research,"IEEE Software","22 Dec 2008","2009","26","1","24","25","Modern programming environments automatically collect lots of data on software development, notably changes and defects. The field of mining software archives is concerned with the automated extraction, collection, and abstraction of information from this data. This is the introduction to a special issue of IEEE Software presenting a selection of the exciting research that is taking place in the field.","1937-4194","","10.1109/MS.2009.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721179","programming environments;construction tools;distribution;maintenance;and enhancement;configuration management;data mining","Software quality;Software maintenance;Programming environments;History;Social network services;Collaborative software;Software engineering;Costs;Humans;Environmental management","","","","1","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Mobile Web Apps","N. Serrano; J. Hernantes; G. Gallardo",University of Navarra; University of Navarra; University of Navarra,"IEEE Software","3 Sep 2013","2013","30","5","22","27","With smartphones being the primary handheld device for more than a billion people, mobile Web apps are a necessity in both technical and commercial fields. There are several approaches to developing mobile Web apps, but given the fast speed of mobile software evolution, in which the leading companies become marginal in months and new gadgets continually appear, it's crucial to understand the basic technologies. Authors Nicolás Serrano, Josune Hernantes, and Gorka Gallardo examine current development approaches that can enhance the decision-making process.","1937-4194","","10.1109/MS.2013.111","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6588524","mobile Web;apps;mobile Web apps;applications;mobile applications;mobile Web applications;software technology;mobile apps","Mobile communication;Cascading style sheets;Browsers;Software engineering;Mobile handsets;Computer applications","decision making;Internet;mobile computing;smart phones","mobile Web apps;smartphones;handheld device;mobile software evolution;decision-making process","","32","2","3","","3 Sep 2013","","","IEEE","IEEE Magazines"
"ReqIF: Seamless Requirements Interchange Format between Business Partners","C. Ebert; M. Jastram",Vector Consulting Services; Formal Mind GmbH,"IEEE Software","21 Aug 2012","2012","29","5","82","87","The primary sources of project risks and product problems are poor, missing, or changing requirements. Often, the underlying root cause is insufficient collaboration between business partners. This article provides insight into how to effectively collaborate in requirements engineering. We describe the Requirements Interchange Format (ReqIF) standard and technologies for seamless requirements development and management. I look forward to hearing from both readers and prospective column authors about this and the technologies and tools you want to know more about.","1937-4194","","10.1109/MS.2012.121","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6276299","software technology;ReqIF;requirements engineering","Software engineering;Software management;Standards","business data processing;project management;risk management;software development management;systems analysis","seamless requirements interchange format;business partners;project risks;changing requirements;poor requirements;missing requirements;root cause;insufficient collaboration;requirements engineering;ReqIF standard;seamless requirements development;seamless requirements management","","11","","6","","21 Aug 2012","","","IEEE","IEEE Magazines"
"Discovering Services during Service-Based System Design Using UML","G. Spanoudakis; A. Zisman","City University, London; City University, London","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","371","389","Recently, there has been a proliferation of service-based systems, i.e., software systems that are composed of autonomous services but can also use software code. In order to support the development of these systems, it is necessary to have new methods, processes, and tools. In this paper, we describe a UML-based framework to assist with the development of service-based systems. The framework adopts an iterative process in which software services that can provide functional and nonfunctional characteristics of a system being developed are discovered, and the identified services are used to reformulate the design models of the system. The framework uses a query language to represent structural, behavioral, and quality characteristics of services to be identified, and a query processor to match the queries against service registries. The matching process is based on distance measurements between the queries and service specifications. A prototype tool has been implemented. The work has been evaluated in terms of recall, precision, and performance measurements.","1939-3520","","10.1109/TSE.2009.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5374424","Design notations and documentation;software process models;search discovery language;service discovery engine.","Unified modeling language;Software systems;Database languages;Quality of service;Computer Society;Distance measurement;Software prototyping;Prototypes;Documentation;Engines","pattern matching;query languages;query processing;software prototyping;Unified Modeling Language;Web services","service-based system design;software systems;software code;UML-based framework;iterative process;software services;query processor;matching process;distance measurements;query language","","31","1","60","","8 Jan 2010","","","IEEE","IEEE Journals"
"Recomputing Coverage Information to Assist Regression Testing","P. K. Chittimalli; M. J. Harrold","Tata Research Development & Design Centre, India; Georgia Institute of Technology, Atlanta","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","452","469","This paper presents a technique that leverages an existing regression test selection algorithm to compute accurate, updated coverage data on a version of the software, Pi+1, without rerunning any test cases that do not execute the changes from the previous version of the software, Pi to Pi+1. The technique also reduces the cost of running those test cases that are selected by the regression test selection algorithm by performing a selective instrumentation that reduces the number of probes required to monitor the coverage data. Users of our technique can avoid the expense of rerunning the entire test suite on Pi+1 or the inaccuracy produced by previous approaches that estimate coverage data for Pi+1 or that reuse outdated coverage data from Pi. This paper also presents a tool, RECOVER, that implements our technique, along with a set of empirical studies on a set of subjects that includes several industrial programs, versions, and test cases. The studies show the inaccuracies that can exist when an application-regression test selection-uses estimated or outdated coverage data. The studies also show that the overhead incurred by selective instrumentation used in our technique is negligible and overall our technique provides savings over earlier techniques.","1939-3520","","10.1109/TSE.2009.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4760153","Regression testing;regression test selection;testing;maintenance.","Software testing;Costs;Performance evaluation;Instruments;Software quality;Software algorithms;Probes;Monitoring;Software performance;Error correction","program testing;regression analysis","coverage information;regression testing;software testing;industrial programs","","31","","16","","23 Jan 2009","","","IEEE","IEEE Journals"
"The Effects of Test-Driven Development on External Quality and Productivity: A Meta-Analysis","Y. Rafique; V. B. Mišić","Ryerson University, Toronto; Ryerson University, Toronto","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","835","856","This paper provides a systematic meta-analysis of 27 studies that investigate the impact of Test-Driven Development (TDD) on external code quality and productivity. The results indicate that, in general, TDD has a small positive effect on quality but little to no discernible effect on productivity. However, subgroup analysis has found both the quality improvement and the productivity drop to be much larger in industrial studies in comparison with academic studies. A larger drop of productivity was found in studies where the difference in test effort between the TDD and the control group's process was significant. A larger improvement in quality was also found in the academic studies when the difference in test effort is substantial; however, no conclusion could be derived regarding the industrial studies due to the lack of data. Finally, the influence of developer experience and task size as moderator variables was investigated, and a statistically significant positive correlation was found between task size and the magnitude of the improvement in quality.","1939-3520","","10.1109/TSE.2012.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6197200","Test-driven development;meta-analysis;code quality;programmer productivity;agile software development","Productivity;Computational modeling;Testing;Process control;Programming;Size measurement","program testing;software development management;software quality","test driven development;systematic meta analysis;code quality;code productivity;TDD;subgroup analysis;quality improvement","","55","","71","","8 May 2012","","","IEEE","IEEE Journals"
"Service-Level Agreements for Electronic Services","J. Skene; F. Raimondi; W. Emmerich","The University of Auckland, Auckland; Middlesex University, London; University College London, London","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","288","304","The potential of communication networks and middleware to enable the composition of services across organizational boundaries remains incompletely realized. In this paper, we argue that this is in part due to outsourcing risks and describe the possible contribution of Service-Level Agreements (SLAs) to mitigating these risks. For SLAs to be effective, it should be difficult to disregard their original provisions in the event of a dispute between the parties. Properties of understandability, precision, and monitorability ensure that the original intent of an SLA can be recovered and compared to trustworthy accounts of service behavior to resolve disputes fairly and without ambiguity. We describe the design and evaluation of a domain-specific language for SLAs that tend to exhibit these properties and discuss the impact of monitorability requirements on service-provision practices.","1939-3520","","10.1109/TSE.2009.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5210121","Service-level agreements;electronic services;contracts;domain-specific languages;model-driven engineering.","Outsourcing;Cloud computing;Consumer electronics;Middleware;Service oriented architecture;Domain specific languages;Distributed computing;Computer Society;Communication networks;Monitoring","client-server systems;high level languages;Internet;outsourcing","service level agreements;electronic services;communication networks;middleware;outsourcing risks;SLA;domain specific language","","24","1","44","","21 Aug 2009","","","IEEE","IEEE Journals"
"DEC: Service Demand Estimation with Confidence","A. Kalbasi; D. Krishnamurthy; J. Rolia; S. Dawson","University of Calgary, Calgary; University of Calgary, Calgary; Hewlett Packard Labs, Bristol; SAP Research Center Belfast, Belfast","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","561","578","We present a new technique for predicting the resource demand requirements of services implemented by multitier systems. Accurate demand estimates are essential to ensure the efficient provisioning of services in an increasingly service-oriented world. The demand estimation technique proposed in this paper has several advantages compared with regression-based demand estimation techniques, which many practitioners employ today. In contrast to regression, it does not suffer from the problem of multicollinearity, it provides more reliable aggregate resource demand and confidence interval predictions, and it offers a measurement-based validation test. The technique can be used to support system sizing and capacity planning exercises, costing and pricing exercises, and to predict the impact of changes to a service upon different service customers.","1939-3520","","10.1109/TSE.2011.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5728829","Benchmarking;resource demand prediction;statistical regression.","Benchmark testing;Equations;Software;Mathematical model;Estimation;Frequency modulation;Computers","multiprocessing systems;regression analysis;service-oriented architecture","DEC;service demand estimation technique;resource demand requirements;multitier systems;service-oriented world;regression-based demand estimation techniques;multicollinearity;system sizing;capacity planning","","23","","33","","10 Mar 2011","","","IEEE","IEEE Journals"
"STAR: Stack Trace Based Automatic Crash Reproduction via Symbolic Execution","N. Chen; S. Kim","Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kong; Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kong","IEEE Transactions on Software Engineering","10 Feb 2015","2015","41","2","198","220","Software crash reproduction is the necessary first step for debugging. Unfortunately, crash reproduction is often labor intensive. To automate crash reproduction, many techniques have been proposed including record-replay and post-failure-process approaches. Record-replay approaches can reliably replay recorded crashes, but they incur substantial performance overhead to program executions. Alternatively, post-failure-process approaches analyse crashes only after they have occurred. Therefore they do not incur performance overhead. However, existing post-failure-process approaches still cannot reproduce many crashes in practice because of scalability issues and the object creation challenge. This paper proposes an automatic crash reproduction framework using collected crash stack traces. The proposed approach combines an efficient backward symbolic execution and a novel method sequence composition approach to generate unit test cases that can reproduce the original crashes without incurring additional runtime overhead. Our evaluation study shows that our approach successfully exploited 31 (59.6 percent) of 52 crashes in three open source projects. Among these exploitable crashes, 22 (42.3 percent) are useful reproductions of the original crashes that reveal the crash triggering bugs. A comparison study also demonstrates that our approach can effectively outperform existing crash reproduction approaches.","1939-3520","","10.1109/TSE.2014.2363469","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6926857","Crash reproduction;static analysis;symbolic execution;test case generation;optimization;Crash reproduction;static analysis;symbolic execution;test case generation;optimization","Computer crashes;Arrays;Indexes;Color;Optimization;Explosions;Software","program debugging;program testing;project management;public domain software;system recovery","STAR;stack trace based automatic crash reproduction;software crash reproduction;debugging;record-replay approach;post-failure-process approach;scalability issues;object creation challenge;crash stack traces;backward symbolic execution;method sequence composition approach;unit test case generation;open source projects","","24","","64","","16 Oct 2014","","","IEEE","IEEE Journals"
"Exploiting the Essential Assumptions of Analogy-Based Effort Estimation","E. Kocaguneli; T. Menzies; A. Bener; J. W. Keung","West Virginia University, Morgantown; West Virginia University, Morgantown; Ryerson University, Toronto; The Hong Kong Polytechnic University, Hong Kong","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","425","438","Background: There are too many design options for software effort estimators. How can we best explore them all? Aim: We seek aspects on general principles of effort estimation that can guide the design of effort estimators. Method: We identified the essential assumption of analogy-based effort estimation, i.e., the immediate neighbors of a project offer stable conclusions about that project. We test that assumption by generating a binary tree of clusters of effort data and comparing the variance of supertrees versus smaller subtrees. Results: For 10 data sets (from Coc81, Nasa93, Desharnais, Albrecht, ISBSG, and data from Turkish companies), we found: 1) The estimation variance of cluster subtrees is usually larger than that of cluster supertrees; 2) if analogy is restricted to the cluster trees with lower variance, then effort estimates have a significantly lower error (measured using MRE, AR, and Pred(25) with a Wilcoxon test, 95 percent confidence, compared to nearest neighbor methods that use neighborhoods of a fixed size). Conclusion: Estimation by analogy can be significantly improved by a dynamic selection of nearest neighbors, using only the project data from regions with small variance.","1939-3520","","10.1109/TSE.2011.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5728833","Software cost estimation;analogy;k-NN.","Estimation;Training;Software;Training data;Linear regression;Euclidean distance;Humans","pattern clustering;program testing;project management;software cost estimation;trees (mathematics)","analogy-based effort estimation;software effort estimator design;essential assumption;supertree variance;subtree variance;Coc81 data set;Nasa93 data set;Desharnais data set;Albrecht data set;ISBSG data set;Turkish companies;estimation variance;binary cluster tree;cluster subtrees;dynamic selection;nearest neighbor selection;project data","","106","","69","","10 Mar 2011","","","IEEE","IEEE Journals"
"Event Logs for the Analysis of Software Failures: A Rule-Based Approach","M. Cinque; D. Cotroneo; A. Pecchia","Universitá degli Studi di Napoli Federico II, Naples; Universitá degli Studi di Napoli Federico II, Naples; Universitá degli Studi di Napoli Federico II, Naples","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","806","821","Event logs have been widely used over the last three decades to analyze the failure behavior of a variety of systems. Nevertheless, the implementation of the logging mechanism lacks a systematic approach and collected logs are often inaccurate at reporting software failures: This is a threat to the validity of log-based failure analysis. This paper analyzes the limitations of current logging mechanisms and proposes a rule-based approach to make logs effective to analyze software failures. The approach leverages artifacts produced at system design time and puts forth a set of rules to formalize the placement of the logging instructions within the source code. The validity of the approach, with respect to traditional logging mechanisms, is shown by means of around 12,500 software fault injection experiments into real-world systems.","1939-3520","","10.1109/TSE.2012.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6320555","Event log;logging mechanism;rule-based logging;error detection;software failures","Unified modeling language;Failure analysis;Analytical models;Systematics;Proposals;Software systems","software fault tolerance","event logs;software failures;rule-based approach;logging mechanism;log-based failure analysis;system design time","","37","","52","","3 Oct 2012","","","IEEE","IEEE Journals"
"A large-scale empirical study of just-in-time quality assurance","Y. Kamei; E. Shihab; B. Adams; A. E. Hassan; A. Mockus; A. Sinha; N. Ubayashi","Kyushu University, Fukuoka; Rochester Institute of Technology, Rochester; École Polytechnique de Montréal, Montréal; Queen's University, Kingston; Avaya Labs Research, Basking Ridge; Research In Motion, Waterloo; Kyushu University, Fukuoka","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","757","773","Defect prediction models are a well-known technique for identifying defect-prone files or packages such that practitioners can allocate their quality assurance efforts (e.g., testing and code reviews). However, once the critical files or packages have been identified, developers still need to spend considerable time drilling down to the functions or even code snippets that should be reviewed or tested. This makes the approach too time consuming and impractical for large software systems. Instead, we consider defect prediction models that focus on identifying defect-prone (“risky”) software changes instead of files or packages. We refer to this type of quality assurance activity as “Just-In-Time Quality Assurance,” because developers can review and test these risky changes while they are still fresh in their minds (i.e., at check-in time). To build a change risk model, we use a wide range of factors based on the characteristics of a software change, such as the number of added lines, and developer experience. A large-scale study of six open source and five commercial projects from multiple domains shows that our models can predict whether or not a change will lead to a defect with an average accuracy of 68 percent and an average recall of 64 percent. Furthermore, when considering the effort needed to review changes, we find that using only 20 percent of the effort it would take to inspect all changes, we can identify 35 percent of all defect-inducing changes. Our findings indicate that “Just-In-Time Quality Assurance” may provide an effort-reducing way to focus on the most risky changes and thus reduce the costs of developing high-quality software.","1939-3520","","10.1109/TSE.2012.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6341763","Maintenance;software metrics;mining software repositories;defect prediction;just-in-time prediction","Measurement;Quality assurance;Predictive models;Software;Entropy;Object oriented modeling;Accuracy","program testing;software maintenance;software metrics;software quality","just-in-time quality assurance;defect prediction models;defect-prone file identification;defect-prone package identification;software systems;risk model;open source projects;commercial projects;risky changes;cost reduction;defect-prone software change identification;software metrics;software repository mining;software quality assurance activities;source code inspection;unit testing","","167","1","63","","10 Nov 2012","","","IEEE","IEEE Journals"
"Plat_Forms: A Web Development Platform Comparison by an Exploratory Experiment Searching for Emergent Platform Properties","L. Prechelt","Freie Universität Berlin, Berlin","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","95","108","Background: For developing Web-based applications, there exist several competing and widely used technological platforms (consisting of a programming language, framework(s), components, and tools), each with an accompanying development culture and style. Research question: Do Web development projects exhibit emergent process or product properties that are characteristic and consistent within a platform, but show relevant substantial differences across platforms or do team-to-team individual differences outweigh such differences, if any? Such a property could be positive (i.e., a platform advantage), negative, or neutral, and it might be unobvious which is which. Method: In a nonrandomized, controlled experiment, framed as a public contest called “Plat_Forms,” top-class teams of three professional programmers competed to implement the same requirements for a Web-based application within 30 hours. Three different platforms (Java EE, PHP, or Perl) were used by three teams each. We compare the resulting nine products and process records along many dimensions, both external (usability, functionality, reliability, security, etc.) and internal (size, structure, modifiability, etc.). Results: The various results obtained cover a wide spectrum: First, there are results that many people would have called “obvious” or “well known,” say, that Perl solutions tend to be more compact than Java solutions. Second, there are results that contradict conventional wisdom, say, that our PHP solutions appear in some (but not all) respects to be actually at least as secure as the others. Finally, one result makes a statement we have not seen discussed previously: Along several dimensions, the amount of within-platform variation between the teams tends to be smaller for PHP than for the other platforms. Conclusion: The results suggest that substantial characteristic platform differences do indeed exist in some dimensions, but possibly not in others.","1939-3520","","10.1109/TSE.2010.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406528","Emergent properties;usability;functionality;reliability;security;product size;design structure;modifiability;Java;PHP;Perl.","Java;Computer languages;Usability;Security;Libraries;Programming profession;Product design;Buildings;Cascading style sheets;Ecosystems","emergent phenomena;Internet;Java;Perl;Web design","Web development platform;emergent platform properties;Web based applications;Java EE;Perl solutions;PHP solutions","","7","","26","","5 Feb 2010","","","IEEE","IEEE Journals"
"Automated Oracle Data Selection Support","G. Gay; M. Staats; M. Whalen; M. P. E. Heimdahl","Department of Computer Science & Engineering, University of South Carolina; Google, Inc.; Department of Computer Science and Engineering, University of Minnesota; Department of Computer Science and Engineering, University of Minnesota","IEEE Transactions on Software Engineering","10 Nov 2015","2015","41","11","1119","1137","The choice of test oracle-the artifact that determines whether an application under test executes correctly-can significantly impact the effectiveness of the testing process. However, despite the prevalence of tools that support test input selection, little work exists for supporting oracle creation. We propose a method of supporting test oracle creation that automatically selects the oracle data-the set of variables monitored during testing-for expected value test oracles. This approach is based on the use of mutation analysis to rank variables in terms of fault-finding effectiveness, thus automating the selection of the oracle data. Experimental results obtained by employing our method over six industrial systems (while varying test input types and the number of generated mutants) indicate that our method-when paired with test inputs generated either at random or to satisfy specific structural coverage criteria-may be a cost-effective approach for producing small, effective oracle data sets, with fault finding improvements over current industrial best practice of up to 1,435 percent observed (with typical improvements of up to 50 percent).","1939-3520","","10.1109/TSE.2015.2436920","NASA; NSF; US National Science Foundation (NSF); Fonds National de la Recherche, Luxembourg; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7112189","Testing;Test Oracles;Oracle Data;Oracle Selection;Verification;Testing;test oracles;oracle data;oracle selection;verification","Testing;Monitoring;Software;Aerospace electronics;Training;Electronic mail;Computer crashes","program testing;program verification","automated oracle data selection support;mutation analysis;software testing;test oracle;oracle creation;specific structural coverage criteria","","9","","40","","22 May 2015","","","IEEE","IEEE Journals"
"Size-Constrained Regression Test Case Selection Using Multicriteria Optimization","S. Mirarab; S. Akhlaghi; L. Tahvildari","University of Texas at Austin, Austin; Shahed University, Tehran; University of Waterloo, Waterloo","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","936","956","To ensure that a modified software system has not regressed, one approach is to rerun existing test cases. However, this is a potentially costly task. To mitigate the costs, the testing effort can be optimized by executing only a selected subset of the test cases that are believed to have a better chance of revealing faults. This paper proposes a novel approach for selecting and ordering a predetermined number of test cases from an existing test suite. Our approach forms an Integer Linear Programming problem using two different coverage-based criteria, and uses constraint relaxation to find many close-to-optimal solution points. These points are then combined to obtain a final solution using a voting mechanism. The selected subset of test cases is then prioritized using a greedy algorithm that maximizes minimum coverage in an iterative manner. The proposed approach has been empirically evaluated and the results show significant improvements over existing approaches for some cases and comparable results for the rest. Moreover, our approach provides more consistency compared to existing approaches.","1939-3520","","10.1109/TSE.2011.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928351","Software regression testing;test case selection;integer programming;Pareto optimality","Testing;Software;Time factors;Fault detection;Optimization;Estimation;IP networks","greedy algorithms;integer programming;linear programming;program testing;regression analysis","size constrained regression test case selection;multicriteria optimization;modified software system;integer linear programming problem;voting mechanism;greedy algorithm;iterative manner","","39","","61","","23 Jun 2011","","","IEEE","IEEE Journals"
"A Lightweight System for Detecting and Tolerating Concurrency Bugs","M. Zhang; Y. Wu; S. Lu; S. Qi; J. Ren; W. Zheng","Tsinghua National Laboratory for Information Science and Technology (TNLIST), the Department of Computer Science and Technology, Tsinghua University, Beijing, China; Tsinghua National Laboratory for Information Science and Technology (TNLIST), the Department of Computer Science and Technology, Tsinghua University, Beijing, China; University of Chicago, Chicago, IL; UBER growth team, San Francisco, CA; Tsinghua National Laboratory for Information Science and Technology (TNLIST), the Department of Computer Science and Technology, Tsinghua University, Beijing, China; Tsinghua National Laboratory for Information Science and Technology (TNLIST), the Department of Computer Science and Technology, Tsinghua University, Beijing, China","IEEE Transactions on Software Engineering","13 Oct 2016","2016","42","10","899","917","Along with the prevalence of multi-threaded programs, concurrency bugs have become one of the most important sources of software bugs. Even worse, due to the non-deterministic nature of concurrency bugs, these bugs are both difficult to detect and fix even after the detection. As a result, it is highly desired to develop an all-around approach that is able to not only detect them during the testing phase but also tolerate undetected bugs during production runs. However, existing bug-detecting and bug-tolerating tools are usually either 1) constrained in types of bugs they can handle or 2) requiring specific hardware supports for achieving an acceptable overhead. In this paper, we present a novel program invariant, name Anticipating Invariant (Ai), that can detect most types of concurrency bugs. More importantly, Ai can be used to anticipate many concurrency bugs before any irreversible changes have been made. Thus it enables us to develop a software-only system that is able to forestall failures with a simple thread stalling technique, which does not rely on execution roll-back and hence has good performance. Experiments with 35 real-world concurrency bugs demonstrate that Ai is capable of detecting and tolerating many important types of concurrency bugs, including both atomicity and order violations. It has also exposed two new bugs (confirmed by developers) that were never reported before in the literature. Performance evaluation with 6 representative parallel programs shows that Ai incurs negligible overhead ( $ < 1\%$ ) for many nontrivial desktop and server applications.","1939-3520","","10.1109/TSE.2016.2531666","Natural Science Foundation of China; National Basic Research (973) Program of China; National High-Tech R&D (863) Program of China; Chinese Special Project of Science and Technology; US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7412768","Concurrency bugs;software reliability;bug tolerating","Computer bugs;Concurrent computing;Artificial intelligence;Turning;Testing;Hardware","","","","4","","67","","18 Feb 2016","","","IEEE","IEEE Journals"
"Language-Independent and Automated Software Composition: The FeatureHouse Experience","S. Apel; C. Kästner; C. Lengauer","University of Passau, Passau; Philipps University Marburg, Marburg; University of Passau, Passau","IEEE Transactions on Software Engineering","13 Feb 2013","2013","39","1","63","79","Superimposition is a composition technique that has been applied successfully in many areas of software development. Although superimposition is a general-purpose concept, it has been (re)invented and implemented individually for various kinds of software artifacts. We unify languages and tools that rely on superimposition by using the language-independent model of feature structure trees (FSTs). On the basis of the FST model, we propose a general approach to the composition of software artifacts written in different languages. Furthermore, we offer a supporting framework and tool chain, called FEATUREHOUSE. We use attribute grammars to automate the integration of additional languages. In particular, we have integrated Java, C#, C, Haskell, Alloy, and JavaCC. A substantial number of case studies demonstrate the practicality and scalability of our approach and reveal insights into the properties that a language must have in order to be ready for superimposition. We discuss perspectives of our approach and demonstrate how we extended FEATUREHOUSE with support for XML languages (in particular, XHTML, XMI/UML, and Ant) and alternative composition approaches (in particular, aspect weaving). Rounding off our previous work, we provide here a holistic view of the FEATUREHOUSE approach based on rich experience with numerous languages and case studies and reflections on several years of research.","1939-3520","","10.1109/TSE.2011.120","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095570","FeatureHouse;feature structure trees;software composition;superimposition;language independence","Software;Java;Grammar;Databases;Printers;Latches;Unified modeling language","attribute grammars;C++ language;Java;software tools;Unified Modeling Language;XML","language-independent software composition;automated software composition;FEATUREHOUSE;superimposition;software development;general-purpose concept;language-independent model;feature structure tree;software artifact composition;supporting framework;tool chain;attribute grammar;integrated Java;C#;Haskell;Alloy;JavaCC;XML language;XHTML;XMI/UML;Ant","","35","","67","","6 Dec 2011","","","IEEE","IEEE Journals"
"On the Asymptotic Behavior of Adaptive Testing Strategy for Software Reliability Assessment","J. Lv; B. Yin; K. Cai","School of Automation Science and Electrical Engineering, Bejing, China; School of Automation Science and Electrical Engineering, Bejing, China; School of Automation Science and Electrical Engineering, Bejing, China","IEEE Transactions on Software Engineering","2 May 2014","2014","40","4","396","412","In software reliability assessment, one problem of interest is how to minimize the variance of reliability estimator, which is often considered as an optimization goal. The basic idea is that an estimator with lower variance makes the estimates more predictable and accurate. Adaptive Testing (AT) is an online testing strategy, which can be adopted to minimize the variance of software reliability estimator. In order to reduce the computational overhead of decision-making, the implemented AT strategy in practice deviates from its theoretical design that guarantees AT's local optimality. This work aims to investigate the asymptotic behavior of AT to improve its global performance without losing the local optimality. To this end, a new AT strategy named Adaptive Testing with Gradient Descent method (AT-GD) is proposed. Theoretical analysis indicates that AT-GD, a locally optimal testing strategy, converges to the globally optimal solution as the assessment process proceeds. Simulation and experiments are set up to validate AT-GD's effectiveness and efficiency. Besides, sensitivity analysis of AT-GD is also conducted in this study.","1939-3520","","10.1109/TSE.2014.2310194","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6762895","Adaptive testing;operational profile;software reliability;testing strategy","Testing;Software reliability;Software;Global Positioning System;Aircraft;Reliability theory","decision making;gradient methods;optimisation;program testing;sensitivity analysis;software reliability","asymptotic behavior;adaptive testing strategy;software reliability assessment;optimization goal;online testing strategy;software reliability estimator;computational overhead reduction;decision-making;global performance improvement;adaptive testing with gradient descent method;AT-GD;locally optimal testing strategy;sensitivity analysis","","26","","35","","11 Mar 2014","","","IEEE","IEEE Journals"
"Input-Sensitive Profiling","E. Coppa; C. Demetrescu; I. Finocchi","Department of Computer Science, Sapienza University of Rome, Italy; Department of Computer, Control, and Management Engineering, Sapienza University of Rome, Italy; Department of Computer Science, Sapienza University of Rome, Italy","IEEE Transactions on Software Engineering","12 Dec 2014","2014","40","12","1185","1205","In this article we present a building block technique and a toolkit towards automatic discovery of workload-dependentperformance bottlenecks. From one or more runs of a program, our profiler automatically measures how the performance of individual routines scales as a function of the input size, yielding clues to their growth rate. The output of the profiler is, for each executed routine of the program, a set of tuples that aggregate performance costs by input size. The collected profiles can be used to produceperformance plots and derive trend functions by statistical curve fitting techniques. A key feature of our method is the ability toautomatically measure the size of the input given to a generic code fragment: to this aim, we propose an effective metric for estimating the input size of a routine and show how to compute it efficiently. We discuss several examples, showing that our approach can reveal asymptotic bottlenecks that other profilers may fail to detect and can provide useful characterizations of the workload and behavior of individual routines in the context of mainstream applications, yielding several code optimizations as well as algorithmic improvements. To prove the feasibility of our techniques, we implemented a Valgrind tool called aprof and performed an extensive experimentalevaluation on the SPEC CPU2006 benchmarks. Our experiments show that aprof delivers comparable performance to otherprominent Valgrind tools, and can generate informative plots even from single runs on typical workloads for mostalgorithmically-critical routines.","1939-3520","","10.1109/TSE.2014.2339825","Italian Ministry of Education, University, and Research (MIUR); “AMANDA-Algorithmics for MAssive and Networked DAta”; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6858059","Performance profiling;asymptotic analysis;dynamic program analysis;instrumentation","Context modeling;Algorithm design and analysis;Market research;Benchmark testing","curve fitting;program diagnostics;software performance evaluation;software tools;statistical analysis","input-sensitive profiling;building block technique;automatic workload-dependent performance bottleneck discovery;growth rate;program executed routine;tuples;performance plots;statistical curve fitting techniques;generic code fragment;code optimizations;aprof;experimental evaluation;SPEC CPU2006 benchmarks;Valgrind tools","","9","","60","","17 Jul 2014","","","IEEE","IEEE Journals"
"NLP-KAOS for Systems Goal Elicitation: Smart Metering System Case Study","E. Casagrande; S. Woldeamlak; W. L. Woon; H. H. Zeineldin; D. Svetinovic","Department of Electrical Engineering and Computer Science, Masdar Institute of Science and Technology, Abu Dhabi, UAE; Department of Electrical Engineering and Computer Science, Masdar Institute of Science and Technology, Abu Dhabi, UAE; Department of Electrical Engineering and Computer Science, Masdar Institute of Science and Technology, Abu Dhabi, UAE; Department of Electrical Engineering and Computer Science, Masdar Institute of Science and Technology, Abu Dhabi, UAE; Department of Electrical Engineering and Computer Science, Masdar Institute of Science and Technology, Abu Dhabi, UAE","IEEE Transactions on Software Engineering","9 Oct 2014","2014","40","10","941","956","This paper presents a computational method that employs Natural Language Processing (NLP) and text mining techniques to support requirements engineers in extracting and modeling goals from textual documents. We developed a NLP-based goal elicitation approach within the context of KAOS goal-oriented requirements engineering method. The hierarchical relationships among goals are inferred by automatically building taxonomies from extracted goals. We use smart metering system as a case study to investigate the proposed approach. Smart metering system is an important subsystem of the next generation of power systems (smart grids). Goals are extracted by semantically parsing the grammar of goal-related phrases in abstracts of research publications. The results of this case study show that the developed approach is an effective way to model goals for complex systems, and in particular, for the research-intensive complex systems.","1939-3520","","10.1109/TSE.2014.2339811","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6857327","Requirements engineering;goal elicitation;NLP;data mining;bibliometrics","Data mining;Taxonomy;Ontologies;Data models;Natural language processing;Abstracts;Data collection","data mining;formal specification;natural language processing;smart meters","NLP-KAOS;systems goal elicitation;smart metering system case study;computational method;natural language processing;text mining techniques;requirements engineers;textual documents;NLP-based goal elicitation approach;KAOS goal-oriented requirements engineering method;hierarchical relationships;power systems;smart grids;goal-related phrases;research publications;complex systems","","22","","57","","16 Jul 2014","","","IEEE","IEEE Journals"
"Synthesis of Partial Behavior Models from Properties and Scenarios","S. Uchitel; G. Brunet; M. Chechik","Imperial College London and FCEN-University of Buenos Aires; University of Toronto, Toronto; University of Toronto, Toronto","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","384","406","Synthesis of behavior models from software development artifacts such as scenario-based descriptions or requirements specifications helps reduce the effort of model construction. However, the models favored by existing synthesis approaches are not sufficiently expressive to describe both universal constraints provided by requirements and existential statements provided by scenarios. In this paper, we propose a novel synthesis technique that constructs behavior models in the form of modal transition systems (MTS) from a combination of safety properties and scenarios. MTSs distinguish required, possible, and proscribed behavior, and their elaboration not only guarantees the preservation of the properties and scenarios used for synthesis but also supports further elicitation of new requirements.","1939-3520","","10.1109/TSE.2008.107","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721439","Modal transition systems;merge;synthesis;partial behavior models.","Computer Society;Analytical models;Programming;Safety;Process design;Buildings;Animation;Upper bound;Educational institutions;Computer science","formal specification","partial behavior model;software development;modal transition system;safety properties","","80","","53","","22 Dec 2008","","","IEEE","IEEE Journals"
"Probabilistic Interface Automata","E. Pavese; V. Braberman; S. Uchitel","Departamento de Computación, Universidad de Buenos Aires; Departamento de Computación, Universidad de Buenos Aires and CONICET; Departamento de Computación, Universidad de Buenos Aires; Imperial College London and CONICET","IEEE Transactions on Software Engineering","15 Sep 2016","2016","42","9","843","865","System specifications have long been expressed through automata-based languages, which allow for compositional construction of complex models and enable automated verification techniques such as model checking. Automata-based verification has been extensively used in the analysis of systems, where they are able to provide yes/no answers to queries regarding their temporal properties. Probabilistic modelling and checking aim at enriching this binary, qualitative information with quantitative information, more suitable to approaches such as reliability engineering. Compositional construction of software specifications reduces the specification effort, allowing the engineer to focus on specifying individual component behaviour to then analyse the composite system behaviour. Compositional construction also reduces the validation effort, since the validity of the composite specification should be dependent on the validity of the components. These component models are smaller and thus easier to validate. Compositional construction poses additional challenges in a probabilistic setting. Numerical annotations of probabilistically independent events must be contrasted against estimations or measurements, taking care of not compounding this quantification with exogenous factors, in particular the behaviour of other system components. Thus, the validity of compositionally constructed system specifications requires that the validated probabilistic behaviour of each component continues to be preserved in the composite system. However, existing probabilistic automata-based formalisms do not support specification of non-deterministic and probabilistic component behaviour which, when observed through logics such as pCTL, is preserved in the composite system. In this paper we present a probabilistic extension to Interface Automata which preserves pCTL properties under probabilistic fairness by ensuring a probabilistic branching simulation between component and composite automata. The extension not only supports probabilistic behaviour but also allows for weaker prerequisites to interfacing composition, that supports delayed synchronisation that may be required because of internal component behaviour. These results are equally applicable as an extension to non-probabilistic Interface Automata.","1939-3520","","10.1109/TSE.2016.2527000","ANPCyT PICT; ANPCyT PICT; ANPCyT PICT; CONICET PIP; CONICET PIP; UBACYT; UBACYT; MEALS; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7401103","Behaviour models;probability;interface automata;model checking","Probabilistic logic;Automata;Interconnected systems;Computational modeling;Model checking;Semantics;Synchronization","formal specification;probabilistic automata;program verification","probabilistic interface automata;system specifications;automata-based languages;compositional construction;complex models;automated verification techniques;model checking;automata-based verification;temporal properties;probabilistic modelling;probabilistic checking;binary qualitative information;quantitative information;reliability engineering;software specifications;component behaviour;composite system behaviour;numerical annotations;probabilistically independent events;exogenous factors;system components;compositionally constructed system specifications;nondeterministic behaviour;probabilistic component behaviour;pCTL;probabilistic fairness;probabilistic branching simulation;composite automata;component automata;internal component behaviour;nonprobabilistic interface automata","","","","42","","8 Feb 2016","","","IEEE","IEEE Journals"
"A Quantitative Investigation of the Acceptable Risk Levels of Object-Oriented Metrics in Open-Source Systems","R. Shatnawi","Jordan University of Science and Technology, Irbid","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","216","225","Object-oriented metrics have been validated empirically as measures of design complexity. These metrics can be used to mitigate potential problems in the software complexity. However, there are few studies that were conducted to formulate the guidelines, represented as threshold values, to interpret the complexity of the software design using metrics. Classes can be clustered into low and high risk levels using threshold values. In this paper, we use a statistical model, derived from the logistic regression, to identify threshold values for the Chidamber and Kemerer (CK) metrics. The methodology is validated empirically on a large open-source system-the Eclipse project. The empirical results indicate that the CK metrics have threshold effects at various risk levels. We have validated the use of these thresholds on the next release of the Eclipse project-Version 2.1-using decision trees. In addition, the selected threshold values were more accurate than those were selected based on either intuitive perspectives or on data distribution parameters. Furthermore, the proposed model can be exploited to find the risk level for an arbitrary threshold value. These findings suggest that there is a relationship between risk levels and object-oriented metrics and that risk levels can be used to identify threshold effects.","1939-3520","","10.1109/TSE.2010.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383377","Object-oriented programming;product metrics;CK metrics;threshold values;open-source software.","Open source software;Object oriented modeling;Software metrics;Software quality;Software testing;Software design;Predictive models;Quality assurance;Probability;Fault diagnosis","decision trees;object-oriented programming;public domain software;software fault tolerance;software maintenance;software metrics;statistical analysis","object-oriented metrics;open source systems;software complexity;software design;software metrics;statistical model;logistic regression;Chidamber and Kemerer metrics;Eclipse project version 2.1;decision trees;threshold values;data distribution parameters","","70","","49","","15 Jan 2010","","","IEEE","IEEE Journals"
"Two Studies of Framework-Usage Templates Extracted from Dynamic Traces","A. Heydarnoori; K. Czarnecki; W. Binder; T. T. Bartolomei","University of Lugano, Lugano; University of Waterloo, Waterloo; University of Lugano, Lugano; University of Waterloo, Waterloo","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1464","1487","Object-oriented frameworks are widely used to develop new applications. They provide reusable concepts that are instantiated in application code through potentially complex implementation steps such as subclassing, implementing interfaces, and calling framework operations. Unfortunately, many modern frameworks are difficult to use because of their large and complex APIs and frequently incomplete user documentation. To cope with these problems, developers often use existing framework applications as a guide. However, locating concept implementations in those sample applications is typically challenging due to code tangling and scattering. To address this challenge, we introduce the notion of concept-implementation templates, which summarize the necessary concept-implementation steps and identify them in the sample application code, and a technique, named FUDA, to automatically extract such templates from dynamic traces of sample applications. This paper further presents the results of two experiments conducted to evaluate the quality and usefulness of FUDA templates. The experimental evaluation of FUDA with 14 concepts in five widely used frameworks suggests that the technique is effective in producing templates with relatively few false positives and false negatives for realistic concepts by using two sample applications. Moreover, we observed in a user study with 28 programmers that the use of templates reduced the concept-implementation time compared to when documentation was used.","1939-3520","","10.1109/TSE.2011.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5975174","Object-oriented application frameworks;framework comprehension;framework documentation;concept-implementation templates;application programming interface (API);dynamic analysis;concept location;feature identification","Dynamic programming;Feature extraction;Documentation;Java;Application programming interfaces;Runtime","application program interfaces;object-oriented methods","framework-usage template extraction;dynamic traces;object-oriented frameworks;application code;subclassing operation;interface implementation;calling framework operations;user documentation;code tangling;code scattering;concept-implementation templates;concept-implementation steps;FUDA templates;framework API understanding through dynamic analysis","","7","","68","","4 Aug 2011","","","IEEE","IEEE Journals"
"Analyzing the Effect of Gain Time on Soft-Task Scheduling Policies in Real-Time Systems","L. Búrdalo; A. Terrasa; A. Espinosa; A. García-Fornes","Universitat Politèecnica de València, Valencia; Universitat Politèecnica de València, Valencia; Universitat Politèecnica de València, Valencia; Universitat Politèecnica de València, Valencia","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1305","1318","In hard real-time systems, gain time is defined as the difference between the Worst Case Execution Time (WCET) of a hard task and its actual processor consumption at runtime. This paper presents the results of an empirical study about how the presence of a significant amount of gain time in a hard real-time system questions the advantages of using the most representative scheduling algorithms or policies for aperiodic or soft tasks in fixed-priority preemptive systems. The work presented here refines and complements many other studies in this research area in which such policies have been introduced and compared. This work has been performed by using the authors' testing framework for soft scheduling policies, which produces actual, synthetic, randomly generated applications, executes them in an instrumented Real-Time Operating System (RTOS), and finally processes this information to obtain several statistical outcomes. The results show that, in general, the presence of a significant amount of gain time reduces the performance benefit of the scheduling policies under study when compared to serving the soft tasks in background, which is considered the theoretical worst case. In some cases, this performance benefit is so small that the use of a specific scheduling policy for soft tasks is questionable.","1939-3520","","10.1109/TSE.2011.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6025357","Real-time systems;RT-Linux;scheduling policies","Real time systems;Servers;Time factors;Generators;Scheduling;Heuristic algorithms;Decision support systems","operating systems (computers);real-time systems;scheduling","gain time;soft-task scheduling policies;hard real-time systems;worst case execution time;WCET;processor consumption;representative scheduling algorithms;aperiodic tasks;fixed-priority preemptive systems;author testing framework;instrumented real-time operating system;RTOS;statistical outcomes","","3","","31","","23 Sep 2011","","","IEEE","IEEE Journals"
"Exploiting Model Morphology for Event-Based Testing","F. Belli; M. Beyazıt","Department of Electrical Engineering and Information Technology, University of Paderborn, Paderborn, Germany; Department of Computer Engineering, Yaşar University, İzmir, Turkey","IEEE Transactions on Software Engineering","10 Feb 2015","2015","41","2","113","134","Model-based testing employs models for testing. Model-based mutation testing (MBMT) additionally involves fault models, called mutants, by applying mutation operators to the original model. A problem encountered with MBMT is the elimination of equivalent mutants and multiple mutants modeling the same faults. Another problem is the need to compare a mutant to the original model for test generation. This paper proposes an event-based approach to MBMT that is not fixed on single events and a single model but rather operates on sequences of events of length k ≥ 1 and invokes a sequence of models that are derived from the original one by varying its morphology based on k. The approach employs formal grammars, related mutation operators, and algorithms to generate test cases, enabling the following: (1) the exclusion of equivalent mutants and multiple mutants; (2) the generation of a test case in linear time to kill a selected mutant without comparing it to the original model; (3) the analysis of morphologically different models enabling the systematic generation of mutants, thereby extending the set of fault models studied in related literature. Three case studies validate the approach and analyze its characteristics in comparison to random testing and another MBMT approach.","1939-3520","","10.1109/TSE.2014.2360690","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6915728","Model-based mutation testing;grammar-based testing;mutant selection;Model-based mutation testing;grammar-based testing;(model) morphology;mutant selection;test generation","Grammar;Testing;Unified modeling language;Production;Context;Morphology;Analytical models","computational complexity;grammars;program testing","model morphology;event-based testing;model-based mutation testing;MBMT;fault models;mutants;mutation operators;test generation;event-based approach;formal grammars;equivalent mutant;multiple mutants;linear time;random testing","","5","","68","","2 Oct 2014","","","IEEE","IEEE Journals"
"An Experience in Testing the Security of Real-World Electronic Voting Systems","D. Balzarotti; G. Banks; M. Cova; V. Felmetsger; R. Kemmerer; W. Robertson; F. Valeur; G. Vigna","Eurecom Institute, Sophia Antipolis, France; University of California, Santa Barbara, Santa Barbara; University of California, Santa Barbara, Santa Barbara; University of California, Santa Barbara, Santa Barbara; University of California, Santa Barbara, Santa Barbara; University of California, Santa Barbara, Santa Barbara; University of California, Santa Barbara, Santa Barbara; University of California, Santa Barbara, Santa Barbara","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","453","473","Voting is the process through which a democratic society determines its government. Therefore, voting systems are as important as other well-known critical systems, such as air traffic control systems or nuclear plant monitors. Unfortunately, voting systems have a history of failures that seems to indicate that their quality is not up to the task. Because of the alarming frequency and impact of the malfunctions of voting systems, in recent years a number of vulnerability analysis exercises have been carried out against voting systems to determine if they can be compromised in order to control the results of an election. We have participated in two such large-scale projects, sponsored by the Secretaries of State of California and Ohio, whose goals were to perform the security testing of the electronic voting systems used in their respective states. As the result of the testing process, we identified major vulnerabilities in all of the systems analyzed. We then took advantage of a combination of these vulnerabilities to generate a series of attacks that would spread across the voting systems and would “steal” votes by combining voting record tampering with social engineering approaches. As a response to the two large-scale security evaluations, the Secretaries of State of California and Ohio recommended changes to improve the security of the voting process. In this paper, we describe the methodology that we used in testing the two real-world electronic voting systems we evaluated, the findings of our analysis, our attacks, and the lessons we learned.","1939-3520","","10.1109/TSE.2009.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5210119","Voting systems;security testing;vulnerability analysis.","Electronic equipment testing;System testing;Security;Electronic voting systems;Large-scale systems;Government;Air traffic control;History;Frequency;Control systems","data privacy;government data processing;security of data","security testing;electronic voting system;alarming frequency;vulnerability analysis exercise;California;Ohio;social engineering approache;large scale security evaluation","","26","","62","","21 Aug 2009","","","IEEE","IEEE Journals"
"Balancing Privacy and Utility in Cross-Company Defect Prediction","F. Peters; T. Menzies; L. Gong; H. Zhang","West Virginia University, Morgantown; West Virginia University, Morgantown; Tsinghua University, Beijing; Tsinghua University, Beijing","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1054","1068","Background: Cross-company defect prediction (CCDP) is a field of study where an organization lacking enough local data can use data from other organizations for building defect predictors. To support CCDP, data must be shared. Such shared data must be privatized, but that privatization could severely damage the utility of the data. Aim: To enable effective defect prediction from shared data while preserving privacy. Method: We explore privatization algorithms that maintain class boundaries in a dataset. CLIFF is an instance pruner that deletes irrelevant examples. MORPH is a data mutator that moves the data a random distance, taking care not to cross class boundaries. CLIFF+MORPH are tested in a CCDP study among 10 defect datasets from the PROMISE data repository. Results: We find: 1) The CLIFFed+MORPHed algorithms provide more privacy than the state-of-the-art privacy algorithms; 2) in terms of utility measured by defect prediction, we find that CLIFF+MORPH performs significantly better. Conclusions: For the OO defect data studied here, data can be privatized and shared without a significant degradation in utility. To the best of our knowledge, this is the first published result where privatization does not compromise defect prediction.","1939-3520","","10.1109/TSE.2013.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6419712","Privacy;classification;defect prediction","Testing;Software;Genetic algorithms;Sociology;Statistics;Search problems;Arrays","data privacy;program debugging","privacy balancing;utility balancing;cross-company defect prediction;CCDP;defect predictors;privacy preservation;privatization algorithms;class boundaries;pruner;data mutator;PROMISE data repository;CLIFFed-MORPHed algorithm;OO defect data","","70","","58","","24 Jan 2013","","","IEEE","IEEE Journals"
"Reducing Features to Improve Code Change-Based Bug Prediction","S. Shivaji; E. James Whitehead; R. Akella; S. Kim","University of California, Santa Cruz, Santa Cruz; University of California, Santa Cruz, Santa Cruz; University of California, Santa Cruz, Santa Cruz; Hong Kong University of Science and, Hong Kong","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","552","569","Machine learning classifiers have recently emerged as a way to predict the introduction of bugs in changes made to source code files. The classifier is first trained on software history, and then used to predict if an impending change causes a bug. Drawbacks of existing classifier-based bug prediction techniques are insufficient performance for practical use and slow prediction times due to a large number of machine learned features. This paper investigates multiple feature selection techniques that are generally applicable to classification-based bug prediction methods. The techniques discard less important features until optimal classification performance is reached. The total number of features used for training is substantially reduced, often to less than 10 percent of the original. The performance of Naive Bayes and Support Vector Machine (SVM) classifiers when using this technique is characterized on 11 software projects. Naive Bayes using feature selection provides significant improvement in buggy F-measure (21 percent improvement) over prior change classification bug prediction results (by the second and fourth authors [28]). The SVM's improvement in buggy F-measure is 9 percent. Interestingly, an analysis of performance for varying numbers of features shows that strong performance is achieved at even 1 percent of the original number of features.","1939-3520","","10.1109/TSE.2012.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226427","Reliability;bug prediction;machine learning;feature selection","Software;Support vector machines;History;Machine learning;Feature extraction;Measurement;Computer bugs","belief networks;learning (artificial intelligence);pattern classification;program debugging;support vector machines","code change-based bug prediction;machine learning classifier;source code file;software history;classifier-based bug prediction;machine learned feature reduction;feature selection technique;classification performance;naive Bayes classifier;support vector machine;SVM classifier;software project;buggy F-measure","","118","","53","","26 Jun 2012","","","IEEE","IEEE Journals"
"Linking Model-Driven Development and Software Architecture: A Case Study","A. Mattsson; B. Lundell; B. Lings; B. Fitzgerald","Combitech AB, Jönköping; University of Skövde, Skövde; University of Skövde, Skövde; Univerity of Limerick, Limerick","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","83","93","A basic premise of model driven development (MDD) is to capture all important design information in a set of formal or semi-formal models which are then automatically kept consistent by tools. The concept however is still relatively immature and there is little by way of empirically validated guidelines. In this paper we report on the use of MDD on a significant real-world project over several years. Our research found the MDD approach to be deficient in terms of modelling architectural design rules. Furthermore, the current body of literature does not offer a satisfactory solution as to how architectural design rules should be modelled. As a result developers have to rely on time-consuming and error-prone manual practices to keep a system consistent with its architecture. To realise the full benefits of MDD it is important to find ways of formalizing architectural design rules which then allow automatic enforcement of the architecture on the system model. Without this, architectural enforcement will remain a bottleneck in large MDD projects.","1939-3520","","10.1109/TSE.2008.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4657364","Software Architecture;Model-Driven Development;Case Study Research;Software Architecture;Model-Driven Development;Case Study Research","Joining processes;Software architecture;Computer architecture;Guidelines;Context modeling;Computer industry;Computer errors;Programming;Keyword search;Portals","formal verification;software architecture;systems analysis","model-driven development;software architecture;formal models;semi-formal models;architectural design rules","","25","2","55","","24 Oct 2008","","","IEEE","IEEE Journals"
"Toward a Tool-Based Development Methodology for Pervasive Computing Applications","D. Cassou; J. Bruneau; C. Consel; E. Balland","University of Bordeaux and INRIA, Talence; University of Bordeaux and INRIA, Talence; University of Bordeaux and INRIA, Talence; University of Bordeaux and INRIA, Talence","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1445","1463","Despite much progress, developing a pervasive computing application remains a challenge because of a lack of conceptual frameworks and supporting tools. This challenge involves coping with heterogeneous devices, overcoming the intricacies of distributed systems technologies, working out an architecture for the application, encoding it in a program, writing specific code to test the application, and finally deploying it. This paper presents a design language and a tool suite covering the development life-cycle of a pervasive computing application. The design language allows us to define a taxonomy of area-specific building-blocks, abstracting over their heterogeneity. This language also includes a layer to define the architecture of an application, following an architectural pattern commonly used in the pervasive computing domain. Our underlying methodology assigns roles to the stakeholders, providing separation of concerns. Our tool suite includes a compiler that takes design artifacts written in our language as input and generates a programming framework that supports the subsequent development stages, namely, implementation, testing, and deployment. Our methodology has been applied on a wide spectrum of areas. Based on these experiments, we assess our approach through three criteria: expressiveness, usability, and productivity.","1939-3520","","10.1109/TSE.2011.107","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6051438","Methodology;domain-specific language;generative programming;pervasive computing;toolkit;programming support;simulation","Pervasive computing;Taxonomy;Computer architecture;Programming;Domain specific languages;Computational modeling;Software architecture","program compilers;software architecture;ubiquitous computing","tool-based development methodology;pervasive computing applications;distributed systems technologies;development life-cycle;area-specific building-blocks;architectural pattern;compiler;design artifacts","","30","","53","","18 Oct 2011","","","IEEE","IEEE Journals"
"Compositional Verification for Hierarchical Scheduling of Real-Time Systems","L. Carnevali; A. Pinzuti; E. Vicario",Università di Firenze; Università di Firenze; Università di Firenze,"IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","638","657","Hierarchical Scheduling (HS) techniques achieve resource partitioning among a set of real-time applications, providing reduction of complexity, confinement of failure modes, and temporal isolation among system applications. This facilitates compositional analysis for architectural verification and plays a crucial role in all industrial areas where high-performance microprocessors allow growing integration of multiple applications on a single platform. We propose a compositional approach to formal specification and schedulability analysis of real-time applications running under a Time Division Multiplexing (TDM) global scheduler and preemptive Fixed Priority (FP) local schedulers, according to the ARINC-653 standard. As a characterizing trait, each application is made of periodic, sporadic, and jittering tasks with offsets, jitters, and nondeterministic execution times, encompassing intra-application synchronizations through semaphores and mailboxes and interapplication communications among periodic tasks through message passing. The approach leverages the assumption of a TDM partitioning to enable compositional design and analysis based on the model of preemptive Time Petri Nets (pTPNs), which is expressly extended with a concept of Required Interface (RI) that specifies the embedding environment of an application through sequencing and timing constraints. This enables exact verification of intra-application constraints and approximate but safe verification of interapplication constraints. Experimentation illustrates results and validates their applicability on two challenging workloads in the field of safety-critical avionic systems.","1939-3520","","10.1109/TSE.2012.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6264049","Real-time systems;hierarchical scheduling;ARINC-653;time division multiplexing;preemptive fixed priority;compositional verification;preemptive time Petri nets;symbolic state-space analysis","Real time systems;Complexity theory;Time division multiplexing;Job shop scheduling;Timing;Resource management;Petri nets","aerospace computing;formal verification;message passing;microprocessor chips;Petri nets;resource allocation;safety-critical software;scheduling","compositional verification;hierarchical scheduling;realtime system;HS technique;resource partitioning;compositional analysis;architectural verification;high-performance microprocessor;formal specification;schedulability analysis;time division multiplexing;TDM global scheduler;preemptive fixed priority local scheduler;FP local scheduler;ARINC-653 standard;periodic task;sporadic task;jittering task;nondeterministic execution time;intra-application synchronization;interapplication communication;message passing;semaphore;mailbox;compositional design;preemptive time Petri nets model;required interface concept;RI concept;sequencing constraint;timing constraint;safety-critical avionic system","","29","","41","","9 Aug 2012","","","IEEE","IEEE Journals"
"Learning a Metric for Code Readability","R. P. L. Buse; W. R. Weimer","University of Virginia, Charlottesville; University of Virginia, Charlottesville","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","546","558","In this paper, we explore the concept of code readability and investigate its relation to software quality. With data collected from 120 human annotators, we derive associations between a simple set of local code features and human notions of readability. Using those features, we construct an automated readability measure and show that it can be 80 percent effective and better than a human, on average, at predicting readability judgments. Furthermore, we show that this metric correlates strongly with three measures of software quality: code changes, automated defect reports, and defect log messages. We measure these correlations on over 2.2 million lines of code, as well as longitudinally, over many releases of selected projects. Finally, we discuss the implications of this study on programming language design and engineering practice. For example, our data suggest that comments, in and of themselves, are less important than simple blank lines to local judgments of readability.","1939-3520","","10.1109/TSE.2009.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5332232","Software readability;program understanding;machine learning;software maintenance;code metrics;FindBugs.","Software quality;Humans;Software maintenance;Readability metrics;Documentation;Software measurement;Computer languages;Design engineering;Machine learning;Costs","human factors;software quality","code readability;software quality;local code features;human notions;code changes;automated defect reports;defect log messages;programming language design","","115","","41","","13 Nov 2009","","","IEEE","IEEE Journals"
"SITAR: GUI Test Script Repair","Z. Gao; Z. Chen; Y. Zou; A. M. Memon","State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China; State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China; State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China; Department of Computer Science, University of Maryland, College Park, MD, USA","IEEE Transactions on Software Engineering","11 Feb 2016","2016","42","2","170","186","System testing of a GUI-based application requires that test cases, consisting of sequences of user actions/events, be executed and the software's output be verified. To enable automated re-testing, such test cases are increasingly being coded as low-level test scripts, to be replayed automatically using test harnesses. Whenever the GUI changes-widgets get moved around, windows get merged-some scripts become unusable because they no longer encode valid input sequences. Moreover, because the software's output may have changed, their test oracles-assertions and checkpoints-encoded in the scripts may no longer correctly check the intended GUI objects. We present ScrIpT repAireR (SITAR), a technique to automatically repair unusable low-level test scripts. SITAR uses reverse engineering techniques to create an abstract test for each script, maps it to an annotated event-flow graph (EFG), uses repairing transformations and human input to repair the test, and synthesizes a new “repaired” test script. During this process, SITAR also repairs the reference to the GUI objects used in the checkpoints yielding a final test script that can be executed automatically to validate the revised software. SITAR amortizes the cost of human intervention across multiple scripts by accumulating the human knowledge as annotations on the EFG. An experiment using QTP test scripts suggests that SITAR is effective in that 41-89 percent unusable test scripts were repaired. Annotations significantly reduced human cost after 20 percent test scripts had been repaired.","1939-3520","","10.1109/TSE.2015.2454510","National Basic Research Program of China; NSFC; US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7214294","GUI testing;GUI test script;test script repair;human knowledge accumulation;GUI testing;GUI test script;test script repair;human knowledge accumulation","Maintenance engineering;Graphical user interfaces;Software;Testing;Automation;Computational modeling;Electronic mail","graph theory;graphical user interfaces;program testing;software maintenance","SITAR;test script repairer;graphical user interface;GUI-based application;system testing;automated retesting;event-flow graph;EFG;software validation","","18","","32","","20 Aug 2015","","","IEEE","IEEE Journals"
"Supporting Self-Adaptation via Quantitative Verification and Sensitivity Analysis at Run Time","A. Filieri; G. Tamburrelli; C. Ghezzi","Reliable Software Systems Group, University of Stuttgart, Stuttgart, Germany; Vrije University of Amsterdam, Netherlands; Dipartimento di Elettronica, Informazione e Bioingegneria at Politecnico di Milano, Milan, Italy","IEEE Transactions on Software Engineering","7 Jan 2016","2016","42","1","75","99","Modern software-intensive systems often interact with an environment whose behavior changes over time, often unpredictably. The occurrence of changes may jeopardize their ability to meet the desired requirements. It is therefore desirable to design software in a way that it can self-adapt to the occurrence of changes with limited, or even without, human intervention. Self-adaptation can be achieved by bringing software models and model checking to run time, to support perpetual automatic reasoning about changes. Once a change is detected, the system itself can predict if requirements violations may occur and enable appropriate counter-actions. However, existing mainstream model checking techniques and tools were not conceived for run-time usage; hence they hardly meet the constraints imposed by on-the-fly analysis in terms of execution time and memory usage. This paper addresses this issue and focuses on perpetual satisfaction of non-functional requirements, such as reliability or energy consumption. Its main contribution is the description of a mathematical framework for run-time efficient probabilistic model checking. Our approach statically generates a set of verification conditions that can be efficiently evaluated at run time as soon as changes occur. The proposed approach also supports sensitivity analysis, which enables reasoning about the effects of changes and can drive effective adaptation strategies.","1939-3520","","10.1109/TSE.2015.2421318","European Commission; Programme IDEAS-ERC; Project 227977-SMScom; Programme FP7-PEOPLE-2011-IEF; Project 302648-RunMore; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7083754","Self-adaptive Systems;Software Evolution;Non-functional Requirements;Discrete-Time Markov models;Rewards;Software Reliability;Costs;Probabilistic Model Checking;Models at Runtime;Self-adaptive systems;software evolution;non-functional requirements;discrete-time Markov models;rewards;software reliability;costs;probabilistic model checking;models at runtime","Model checking;Adaptation models;Software;Markov processes;Probabilistic logic;Computational modeling;Reliability","probability;program verification;software reliability","self-adaptation;quantitative verification;run time analysis;software-intensive systems;software design;software models;perpetual automatic reasoning;requirements violation;on-the-fly analysis;execution time;memory usage;perpetual satisfaction;nonfunctional requirements;mathematical framework;probabilistic model checking;sensitivity analysis","","59","","91","","9 Apr 2015","","","IEEE","IEEE Journals"
"On the Distribution of Bugs in the Eclipse System","G. Concas; M. Marchesi; A. Murgia; R. Tonelli; I. Turnu","University of Cagliari, Cagliari; University of Cagliari, Cagliari; University of Cagliari, Cagliari; University of Cagliari, Cagliari; University of Cagliari, Cagliari","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","872","877","The distribution of bugs in software systems has been shown to satisfy the Pareto principle, and typically shows a power-law tail when analyzed as a rank-frequency plot. In a recent paper, Zhang showed that the Weibull cumulative distribution is a very good fit for the Alberg diagram of bugs built with experimental data. In this paper, we further discuss the subject from a statistical perspective, using as case studies five versions of Eclipse, to show how log-normal, Double-Pareto, and Yule-Simon distributions may fit the bug distribution at least as well as the Weibull distribution. In particular, we show how some of these alternative distributions provide both a superior fit to empirical data and a theoretical motivation to be used for modeling the bug generation process. While our results have been obtained on Eclipse, we believe that these models, in particular the Yule-Simon one, can generalize to other software systems.","1939-3520","","10.1109/TSE.2011.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928349","Software bug distribution;empirical research;object-oriented systems.","Computer bugs;Software systems;Data models;Computational modeling;Weibull distribution;Object oriented modeling","eclipses;Pareto analysis;Weibull distribution","software systems;Pareto principle;Weibull cumulative distribution;statistical perspective;eclipse system","","26","","22","","23 Jun 2011","","","IEEE","IEEE Journals"
"BURN: Enabling Workload Burstiness in Customized Service Benchmarks","G. Casale; A. Kalbasi; D. Krishnamurthy; J. Rolia","Imperial College London, London; University of Calgary, Calgary; University of Calgary, Calgary; HP Labs, Palo Alto","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","778","793","We introduce BURN, a methodology to create customized benchmarks for testing multitier applications under time-varying resource usage conditions. Starting from a set of preexisting test workloads, BURN finds a policy that interleaves their execution to stress the multitier application and generate controlled burstiness in resource consumption. This is useful to study, in a controlled way, the robustness of software services to sudden changes in the workload characteristics and in the usage levels of the resources. The problem is tackled by a model-based technique which first generates Markov models to describe resource consumption patterns of each test workload. Then, a policy is generated using an optimization program which sets as constraints a target request mix and user-specified levels of burstiness at the different resources in the system. Burstiness is quantified using a novel metric called overdemand, which describes in a natural way the tendency of a workload to keep a resource congested for long periods of time and across multiple requests. A case study based on a three-tier application testbed shows that our method is able to control and predict burstiness for session service demands at a fine-grained scale. Furthermore, experiments demonstrate that for any given request mix our approach can expose latency and throughput degradations not found with nonbursty workloads having the same request mix.","1939-3520","","10.1109/TSE.2011.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928353","Benchmarking;performance;burstiness;bottleneck migration;overdemand","Benchmark testing;Markov processes;Servers;Aggregates;Analytical models;Computational modeling;Linear regression","benchmark testing;Markov processes","BURN;workload burstiness;customized service benchmarks;customized benchmarks;multitier application;time-varying resource usage condition;controlled burstiness;software services;model-based technique;Markov models;resource consumption pattern;optimization program;target request mix;user-specified levels;three-tier application testbed;session service demands;fine-grained scale;latency;throughput degradation;nonbursty workloads","","9","","38","","23 Jun 2011","","","IEEE","IEEE Journals"
"The Oracle Problem in Software Testing: A Survey","E. T. Barr; M. Harman; P. McMinn; M. Shahbaz; S. Yoo","Department of Computer Science, University College London, Gower Street, London WC2R 2LS, London, United Kingdom; Department of Computer Science, University College London, Gower Street, London WC2R 2LS, London, United Kingdom; Department of Computer Science, University of Sheffield, Sheffield S1 4DP, South Yorkshire, United Kingdom; Department of Computer Science, University of Sheffield, Sheffield S1 4DP, South Yorkshire, United Kingdom; Department of Computer Science, University College London, Gower Street, London WC2R 2LS, London, United Kingdom","IEEE Transactions on Software Engineering","12 May 2015","2015","41","5","507","525","Testing involves examining the behaviour of a system in order to discover potential faults. Given an input for a system, the challenge of distinguishing the corresponding desired, correct behaviour from potentially incorrect behavior is called the “test oracle problem”. Test oracle automation is important to remove a current bottleneck that inhibits greater overall test automation. Without test oracle automation, the human has to determine whether observed behaviour is correct. The literature on test oracles has introduced techniques for oracle automation, including modelling, specifications, contract-driven development and metamorphic testing. When none of these is completely adequate, the final source of test oracle information remains the human, who may be aware of informal specifications, expectations, norms and domain specific information that provide informal oracle guidance. All forms of test oracles, even the humble human, involve challenges of reducing cost and increasing benefit. This paper provides a comprehensive survey of current approaches to the test oracle problem and an analysis of trends in this important area of software testing research and practice.","1939-3520","","10.1109/TSE.2014.2372785","Engineering and Physical Sciences Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6963470","Test oracle;Automatic testing;Testing formalism;Test oracle;automatic testing;testing formalism","Probabilistic logic;Licenses;Automation;Software testing;Market research;Reliability","formal specification;program testing","test oracle problem;test oracle information;informal specifications;domain specific information;informal oracle guidance;software testing research;software testing practice;oracle automation;contract-driven development;metamorphic testing;oracle automation","","272","","211","","20 Nov 2014","","","IEEE","IEEE Journals"
"Enhanced Code Conversion Approach for the Integrated Cross-Platform Mobile Development (ICPMD)","W. S. El-Kassas; B. A. Abdullah; A. H. Yousef; A. M. Wahba","Department of Computer and Systems Engineering, Faculty of Engineering, Ain Shams University, Cairo, Egypt; Department of Computer and Systems Engineering, Faculty of Engineering, Ain Shams University, Cairo, Egypt; Department of Computer and Systems Engineering, Faculty of Engineering, Ain Shams University, Cairo, Egypt; Department of Computer and Systems Engineering, Faculty of Engineering, Ain Shams University, Cairo, Egypt","IEEE Transactions on Software Engineering","10 Nov 2016","2016","42","11","1036","1053","Mobile development companies aim to maximize the return on investments by making their mobile applications (Apps) available on different mobile platforms. Consequently, the same App is developed several times; each time the developer uses the programming languages and development tools of a specific platform. Therefore, there is a need to have cross-platform mobile applications development solutions that enable the developers to develop the App once and run it everywhere. The Integrated Cross-Platform Mobile Applications Development (ICPMD) solution is one of the attempts that enables the developers to use the most popular programming languages like Java for Android and C# for Windows Phone 8 (WP8). ICPMD is used to transform both the source code and user interface to another language to generate full Apps on the target platform. This paper extends ICPMD by proposing a new code conversion approach based on XSLT and Regular Expressions to ease the conversion process. In addition, it provides the assessment method to compare the ICPMD efficiency with competing approaches. Several Apps are converted from WP8 to Android and vice versa. The ICPMD evaluation results show reasonable improvement over commercial cross-platform mobile development tools (Titanium and Xamarin).","1939-3520","","10.1109/TSE.2016.2543223","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7442177","Cross-platform mobile development;code conversion;code reuse;generated apps;ICPMD, source code patterns","Mobile communication;Java;Runtime;Titanium;Application programming interfaces;Smart phones","Android (operating system);mobile computing;programming languages;smart phones;software tools;source code (software);user interfaces","code conversion;integrated cross-platform mobile development;ICPMD;mobile application development;mobile platform;programming language;development tool;source code;user interface;smart phone","","10","","39","","25 Mar 2016","","","IEEE","IEEE Journals"
"Quality Requirements in Industrial Practice—An Extended Interview Study at Eleven Companies","R. Berntsson Svensson; T. Gorschek; B. Regnell; R. Torkar; A. Shahrokni; R. Feldt","Lund University, Lund; Blekinge Institute of Technology, Karlskrona; Lund University, Lund; Blekinge Institute of Technology, Karlskrona; Chalmers University of Technology, Göteborg; Chalmers University of Technology, Göteborg","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","923","935","In order to create a successful software product and assure its quality, it is not enough to fulfill the functional requirements, it is also crucial to find the right balance among competing quality requirements (QR). An extended, previously piloted, interview study was performed to identify specific challenges associated with the selection, tradeoff, and management of QR in industrial practice. Data were collected through semistructured interviews with 11 product managers and 11 project leaders from 11 software companies. The contribution of this study is fourfold: First, it compares how QR are handled in two cases, companies working in business-to-business markets and companies that are working in business-to-consumer markets. These two are also compared in terms of impact on the handling of QR. Second, it compares the perceptions and priorities of QR by product and project management, respectively. Third, it includes an examination of the interdependencies among quality requirements perceived as most important by the practitioners. Fourth, it characterizes the selection and management of QR in downstream development activities.","1939-3520","","10.1109/TSE.2011.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5753901","Management;process;requirements/specifications","Companies;Interviews;Industries;Usability;Telecommunications;Reliability","DP industry;project management;software management;software quality","quality requirements;industrial practice;software product;software quality;QR selection;QR tradeoff;QR management;software company;business-to-business market;business-to-consumer market;project management;QR handling","","37","","40","","21 Apr 2011","","","IEEE","IEEE Journals"
"An Empirical Evaluation of Mutation Testing for Improving the Test Quality of Safety-Critical Software","R. Baker; I. Habli","Aero Engine Controls, Birmingham; University of York, York","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","787","805","Testing provides a primary means for assuring software in safety-critical systems. To demonstrate, particularly to a certification authority, that sufficient testing has been performed, it is necessary to achieve the test coverage levels recommended or mandated by safety standards and industry guidelines. Mutation testing provides an alternative or complementary method of measuring test sufficiency, but has not been widely adopted in the safety-critical industry. In this study, we provide an empirical evaluation of the application of mutation testing to airborne software systems which have already satisfied the coverage requirements for certification. Specifically, we apply mutation testing to safety-critical software developed using high-integrity subsets of C and Ada, identify the most effective mutant types, and analyze the root causes of failures in test cases. Our findings show how mutation testing could be effective where traditional structural coverage analysis and manual peer review have failed. They also show that several testing issues have origins beyond the test activity, and this suggests improvements to the requirements definition and coding process. Our study also examines the relationship between program characteristics and mutation survival and considers how program size can provide a means for targeting test areas most likely to have dormant faults. Industry feedback is also provided, particularly on how mutation testing can be integrated into a typical verification life cycle of airborne software.","1939-3520","","10.1109/TSE.2012.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6298894","Mutation;safety-critical software;verification;testing;certification","Testing;Certification;Software systems;Safety;Industries;Guidelines","Ada;aerospace computing;C language;certification;integrated software;program testing;program verification;safety-critical software;software quality","software test quality;safety-critical software;test coverage level;safety standard;industry guideline;test sufficiency measurement;empirical evaluation;mutation testing;airborne software system;certification;coverage requirement satisfaction;C;Ada;software integration;mutant type;software failure;structural coverage analysis;coding process;verification life cycle","","30","","41","","11 Sep 2012","","","IEEE","IEEE Journals"
"Composite Constant Propagation and its Application to Android Program Analysis","D. Octeau; D. Luchaup; S. Jha; P. McDaniel","Department of Computer Sciences, University of Wisconsin, Madison, WI; CyLab, Carnegie Mellon University, Pittsburgh, PA; Department of Computer Sciences, University of Wisconsin, Madison, WI; Department of Computer Science and Engineering, Pennsylvania State University, University Park, PA","IEEE Transactions on Software Engineering","10 Nov 2016","2016","42","11","999","1014","Many program analyses require statically inferring the possible values of composite types. However, current approaches either do not account for correlations between object fields or do so in an ad hoc manner. In this paper, we introduce the problem of composite constant propagation. We develop the first generic solver that infers all possible values of complex objects in an interprocedural, flow and context-sensitive manner, taking field correlations into account. Composite constant propagation problems are specified using COAL, a declarative language. We apply our COAL solver to the problem of inferring Android Inter-Component Communication (ICC) values, which is required to understand how the components of Android applications interact. Using COAL, we model ICC objects in Android more thoroughly than the state-of-the-art. We compute ICC values for 489 applications from the Google Play store. The ICC values we infer are substantially more precise than previous work. The analysis is efficient, taking two minutes per application on average. While this work can be used as the basis for many whole-program analyses of Android applications, the COAL solver can also be used to infer the values of composite objects in many other contexts.","1939-3520","","10.1109/TSE.2016.2550446","National Science Foundation; National Science Foundation; Google; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7447806","Composite constant;constant propagation;inter-component communication;ICC;Android application analysis","Androids;Humanoid robots;Coal;Correlation;Context;Object oriented modeling;Receivers","Android (operating system);mobile computing;program diagnostics","composite constant propagation;Android program analysis;COAL declarative language;Android inter-component communication value;ICC values;Google Play Store;whole-program analysis;Android applications","","11","","44","","5 Apr 2016","","","IEEE","IEEE Journals"
"Who Will Stay in the FLOSS Community? Modeling Participant’s Initial Behavior","M. Zhou; A. Mockus","School of Electronics Engineering and Computer Science, Peking University and Key Laboratory of High Confidence Software Technologies, Ministry of Education, Beijing, China; Department of Electrical Engineering and Computer Science, University of Tennessee, Min H. Kao Building, Room 613, 1520 Middle Drive, Knoxville, TN","IEEE Transactions on Software Engineering","7 Jan 2015","2015","41","1","82","99","Motivation: To survive and succeed, FLOSS projects need contributors able to accomplish critical project tasks. However, such tasks require extensive project experience of long term contributors (LTCs). Aim: We measure, understand, and predict how the newcomers' involvement and environment in the issue tracking system (ITS) affect their odds of becoming an LTC. Method: ITS data of Mozilla and Gnome, literature, interviews, and online documents were used to design measures of involvement and environment. A logistic regression model was used to explain and predict contributor's odds of becoming an LTC. We also reproduced the results on new data provided by Mozilla. Results: We constructed nine measures of involvement and environment based on events recorded in an ITS. Macro-climate is the overall project environment while micro-climate is person-specific and varies among the participants. Newcomers who are able to get at least one issue reported in the first month to be fixed, doubled their odds of becoming an LTC. The macro-climate with high project popularity and the micro-climate with low attention from peers reduced the odds. The precision of LTC prediction was 38 times higher than for a random predictor. We were able to reproduce the results with new Mozilla data without losing the significance or predictive power of the previously published model. We encountered unexpected changes in some attributes and suggest ways to make analysis of ITS data more reproducible. Conclusions: The findings suggest the importance of initial behaviors and experiences of new participants and outline empirically-based approaches to help the communities with the recruitment of contributors for long-term participation and to help the participants contribute more effectively. To facilitate the reproduction of the study and of the proposed measures in other contexts, we provide the data we retrieved and the scripts we wrote at https://www.passion-lab.org/projects/developerfluency.html.","1939-3520","","10.1109/TSE.2014.2349496","National Basic Research Program of China; National Natural Science Foundation of China; National Hi-Tech Research and Development Program of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6880395","Long term contributor;open source software;issue tracking system;mining software repository;extent of involvement;interaction with environment;initial behavior","Communities;Atmospheric measurements;Particle measurements;Predictive models;Data models;Data mining;Electronic mail","behavioural sciences;project management;public domain software","Free-Libre and/or open source software projects;open source software;Mozilla data;microclimate;macroclimate;logistic regression model;Gnome;ITS data;issue tracking system;LTC;long term contributors;critical project;FLOSS community","","36","","47","","19 Aug 2014","","","IEEE","IEEE Journals"
"A Data Mining Approach for Detecting Higher-Level Clones in Software","H. A. Basit; S. Jarzabek","Lahore University of Management Sciences, Lahore; National University of Singapore, Singapore","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","497","514","Code clones are similar program structures recurring in variant forms in software system(s). Several techniques have been proposed to detect similar code fragments in software, so-called simple clones. Identification and subsequent unification of simple clones is beneficial in software maintenance. Even further gains can be obtained by elevating the level of code clone analysis. We observed that recurring patterns of simple clones often indicate the presence of interesting higher-level similarities that we call structural clones. Structural clones show a bigger picture of similarity situation than simple clones alone. Being logical groups of simple clones, structural clones alleviate the problem of huge number of clones typically reported by simple clone detection tools, a problem that is often dealt with postdetection visualization techniques. Detection of structural clones can help in understanding the design of the system for better maintenance and in reengineering for reuse, among other uses. In this paper, we propose a technique to detect some useful types of structural clones. The novelty of our approach includes the formulation of the structural clone concept and the application of data mining techniques to detect these higher-level similarities. We describe a tool called clone miner that implements our proposed technique. We assess the usefulness and scalability of the proposed techniques via several case studies. We discuss various usage scenarios to demonstrate in what ways the knowledge of structural clones adds value to the analysis based on simple clones alone.","1939-3520","","10.1109/TSE.2009.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4796208","Design concepts;maintainability;restructuring;reverse engineering;reengineering;reusable software.","Data mining;Cloning;Software systems;Software maintenance;Collaboration;Portals;Computer Society;Visualization;Scalability;Reverse engineering","data mining;software maintenance;software reusability","data mining approach;higher-level clone detection;program structures;software system;software maintenance;code clone analysis;postdetection visualization techniques;software reusability","","64","1","53","","27 Feb 2009","","","IEEE","IEEE Journals"
"A Comprehensive Approach to Naming and Accessibility in Refactoring Java Programs","M. Schäfer; A. Thies; F. Steimann; F. Tip","IBM T.J. Watson Research Center, Hawthorne; Fernuniversität in Hagen, Hagen; Fernuniversität in Hagen, Hagen; IBM, Hawthorne","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1233","1257","Automated tool support for refactoring is now widely available for mainstream programming languages such as Java. However, current refactoring tools are still quite fragile in practice and often fail to preserve program behavior or compilability. This is mainly because analyzing and transforming source code requires consideration of many language features that complicate program analysis, in particular intricate name lookup and access control rules. This paper introduces JL, a lookup-free, access control-free representation of Java programs. We present algorithms for translating Java programs into JL and vice versa, thereby making it possible to formulate refactorings entirely at the level of JL and to rely on the translations to take care of naming and accessibility issues. We demonstrate how complex refactorings become more robust and powerful when lifted to JL. Our approach has been implemented using the JastAddJ compiler framework, and evaluated by systematically performing two commonly used refactorings on an extensive suite of real-world Java applications. The evaluation shows that our tool correctly handles many cases where current refactoring tools fail to handle the complex rules for name binding and accessibility in Java.","1939-3520","","10.1109/TSE.2012.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6152131","Restructuring;reverse engineering;and reengineering;object-oriented languages;Java","Java;Access control;Feature extraction;Reverse engineering;Object oriented programming;Shadow mapping;Program processors","authorisation;Java;naming services;program compilers;program diagnostics;software maintenance","comprehensive approach;naming issues;accessibility issues;Java program refactoring;mainstream programming languages;source code analysis;source code transformation;language features;program analysis;name lookup;access control rules;JL;lookup-free access control-free representation;JastAddJ compiler framework","","14","","43","","14 Feb 2012","","","IEEE","IEEE Journals"
"Verifying the Evolution of Probability Distributions Governed by a DTMC","Y. Kwon; G. Agha","Microsoft Corporation, Redmond; University of Illinois at Urbana-Champaign, Urbana","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","126","141","We propose a new probabilistic temporal logic, iLTL, which captures properties of systems whose state can be represented by probability mass functions (pmfs). Using iLTL, we can specify reachability to a state (i.e., a pmf), as well as properties representing the aggregate (expected) behavior of a system. We then consider a class of systems whose transitions are governed by a Markov Chain-in this case, the set of states a system may be in is specified by the transitions of pmfs from all potential initial states to the final state. We then provide a model checking algorithm to check iLTL properties of such systems. Unlike existing model checking techniques, which either compute the portions of the computational paths that satisfy a specification or evaluate properties along a single path of pmf transitions, our model checking technique enables us to do a complete analysis on the expected behaviors of large-scale systems. Desirable system parameters may also be found as a counterexample of a negated goal. Finally, we illustrate the usefulness of iLTL model checking by means of two examples: assessing software reliability and ensuring the results of administering a drug.","1939-3520","","10.1109/TSE.2010.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5557891","Probabilistic model checking;linear temporal logic;Discrete Time Markov Chain;pharmacokinetics.","Markov processes;Limiting;Eigenvalues and eigenfunctions;Computational modeling;Transient analysis;Probability distribution;Steady-state","formal verification;Markov processes;statistical distributions;temporal logic","probability distribution;DTMC;temporal logic;iLTL;probability mass function;model checking;large scale system;discrete time Markov chain","","10","","39","","26 Aug 2010","","","IEEE","IEEE Journals"
"Static Analysis of Model Transformations","J. S. Cuadrado; E. Guerra; J. de Lara","Department of Languages and Systems, Universidad de Murcia, Murcia, Spain; Department of Computer Science, Universidad Autónoma de Madrid, Madrid, Spain; Department of Computer Science, Universidad Autónoma de Madrid, Madrid, Spain","IEEE Transactions on Software Engineering","15 Sep 2017","2017","43","9","868","897","Model transformations are central to Model-Driven Engineering (MDE), where they are used to transform models between different languages; to refactor and simulate models; or to generate code from models. Thus, given their prominent role in MDE, practical methods helping in detecting errors in transformations and automate their verification are needed. In this paper, we present a method for the static analysis of ATL model transformations. The method aims at discovering typing and rule errors, like unresolved bindings, uninitialized features or rule conflicts. It relies on static analysis and type inference, and uses constraint solving to assert whether a source model triggering the execution of a given problematic statement can possibly exist. Our method is supported by a tool that integrates seamlessly with the ATL development environment. To evaluate the usefulness of our method, we have used it to analyse a public repository of ATL transformations. The high number of errors discovered shows that static analysis of ATL transformations is needed in practice. Moreover, we have measured the precision and recall of the method by considering a synthetic set of transformations obtained by mutation techniques, and comparing with random testing. The experiment shows good overall results in terms of false positives and negatives.","1939-3520","","10.1109/TSE.2016.2635137","Spanish MINECO; R&D programme of the Madrid Region; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7765073","Model-driven engineering;model transformation;ATL;static analysis;model finders;verification and testing","Unified modeling language;Analytical models;Testing;Model driven engineering;Transforms;Manuals;Computational modeling","constraint handling;error detection;formal verification;inference mechanisms;program diagnostics;random functions","static analysis;model-driven engineering;MDE;error detection;verification automation;ATL model transformations;typing errors;rule errors;unresolved bindings;uninitialized features;rule conflicts;type inference;constraint solving;public repository analysis;mutation techniques;random testing","","7","","70","Traditional","2 Dec 2016","","","IEEE","IEEE Journals"
"What Industry Needs from Architectural Languages: A Survey","I. Malavolta; P. Lago; H. Muccini; P. Pelliccione; A. Tang","Università dell'Aquila, Italy; VU University Amsterdam, Amsterdam; Università dell'Aquila, Italy; Università dell'Aquila, Italy; Swinburne University of Technology, Melbourne","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","869","891","Many times we are faced with the proliferation of definitions, concepts, languages, and tools in certain (research) topics. But often there is a gap between what is provided by existing technologies and what is needed by their users. The strengths, limitations, and needs of the available technologies can be dubious. The same applies to software architectures, and specifically to languages designed to represent architectural models. Tens of different architectural languages have been introduced by the research and industrial communities in the last two decades. However, it is unclear if they fulfill the user's perceived needs in architectural description. As a way to plan for next generation languages for architectural description, this study analyzes practitioners' perceived strengths, limitations, and needs associated with existing languages for software architecture modeling in industry. We run a survey by interviewing 48 practitioners from 40 different IT companies in 15 countries. Each participant is asked to fill in a questionnaire of 51 questions. By analyzing the data collected through this study, we have concluded that 1) while practitioners are generally satisfied with the design capabilities provided by the languages they use, they are dissatisfied with the architectural language analysis features and their abilities to define extra-functional properties; 2) architectural languages used in practice mostly originate from industrial development instead of from academic research; 3) more formality and better usability are required of an architectural language.","1939-3520","","10.1109/TSE.2012.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6374194","Software architecture;architecture description languages;ADL;survey;empirical study","Unified modeling language;Software architecture;Computer architecture;Industries;Communities;Software;Google","data analysis;software architecture;specification languages","architectural languages;software architectures;architectural models;next generation languages;architectural description;data collection analysis;industrial development","","136","1","64","","4 Dec 2012","","","IEEE","IEEE Journals"
"Context-Aware Adaptive Applications: Fault Patterns and Their Automated Identification","M. Sama; S. Elbaum; F. Raimondi; D. S. Rosenblum; Z. Wang","University College London, UK; University of Nebraska, Lincoln, NE; University College London, UK; University College, London, UK; University of Nebraska, Lincoln, NE","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","644","661","Applications running on mobile devices are intensely context-aware and adaptive. Streams of context values continuously drive these applications, making them very powerful but, at the same time, susceptible to undesired configurations. Such configurations are not easily exposed by existing validation techniques, thereby leading to new analysis and testing challenges. In this paper, we address some of these challenges by defining and applying a new model of adaptive behavior called an Adaptation Finite-State Machine (A-FSM) to enable the detection of faults caused by both erroneous adaptation logic and asynchronous updating of context information, with the latter leading to inconsistencies between the external physical context and its internal representation within an application. We identify a number of adaptation fault patterns, each describing a class of faulty behaviors. Finally, we describe three classes of algorithms to detect such faults automatically via analysis of the A-FSM. We evaluate our approach and the trade-offs between the classes of algorithms on a set of synthetically generated Context-Aware Adaptive Applications (CAAAs) and on a simple but realistic application in which a cell phone's configuration profile changes automatically as a result of changes to the user's location, speed, and surrounding environment. Our evaluation describes the faults our algorithms are able to detect and compares the algorithms in terms of their performance and storage requirements.","1939-3520","","10.1109/TSE.2010.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432224","Adaptation;context-awareness;fault detection;mobile computing;model-based analysis;model checking;ordered binary decision diagrams;symbolic verification;ubiquitous computing.","Fault diagnosis;Fault detection;Context modeling;Algorithm design and analysis;Handheld computers;Personal digital assistants;Data structures;Global Positioning System;Computer science;Lead","finite state machines;formal logic;mobile computing;program verification;software fault tolerance","context-aware adaptive applications;mobile devices;validation techniques;adaptation finite-state machine;A-FSM analysis;asynchronous information updating;fault pattern adaptation;cell phone;fault detection","","65","1","33","","18 Mar 2010","","","IEEE","IEEE Journals"
"Toward Comprehensible Software Fault Prediction Models Using Bayesian Network Classifiers","K. Dejaeger; T. Verbraken; B. Baesens","Katholieke Universiteit Leuven, Leuven; Katholieke Universiteit Leuven, Leuven; Katholieke Universiteit Leuven, Leuven","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","237","257","Software testing is a crucial activity during software development and fault prediction models assist practitioners herein by providing an upfront identification of faulty software code by drawing upon the machine learning literature. While especially the Naive Bayes classifier is often applied in this regard, citing predictive performance and comprehensibility as its major strengths, a number of alternative Bayesian algorithms that boost the possibility of constructing simpler networks with fewer nodes and arcs remain unexplored. This study contributes to the literature by considering 15 different Bayesian Network (BN) classifiers and comparing them to other popular machine learning techniques. Furthermore, the applicability of the Markov blanket principle for feature selection, which is a natural extension to BN theory, is investigated. The results, both in terms of the AUC and the recently introduced H-measure, are rigorously tested using the statistical framework of Demšar. It is concluded that simple and comprehensible networks with less nodes can be constructed using BN classifiers other than the Naive Bayes classifier. Furthermore, it is found that the aspects of comprehensibility and predictive performance need to be balanced out, and also the development context is an item which should be taken into account during model selection.","1939-3520","","10.1109/TSE.2012.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6175912","Software fault prediction;Bayesian networks;classification;comprehensibility","Software;Predictive models;Bayesian methods;Measurement;Capability maturity model;Probability distribution;Machine learning","belief networks;feature extraction;learning (artificial intelligence);Markov processes;pattern classification;prediction theory;program testing;software fault tolerance;statistical analysis","software fault prediction models;Bayesian network classifiers;software testing;software development;faulty software code;machine learning literature;Naive Bayes classifier;citing predictive performance;BN classifiers;Markov blanket principle;feature selection;BN theory;AUC;introduced H-measure;statistical framework;Demsar;predictive performance;model selection","","103","1","109","","3 Apr 2012","","","IEEE","IEEE Journals"
"A Comparative Study of Software Model Checkers as Unit Testing Tools: An Industrial Case Study","M. Kim; Y. Kim; H. Kim","KAIST, Daejon; KAIST, Daejon; Samsung Electronics, Suwon","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","146","160","Conventional testing methods often fail to detect hidden flaws in complex embedded software such as device drivers or file systems. This deficiency incurs significant development and support/maintenance cost for the manufacturers. Model checking techniques have been proposed to compensate for the weaknesses of conventional testing methods through exhaustive analyses. Whereas conventional model checkers require manual effort to create an abstract target model, modern software model checkers remove this overhead by directly analyzing a target C program, and can be utilized as unit testing tools. However, since software model checkers are not fully mature yet, they have limitations according to the underlying technologies and tool implementations, potentially critical issues when applied in industrial projects. This paper reports our experience in applying Blast and CBMC to testing the components of a storage platform software for flash memory. Through this project, we analyzed the strong and weak points of two different software model checking technologies in the viewpoint of real-world industrial application-counterexample-guided abstraction refinement with predicate abstraction and SAT-based bounded analysis.","1939-3520","","10.1109/TSE.2010.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5510242","Embedded software verification;software model checking;bounded model checking;CEGAR-based model checking;flash file systems.","Software tools;Software testing;Computer industry;Manufacturing industries;System testing;Embedded software;File systems;Costs;Flash memory;Refining","C language;program testing;program verification;storage management","software model checkers;unit testing tools;complex embedded software;model checking techniques;abstract target model;C program;Blast;CBMC;storage platform software;flash memory","","21","","54","","15 Jul 2010","","","IEEE","IEEE Journals"
"An Observe-Model-Exercise* Paradigm to Test Event-Driven Systems with Undetermined Input Spaces","B. N. Nguyen; A. M. Memon","Department of Computer Science, University of Maryland, College Park; Department of Computer Science, University of Maryland, College Park","IEEE Transactions on Software Engineering","31 Mar 2014","2014","40","3","216","234","System testing of software applications with a graphical-user interface (GUI) front-end requires that sequences of GUI events, that sample the application's input space, be generated and executed as test cases on the GUI. However, the context-sensitive behavior of the GUI of most of today's non-trivial software applications makes it practically impossible to fully determine the software's input space. Consequently, GUI testers-both automated and manual-working with undetermined input spaces are, in some sense, blindly navigating the GUI, unknowingly missing allowable event sequences, and failing to realize that the GUI implementation may allow the execution of some disallowed sequences. In this paper, we develop a new paradigm for GUI testing, one that we call Observe-Model-Exercise* (OME*) to tackle the challenges of testing context-sensitive GUIs with undetermined input spaces. Starting with an incomplete model of the GUI's input space, a set of coverage elements to test, and test cases, OME* iteratively observes the existence of new events during execution of the test cases, expands the model of the GUI's input space, computes new coverage elements, and obtains new test cases to exercise the new elements. Our experiment with 8 open-source software subjects, more than 500,000 test cases running for almost 1,100 machine-days, shows that OME* is able to expand the test space on average by 464.11 percent; it detected 34 faults that had never been detected before.","1939-3520","","10.1109/TSE.2014.2300857","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6714448","Test generation;user interfaces;quality concepts","Graphical user interfaces;Computational modeling;Blogs;Testing;Software;Context;Layout","graphical user interfaces;program testing;public domain software","observe-model-exercise paradigm;test event-driven system;undetermined input spaces;software system testing;graphical-user interface front-end;GUI context-sensitive behavior;open-source software subjects;test generation","","19","","44","","16 Jan 2014","","","IEEE","IEEE Journals"
"Comparing Semi-Automated Clustering Methods for Persona Development","J. Brickey; S. Walczak; T. Burgess","US Army, Combating Terrorism Center, West Point; University of Colorado Denver, Denver; United States Military Academy, West Point","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","537","546","Current and future information systems require a better understanding of the interactions between users and systems in order to improve system use and, ultimately, success. The use of personas as design tools is becoming more widespread as researchers and practitioners discover its benefits. This paper presents an empirical study comparing the performance of existing qualitative and quantitative clustering techniques for the task of identifying personas and grouping system users into those personas. A method based on Factor (Principal Components) Analysis performs better than two other methods which use Latent Semantic Analysis and Cluster Analysis as measured by similarity to expert manually defined clusters.","1939-3520","","10.1109/TSE.2011.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928355","Clustering;interaction styles;personas;user-centered design;user interfaces.","Manuals;Clustering methods;Principal component analysis;Software;Interviews;Humans;Organizations","information systems;pattern clustering;principal component analysis","semi-automated clustering methods;persona development;information systems;design tools;quantitative clustering techniques;qualitative clustering techniques;principal components analysis;latent semantic analysis","","13","","47","","23 Jun 2011","","","IEEE","IEEE Journals"
"DECOR: A Method for the Specification and Detection of Code and Design Smells","N. Moha; Y. Gueheneuc; L. Duchien; A. Le Meur","INRIA, IRISA, Université de Rennes 1, France; École Polytechnique de Montréal, Québec; LIFL, INRIA Lille-Nord Europe, Université de Lille, France; LIFL, INRIA Lille-Nord Europe, Université de Lille, France","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","20","36","Code and design smells are poor solutions to recurring implementation and design problems. They may hinder the evolution of a system by making it hard for software engineers to carry out changes. We propose three contributions to the research field related to code and design smells: (1) DECOR, a method that embodies and defines all the steps necessary for the specification and detection of code and design smells, (2) DETEX, a detection technique that instantiates this method, and (3) an empirical validation in terms of precision and recall of DETEX. The originality of DETEX stems from the ability for software engineers to specify smells at a high level of abstraction using a consistent vocabulary and domain-specific language for automatically generating detection algorithms. Using DETEX, we specify four well-known design smells: the antipatterns Blob, Functional Decomposition, Spaghetti Code, and Swiss Army Knife, and their 15 underlying code smells, and we automatically generate their detection algorithms. We apply and validate the detection algorithms in terms of precision and recall on XERCES v2.7.0, and discuss the precision of these algorithms on 11 open-source systems.","1939-3520","","10.1109/TSE.2009.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5196681","Antipatterns;design smells;code smells;specification;metamodeling;detection;Java.","Detection algorithms;Vocabulary;Domain specific languages;Algorithm design and analysis;Metamodeling;Java;Design engineering;Object oriented programming;Phase detection;Costs","formal specification;program verification;software quality","code specification;code detection;design smells;DECOR;DETEX;antipatterns Blob;functional decomposition;Spaghetti code;Swiss army knife;empirical validation;domain-specific language;open-source systems","","364","","66","","7 Aug 2009","","","IEEE","IEEE Journals"
"Comments on ScottKnottESD in response to ""An empirical comparison of model validation techniques for defect prediction models""","S. Herbold","Institute of Computer Science, University of Goettingen, Goettingen, Germany","IEEE Transactions on Software Engineering","10 Nov 2017","2017","43","11","1091","1094","In this article, we discuss the ScottKnottESD test, which was proposed in a recent paper “An Empirical Comparison of Model Validation Techniques for Defect Prediction Models” that was published in this journal. We discuss the implications and the empirical impact of the proposed normality correction of ScottKnottESD and come to the conclusion that this correction does not necessarily lead to the fulfillment of the assumptions of the original Scott-Knott test and may cause problems with the statistical analysis.","1939-3520","","10.1109/TSE.2017.2748129","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8024011","Scott-knott test, log transformation, statistics","Analysis of variance;Measurement;Distributed databases;Predictive models;Sociology","program testing;software metrics;statistical analysis","model validation techniques;defect prediction models;ScottKnottESD test;empirical impact;statistical analysis","","","","23","Traditional","1 Sep 2017","","","IEEE","IEEE Journals"
"A Game-Theoretic Foundation for the Maximum Software Resilience against Dense Errors","C. Huang; D. A. Peled; S. Schewe; F. Wang","Graduate Institute of Electronic Engineering, National Taiwan University, Taiwan, ROC; Department of Computer Science, Bar Ilan University, Ramat Gan, Israel; Department of Computer Science, University of Liverpool, Liverpool, United Kingdom; Department of Electrical Engineering, National Taiwan University, Taiwan, ROC","IEEE Transactions on Software Engineering","14 Jul 2016","2016","42","7","605","622","Safety-critical systems need to maintain their functionality in the presence of multiple errors caused by component failures or disastrous environment events. We propose a game-theoretic foundation for synthesizing control strategies that maximize the resilience of a software system in defense against a realistic error model. The new control objective of such a game is called $k$ -resilience. In order to be $k$ -resilient, a system needs to rapidly recover from infinitely many waves of a small number of up to $k$  close errors provided that the blocks of up to $k$  errors are separated by short time intervals, which can be used by the system to recover. We first argue why we believe this to be the right level of abstraction for safety critical systems when local faults are few and far between. We then show how the analysis of $k$ -resilience problems can be formulated as a model-checking problem of a mild extension to the alternating-time  $\mu$ -calculus (AMC). The witness for $k$  resilience, which can be provided by the model checker, can be used for providing control strategies that are optimal with respect to resilience. We show that the computational complexity of constructing such optimal control strategies is low and demonstrate the feasibility of our approach through an implementation and experimental results.","1939-3520","","10.1109/TSE.2015.2510001","ISF; Efficient Synthesis Method of Control for Concurrent Systems; Engineering and Physical Science Research Council (EPSRC); MOST; Research Center for Information Technology Innovation (CITI); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7360234","Fault tolerance;resilience;formal verification;model-checking;game;strategy;complexity","Resilience;Games;Software systems;Safety;Game theory;Computer science","","","","7","","44","","17 Dec 2015","","","IEEE","IEEE Journals"
"Evaluating Dynamic Software Update Safety Using Systematic Testing","C. M. Hayden; E. K. Smith; E. A. Hardisty; M. Hicks; J. S. Foster","University of Maryland, College Park, College Park; University of Maryland, College Park, College Park; University of Maryland, College Park, College Park; University of Maryland, College Park, College Park; University of Maryland, College Park, College Park","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1340","1354","Dynamic software updating (DSU) systems patch programs on the fly without incurring downtime. To avoid failures due to the updating process itself, many DSU systems employ timing restrictions. However, timing restrictions are theoretically imperfect, and their practical effectiveness is an open question. This paper presents the first significant empirical evaluation of three popular timing restrictions: activeness safety (AS), which prevents updates to active functions, con-freeness safety (CFS), which only allows modifications to active functions when doing so is provably type-safe, and manual identification of the event-handling loops during which an update may occur. We evaluated these timing restrictions using a series of DSU patches to three programs: OpenSSH, vsftpd, and ngIRCd. We systematically applied updates at each distinct update point reached during execution of a suite of system tests for these programs to determine which updates pass and which fail. We found that all three timing restrictions prevented most failures, but only manual identification allowed none. Further, although CFS and AS allowed many more update points, manual identification still supported updates with minimal delay. Finally, we found that manual identification required the least developer effort. Overall, we conclude that manual identification is most effective.","1939-3520","","10.1109/TSE.2011.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6035725","Dynamic software updating (DSU);hot-swapping;software reliability;testing;program tracing","Software reliability;Software testing;Servers","program testing;safety-critical software;software fault tolerance;software maintenance","dynamic software updating safety evaluation;systematic testing;DSU systems;timing restrictions;activeness safety;AS;active functions;con-freeness safety;CFS;event-handling loop identification;OpenSSH;vsftpd;ngIRCd;manual identification;failure prevention","","18","2","35","","6 Oct 2011","","","IEEE","IEEE Journals"
"Guided Mutation Testing for JavaScript Web Applications","S. Mirshokraie; A. Mesbah; K. Pattabiraman","Department of Electrical and Computer Engineering, University of British Columbia, 2332 Main Mall, Vancouver, BC, Canada; Department of Electrical and Computer Engineering, University of British Columbia, 2332 Main Mall, Vancouver, BC, Canada; Department of Electrical and Computer Engineering, University of British Columbia, 2332 Main Mall, Vancouver, BC, Canada","IEEE Transactions on Software Engineering","12 May 2015","2015","41","5","429","444","Mutation testing is an effective test adequacy assessment technique. However, there is a high computational cost in executing the test suite against a potentially large pool of generated mutants. Moreover, there is much effort involved in filtering out equivalent mutants. Prior work has mainly focused on detecting equivalent mutants after the mutation generation phase, which is computationally expensive and has limited efficiency. We propose an algorithm to select variables and branches for mutation as well as a metric, called FunctionRank, to rank functions according to their relative importance from the application's behaviour point of view. We present a technique that leverages static and dynamic analysis to guide the mutation generation process towards parts of the code that are more likely to influence the program's output. Further, we focus on the JavaScript language, and propose a set of mutation operators that are specific to Web applications. We implement our approach in a tool called MUTANDIS. The results of our empirical evaluation show that (1) more than 93 percent of generated mutants are non-equivalent, and (2) more than 75 percent of the surviving non-equivalent mutants are in the top 30 percent of the ranked functions.","1939-3520","","10.1109/TSE.2014.2371458","NSERC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6960094","mutation testing;JavaScript;equivalent mutants;guided mutation generation;web applications;Mutation testing;JavaScript;equivalent mutants;guided mutation generation;web applications","Testing;Measurement;Heuristic algorithms;Complexity theory;Performance analysis;Instruments;IEEE Computer Society","Java;program diagnostics;program testing","guided mutation testing;JavaScript Web applications;test adequacy assessment technique;computational cost;test suite execution;equivalent mutants;mutation generation phase;variable selection;FunctionRank;function ranking;relative function importance;application behaviour;static analysis;dynamic analysis;program output;mutation operators;nonequivalent mutants;empirical evaluation;MUTANDIS tool;Web applications","","25","","50","","20 Nov 2014","","","IEEE","IEEE Journals"
"Black-Box String Test Case Generation through a Multi-Objective Optimization","A. Shahbazi; J. Miller","Department of Electrical and Computer Engineering, Edmonton, AB, Canada; Department of Electrical and Computer Engineering, Edmonton, AB, Canada","IEEE Transactions on Software Engineering","14 Apr 2016","2016","42","4","361","378","String test cases are required by many real-world applications to identify defects and security risks. Random Testing (RT) is a low cost and easy to implement testing approach to generate strings. However, its effectiveness is not satisfactory. In this research, black-box string test case generation methods are investigated. Two objective functions are introduced to produce effective test cases. The diversity of the test cases is the first objective, where it can be measured through string distance functions. The second objective is guiding the string length distribution into a Benford distribution based on the hypothesis that the population of strings is right-skewed within its range. When both objectives are applied via a multi-objective optimization algorithm, superior string test sets are produced. An empirical study is performed with several real-world programs indicating that the generated string test cases outperform test cases generated by other methods.","1939-3520","","10.1109/TSE.2015.2487958","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7293669","Adaptive random testing;automated test case generation;black-box testing;mutation;random testing;software testing;string distance;string test cases;Adaptive random testing;automated test case generation;black-box testing;mutation;random testing;software testing;string distance;string test cases","Sociology;Statistics;Biological cells;Subspace constraints;Testing;Power capacitors;Genetic algorithms","optimisation;program testing;security of data","black-box string test case generation;security risks;random testing;RT;objective functions;string distance functions;Benford distribution;multiobjective optimization algorithm","","19","","76","","7 Oct 2015","","","IEEE","IEEE Journals"
"Fluid Rewards for a Stochastic Process Algebra","M. Tribastone; J. Ding; S. Gilmore; J. Hillston","Ludwig-Maximilians-Universität, München; Yangzhou University, Yangzhou; Edinburgh University, Edinburgh; Edinburgh University, Edinburgh","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","861","874","Reasoning about the performance of models of software systems typically entails the derivation of metrics such as throughput, utilization, and response time. If the model is a Markov chain, these are expressed as real functions of the chain, called reward models. The computational complexity of reward-based metrics is of the same order as the solution of the Markov chain, making the analysis infeasible when evaluating large-scale systems. In the context of the stochastic process algebra PEPA, the underlying continuous-time Markov chain has been shown to admit a deterministic (fluid) approximation as a solution of an ordinary differential equation, which effectively circumvents state-space explosion. This paper is concerned with approximating Markovian reward models for PEPA with fluid rewards, i.e., functions of the solution of the differential equation problem. It shows that (1) the Markovian reward models for typical metrics of performance enjoy asymptotic convergence to their fluid analogues, and that (2) via numerical tests, the approximation yields satisfactory accuracy in practice.","1939-3520","","10.1109/TSE.2011.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5975178","Modeling and prediction;ordinary differential equations;Markov processes","Convergence;Markov processes;Approximation methods;Computational modeling;Mathematical model;Servers","computational complexity;Markov processes;mathematics computing;process algebra;stochastic processes","fluid rewards;stochastic process algebra;software systems;metric derivation;Markov chain;computational complexity;ordinary differential equation;state-space explosion","","19","","33","","4 Aug 2011","","","IEEE","IEEE Journals"
"Using Traceability Links to Recommend Adaptive Changes for Documentation Evolution","B. Dagenais; M. P. Robillard","Resulto Inc., Montreal, QC, Canada; School of Computer Science, McGill University, 3480 University Street, McConnell Engineering Building, Office 114N, Montreal, QC, Canada","IEEE Transactions on Software Engineering","10 Nov 2014","2014","40","11","1126","1146","Developer documentation helps developers learn frameworks and libraries, yet developing and maintaining accurate documentation requires considerable effort and resources. Contributors who work on developer documentation often need to manually track all changes in the code, determine which changes are significant enough to document, and then, adapt the documentation. We propose AdDoc, a technique that automatically discovers documentation patterns, i.e., coherent sets of code elements that are documented together, and that reports violations of these patterns as the code and the documentation evolves. We evaluated our approach in a retrospective analysis of four Java open source projects and found that at least 50 percent of all the changes in the documentation were related to existing documentation patterns. Our technique allows contributors to quickly adapt existing documentation, so that they can focus their documentation effort on the new features.","1939-3520","","10.1109/TSE.2014.2347969","Natural Sciences and Engineering Research Council of Canada; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6878435","Documentation;maintainability;frameworks","Documentation;Java;Manuals;Libraries;Sections;Joining processes;Concrete","data mining;Java;program diagnostics;public domain software;system documentation","traceability links;adaptive changes;documentation evolution;developer documentation;AdDoc;automatic documentation pattern discovery;code elements;Java open source projects","","11","","24","","14 Aug 2014","","","IEEE","IEEE Journals"
"Managing Technical Debt in Enterprise Software Packages","N. Ramasubbu; C. F. Kemerer","Joseph M. Katz Graduate School of Business, University of Pittsburgh, Pittsburgh, PA; Joseph M. Katz Graduate School of Business, University of Pittsburgh, Pittsburgh, PA","IEEE Transactions on Software Engineering","8 Aug 2014","2014","40","8","758","772","We develop an evolutionary model and theory of software technical debt accumulation to facilitate a rigorous and balanced analysis of its benefits and costs in the context of a large commercial enterprise software package. Our theory focuses on the optimization problem involved in managing technical debt, and illustrates the different tradeoff patterns between software quality and customer satisfaction under early and late adopter scenarios at different lifecycle stages of the software package. We empirically verify our theory utilizing a ten year longitudinal data set drawn from 69 customer installations of the software package. We then utilize the empirical results to develop actionable policies for managing technical debt in enterprise software product adoption.","1939-3520","","10.1109/TSE.2014.2327027","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6824267","Technical debt;enterprise software;software platforms;customer satisfaction;software quality;technology adoption;COTS;software evolution;software maintenance;software management;longitudinal data","Software packages;Business;Software quality;Measurement;Maintenance engineering;Context","cost-benefit analysis;evolutionary computation;software development management;software maintenance;software packages;software quality","technical debt management;evolutionary model;software technical debt theory;commercial enterprise software package;optimization problem;software quality;customer satisfaction;early adopter scenario;late adopter scenario;software package lifecycle stage;enterprise software product adoption","","18","","57","","2 Jun 2014","","","IEEE","IEEE Journals"
"Test Oracle Strategies for Model-Based Testing","N. Li; J. Offutt","Research and Development Division, Medidata Solutions, New York, NY; George Mason University, Fairfax, VA","IEEE Transactions on Software Engineering","14 Apr 2017","2017","43","4","372","395","Testers use model-based testing to design abstract tests from models of the system's behavior. Testers instantiate the abstract tests into concrete tests with test input values and test oracles that check the results. Given the same test inputs, more elaborate test oracles have the potential to reveal more failures, but may also be more costly. This research investigates the ability for test oracles to reveal failures. We define ten new test oracle strategies that vary in amount and frequency of program state checked. We empirically compared them with two baseline test oracle strategies. The paper presents several main findings. (1) Test oracles must check more than runtime exceptions because checking exceptions alone is not effective at revealing failures. (2) Test oracles do not need to check the entire output state because checking partial states reveals nearly as many failures as checking entire states. (3) Test oracles do not need to check program states multiple times because checking states less frequently is as effective as checking states more frequently. In general, when state machine diagrams are used to generate tests, checking state invariants is a reasonably effective low cost approach to creating test oracles.","1939-3520","","10.1109/TSE.2016.2597136","George Mason University; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7529115","Test oracle;RIPR model;test oracle strategy;test automation;subsumption;model-based testing","Unified modeling language;Software;Context;Concrete;System testing;Observability","data flow analysis;diagrams;finite state machines;program testing;software fault tolerance","test oracle strategy;model-based testing;abstract test design;failure revelation;runtime exception;partial state checking;state machine diagram","","21","","46","","2 Aug 2016","","","IEEE","IEEE Journals"
"Are Slice-Based Cohesion Metrics Actually Useful in Effort-Aware Post-Release Fault-Proneness Prediction? An Empirical Study","Y. Yang; Y. Zhou; H. Lu; L. Chen; Z. Chen; B. Xu; H. Leung; Z. Zhang","State Key Laboratory for Novel Software Technology, Department of Computer Science and Technology, Nanjing, China; State Key Laboratory for Novel Software Technology, Department of Computer Science and Technology, Nanjing, China; State Key Laboratory for Novel Software Technology, Department of Computer Science and Technology, Nanjing, China; State Key Laboratory for Novel Software Technology, Department of Computer Science and Technology, Nanjing, China; State Key Laboratory for Novel Software Technology, School of Software, Nanjing, China; State Key Laboratory for Novel Software Technology, Department of Computer Science and Technology, Nanjing, China; Department of Computing, Hong Kong Polytechnic University, Hung Hom, Hong Kong, China; State Key Laboratory of Computer Science, Institute of Software, Beijing, China","IEEE Transactions on Software Engineering","14 Apr 2015","2015","41","4","331","357","Background. Slice-based cohesion metrics leverage program slices with respect to the output variables of a module to quantify the strength of functional relatedness of the elements within the module. Although slice-based cohesion metrics have been proposed for many years, few empirical studies have been conducted to examine their actual usefulness in predicting fault-proneness. Objective. We aim to provide an in-depth understanding of the ability of slice-based cohesion metrics in effort-aware post-release fault-proneness prediction, i.e. their effectiveness in helping practitioners find post-release faults when taking into account the effort needed to test or inspect the code. Method. We use the most commonly used code and process metrics, including size, structural complexity, Halstead's software science, and code churn metrics, as the baseline metrics. First, we employ principal component analysis to analyze the relationships between slice-based cohesion metrics and the baseline metrics. Then, we use univariate prediction models to investigate the correlations between slice-based cohesion metrics and post-release fault-proneness. Finally, we build multivariate prediction models to examine the effectiveness of slice-based cohesion metrics in effort-aware post-release fault-proneness prediction when used alone or used together with the baseline code and process metrics. Results. Based on open-source software systems, our results show that: 1) slice-based cohesion metrics are not redundant with respect to the baseline code and process metrics; 2) most slice-based cohesion metrics are significantly negatively related to post-release fault-proneness; 3) slice-based cohesion metrics in general do not outperform the baseline metrics when predicting post-release fault-proneness; and 4) when used with the baseline metrics together, however, slice-based cohesion metrics can produce a statistically significant and practically important improvement of the effectiveness in effort-aware post-release fault-proneness prediction. Conclusion. Slice-based cohesion metrics are complementary to the most commonly used code and process metrics and are of practical value in the context of effort-aware post-release fault-proneness prediction.","1939-3520","","10.1109/TSE.2014.2370048","National Key Basic Research and Development Program of China; National Natural Science Foundation of China; National Natural Science Foundation of Jiangsu Province; National Science and Technology Major Project of China; Hong Kong Competitive Earmarked Research; PolyU; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6954519","Cohesion;metrics;slice-based;fault-proneness;prediction;effort-aware","Measurement;Software;Predictive models;Context;Complexity theory;Correlation;Laboratories","principal component analysis;public domain software;software metrics","effort aware post-release fault proneness prediction;slice-based cohesion metrics leverage program slices;structural complexity;Halstead's software science;code churn metrics;baseline metrics;principal component analysis;univariate prediction models;multivariate prediction models;baseline code;process metrics;open source software systems","","27","","66","","12 Nov 2014","","","IEEE","IEEE Journals"
"Monitor-Based Instant Software Refactoring","H. Liu; X. Guo; W. Shao","Beijing Institute of Technology, Beijing; Beijing Institute of Technology, Beijing; Peking University, Beijing","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1112","1126","Software refactoring is an effective method for improvement of software quality while software external behavior remains unchanged. To facilitate software refactoring, a number of tools have been proposed for code smell detection and/or for automatic or semi-automatic refactoring. However, these tools are passive and human driven, thus making software refactoring dependent on developers' spontaneity. As a result, software engineers with little experience in software refactoring might miss a number of potential refactorings or may conduct refactorings later than expected. Few refactorings might result in poor software quality, and delayed refactorings may incur higher refactoring cost. To this end, we propose a monitor-based instant refactoring framework to drive inexperienced software engineers to conduct more refactorings promptly. Changes in the source code are instantly analyzed by a monitor running in the background. If these changes have the potential to introduce code smells, i.e., signs of potential problems in the code that might require refactorings, the monitor invokes corresponding smell detection tools and warns developers to resolve detected smells promptly. Feedback from developers, i.e., whether detected smells have been acknowledged and resolved, is consequently used to optimize smell detection algorithms. The proposed framework has been implemented, evaluated, and compared with the traditional human-driven refactoring tools. Evaluation results suggest that the proposed framework could drive inexperienced engineers to resolve more code smells (by an increase of 140 percent) promptly. The average lifespan of resolved smells was reduced by 92 percent. Results also suggest that the proposed framework could help developers to avoid similar code smells through timely warnings at the early stages of software development, thus reducing the total number of code smells by 51 percent.","1939-3520","","10.1109/TSE.2013.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6409360","Software refactoring;code smell detection;monitor;instant refactoring","Software;Monitoring;Detection algorithms;Cloning;Detectors;Algorithm design and analysis;Inspection","software maintenance;software quality","monitor-based instant software refactoring;software quality;software external behavior;code smell detection;smell detection algorithm","","28","","50","","10 Jan 2013","","","IEEE","IEEE Journals"
"The Link between Dependency and Cochange: Empirical Evidence","M. M. Geipel; F. Schweitzer","ETH Zurich, Zurich; ETH Zurich, Zurich","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1432","1444","We investigate the relationship between class dependency and change propagation (cochange) in software written in Java. On the one hand, we find a strong correlation between dependency and cochange. Furthermore, we provide empirical evidence for the propagation of change along paths of dependency. These findings support the often alleged role of dependencies as propagators of change. On the other hand, we find that approximately half of all dependencies are never involved in cochanges and that the vast majority of cochanges pertain to only a small percentage of dependencies. This means that inferring the cochange characteristics of a software architecture solely from its dependency structure results in a severely distorted approximation of cochange characteristics. Any metric which uses dependencies alone to pass judgment on the evolvability of a piece of Java software is thus unreliable. As a consequence, we suggest to always take both the change characteristics and the dependency structure into account when evaluating software architecture.","1939-3520","","10.1109/TSE.2011.91","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363462","Modularity;class dependency;open source","Software development;Java;Open source software","Java;software architecture","class dependency;change propagation;Java software;cochange characteristic;software architecture","","13","","48","","29 Nov 2012","","","IEEE","IEEE Journals"
"An I/O Efficient Approach for Detecting All Accepting Cycles","L. Wu; K. Su; S. Cai; X. Zhang; C. Zhang; S. Wang","School of Computer Science and Engineering, University of Electronic Science and Technology, Chengdu, China; Institute for Integrated and Intelligent Systems, Griffith University, Brisbane, Australia; State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing, China; School of Computer Science and Engineering, University of Electronic Science and Technology, Chengdu, China; School of Information Technology and Electrical Engineering, University of Queensland, Brisbane, Australia; School of Computer Science and Engineering, University of Electronic Science and Technology, Chengdu, China","IEEE Transactions on Software Engineering","11 Aug 2015","2015","41","8","730","744","Existing algorithms for I/O Linear Temporal Logic (LTL) model checking usually output a single counterexample for a system which violates the property. However, in real-world applications, such as diagnosis and debugging in software and hardware system designs, people often need to have a set of counterexamples or even all counterexamples. For this purpose, we propose an I/O efficient approach for detecting all accepting cycles, called Detecting All Accepting Cycles (DAAC), where the properties to be verified are in LTL. Different from other algorithms for finding all cycles, DAAC first searches for the accepting strongly connected components (ASCCs), and then finds all accepting cycles of every ASCC, which can avoid searching for a great many paths that are impossible to be extended to accepting cycles. In order to further lower DAAC's I/O complexity and improve its performance, we propose an intersection computation technique and a dynamic path management technique, and exploit a minimal perfect hash function (MPHF). We carry out both complexity and experimental comparisons with the state-of-the-art algorithms including Detect Accepting Cycle (DAC), Maximal Accepting Predecessors (MAP) and Iterative-Deepening Depth-First Search (IDDFS). The comparative results show that our approach is better on the whole in terms of I/O complexity and practical performance, despite the fact that it finds all counterexamples.","1939-3520","","10.1109/TSE.2015.2411284","National Natural Science Foundation of China; China National; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7056483","Model Checking;Detection of All Accepting Cycles;Breath-First Search;Model checking;detection of all accepting cycles;state space explosion;accepting strongly connected component;breath-first search","Complexity theory;Model checking;Algorithm design and analysis;Educational institutions;Heuristic algorithms;Software algorithms;Software","formal verification;temporal logic","input-output efficient approach;I/O linear temporal logic;LTL model checking;DAAC approach;detecting all accepting cycles approach;accepting strongly connected components;ASCC;I/O complexity;intersection computation technique;dynamic path management technique;minimal perfect hash function;MPHF;detect accepting cycle algorithm;DAC algorithm;maximal accepting predecessors algorithm;iterative-deepening depth-first search algorithm;IDDFS algorithm","","2","","36","","9 Mar 2015","","","IEEE","IEEE Journals"
"Compositional Control of IP Media","P. Zave; E. Cheung","AT&T Laboratories-Research, Florham Park; AT&T Laboratories-Research, Florham Park","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","46","66","In many IP media services, the media channels are point-to-point, dynamic, and set up with the participation of one or more application servers, even thou the media packets themselves travel directly between media endpoints. The application servers must be programmed so that media behavior is globally correct, even though the servers may attempt to manipulate the same media channels concurrently and without knowledge of each other. Our proposed solution to this problem of compositional media control includes an architecture-independent descriptive model, a set of high-level programming primitives, a formal specification of their compositional semantics, a signaling protocol, an implementation, and partial verification of correctness. The paper includes performance analysis, comparison to related work, and principles for making other networked applications more compositional.","1939-3520","","10.1109/TSE.2008.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4569853","distributed applications;domain-specific architectures;protocol verification;protocol design;software/program verification;networks;streaming media;multimedia services;telecommunications;feature interaction;distributed applications;domain-specific architectures;protocol verification;protocol design;software/program verification;networks;streaming media;multimedia services;telecommunications;feature interaction","Application software;Network servers;Streaming media;Protocols;Internet telephony;Web server;Performance analysis;Computer architecture;Computer networks;Home computing","formal specification;IP networks;multimedia communication;signalling protocols","compositional control;IP media services;media channels;media packets;media endpoints;architecture-independent descriptive model;high-level programming primitives;formal specification;signaling protocol","","8","1","16","","18 Jul 2008","","","IEEE","IEEE Journals"
"Identification of Move Method Refactoring Opportunities","N. Tsantalis; A. Chatzigeorgiou","University of Macedonia, Thessaloniki; University of Macedonia, Thessaloniki","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","347","367","Placement of attributes/methods within classes in an object-oriented system is usually guided by conceptual criteria and aided by appropriate metrics. Moving state and behavior between classes can help reduce coupling and increase cohesion, but it is nontrivial to identify where such refactorings should be applied. In this paper, we propose a methodology for the identification of Move Method refactoring opportunities that constitute a way for solving many common feature envy bad smells. An algorithm that employs the notion of distance between system entities (attributes/methods) and classes extracts a list of behavior-preserving refactorings based on the examination of a set of preconditions. In practice, a software system may exhibit such problems in many different places. Therefore, our approach measures the effect of all refactoring suggestions based on a novel entity placement metric that quantifies how well entities have been placed in system classes. The proposed methodology can be regarded as a semi-automatic approach since the designer will eventually decide whether a suggested refactoring should be applied or not based on conceptual or other design quality criteria. The evaluation of the proposed approach has been performed considering qualitative, metric, conceptual, and efficiency aspects of the suggested refactorings in a number of open-source projects.","1939-3520","","10.1109/TSE.2009.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4752842","Move Method refactoring;Feature Envy;object-oriented design;Jaccard distance;design quality.","Software systems;Performance evaluation;Open source software;Runtime;Productivity;Data mining","object-oriented programming;software maintenance;software metrics","Move Method refactoring opportunity identification;object-oriented system;conceptual criteria;software metrics;feature envy","","188","","33","","19 Jan 2009","","","IEEE","IEEE Journals"
"Modeling Product Line Software Assets Using Domain-Specific Kits","N. I. Altintas; S. Cetin; A. H. Dogru; H. Oguztuzun","Cybersoft Information Technologies, Istanbul; Cybersoft Information Technologies, Istanbul; Middle East Technical University, Ankara; Middle East Technical University, Ankara","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1376","1402","Software Product Line Engineering (SPLE) is a prominent paradigm for the assembly of a family of products using product line core assets. The modeling of software assets that together form the actual products is critical for achieving the strategic benefits of Software Product Lines (SPLs). We propose a feature-based approach to software asset modeling based on abstractions provided by Domain-Specific Kits (DSKs). This approach involves a software Asset Metamodel (AMM) used to derive Asset Modeling Languages (AMLs) that define reusable software assets in domain-specific terms. The approach also prescribes a roadmap for modeling these software assets in conjunction with the product line reference architecture. Asset capabilities can be modeled using feature diagrams as the external views of the software assets. Internal views can be expressed in terms of Domain-Specific Artifacts (DSAs) with Variability Points (VPs), where the domain-specific artifacts are created using Domain-Specific Kits. This approach produces loosely coupled and highly cohesive software assets that are reusable for multiple product lines. The approach is validated by assessing software asset reuse in two different product lines in the finance domain. We also evaluated the productivity gains in large-scale complex projects, and found that the approach yielded a significant reduction in the total project effort.","1939-3520","","10.1109/TSE.2011.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6065739","Asset modeling;domain-specific kits;feature models;reuse;software asset;software product lines","Software reliability;Computer architecture;Productivity;Programming;Complexity theory;Systematics","financial data processing;product development;project management;simulation languages;software reusability","product line software asset modelling;domain-specific kits;software product line engineering;SPLE;product line core assets;feature-based approach;DSK;software asset metamodel;AMM;asset modeling languages;AML;software asset reusability;domain-specific terms;product line reference architecture;feature diagrams;internal views;domain-specific artifacts;DSA;variability points;VP;finance domain;productivity gains;large-scale complex projects","","5","","86","","1 Nov 2011","","","IEEE","IEEE Journals"
"Identifying Code of Individual Features in Client-Side Web Applications","J. Maras; M. Stula; J. Carlson; I. Crnkovic","University of Split, Split; University of Split, Split; Mälardalen University, Västerås; Mälardalen University, Västerås","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1680","1697","Web applications are one of today's fastest growing software systems. Structurally, they are composed of two parts: the server side, used for data access and business logic, and the client side, used as a user interface. In recent years, with developers building complex interfaces, the client side is playing an increasingly important role. Unfortunately, the techniques and tools used to support development are not as advanced as in other disciplines. From the user's perspective, the client side offers a number of features that are relatively easy to distinguish. However, the same cannot be said for their implementation details. This makes the understanding, maintenance, and reuse of code difficult. The goal of the work presented in this paper is to improve reusability, maintainability, and performance of client-side web applications by identifying the code that implements a particular feature. We have evaluated the approach based on three different experiments: extracting features, extracting library functionalities, and page optimization. The evaluation shows that the method is able to identify the implementation details of individual features, and that by extracting the identified code, a considerable reduction in code size and increase in performance can be achieved.","1939-3520","","10.1109/TSE.2013.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6576749","Web applications;feature location;program slicing;code extraction","Feature extraction;HTML;Cascading style sheets;Browsers;Web and internet services;Optimization;Codes","feature extraction;Internet;user interfaces","individual features code identification;client-side Web application reusability;software systems;server side;data access;business logic;user interface;client-side Web application maintainability;client-side Web application performance;feature extraction;library functionality extraction;page optimization","","9","","35","","8 Aug 2013","","","IEEE","IEEE Journals"
"Measuring the Discriminative Power of Object-Oriented Class Cohesion Metrics","J. Al Dallal","Kuwait University, Kuwait","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","788","804","Several object-oriented cohesion metrics have been proposed in the literature. These metrics aim to measure the relationship between class members, namely, methods and attributes. Different metrics use different models to represent the connectivity pattern of cohesive interactions (CPCI) between class members. Most of these metrics are normalized to allow for easy comparison of the cohesion of different classes. However, in some cases, these metrics obtain the same cohesion values for different classes that have the same number of methods and attributes but different CPCIs. This leads to incorrectly considering the classes to be the same in terms of cohesion, even though their CPCIs clearly indicate that the degrees of cohesion are different. We refer to this as a lack of discrimination anomaly (LDA) problem. In this paper, we list and discuss cases in which the LDA problem exists, as expressed through the use of 16 cohesion metrics. In addition, we empirically study the frequent occurrence of the LDA problem when the considered metrics are applied to classes in five open source Java systems. Finally, we propose a metric and a simulation-based methodology to measure the discriminative power of cohesion metrics. The discrimination metric measures the probability that a cohesion metric will produce distinct cohesion values for classes with the same number of attributes and methods but different CPCIs. A highly discriminating cohesion metric is more desirable because it exhibits a lower chance of incorrectly considering classes to be cohesively equal when they have different CPCIs.","1939-3520","","10.1109/TSE.2010.97","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5639020","Cohesive interactions;connectivity pattern;discrimination metric;discriminative power;lack of discrimination anomaly;object-oriented class cohesion.","Power measurement;Object oriented modeling;Software measurement;Phase measurement","Java;laser Doppler anemometry;object-oriented methods;public domain software","discriminative power measurement;object oriented class cohesion metrics;cohesive interactions;discrimination anomaly;open source Java systems;simulation based methodology","","33","","41","","18 Nov 2010","","","IEEE","IEEE Journals"
"A Model of Data Warehousing Process Maturity","A. Sen; K. Ramamurthy; A. P. Sinha","Texas A&M University, College Station; University of Wisconsin-Milwaukee, Milwaukee; University of Wisconsin-Milwaukee, Milwaukee","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","336","353","Even though data warehousing (DW) requires huge investments, the data warehouse market is experiencing incredible growth. However, a large number of DW initiatives end up as failures. In this paper, we argue that the maturity of a data warehousing process (DWP) could significantly mitigate such large-scale failures and ensure the delivery of consistent, high quality, “single-version of truth” data in a timely manner. However, unlike software development, the assessment of DWP maturity has not yet been tackled in a systematic way. In light of the critical importance of data as a corporate resource, we believe that the need for a maturity model for DWP could not be greater. In this paper, we describe the design and development of a five-level DWP maturity model (DWP-M) over a period of three years. A unique aspect of this model is that it covers processes in both data warehouse development and operations. Over 20 key DW executives from 13 different corporations were involved in the model development process. The final model was evaluated by a panel of experts; the results strongly validate the functionality, productivity, and usability of the model. We present the initial and final DWP-M model versions, along with illustrations of several key process areas at different levels of maturity.","1939-3520","","10.1109/TSE.2011.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680911","Data warehousing process;design-science research;model validation;software maturity models.","Data warehouses;Business;Warehousing;Software;Programming;Data mining;Standards organizations","data warehouses","data warehousing process maturity;data warehouse market;large-scale failures;DWP-M model","","28","","75","","6 Jan 2011","","","IEEE","IEEE Journals"
"Using Stochastic State Classes in Quantitative Evaluation of Dense-Time Reactive Systems","E. Vicario; L. Sassoli; L. Carnevali","Università di Firenze, Firenze; Università di Firenze, Firenze; Università di Firenze, Firenze","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","703","719","In the verification of reactive systems with nondeterministic densely valued temporal parameters, the state-space can be covered through equivalence classes, each composed of a discrete logical location and a dense variety of clock valuations encoded as a difference bounds matrix (DBM). The reachability relation among such classes enables qualitative verification of properties pertaining events ordering and stimulus/response deadlines, but it does not provide any measure of probability for feasible behaviors. We extend DBM equivalence classes with a density-function which provides a measure for the probability of individual states. To this end, we extend time Petri nets by associating a probability density-function to the static firing interval of each nondeterministic transition. We then explain how this stochastic information induces a probability distribution for the states contained within a DBM class and how this probability evolves in the enumeration of the reachability relation among classes. This enables the construction of a stochastic transition system which supports correctness verification based on the theory of TPNs, provides a measure of probability for each feasible run, enables steady-state analysis based on Markov renewal theory. In so doing, we provide a means to identify feasible behaviors and to associate them with a measure of probability in models with multiple concurrent generally distributed nondeterministic timers.","1939-3520","","10.1109/TSE.2009.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5010440","Correctness verification;performance and dependability evaluation;stochastic Time Petri nets;non-Markovian Stochastic Petri Nets;dense-time state-space analysis;Difference Bounds Matrix;Markov Renewal Theory.","Stochastic systems;Stochastic processes;Petri nets;Delay;Clocks;Timing;Density functional theory;Concurrent computing;Computer Society;Cost accounting","equivalence classes;Markov processes;matrix algebra;Petri nets;program verification;reachability analysis;statistical distributions","stochastic state-space class analysis;dense-time reactive system verification;quantitative evaluation;nondeterministic densely-valued temporal parameter;equivalence class;discrete logical location;difference bound matrix;DBM;reachability relation;qualitative correctness verification;event ordering;stimulus/response deadline;stochastic timed Petri net;probability density distribution function measure;static firing interval;nondeterministic transition;stochastic transition system;STPN theory;Markov renewal theory;nondeterministic timer","","44","","43","","29 May 2009","","","IEEE","IEEE Journals"
"Automated Trace Analysis of Discrete-Event System Models","P. Kemper; C. Tepper","College of William and Mary, Williamsburg; ITGAIN Consulting, Hanover","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","195","208","In this paper, we describe a novel technique that helps a modeler gain insight into the dynamic behavior of a complex stochastic discrete event simulation model based on trace analysis. We propose algorithms to distinguish progressive from repetitive behavior in a trace and to extract a minimal progressive fragment of a trace. The implied combinatorial optimization problem for trace reduction is solved in linear time with dynamic programming. We present and compare several approximate and one exact solution method. Information on the reduction operation as well as the reduced trace itself helps a modeler to recognize the presence of certain errors and to identify their cause. We track down a subtle modeling error in a dependability model of a multi-class server system to illustrate the effectiveness of our approach in revealing the cause of an observed effect. The proposed technique has been implemented and integrated in Traviando, a trace analyzer to debug stochastic simulation models.","1939-3520","","10.1109/TSE.2008.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4620122","Testing and Debugging;Simulation;Trace analysis;Cycle reduction;Testing and Debugging;Simulation;Trace analysis;Cycle reduction","Discrete event systems;Discrete event simulation;Context modeling;Communication system software;Software performance;Automatic control;Control systems;Stochastic systems;Debugging;Data mining","combinatorial mathematics;discrete event simulation;dynamic programming;program diagnostics","automated trace analysis;discrete event system models;dynamic behavior;complex stochastic discrete event simulation model;minimal progressive fragment;combinatorial optimization problem;trace reduction;linear time;dynamic programming;reduction operation;modeling error;dependability model;multiclass server system;Traviando;trace analyzer;stochastic simulation model","","20","","22","","5 Sep 2008","","","IEEE","IEEE Journals"
"Estimating Computational Requirements in Multi-Threaded Applications","J. F. Pérez; G. Casale; S. Pacheco-Sanchez","Department of Computing, Imperial College London, United Kingdom; Department of Computing, Imperial College London, United Kingdom; SAP HANA Cloud Computing, Systems Engineering, Belfast, United Kingdom","IEEE Transactions on Software Engineering","11 Mar 2015","2015","41","3","264","278","Performance models provide effective support for managing quality-of-service (QoS) and costs of enterprise applications. However, expensive high-resolution monitoring would be needed to obtain key model parameters, such as the CPU consumption of individual requests, which are thus more commonly estimated from other measures. However, current estimators are often inaccurate in accounting for scheduling in multi-threaded application servers. To cope with this problem, we propose novel linear regression and maximum likelihood estimators. Our algorithms take as inputs response time and resource queue measurements and return estimates of CPU consumption for individual request types. Results on simulated and real application datasets indicate that our algorithms provide accurate estimates and can scale effectively with the threading levels.","1939-3520","","10.1109/TSE.2014.2363472","Seventh Framework Programme; InvestNI/SAP VIRTEX; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6926798","Demand estimation;Multi-threaded application servers;Application performance management;Demand estimation;multi-threaded application servers;application performance management","Time factors;Servers;Instruction sets;Maximum likelihood estimation;Computational modeling;Time measurement","maximum likelihood estimation;multi-threading;quality of service;queueing theory;regression analysis;software performance evaluation;systems analysis","computational requirement estimation;expensive high-resolution monitoring;quality-of-service;QoS management;cost management;performance models;CPU consumption;multithreaded application server scheduling;linear regression;maximum likelihood estimators;input response time;resource queue measurements;enterprise applications","","21","","41","","16 Oct 2014","","","IEEE","IEEE Journals"
"Software Reliability Modeling with Software Metrics Data via Gaussian Processes","N. Torrado; M. P. Wiper; R. E. Lillo","Universidad Carlos III de Madrid, Madrid; Universidad Carlos III de Madrid, Madrid; Universidad Carlos III de Madrid, Madrid","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1179","1186","In this paper, we describe statistical inference and prediction for software reliability models in the presence of covariate information. Specifically, we develop a semiparametric, Bayesian model using Gaussian processes to estimate the numbers of software failures over various time periods when it is assumed that the software is changed after each time period and that software metrics information is available after each update. Model comparison is also carried out using the deviance information criterion, and predictive inferences on future failures are shown. Real-life examples are presented to illustrate the approach.","1939-3520","","10.1109/TSE.2012.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392172","Software metrics;software failures;reliability;statistical methods;Markov chain Monte Carlo method","Software;Gaussian processes;Software reliability;Software metrics;Predictive models;Bayesian methods","Bayes methods;Gaussian processes;inference mechanisms;software metrics;software reliability;statistical analysis;system recovery","software reliability modeling;statistical inference;covariate information;semiparametric Bayesian model;Gaussian process;software failure;software metrics information;deviance information criterion;predictive inference;future failure","","8","","30","","21 Dec 2012","","","IEEE","IEEE Journals"
"COVERT: Compositional Analysis of Android Inter-App Permission Leakage","H. Bagheri; A. Sadeghi; J. Garcia; S. Malek","Department of Computer Science, George Mason University, Fairfax, VA; Department of Computer Science, George Mason University, Fairfax, VA 22030; Computer Science and Artificial Intelligence Laboratory at MIT, Cambridge, MA; Computer Science and Artificial Intelligence Laboratory at MIT, Cambridge, MA","IEEE Transactions on Software Engineering","15 Sep 2015","2015","41","9","866","886","Android is the most popular platform for mobile devices. It facilitates sharing of data and services among applications using a rich inter-app communication system. While access to resources can be controlled by the Android permission system, enforcing permissions is not sufficient to prevent security violations, as permissions may be mismanaged, intentionally or unintentionally. Android's enforcement of the permissions is at the level of individual apps, allowing multiple malicious apps to collude and combine their permissions or to trick vulnerable apps to perform actions on their behalf that are beyond their individual privileges. In this paper, we present COVERT, a tool for compositional analysis of Android inter-app vulnerabilities. COVERT's analysis is modular to enable incremental analysis of applications as they are installed, updated, and removed. It statically analyzes the reverse engineered source code of each individual app, and extracts relevant security specifications in a format suitable for formal verification. Given a collection of specifications extracted in this way, a formal analysis engine (e.g., model checker) is then used to verify whether it is safe for a combination of applications-holding certain permissions and potentially interacting with each other-to be installed together. Our experience with using COVERT to examine over 500 real-world apps corroborates its ability to find inter-app vulnerabilities in bundles of some of the most popular apps on the market.","1939-3520","","10.1109/TSE.2015.2419611","US Defense Advanced Research Projects Agency; US National Security Agency; US Department of Homeland Security; US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7079508","Formal Verification;Static Analysis;Android;Inter-App Vulnerabilities;Formal verification;static analysis;Android;Inter-App vulnerabilities","Smart phones;Androids;Humanoid robots;Security;Analytical models;Data mining;Metals","Android (operating system);formal specification;formal verification;mobile computing;program diagnostics;security of data","COVERT tool;compositional analysis;formal analysis engine;security specification;formal verification;incremental analysis;Android inter-app vulnerabilities analysis;security violation;Android permission system;inter-app communication system;mobile devices;Android inter-app permission leakage","","59","1","60","","3 Apr 2015","","","IEEE","IEEE Journals"
"WAM—The Weighted Average Method for Predicting the Performance of Systems with Bursts of Customer Sessions","D. Krishnamurthy; J. Rolia; M. Xu","University of Calgary, Calgary; Hewlett Packard Labs, Bristol; University of Calgary, Calgary","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","718","735","Predictive performance models are important tools that support system sizing, capacity planning, and systems management exercises. We introduce the Weighted Average Method (WAM) to improve the accuracy of analytic predictive performance models for systems with bursts of concurrent customers. WAM considers the customer population distribution at a system to reflect the impact of bursts. The WAM approach is robust with respect to distribution functions, including heavy-tail-like distributions, for workload parameters. We demonstrate the effectiveness of WAM using a case study involving a multitier TPC-W benchmark system. To demonstrate the utility of WAM with multiple performance modeling approaches, we developed both Queuing Network Models and Layered Queuing Models for the system. Results indicate that WAM improves prediction accuracy for bursty workloads for QNMs and LQMs by 10 and 12 percent, respectively, with respect to a Markov Chain approach reported in the literature.","1939-3520","","10.1109/TSE.2011.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5953602","Performance of systems;modeling techniques;queuing theory;operational analysis.","Markov processes;Analytical models;Predictive models;Accuracy;Queueing analysis;Time factors;Software","Markov processes;queueing theory;software performance evaluation;systems analysis","weighted average method;system performance prediction;customer session bursts;system sizing;capacity planning;systems management exercises;analytic predictive performance models;heavy tail like distributions;multitier TPC-W benchmark system;queuing network models;layered queuing models;bursty workloads;Markov chain approach","","10","","41","","14 Jul 2011","","","IEEE","IEEE Journals"
"A Study of Causes and Consequences of Client-Side JavaScript Bugs","F. S. Ocariza; K. Bajaj; K. Pattabiraman; A. Mesbah","Department of Electrical and Computer Engineering, University of British Columbia, Vancouver, BC, Canada; Department of Electrical and Computer Engineering, University of British Columbia, Vancouver, BC, Canada; Department of Electrical and Computer Engineering, University of British Columbia, Vancouver, BC, Canada; Department of Electrical and Computer Engineering, University of British Columbia, Vancouver, BC, Canada","IEEE Transactions on Software Engineering","13 Feb 2017","2017","43","2","128","144","Client-side JavaScript is widely used in web applications to improve user-interactivity and minimize client-server communications. Unfortunately, JavaScript is known to be error-prone. While prior studies have demonstrated the prevalence of JavaScript faults, no attempts have been made to determine their causes and consequences. The goal of our study is to understand the root causes and impact of JavaScript faults and how the results can impact JavaScript programmers, testers and tool developers. We perform an empirical study of 502 bug reports from 19 bug repositories. The bug reports are thoroughly examined to classify and extract information about each bug' cause (the error) and consequence (the failure and impact). Our results show that the majority (68 percent) of JavaScript faults are DOM-related, meaning they are caused by faulty interactions of the JavaScript code with the Document Object Model (DOM). Further, 80 percent of the highest impact JavaScript faults are DOM-related. Finally, most JavaScript faults originate from programmer mistakes committed in the JavaScript code itself, as opposed to other web application components. These results indicate that JavaScript programmers and testers need tools that can help them reason about the DOM. Additionally, developers can use the error patterns we found to design more powerful static analysis tools for JavaScript.","1939-3520","","10.1109/TSE.2016.2586066","Natural Sciences and Engineering Research Council of Canada (NSERC); Intel Corporation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7501855","Faults;JavaScript;Document Object Model (DOM);bug reports;empirical study","Computer bugs;Servers;Market research;HTML;Data mining;Reliability;Cascading style sheets","client-server systems;Internet;Java;program debugging;software fault tolerance","client-side JavaScript bugs;user-interactivity;client-server communications;JavaScript programmers;bug repositories;information extraction;DOM-related JavaScript faults;JavaScript code;document object model;Web application components;static analysis tools","","16","","55","","29 Jun 2016","","","IEEE","IEEE Journals"
"Improving Automated Bug Triaging with Specialized Topic Model","X. Xia; D. Lo; Y. Ding; J. M. Al-Kofahi; T. N. Nguyen; X. Wang","College of Computer Science and Technology, Zhejiang University, Hangzhou, China; School of Information Systems, Singapore Management University, Singapore, Singapore; School of Information Systems, Singapore Management University, Singapore, Singapore; Electrical and Computer Engineering Department, Iowa State University, Ames, IA, USA; Electrical and Computer Engineering Department, Iowa State University, Ames, IA, USA; College of Computer Science and Technology, Zhejiang University, Hangzhou, China","IEEE Transactions on Software Engineering","13 Mar 2017","2017","43","3","272","297","Bug triaging refers to the process of assigning a bug to the most appropriate developer to fix. It becomes more and more difficult and complicated as the size of software and the number of developers increase. In this paper, we propose a new framework for bug triaging, which maps the words in the bug reports (i.e., the term space) to their corresponding topics (i.e., the topic space). We propose a specialized topic modeling algorithm named  multi-feature topic model (MTM) which extends Latent Dirichlet Allocation (LDA) for bug triaging. MTM  considers product and component information of bug reports to map the term space to the topic space. Finally, we propose an incremental learning method named TopicMiner which considers the topic distribution of a new bug report to assign an appropriate fixer based on the affinity of the fixer to the topics. We pair  TopicMiner with MTM (TopicMiner$^{MTM}$ ). We have evaluated our solution on 5 large bug report datasets including GCC, OpenOffice, Mozilla, Netbeans, and Eclipse containing a total of 227,278 bug reports. We show that TopicMiner $^{MTM}$  can achieve top-1 and top-5 prediction accuracies of 0.4831-0.6868, and 0.7686-0.9084, respectively. We also compare TopicMiner$^{MTM}$  with Bugzie, LDA-KL, SVM-LDA, LDA-Activity, and Yang et al.'s approach. The results show that TopicMiner $^{MTM}$  on average improves top-1 and top-5 prediction accuracies of Bugzie by 128.48 and 53.22 percent, LDA-KL by 262.91 and 105.97 percent, SVM-LDA by 205.89 and 110.48 percent, LDA-Activity by 377.60 and 176.32 percent, and Yang et al.'s approach by 59.88 and 13.70 percent, respectively.","1939-3520","","10.1109/TSE.2016.2576454","National Basic Research Program of China (the 973 Program); NSFC; National Key Technology R&D Program; Ministry of Science and Technology of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7484672","Developer;bug triaging;feature information;topic model","Software;Resource management;Software algorithms;Support vector machines;Learning systems;Indexes;Computer bugs","","","","53","","46","","7 Jun 2016","","","IEEE","IEEE Journals"
"GreenDroid: Automated Diagnosis of Energy Inefficiency for Smartphone Applications","Y. Liu; C. Xu; S. C. Cheung; J. Lü","Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kong; State Key Laboratory for Novel Software Technology and Department of Computer Science and Technology, Nanjing University, 163 Xianlin Avenue, Nanjing, China; Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kong; State Key Laboratory for Novel Software Technology and Department of Computer Science and Technology, Nanjing University, 163 Xianlin Avenue, Nanjing, China","IEEE Transactions on Software Engineering","4 Sep 2014","2014","40","9","911","940","Smartphone applications' energy efficiency is vital, but many Android applications suffer from serious energy inefficiency problems. Locating these problems is labor-intensive and automated diagnosis is highly desirable. However, a key challenge is the lack of a decidable criterion that facilitates automated judgment of such energy problems. Our work aims to address this challenge. We conducted an in-depth study of 173 open-source and 229 commercial Android applications, and observed two common causes of energy problems: missing deactivation of sensors or wake locks, and cost-ineffective use of sensory data. With these findings, wepropose an automated approach to diagnosing energy problems in Android applications. Our approach explores an application's state space by systematically executing the application using Java PathFinder (JPF). It monitors sensor and wake lock operations to detect missing deactivation of sensors and wake locks. It also tracks the transformation and usage of sensory data and judges whether they are effectively utilized by the application using our state-sensitive data utilization metric. In this way, our approach can generate detailed reports with actionable information to assist developers in validating detected energy problems. We built our approach as a tool, GreenDroid, on top of JPF. Technically, we addressed the challenges of generating user interaction events and scheduling event handlers in extending JPF for analyzing Android applications. We evaluated GreenDroid using 13 real-world popular Android applications. GreenDroid completed energy efficiency diagnosis for these applications in a few minutes. It successfully located real energy problems in these applications, and additionally found new unreported energy problems that were later confirmed by developers.","1939-3520","","10.1109/TSE.2014.2323982","Research Grants Council; National High-Tech Research & Development Program; National Natural Science Foundation; New Century Excellent Talents in University; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6815752","Smartphone application;energy inefficiency;automated diagnosis;sensory data utilization;green computing","Androids;Humanoid robots;Computer bugs;Sensors;Open source software;Green products;Google","Android (operating system);Java;power aware computing;program diagnostics;public domain software;smart phones","GreenDroid;automated energy inefficiency diagnosis;smartphone applications;labor-intensive diagnosis;automated diagnosis;open-source Android applications;commercial Android applications;Java PathFinder;JPF;wake lock operations;state-sensitive data utilization metric;user interaction events;scheduling event handlers","","40","","72","","14 May 2014","","","IEEE","IEEE Journals"
"A Controlled Experiment for Program Comprehension through Trace Visualization","B. Cornelissen; A. Zaidman; A. van Deursen","Software Improvement Group, Amsterdam; Delft University of Technology, Delft; Delft University of Technology, Delft","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","341","355","Software maintenance activities require a sufficient level of understanding of the software at hand that unfortunately is not always readily available. Execution trace visualization is a common approach in gaining this understanding, and among our own efforts in this context is Extravis, a tool for the visualization of large traces. While many such tools have been evaluated through case studies, there have been no quantitative evaluations to the present day. This paper reports on the first controlled experiment to quantitatively measure the added value of trace visualization for program comprehension. We designed eight typical tasks aimed at gaining an understanding of a representative subject system, and measured how a control group (using the Eclipse IDE) and an experimental group (using both Eclipse and Extravis) performed these tasks in terms of time spent and solution correctness. The results are statistically significant in both regards, showing a 22 percent decrease in time requirements and a 43 percent increase in correctness for the group using trace visualization.","1939-3520","","10.1109/TSE.2010.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5441291","Program comprehension;dynamic analysis;controlled experiment.","Visualization;Computer Society;Time measurement;Programming;Documentation;Scalability;Software maintenance;Gain measurement;Control systems;Performance evaluation","data visualisation;software maintenance","program comprehension;software maintenance;execution trace visualization","","63","","56","","1 Apr 2010","","","IEEE","IEEE Journals"
"Loupe: Verifying Publish-Subscribe Architectures with a Magnifying Lens","L. Baresi; C. Ghezzi; L. Mottola","Politecnico di Milano, Milano; Politecnico di Milano, Milano; Politecnico di Milano, Milano","IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","228","246","The Publish-Subscribe (P/S) communication paradigm fosters high decoupling among distributed components. This facilitates the design of dynamic applications, but also impacts negatively on their verification, making it difficult to reason on the overall federation of components. In addition, existing P/S infrastructures offer radically different features to the applications, e.g., in terms of message reliability. This further complicates the verification as its outcome depends on the specific guarantees provided by the underlying P/S system. Although model checking has been proposed as a tool for the verification of P/S architectures, existing solutions overlook many characteristics of the underlying communication infrastructure to avoid state explosion problems. To overcome these limitations, the Loupe domain-specific model checker adopts a different approach. The P/S infrastructure is not modeled on top of a general-purpose model checker. Instead, it is embedded within the checking engine, and the traditional P/S operations become part of the modeling language. In this paper, we describe Loupe's design and the dedicated state abstractions that enable accurate verification without incurring state explosion problems. We also illustrate our use of state-of-the-art software verification tools to assess some key functionality in Loupe's current implementation. A complete case study shows how Loupe eases the verification of P/S architectures. Finally, we quantitatively compare Loupe's performance against alternative approaches. The results indicate that Loupe is effective and efficient in enabling accurate verification of P/S architectures.","1939-3520","","10.1109/TSE.2010.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432228","Publish-subscribe;verification;model-checking.","Publish-subscribe;Lenses;Application software;Explosions;Computer architecture;Context;Engines;Software tools;Software systems;Business communication","formal verification;message passing;middleware","publish-subscribe architectures;lens magnification;publish-subscribe communication paradigm;distributed component;P-S infrastructures;message reliability;P-S architectures verification;communication infrastructure;state explosion problem;Loupe domain-specific model checker;general purpose model checker;P-S operation;modeling language;Loupe design;dedicated state abstraction;state-of-the-art software verification tool","","10","","64","","18 Mar 2010","","","IEEE","IEEE Journals"
"Exploiting Dynamic Information in IDEs Improves Speed and Correctness of Software Maintenance Tasks","D. Rothlisberger; M. Harry; W. Binder; P. Moret; D. Ansaloni; A. Villazon; O. Nierstrasz","Universitát Bern, Bern; Universitát Bern, Bern; University of Lugano (USI), Lugano; University of Lugano (USI), Lugano; University of Lugano (USI), Lugano; Universidad Privada Boliviana (UPB), Cochabamba; Universitát Bern, Bern","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","579","591","Modern IDEs such as Eclipse offer static views of the source code, but such views ignore information about the runtime behavior of software systems. Since typical object-oriented systems make heavy use of polymorphism and dynamic binding, static views will miss key information about the runtime architecture. In this paper, we present an approach to gather and integrate dynamic information in the Eclipse IDE with the goal of better supporting typical software maintenance activities. By means of a controlled experiment with 30 professional developers, we show that for typical software maintenance tasks, integrating dynamic information into the Eclipse IDE yields a significant 17.5 percent decrease of time spent while significantly increasing the correctness of the solutions by 33.5 percent. We also provide a comprehensive performance evaluation of our approach.","1939-3520","","10.1109/TSE.2011.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6178187","Object-oriented programming;integrated environments;restructuring;reverse engineering;reengineering;complexity measures;performance measures.","Runtime;Measurement;Java;Context;Software maintenance;Concrete;Weaving","dynamic programming;object-oriented programming;program compilers;software maintenance","exploiting dynamic information;IDE;software maintenance tasks;Eclipse;source code;runtime behavior;software systems;object-oriented systems;dynamic binding;runtime architecture;dynamic information","","18","","35","","5 Apr 2012","","","IEEE","IEEE Journals"
"A Dynamic Slicing Technique for UML Architectural Models","J. T. Lallchandani; R. Mall","Indian Institute of Technology Kharagpur, WB INDIA; Indian Institute of Technology Kharagpur, WB INDIA","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","737","771","This paper proposes a technique for dynamic slicing of UML architectural models. The presence of related information in diverse model parts (or fragments) makes dynamic slicing of Unified Modeling Language (UML) models a complex problem. We first extract all relevant information from a UML model specifying a software architecture into an intermediate representation, which we call a Model Dependency Graph (MDG). For a given slicing criterion, our slicing algorithm traverses the constructed MDG to identify the relevant model parts that are directly or indirectly affected during the execution of a specified scenario. One novelty of our approach is computation of dynamic slice based on the structural and behavioral (interactions only) UML models as against independently processing separate UML models, and determining the implicit interdependencies among different model elements distributed across model views. We also briefly discuss a prototype tool named Archlice, which we have developed to implement our algorithm.","1939-3520","","10.1109/TSE.2010.112","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680909","Software architecture;UML;architectural metamodel;dynamic slicing;impact analysis.","Unified modeling language;Computational modeling;Heuristic algorithms;Computer architecture;Analytical models;Software architecture;Software algorithms","program slicing;software architecture;software prototyping;Unified Modeling Language","dynamic slicing technique;UML architectural models;unified modeling language models;model dependency graph;software architecture;prototype tool;Archlice","","16","","46","","6 Jan 2011","","","IEEE","IEEE Journals"
"Putting Preemptive Time Petri Nets to Work in a V-Model SW Life Cycle","L. Carnevali; L. Ridi; E. Vicario","Università di Firenze, Firenze; Università di Firenze, Firenze; Università di Firenze, Firenze","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","826","844","Preemptive Time Petri Nets (pTPNs) support modeling and analysis of concurrent timed SW components running under fixed priority preemptive scheduling. The model is supported by a well-established theory based on symbolic state space analysis through Difference Bounds Matrix (DBM) zones, with specific contributions on compositional modularization, trace analysis, and efficient overapproximation and cleanup in the management of suspension deriving from preemptive behavior. In this paper, we devise and implement a framework that brings the theory to application. To this end, we cast the theory into an organic tailoring of design, coding, and testing activities within a V-Model SW life cycle in respect of the principles of regulatory standards applied to the construction of safety-critical SW components. To implement the toolchain subtended by the overall approach into a Model Driven Development (MDD) framework, we complement the theory of state space analysis with methods and techniques supporting semiformal specification and automated compilation into pTPN models and real-time code, measurement-based Execution Time estimation, test case selection and execution, coverage evaluation.","1939-3520","","10.1109/TSE.2011.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680913","Real-time systems;safety-critical SW components;SW life cycle;V-Model;preemptive Time Petri Nets;symbolic state space analysis;model driven development;automated model transformation;automated code generation;Execution Time estimation;real-time testing;test case selection and execution;coverage analysis.","Real time systems;Analytical models;Unified modeling language;Petri nets;Mathematical model;Computer architecture","formal specification;Petri nets;program diagnostics;program testing;safety-critical software;scheduling","preemptive time Petri nets;V-model SW life cycle;concurrent timed SW components;fixed priority preemptive scheduling;symbolic state space analysis;difference bounds matrix zones;compositional modularization;trace analysis;overapproximation;safety-critical SW components;model driven development framework;semiformal specification;automated compilation;pTPN models;real-time code;measurement-based execution time estimation;test case selection;test case execution;coverage evaluation","","11","","71","","6 Jan 2011","","","IEEE","IEEE Journals"
"A General Testability Theory: Classes, Properties, Complexity, and Testing Reductions","I. Rodríguez; L. Llana; P. Rabanal","Department of Sistemas Informáticos y Computación, Universidad Complutense de Madrid, Madrid, Spain; Department of Sistemas Informáticos y Computación, Universidad Complutense de Madrid, Madrid, Spain; Department of Sistemas Informáticos y Computación, Universidad Complutense de Madrid, Madrid, Spain","IEEE Transactions on Software Engineering","5 Sep 2014","2014","40","9","862","894","In this paper we develop a general framework to reason about testing. The difficulty of testing is assessed in terms of the amount of tests that must be applied to determine whether the system is correct or not. Based on this criterion, five testability classes are presented and related. We also explore conditions that enable and disable finite testability, and their relation to testing hypotheses is studied. We measure how far incomplete test suites are from being complete, which allows us to compare and select better incomplete test suites. The complexity of finding that measure, as well as the complexity of finding minimum complete test suites, is identified. Furthermore, we address the reduction of testing problems to each other, that is, we study how the problem of finding test suites to test systems of some kind can be reduced to the problem of finding test suites for another kind of systems. This enables to export testing methods. In order to illustrate how general notions are applied to specific cases, many typical examples from the formal testing techniques domain are presented.","1939-3520","","10.1109/TSE.2014.2331690","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6839051","Formal testing techniques;general testing frameworks","Testing;Complexity theory;Proposals;Computational modeling;Probabilistic logic;Abstracts;Computer languages","formal languages;formal verification","general testability theory;complexity;testing reductions;testability classes;finite testability;incomplete test suites;formal testing techniques domain","","17","","35","","18 Jun 2014","","","IEEE","IEEE Journals"
"Methodbook: Recommending Move Method Refactorings via Relational Topic Models","G. Bavota; R. Oliveto; M. Gethers; D. Poshyvanyk; A. De Lucia","University of Sannio, Benevento, Italy; University of Molise, Pesche (IS), Italy; Information Systems Department , University of Maryland, Baltimore County, 1000 Hilltop Circle, Baltimore; College of William and Mary, McGlothlin-Street Hall 006, Williamsburg; University of Salerno, Fisciano (SA), Italy","IEEE Transactions on Software Engineering","8 Jul 2014","2014","40","7","671","694","During software maintenance and evolution the internal structure of the software system undergoes continuous changes. These modifications drift the source code away from its original design, thus deteriorating its quality, including cohesion and coupling of classes. Several refactoring methods have been proposed to overcome this problem. In this paper we propose a novel technique to identify Move Method refactoring opportunities and remove the Feature Envy bad smell from source code. Our approach, coined as Methodbook, is based on relational topic models (RTM), a probabilistic technique for representing and modeling topics, documents (in our case methods) and known relationships among these. Methodbook uses RTM to analyze both structural and textual information gleaned from software to better support move method refactoring. We evaluated Methodbook in two case studies. The first study has been executed on six software systems to analyze if the move method operations suggested by Methodbook help to improve the design quality of the systems as captured by quality metrics. The second study has been conducted with eighty developers that evaluated the refactoring recommendations produced by Methodbook. The achieved results indicate that Methodbook provides accurate and meaningful recommendations for move method refactoring operations.","1939-3520","","10.1109/TSE.2013.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6684534","Refactoring;relational topic models;empirical studies","Software systems;Couplings;Measurement;Object oriented modeling;Educational institutions;Electronic mail","software maintenance;software metrics;source code (software)","Methodbook;recommending move method refactorings;relational topic model;software maintenance;source code;modifications drift;quality metrics;software development","","70","","57","","16 Dec 2013","","","IEEE","IEEE Journals"
"Atomicity Analysis of Service Composition across Organizations","C. Ye; S. C. Cheung; W. K. Chan; C. Xu","The Hong Kong University of Science and Technology, Hong Kong; The Hong Kong University of Science and Technology, Hong Kong; City University of Hong Kong, Hong Kong; The Hong Kong University of Science and Technology, Hong Kong","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","2","28","Atomicity is a highly desirable property for achieving application consistency in service compositions. To achieve atomicity, a service composition should satisfy the atomicity sphere, a structural criterion for the backend processes of involved services. Existing analysis techniques for atomicity sphere generally assume complete knowledge of all involved backend processes. Such an assumption is invalid when some service providers do not release all details of their backend processes to service consumers outside the organizations. To address this problem, we propose a process algebraic framework to publish atomicity-equivalent public views from the backend processes. These public views extract relevant task properties and reveal only partial process details that service providers need to expose. Our framework enables the analysis of atomicity sphere for service compositions using these public views instead of their backend processes. This allows service consumers to choose suitable services such that their composition satisfies the atomicity sphere without disclosing the details of their backend processes. Based on the theoretical result, we present algorithms to construct atomicity-equivalent public views and to analyze the atomicity sphere for a service composition. Two case studies from supply chain and insurance domains are given to evaluate our proposal and demonstrate the applicability of our approach.","1939-3520","","10.1109/TSE.2008.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4641941","Analysis;Specification;Software and System Safety;System integration and implementation;Formal methods;Model checking;Validation;Analysis;Specification;Software and System Safety;System integration and implementation;Formal methods;Model checking;Validation","Web services;Privacy;System recovery;Supply chains;Protection;Application software;Algorithm design and analysis;Insurance;Algebra;Internet","process algebra;Web services","atomicity sphere analysis;Web service composition;backend process;process algebraic framework;atomicity-equivalent public view;supply chain;insurance","","22","","76","","10 Oct 2008","","","IEEE","IEEE Journals"
"Quantifying the Effect of Code Smells on Maintenance Effort","D. I. K. Sjøberg; A. Yamashita; B. C. D. Anda; A. Mockus; T. Dybå","University of Oslo, Oslo; University of Oslo, Oslo; University of Oslo, Oslo; Avaya Labs Research, Basking Ridge; University of Oslo, Oslo and SINTEF, Trondheim","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1144","1156","Context: Code smells are assumed to indicate bad design that leads to less maintainable code. However, this assumption has not been investigated in controlled studies with professional software developers. Aim: This paper investigates the relationship between code smells and maintenance effort. Method: Six developers were hired to perform three maintenance tasks each on four functionally equivalent Java systems originally implemented by different companies. Each developer spent three to four weeks. In total, they modified 298 Java files in the four systems. An Eclipse IDE plug-in measured the exact amount of time a developer spent maintaining each file. Regression analysis was used to explain the effort using file properties, including the number of smells. Result: None of the 12 investigated smells was significantly associated with increased effort after we adjusted for file size and the number of changes; Refused Bequest was significantly associated with decreased effort. File size and the number of changes explained almost all of the modeled variation in effort. Conclusion: The effects of the 12 smells on maintenance effort were limited. To reduce maintenance effort, a focus on reducing code size and the work practices that limit the number of changes may be more beneficial than refactoring code smells.","1939-3520","","10.1109/TSE.2012.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392174","Maintainability;object-oriented design;product metrics;code churn","Maintenance engineering;Java;Software;Surgery;Time measurement;Context;Electronic mail","Java;regression analysis;software maintenance","code smell effect quantification;maintenance effort;maintainable code;maintenance tasks;Java systems;Java files;Eclipse IDE plug-in;regression analysis;file properties;refused bequest;file size;code size reduction;code smell refactoring","","142","","46","","21 Dec 2012","","","IEEE","IEEE Journals"
"GUI Interaction Testing: Incorporating Event Context","X. Yuan; M. B. Cohen; A. M. Memon","Google Kirkland; University of Nebraska-Lincoln, Lincoln; University of Maryland, College Park","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","559","574","Graphical user interfaces (GUIs), due to their event-driven nature, present an enormous and potentially unbounded way for users to interact with software. During testing, it is important to “adequately cover” this interaction space. In this paper, we develop a new family of coverage criteria for GUI testing grounded in combinatorial interaction testing. The key motivation of using combinatorial techniques is that they enable us to incorporate “context” into the criteria in terms of event combinations, sequence length, and by including all possible positions for each event. Our new criteria range in both efficiency (measured by the size of the test suite) and effectiveness (the ability of the test suites to detect faults). In a case study on eight applications, we automatically generate test cases and systematically explore the impact of context, as captured by our new criteria. Our study shows that by increasing the event combinations tested and by controlling the relative positions of events defined by the new criteria, we can detect a large number of faults that were undetectable by earlier techniques.","1939-3520","","10.1109/TSE.2010.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5444885","GUI testing;automated testing;model-based testing;combinatorial interaction testing;GUITAR testing system.","Graphical user interfaces;System testing;Software testing;Automatic testing;Fault detection;Context modeling;Computer science;Software performance;Logic testing;User interfaces","automatic test pattern generation;graphical user interfaces;program testing","GUI interaction testing;graphical user interface;event driven nature;combinatorial interaction testing;automatic test case generation","","89","4","44","","8 Apr 2010","","","IEEE","IEEE Journals"
"Directed Explicit State-Space Search in the Generation of Counterexamples for Stochastic Model Checking","H. Aljazzar; S. Leue","University of Konstanz, Konstanz; University of Konstanz, Konstanz","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","37","60","Current stochastic model checkers do not make counterexamples for property violations readily available. In this paper, we apply directed explicit state-space search to discrete and continuous-time Markov chains in order to compute counterexamples for the violation of PCTL or CSL properties. Directed explicit state-space search algorithms explore the state space on-the-fly, which makes our method very efficient and highly scalable. They can also be guided using heuristics which usually improve the performance of the method. Counterexamples provided by our method have two important properties. First, they include those traces which contribute the greatest amount of probability to the property violation. Hence, they show the most probable offending execution scenarios of the system. Second, the obtained counterexamples tend to be small. Hence, they can be effectively analyzed by a human user. Both properties make the counterexamples obtained by our method very useful for debugging purposes. We implemented our method based on the stochastic model checker PRISM and applied it to a number of case studies in order to illustrate its applicability.","1939-3520","","10.1109/TSE.2009.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5262946","Directed explicit state-space search;heuristic search;counterexamples;stochastic model checking.","Stochastic processes;Debugging;Probabilistic logic;Safety;Performance analysis;Space exploration;State-space methods;Humans;Shape;Sampling methods","formal verification;Markov processes;program debugging;tree searching","directed explicit state-space search;stochastic model checking;discrete-time Markov chains;continuous-time Markov chains;PCTL properties;CSL properties;heuristic search;debugging","","31","","49","","25 Sep 2009","","","IEEE","IEEE Journals"
"Conservative Reasoning about the Probability of Failure on Demand of a 1-out-of-2 Software-Based System in Which One Channel Is ""Possibly Perfect""","B. Littlewood; A. Povyakalo","City University London, London; City University London, London","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1521","1530","In earlier work, [11] (henceforth LR), an analysis was presented of a 1-out-of-2 software-based system in which one channel was “possibly perfect”. It was shown that, at the aleatory level, the system pfd (probability of failure on demand) could be bounded above by the product of the pfd of channel A and the pnp (probability of nonperfection) of channel B. This result was presented as a way of avoiding the well-known difficulty that for two certainly-fallible channels, failures of the two will be dependent, i.e., the system pfd cannot be expressed simply as a product of the channel pfds. A price paid in this new approach for avoiding the issue of failure dependence is that the result is conservative. Furthermore, a complete analysis requires that account be taken of epistemic uncertainty-here concerning the numeric values of the two parameters pfdA and pnpB. Unfortunately this introduces a different difficult problem of dependence: estimating the dependence between an assessor's beliefs about the parameters. The work reported here avoids this problem by obtaining results that require only an assessor's marginal beliefs about the individual channels, i.e., they do not require knowledge of the dependence between these beliefs. The price paid is further conservatism in the results.","1939-3520","","10.1109/TSE.2013.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6574864","Software reliability;fault tolerance;software perfection;probability of failure;epistemic uncertainty;software diversity;multiversion software","Phase frequency detector;Uncertainty;Cognition;Software reliability;Software;Safety","belief networks;failure analysis;probability;software reliability;uncertainty handling","conservative reasoning;probability of failure on demand;1-out-of-2 software-based system;PFD;PNP;probability of nonperfection;certainly fallible channel;assessor marginal belief;epistemic uncertainty;software perfection","","4","","15","","5 Aug 2013","","","IEEE","IEEE Journals"
"An Empirical Study of RefactoringChallenges and Benefits at Microsoft","M. Kim; T. Zimmermann; N. Nagappan","Department of Electrical and Computer Engineering, University of Texas, Austin; Microsoft Research at Redmond; Microsoft Research at Redmond","IEEE Transactions on Software Engineering","8 Jul 2014","2014","40","7","633","649","It is widely believed that refactoring improves software quality and developer productivity. However, few empirical studies quantitatively assess refactoring benefits or investigate developers' perception towards these benefits. This paper presents a field study of refactoring benefits and challenges at Microsoft through three complementary study methods: a survey, semi-structured interviews with professional software engineers, and quantitative analysis of version history data. Our survey finds that the refactoring definition in practice is not confined to a rigorous definition of semantics-preserving code transformations and that developers perceive that refactoring involves substantial cost and risks. We also report on interviews with a designated refactoring team that has led a multi-year, centralized effort on refactoring Windows. The quantitative analysis of Windows 7 version history finds the top 5 percent of preferentially refactored modules experience higher reduction in the number of inter-module dependencies and several complexity measures but increase size more than the bottom 95 percent. This indicates that measuring the impact of refactoring requires multi-dimensional assessment.","1939-3520","","10.1109/TSE.2014.2318734","National Science Foundation; Microsoft SEIF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6802406","Refactoring;empirical study;software evolution;component dependencies;defects;churn","Computer bugs;Software;Interviews;History;Complexity theory;Size measurement;Software metrics","data analysis;software maintenance;software metrics;software quality","refactoring challenges;refactoring benefits;Microsoft;software quality improvement;survey;semi-structured interviews;quantitative Windows 7 version history data analysis;intermodule dependencies;complexity measures;software evolution","","62","","58","","18 Apr 2014","","","IEEE","IEEE Journals"
"Mining Crosscutting Concerns through Random Walks","C. Zhang; H. Jacobsen","The Hong Kong University of Science and Technology, Hong Kong; University of Toronto, Toronto","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1123","1137","Inspired by our past manual aspect mining experiences, this paper describes a probabilistic random walk model to approximate the process of discovering crosscutting concerns (CCs) in the absence of the domain knowledge about the investigated application. The random walks are performed on the concept graphs extracted from the program sources to calculate metrics of “utilization” and “aggregation” for each of the program elements. We rank all the program elements based on these metrics and use a threshold to produce a set of candidates that represent crosscutting concerns. We implemented the algorithm as the Prism CC miner (PCM) and evaluated PCM on Java applications ranging from a small-scale drawing application to a medium-sized middleware application and to a large-scale enterprise application server. Our quantification shows that PCM is able to produce comparable results (95 percent accuracy for the top 125 candidates) with respect to the manual mining effort. PCM is also significantly more effective as compared to the conventional approach.","1939-3520","","10.1109/TSE.2011.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5989837","Aspect mining;mining crosscutting concerns","Phase change materials;Radiation detectors;Data mining;Manuals;Mathematical model;Computational modeling;Algorithm design and analysis","aspect-oriented programming;data mining;graph theory;Java;middleware;probability;small-to-medium enterprises","crosscutting concerns mining;probabilistic random walk model;concept graphs;utilization metric;aggregation metric;program sources;program elements;Prism CC miner;Java applications;small-scale drawing application;medium-sized middleware application;large-scale enterprise application server;aspect mining","","6","","37","","18 Aug 2011","","","IEEE","IEEE Journals"
"A Framework for Programming Robust Context-Aware Applications","D. Kulkarni; A. Tripathi","University of Minnesota, Minneapolis; University of Minnesota, Minneapolis","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","184","197","In this paper, we present a forward recovery model for programming robust context-aware applications. The mechanisms devised as part of this model fall into two categories: asynchronous event handling and synchronous exception handling. These mechanisms enable designing recovery actions to handle different kinds of failure conditions arising in context-aware applications. These include service discovery failures, service binding failures, exceptions raised by a service, and context invalidations. This model is integrated in the high-level programming framework that we have designed for building context-aware collaborative (CSCW) applications. In this paper, we demonstrate the capabilities of this model for programming various kinds of recovery patterns in context-aware applications.","1939-3520","","10.1109/TSE.2010.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5396345","Exception handling;context-aware applications;robustness;fault tolerance;design methodology.","Robustness;Context-aware services;Context modeling;Access control;Application software;Collaboration;Information systems;Buildings;Fault tolerance;Design methodology","exception handling;groupware;object-oriented programming;software fault tolerance;system recovery;ubiquitous computing","robust context aware application programming;forward recovery model;asynchronous event handling;synchronous exception handling;recovery patterns;service discovery failures;service binding failures;context invalidations;high level programming framework;context aware collaborative applications;CSCW","","40","","30","","22 Jan 2010","","","IEEE","IEEE Journals"
"Analyzing Critical Decision-Based Processes","C. Damas; B. Lambeau; A. van Lamsweerde","Department of Computing, Icteam Institute, Université Catholique de Louvain, Louvain-La-Neuve, Belgium; Department of Computing, Icteam Institute, Université Catholique de Louvain, Louvain-La-Neuve, Belgium; Department of Computing, Icteam Institute, Université Catholique de Louvain, Louvain-La-Neuve, Belgium","IEEE Transactions on Software Engineering","2 May 2014","2014","40","4","338","365","Decision-based processes are composed of tasks whose application may depend on explicit decisions relying on the state of the process environment. In specific domains such as healthcare, decision-based processes are often complex and critical in terms of timing and resources. The paper presents a variety of tool-supported techniques for analyzing models of such processes. The analyses allow a variety of errors to be detected early and incrementally on partial models, notably: inadequate decisions resulting from inaccurate or outdated information about the environment state; incomplete decisions; non-deterministic task selections; unreachable tasks along process paths; and violations of non-functional process requirements involving time, resources or costs. The proposed techniques are based on different instantiations of the same generic algorithm that propagates decorations iteratively through the process model. This algorithm in particular allows event-based models to be automatically decorated with state-based invariants. A formal language supporting both event-based and state-based specifications is introduced as a process modeling language to enable such analyses. This language mimics the informal flowcharts commonly used by process stakeholders. It extends High-Level Message Sequence Charts with guards on task-related and environment-related variables. The language provides constructs for specifying task compositions, task refinements, decision trees, multi-agent communication scenarios, and time and resource constraints. The proposed techniques are demonstrated on the incremental building and analysis of a complex model of a real protocol for cancer therapy.","1939-3520","","10.1109/TSE.2014.2312954","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6776491","Process modeling;process analysis;model verification;decision errors;safety-critical workflows;non-functional requirements;domain-specific languages;formal specification","Analytical models;Unified modeling language;Algorithm design and analysis;Semantics;Blood;Flowcharts;Medical treatment","cancer;decision trees;formal languages;formal specification;multi-agent systems;patient treatment","critical decision-based process analysis;tool-supported techniques;partial models;environment state;incomplete decisions;nondeterministic task selections;unreachable tasks;process paths;nonfunctional process requirement violation;event-based models;state-based invariants;formal language;event-based specification;state-based specification;process modeling language;informal flowcharts;high-level message sequence charts;task-related variables;environment-related variables;task compositions;task refinements;decision trees;multiagent communication scenarios;time constraints;resource constraints;cancer therapy","","2","","80","","20 Mar 2014","","","IEEE","IEEE Journals"
"Software Architecture Optimization Methods: A Systematic Literature Review","A. Aleti; B. Buhnova; L. Grunske; A. Koziolek; I. Meedeniya","Monash University, Australia; Masaryk University, Brno; University of Kaiserslautern, Kaiserslautern; University of Zurich, Zurich; Swinburne University of Technology, Hawthorn","IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","658","683","Due to significant industrial demands toward software systems with increasing complexity and challenging quality requirements, software architecture design has become an important development activity and the research domain is rapidly evolving. In the last decades, software architecture optimization methods, which aim to automate the search for an optimal architecture design with respect to a (set of) quality attribute(s), have proliferated. However, the reported results are fragmented over different research communities, multiple system domains, and multiple quality attributes. To integrate the existing research results, we have performed a systematic literature review and analyzed the results of 188 research papers from the different research communities. Based on this survey, a taxonomy has been created which is used to classify the existing research. Furthermore, the systematic analysis of the research literature provided in this review aims to help the research community in consolidating the existing research efforts and deriving a research agenda for future developments.","1939-3520","","10.1109/TSE.2012.64","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311410","Software architecture optimization;systematic literature review;optimization methods;problem overview","Taxonomy;Computer architecture;Software;Software architecture;Systematics;Optimization methods","software architecture;software quality","software architecture optimization method;software system;software architecture design;software quality attribute","","138","","245","","24 Sep 2012","","","IEEE","IEEE Journals"
"CHARMY: A Framework for Designing and Verifying Architectural Specifications","P. Pelliccione; P. Inverardi; H. Muccini","Università dell' Aquila, L'Aquila; Università dell' Aquila, L'Aquila; Università dell' Aquila, L'Aquila","IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","325","346","Introduced in the early stages of software development, the Charmy framework assists the software architect in making and evaluating architectural choices. Rarely, the software architecture of a system can be established once and forever. Most likely poorly defined and understood architectural constraints and requirements force the software architect to accept ambiguities and move forward to the construction of a suboptimal software architecture. Charmy aims to provide an easy and practical tool for supporting the iterative modeling and evaluation of software architectures. From an UML-based architectural design, an executable prototype is automatically created. Charmy simulation and model checking features help in understanding the functioning of the system and discovering potential inconsistencies of the design. When a satisfactory and stable software architecture is reached, Java code conforming to structural software architecture constraints is automatically generated through suitable transformations. The overall approach is tool supported.","1939-3520","","10.1109/TSE.2008.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4711062","Software architectures;model checking.;Software Architectures;Model checking;Design notations and documentation;State diagrams;Rapid prototyping","Software architecture;Computer architecture;Software prototyping;Software systems;Prototypes;Connectors;Unified modeling language;Programming;Java;Topology","Java;program verification;software architecture;Unified Modeling Language","software development;Charmy framework;UML-based architectural design;model checking;Java code;structural software architecture constraints","","39","","39","","12 Dec 2008","","","IEEE","IEEE Journals"
"Aspectizing Java Access Control","R. Toledo; A. Nunez; E. Tanter; J. Noye","University of Chile, Santiago; École des Mines de Nantes-INRIA, LINA, Nantes; University of Chile, Santiago; École des Mines de Nantes-INRIA, LINA, Nantes","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","101","117","It is inevitable that some concerns crosscut a sizeable application, resulting in code scattering and tangling. This issue is particularly severe for security-related concerns: It is difficult to be confident about the security of an application when the implementation of its security-related concerns is scattered all over the code and tangled with other concerns, making global reasoning about security precarious. In this study, we consider the case of access control in Java, which turns out to be a crosscutting concern with a nonmodular implementation based on runtime stack inspection. We describe the process of modularizing access control in Java by means of Aspect-Oriented Programming (AOP). We first show a solution based on AspectJ, the most popular aspect-oriented extension to Java, that must rely on a separate automata infrastructure. We then put forward a novel solution via dynamic deployment of aspects and scoping strategies. Both solutions, apart from providing a modular specification of access control, make it possible to easily express other useful policies such as the Chinese wall policy. However, relying on expressive scope control results in a compact implementation, which, at the same time, permits the straightforward expression of even more interesting policies. These new modular implementations allowed by AOP alleviate maintenance and evolution issues produced by the crosscutting nature of access control.","1939-3520","","10.1109/TSE.2011.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680915","Programming languages;security;aspect-oriented programming;access control.","Aspect-oriented programming;Access control;Computer architecture;Java;Programming;Computer security","aspect-oriented programming;authorisation;automata theory;Java","Java access control aspectization;code scattering;code tangling;security-related concerns;runtime stack inspection;aspect-oriented programming;AspectJ;automata infrastructure;aspects strategies;scoping strategies;Chinese wall policy","","6","","45","","6 Jan 2011","","","IEEE","IEEE Journals"
"A Component Model for Model Transformations","J. S. Cuadrado; E. Guerra; J. de Lara","Department of Computer Science, Universidad Autónoma de Madrid, Spain; Department of Computer Science, Universidad Autónoma de Madrid, Spain; Department of Computer Science, Universidad Autónoma de Madrid, Spain","IEEE Transactions on Software Engineering","10 Nov 2014","2014","40","11","1042","1060","Model-driven engineering promotes an active use of models to conduct the software development process. In this way, models are used to specify, simulate, verify, test and generate code for the final systems. Model transformations are key enablers for this approach, being used to manipulate instance models of a certain modelling language. However, while other development paradigms make available techniques to increase productivity through reutilization, there are few proposals for the reuse of model transformations across different modelling languages. As a result, transformations have to be developed from scratch even if other similar ones exist. In this paper, we propose a technique for the flexible reutilization of model transformations. Our proposal is based on generic programming for the definition and instantiation of transformation templates, and on component-based development for the encapsulation and composition of transformations. We have designed a component model for model transformations, supported by an implementation currently targeting the Atlas Transformation Language (ATL). To evaluate its reusability potential, we report on a generic transformation component to analyse workflow models through their transformation into Petri nets, which we have reused for eight workflow languages, including UML Activity Diagrams, YAWL and two versions of BPMN.","1939-3520","","10.1109/TSE.2014.2339852","Spanish Ministry of Economy and Competitivity with project Go-Lite; EU commission with project MONDO; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6858077","Model-driven engineering;model transformation;reusability;genericity;component-based development","Unified modeling language;Adaptation models;Petri nets;Analytical models;Logic gates;Software;Proposals","object-oriented programming;Petri nets;software reusability","BPMN;YAWL;UML activity diagrams;workflow languages;Petri nets;workflow models;generic transformation component;ATL;Atlas transformation language;component-based development;generic programming;modelling language instance models;software development process;model-driven engineering;model transformations;component model","","25","","69","","17 Jul 2014","","","IEEE","IEEE Journals"
"Dependence Guided Symbolic Execution","H. Wang; T. Liu; X. Guan; C. Shen; Q. Zheng; Z. Yang","Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), School of Electronic and Information Engineering, Xi'an Jiaotong University, Xi'an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), School of Electronic and Information Engineering, Xi'an Jiaotong University, Xi'an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), School of Electronic and Information Engineering, Xi'an Jiaotong University, Xi'an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), School of Electronic and Information Engineering, Xi'an Jiaotong University, Xi'an, China; Ministry of Education Key Lab For Intelligent Networks and Network Security (MOEKLINNS), School of Electronic and Information Engineering, Xi'an Jiaotong University, Xi'an, China; Department of Computer Science, Western Michigan University, Kalamazoo, MI","IEEE Transactions on Software Engineering","13 Mar 2017","2017","43","3","252","271","Symbolic execution is a powerful technique for systematically exploring the paths of a program and generating the corresponding test inputs. However, its practical usage is often limited by the path explosion problem, that is, the number of explored paths usually grows exponentially with the increase of program size. In this paper, we argue that for the purpose of fault detection it is not necessary to systematically explore the paths, and propose a new symbolic execution approach to mitigate the path explosion problem by predicting and eliminating the redundant paths based on symbolic value. Our approach can achieve the equivalent fault detection capability as traditional symbolic execution without exhaustive path exploration. In addition, we develop a practical implementation called Dependence Guided Symbolic Execution (DGSE) to soundly approximate our approach. Through exploiting program dependence, DGSE can predict and eliminate the redundant paths at a reasonable computational cost. Our empirical study shows that the redundant paths are abundant and widespread in a program. Compared with traditional symbolic execution, DGSE only explores 6.96 to 96.57 percent of the paths and achieves a speedup of 1.02 $\times$  to 49.56$\times$ . We have released our tool and the benchmarks used to evaluate DGSE$^\ast$ .","1939-3520","","10.1109/TSE.2016.2584063","National Natural Science Foundation of China; Fok Ying-Tong Education Foundation; National Research Program of China; Ministry of Education Innovation Research Team; Fundamental Research Funds for the Central Universities; US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7497518","Symbolic execution;path coverage;program dependence","Fault detection;Explosions;Benchmark testing;Electronic mail;Computational efficiency;Input variables","","","","19","","65","","22 Jun 2016","","","IEEE","IEEE Journals"
"CoMoM: Efficient Class-Oriented Evaluation of Multiclass Performance Models","G. Casale","College of William and Mary, Williamsburg","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","162","177","We introduce the class-oriented method of moments (CoMoM), a new exact algorithm to compute performance indexes in closed multiclass queuing networks. Closed models are important for performance evaluation of multitier applications, but when the number of service classes is large, they become too expensive to solve with exact methods such as mean value analysis (MVA). CoMoM addresses this limitation by a new recursion that scales efficiently with the number of classes. Compared to the MVA algorithm, which recursively computes mean queue lengths, CoMoM also carries on in the recursion information on higher-order moments of queue lengths. We show that this additional information greatly reduces the number of operations needed to solve the model and makes CoMoM the best-available algorithm for networks with several classes. We conclude the paper by generalizing CoMoM to the efficient computation of marginal queue-length probabilities, which finds application in the evaluation of state-dependent attributes such as quality-of-service metrics.","1939-3520","","10.1109/TSE.2008.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4641939","Performance of Systems;Modeling techniques;Queuing theory;Performance of Systems;Modeling techniques;Queuing theory","Performance analysis;Moment methods;Quality of service;Queueing analysis;Network servers;Computer networks;Capacity planning;Web server;Transaction databases;Algorithm design and analysis","method of moments;probability;quality of service;queueing theory","class-oriented method of moment;closed multiclass queueing network;marginal queue-length probability;performance evaluation;multitier application;mean value analysis;higher-order moment;J2EE application;state-dependent index evaluation;energy consumption;quality-of-service metrics","","6","","24","","10 Oct 2008","","","IEEE","IEEE Journals"
"Equality to Equals and Unequals: A Revisit of the Equivalence and Nonequivalence Criteria in Class-Level Testing of Object-Oriented Software","H. Y. Chen; T. H. Tse","Jinan University, Guangzhou; The University of Hong Kong, Hong Kong","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1549","1563","Algebraic specifications have been used in the testing of object-oriented programs and received much attention since the 1990s. It is generally believed that class-level testing based on algebraic specifications involves two independent aspects: the testing of equivalent and nonequivalent ground terms. Researchers have cited intuitive examples to illustrate the philosophy that even if an implementation satisfies all the requirements specified by the equivalence of ground terms, it may still fail to satisfy some of the requirements specified by the nonequivalence of ground terms. Thus, both the testing of equivalent ground terms and the testing of nonequivalent ground terms have been considered as significant and cannot replace each other. In this paper, we present an innovative finding that, given any canonical specification of a class with proper imports, a complete implementation satisfies all the observationally equivalent ground terms if and only if it satisfies all the observationally nonequivalent ground terms. As a result, these two aspects of software testing cover each other and can therefore replace each other. These findings provide a deeper understanding of software testing based on algebraic specifications, rendering the theory more elegant and complete. We also highlight a couple of important practical implications of our theoretical results.","1939-3520","","10.1109/TSE.2013.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6570471","Software testing;equivalence criterion;nonequivalence criterion;algebraic specification;object-oriented software","Software;Software testing;Observers;Context;Semantics;Computer science","algebraic specification;object-oriented programming;program testing","nonequivalence criteria;class-level testing;object-oriented software;algebraic specifications;object-oriented programs;equivalent ground terms;canonical specification;software testing","","7","","33","","26 Jul 2013","","","IEEE","IEEE Journals"
"A Survey on Metamorphic Testing","S. Segura; G. Fraser; A. B. Sanchez; A. Ruiz-Cortés","Department of Computer Languages and Systems, Universidad de Sevilla, Spain; Department of Computer Science, University of Sheffield, Sheffield, United Kingdom; Department of Computer Languages and Systems, Universidad de Sevilla, Spain; Department of Computer Languages and Systems, Universidad de Sevilla, Spain","IEEE Transactions on Software Engineering","15 Sep 2016","2016","42","9","805","824","A test oracle determines whether a test execution reveals a fault, often by comparing the observed program output to the expected output. This is not always practical, for example when a program's input-output relation is complex and difficult to capture formally. Metamorphic testing provides an alternative, where correctness is not determined by checking an individual concrete output, but by applying a transformation to a test input and observing how the program output “morphs” into a different one as a result. Since the introduction of such metamorphic relations in 1998, many contributions on metamorphic testing have been made, and the technique has seen successful applications in a variety of domains, ranging from web services to computer graphics. This article provides a comprehensive survey on metamorphic testing: It summarises the research results and application areas, and analyses common practice in empirical studies of metamorphic testing as well as the main open challenges.","1939-3520","","10.1109/TSE.2016.2532875","European Commission (FEDER); Spanish Government; CICYT projects TAPAS; BELI; Andalusian Government projects THEOS; COPAS; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7422146","Metamorphic testing;oracle problem;survey","Testing;Search engines;Google;Libraries;Concrete;Distance measurement;Web services","program testing","metamorphic testing;test oracle;test execution;metamorphic relations","","120","","148","","29 Feb 2016","","","IEEE","IEEE Journals"
"Test Case Prioritization Using Lexicographical Ordering","S. Eghbali; L. Tahvildari","Department of Electrical and Computer Engineering, 200 University Ave West, University of Waterloo, Waterloo, Ontario; Department of Electrical and Computer Engineering, 200 University Ave West, University of Waterloo, Waterloo, Ontario","IEEE Transactions on Software Engineering","8 Dec 2016","2016","42","12","1178","1195","Test case prioritization aims at ordering test cases to increase the rate of fault detection, which quantifies how fast faults are detected during the testing phase. A common approach for test case prioritization is to use the information of previously executed test cases, such as coverage information, resulting in an iterative (greedy) prioritization algorithm. Current research in this area validates the fact that using coverage information can improve the rate of fault detection in prioritization algorithms. The performance of such iterative prioritization schemes degrade as the number of ties encountered in prioritization steps increases. In this paper, using the notion of lexicographical ordering, we propose a new heuristic for breaking ties in coverage based techniques. Performance of the proposed technique in terms of the rate of fault detection is empirically evaluated using a wide range of programs. Results indicate that the proposed technique can resolve ties and in turn noticeably increases the rate of fault detection.","1939-3520","","10.1109/TSE.2016.2550441","Natural Sciences and Engineering Research Council of Canada; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7456343","Regression testing;test case prioritization;lexicographical ordering","Software testing;Fault detection;Feature extraction;Regression analysis;Fault diagnosis","fault diagnosis;greedy algorithms;iterative methods;program testing;regression analysis","regression testing;coverage information;iterative greedy prioritization algorithm;fault detection;lexicographical ordering;test case prioritization","","24","","60","","21 Apr 2016","","","IEEE","IEEE Journals"
"Abstracting runtime heaps for program understanding","M. Marron; C. Sanchez; Z. Su; M. Fahndrich","Imdea Software Institute, Boadilla del Monte; Imdea Software Institute, Boadilla del Monte; University of California, Davis, Davis; Microsoft Research","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","774","786","Modern programming environments provide extensive support for inspecting, analyzing, and testing programs based on the algorithmic structure of a program. Unfortunately, support for inspecting and understanding runtime data structures during execution is typically much more limited. This paper provides a general purpose technique for abstracting and summarizing entire runtime heaps. We describe the abstract heap model and the associated algorithms for transforming a concrete heap dump into the corresponding abstract model as well as algorithms for merging, comparing, and computing changes between abstract models. The abstract model is designed to emphasize high-level concepts about heap-based data structures, such as shape and size, as well as relationships between heap structures, such as sharing and connectivity. We demonstrate the utility and computational tractability of the abstract heap model by building a memory profiler. We use this tool to identify, pinpoint, and correct sources of memory bloat for programs from DaCapo.","1939-3520","","10.1109/TSE.2012.69","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6331492","Heap structure;runtime analysis;memory profiling;program understanding","Abstracts;Concrete;Shape;Runtime;Arrays;Computational modeling","data structures;merging;program diagnostics;program testing","program testing;program analysis;program inspection;program algorithmic structure;runtime data structure relationships;runtime heap abstracting;runtime heap summarization;concrete heap dump;program merging;program comparison;program computing;high-level concepts;heap structure sharing;heap structure connectivity;abstract heap model utility;abstract heap model computational tractability;memory profiler;memory bloat;DaCapo","","10","","37","","16 Oct 2012","","","IEEE","IEEE Journals"
"A Systematic Study on Explicit-State Non-Zenoness Checking for Timed Automata","T. Wang; J. Sun; X. Wang; Y. Liu; Y. Si; J. S. Dong; X. Yang; X. Li","College of Computer Science, Zhejiang University, P.R., China; ISTD, Singapore University of Technology and Design, Singapore; College of Computer Science, Zhejiang University, P.R., China; School of Computer Engineering, Nanyang Technological University, Singapore; College of Computer Science, Zhejiang University, P.R., China; School of Computing, National University of Singapore, Singapore; College of Computer Science, Zhejiang University, P.R., China; School of Computer Science and Technology, Tianjin University, P.R., China","IEEE Transactions on Software Engineering","7 Jan 2015","2015","41","1","3","18","Zeno runs, where infinitely many actions occur within finite time, may arise in Timed Automata models. Zeno runs are not feasible in reality and must be pruned during system verification. Thus it is necessary to check whether a run is Zeno or not so as to avoid presenting Zeno runs as counterexamples during model checking. Existing approaches on non-Zenoness checking include either introducing an additional clock in the Timed Automata models or additional accepting states in the zone graphs. In addition, there are approaches proposed for alternative timed modeling languages, which could be generalized to Timed Automata. In this work, we investigate the problem of non-Zenoness checking in the context of model checking LTL properties, not only evaluating and comparing existing approaches but also proposing a new method. To have a systematic evaluation, we develop a software toolkit to support multiple non-Zenoness checking algorithms. The experimental results show the effectiveness of our newly proposed algorithm, and demonstrate the strengths and weaknesses of different approaches.","1939-3520","","10.1109/TSE.2014.2359893","National Natural Science Foundation Program; National Key Technology Support Program; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6908008","Timed automata;non-Zenoness;model checking;verification tool","Automata;Clocks;Safety;Educational institutions;Systematics;Cost accounting;Model checking","automata theory;formal verification;graph theory;real-time systems","explicit-state nonzenoness checking;timed automata models;zeno runs;system verification;clocks;zone graphs;timed modeling languages;model checking LTL properties;systematic evaluation;software toolkit","","3","","37","","23 Sep 2014","","","IEEE","IEEE Journals"
"Parallel Performance Problems on Shared-Memory Multicore Systems: Taxonomy and Observation","R. Atachiants; G. Doherty; D. Gregg","Trinity College Dublin, Ireland; Trinity College Dublin, Ireland; Trinity College Dublin, Ireland","IEEE Transactions on Software Engineering","11 Aug 2016","2016","42","8","764","785","The shift towards multicore processing has led to a much wider population of developers being faced with the challenge of exploiting parallel cores to improve software performance. Debugging and optimizing parallel programs is a complex and demanding task. Tools which support development of parallel programs should provide salient information to allow programmers of multicore systems to diagnose and distinguish performance problems. Appropriate design of such tools requires a systematic analysis of the problems which might be identified, and the information used to diagnose them. Building on the literature, we put forward a potential taxonomy of parallel performance problems, and an observational model which links measurable performance data to these problems. We present a validation of this model carried out with parallel programming experts, identifying areas of agreement and disagreement. This is accompanied with a survey of the prevalence of these problems in software development. From this we can identify contentious areas worthy of further exploration, as well as those with high prevalence and strong agreement, which are natural candidates for initial moves towards better tool support.","1939-3520","","10.1109/TSE.2016.2519346","Science Foundation Ireland; Irish Software Research Centre; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7386691","Parallel programming, multicore, multi-threaded, optimization, performance problems, performance analysis, diagnosis, debugging, taxonomy.","Multicore processing;Software;Taxonomy;Computers;Context;Parallel programming;Hardware","parallel programming;performance evaluation;program debugging;shared memory systems;software tools","shared-memory multicore systems;parallel performance problems;multicore processing;software performance;parallel program debugging;parallel program optimization;tool support","","4","","97","","19 Jan 2016","","","IEEE","IEEE Journals"
"Assessing the Cost Effectiveness of Fault Prediction in Acceptance Testing","A. Monden; T. Hayashi; S. Shinoda; K. Shirai; J. Yoshida; M. Barker; K. Matsumoto","Nara Institute of Science and Technology, Ikoma; NTT West Corporation, Osaka; NTT West Corporation, Osaka; NTT West Corporation, Osaka; NTT West Corporation, Osaka; Nara Institute of Science and Technology, Ikoma; Nara Institute of Science and Technology, Ikoma","IEEE Transactions on Software Engineering","25 Sep 2013","2013","39","10","1345","1357","Until now, various techniques for predicting fault-prone modules have been proposed and evaluated in terms of their prediction performance; however, their actual contribution to business objectives such as quality improvement and cost reduction has rarely been assessed. This paper proposes using a simulation model of software testing to assess the cost effectiveness of test effort allocation strategies based on fault prediction results. The simulation model estimates the number of discoverable faults with respect to the given test resources, the resource allocation strategy, a set of modules to be tested, and the fault prediction results. In a case study applying fault prediction of a small system to acceptance testing in the telecommunication industry, results from our simulation model showed that the best strategy was to let the test effort be proportional to ""the number of expected faults in a module × log(module size)."" By using this strategy with our best fault prediction model, the test effort could be reduced by 25 percent while still detecting as many faults as were normally discovered in testing, although the company required about 6 percent of the test effort for metrics collection, data cleansing, and modeling. The simulation results also indicate that the lower bound of acceptable prediction accuracy is around 0.78 in terms of an effort-aware measure, Norm(Popt). The results indicate that reduction of the test effort can be achieved by fault prediction only if the appropriate test strategy is employed with high enough fault prediction accuracy. Based on these preliminary results, we expect further research to assess their general validity with larger systems.","1939-3520","","10.1109/TSE.2013.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6497441","Complexity measures;fault prediction;quality assurance;resource allocation;simulation","Testing;Predictive models;Measurement;Software;Resource management;Companies;Accuracy","program testing;resource allocation;software cost estimation;software fault tolerance;software metrics","cost effectiveness assessment;fault prediction;acceptance testing;quality improvement;cost reduction;software testing;test effort allocation strategies;fault discovery;resource allocation strategy;test resources;telecommunication industry;metrics collection;data cleansing;data modeling;effort-aware measure","","33","","34","","12 Apr 2013","","","IEEE","IEEE Journals"
"Predicting Consistency-Maintenance Requirement of Code Clonesat Copy-and-Paste Time","X. Wang; Y. Dang; L. Zhang; D. Zhang; E. Lan; H. Mei","Key Laboratory of High Confidence Software Technologies, Peking University, Ministry of Education, and with the Department of Computer Science, University of Texas, San Antonio; Microsoft Research Asia, Beijing, China; Microsoft Research Asia, Beijing, China; Microsoft Research Asia, Beijing, China; Microsoft Corporation, One Microsoft Way, Redmond, WA; Key Laboratory of High Confidence Software Technologies, Peking University, Ministry of Education, and with the Department of Computer Science, University of Texas, San Antonio","IEEE Transactions on Software Engineering","8 Aug 2014","2014","40","8","773","794","Code clones have always been a double edged sword in software development. On one hand, it is a very convenient way to reuse existing code, and to save coding effort. On the other hand, since developers may need to ensure consistency among cloned code segments, code clones can lead to extra maintenance effort and even bugs. Recently studies on the evolution of code clones show that only some of the code clones experience consistent changes during their evolution history. Therefore, if we can accurately predict whether a code clone will experience consistent changes, we will be able to provide useful recommendations to developers onleveraging the convenience of some code cloning operations, while avoiding other code cloning operations to reduce future consistency maintenance effort. In this paper, we define a code cloning operation as consistency-maintenance-required if its generated code clones experience consistent changes in the software evolution history, and we propose a novel approach that automatically predicts whether a code cloning operation requires consistency maintenance at the time point of performing copy-and-paste operations. Our insight is that whether a code cloning operation requires consistency maintenance may relate to the characteristics of the code to be cloned and the characteristics of its context. Based on a number of attributes extracted from the cloned code and the context of the code cloning operation, we use Bayesian Networks, a machine-learning technique, to predict whether an intended code cloning operation requires consistency maintenance. We evaluated our approach on four subjects-two large-scale Microsoft software projects, and two popular open-source software projects-under two usage scenarios: 1) recommend developers to perform only the cloning operations predicted to be very likely to be consistency-maintenance-free, and 2) recommend developers to perform all cloning operations unless they are predicted very likely to be consistency-maintenance-required. In the first scenario, our approach is able to recommend developers to perform more than 50 percent cloning operations with a precision of at least 94 percent in the four subjects. In the second scenario, our approach is able to avoid 37 to 72 percent consistency-maintenance-required code clones by warning developers on only 13 to 40 percent code clones, in the four subjects.","1939-3520","","10.1109/TSE.2014.2323972","National 863 Program; National 973 Program; Science Fund for Creative Research Groups; Natural Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6815760","Code cloning;consistency maintenance;programming aid","Cloning;Software;Maintenance engineering;Bayes methods;History;Training;Educational institutions","belief networks;learning (artificial intelligence);public domain software;software maintenance","consistency-maintenance requirement;code clones;copy-and-paste time;software development;maintenance effort;code cloning operations;consistency maintenance effort;Bayesian networks;machine-learning technique;Microsoft software projects;open-source software projects","","12","","46","","14 May 2014","","","IEEE","IEEE Journals"
"Magiclock: Scalable Detection of Potential Deadlocks in Large-Scale Multithreaded Programs","Y. Cai; W. K. Chan","Department of Computer Science, City University of Hong Kong, Tat Chee Avenue; Department of Computer Science, City University of Hong Kong, Tat Chee Avenue","IEEE Transactions on Software Engineering","31 Mar 2014","2014","40","3","266","281","We present Magiclock, a novel potential deadlock detection technique by analyzing execution traces (containing no deadlock occurrence) of large-scale multithreaded programs. Magiclock iteratively eliminates removable lock dependencies before potential deadlock localization. It divides lock dependencies into thread specific partitions, consolidates equivalent lock dependencies, and searches over the set of lock dependency chains without the need to examine any duplicated permutations of the same lock dependency chains. We validate Magiclock through a suite of real-world, large-scale multithreaded programs. The experimental results show that Magiclock is significantly more scalable and efficient than existing dynamic detectors in analyzing and detecting potential deadlocks in execution traces of large-scale multithreaded programs.","1939-3520","","10.1109/TSE.2014.2301725","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6718069","Deadlock detection;multithreaded programs;concurrency;lock order graph;scalability","System recovery;Message systems;Classification algorithms;Instruction sets;Image edge detection;Monitoring;Multicore processing","concurrency control;multi-threading;operating systems (computers);system recovery","Magiclock;potential deadlocks scalable detection;large-scale multithreaded programs;potential deadlock localization;lock order graph;scalability","","25","","47","","21 Jan 2014","","","IEEE","IEEE Journals"
"Predicting Project Velocity in XP Using a Learning Dynamic Bayesian Network Model","P. Hearty; N. Fenton; D. Marquez; M. Neil","Queen Mary University of London-Computer, London; Queen Mary University of London-Computer, London; Queen Mary University of London-Computer, London; Queen Mary University of London-Computer, London","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","124","137","Bayesian networks, which can combine sparse data, prior assumptions and expert judgment into a single causal model, have already been used to build software effort prediction models. We present such a model of an extreme programming environment and show how it can learn from project data in order to make quantitative effort predictions and risk assessments without requiring any additional metrics collection program. The model's predictions are validated against a real world industrial project, with which they are in good agreement.","1939-3520","","10.1109/TSE.2008.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4624275","extreme programming;Bayesian networks;causal models;risk assessment;extreme programming;Bayesian networks;causal models;risk assessment","Bayesian methods;Predictive models;Project management;Risk management;Programming environments;Testing;Large-scale systems;Size measurement;Calendars;Uncertainty","belief networks;project management;risk management;software metrics","project velocity;XP;extreme programming;learning dynamic Bayesian network model;software effort prediction models;quantitative effort predictions;risk assessments;metrics collection program;software development","","31","","41","","12 Sep 2008","","","IEEE","IEEE Journals"
"Probabilistic Model Checking of Regenerative Concurrent Systems","M. Paolieri; A. Horváth; E. Vicario","Department of Information Engineering, Università di Firenze, Firenze, Italy; Department of Computer Science, Università di Torino, Torino, Italy; Department of Information Engineering, Università di Firenze, Firenze, Italy","IEEE Transactions on Software Engineering","11 Feb 2016","2016","42","2","153","169","We consider the problem of verifying quantitative reachability properties in stochastic models of concurrent activities with generally distributed durations. Models are specified as stochastic time Petri nets and checked against Boolean combinations of interval until operators imposing bounds on the probability that the marking process will satisfy a goal condition at some time in the interval [α, β] after an execution that never violates a safety property. The proposed solution is based on the analysis of regeneration points in model executions: a regeneration is encountered after a discrete event if the future evolution depends only on the current marking and not on its previous history, thus satisfying the Markov property. We analyze systems in which multiple generally distributed timers can be started or stopped independently, but regeneration points are always encountered with probability 1 after a bounded number of discrete events. Leveraging the properties of regeneration points in probability spaces of execution paths, we show that the problem can be reduced to a set of Volterra integral equations, and we provide algorithms to compute their parameters through the enumeration of finite sequences of stochastic state classes encoding the joint probability density function (PDF) of generally distributed timers after each discrete event. The computation of symbolic PDFs is limited to discrete events before the first regeneration, and the repetitive structure of the stochastic process is exploited also before the lower bound α, providing crucial benefits for large time bounds. A case study is presented through the probabilistic formulation of Fischer's mutual exclusion protocol, a well-known real-time verification benchmark.","1939-3520","","10.1109/TSE.2015.2468717","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7202875","Probabilistic Model Checking;Reachability;Stochastic Petri Net;Markov Regenerative Process;Markov Renewal Theory;Probabilistic model checking;reachability;stochastic Petri net;Markov regenerative process;Markov renewal theory","Probabilistic logic;Probability density function;Markov processes;Computational modeling;Numerical models;Petri nets","concurrency control;Markov processes;Petri nets;program verification;Volterra equations","probabilistic model checking;regenerative concurrent systems;quantitative reachability properties;stochastic models;concurrent activities;stochastic time Petri nets;Boolean combinations;regeneration point analysis;model executions;discrete event;Markov property;distributed timers;Volterra integral equations;stochastic state classes;joint probability density function;symbolic PDFs;stochastic process;Fischer's mutual exclusion protocol;real-time verification benchmark","","16","","47","","14 Aug 2015","","","IEEE","IEEE Journals"
"Proactive Self-Adaptation for Improving the Reliability of Mission-Critical, Embedded, and Mobile Software","D. Cooray; E. Kouroshfar; S. Malek; R. Roshandel","VeriSign Inc., Reston; George Mason University, Fairfax; George Mason University, Fairfax; Seattle University, Seattle","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1714","1735","Embedded and mobile software systems are marked with a high degree of unpredictability and dynamism in the execution context. At the same time, such systems are often mission-critical, meaning that they need to satisfy strict reliability requirements. Most current software reliability analysis approaches are not suitable for these types of software systems, as they do not take the changes in the execution context of the system into account. We propose an approach geared to such systems which continuously furnishes refined reliability predictions at runtime by incorporating various sources of information, including the execution context of the system. The reliability predictions are leveraged to proactively place the software in the (near-)optimal configuration with respect to changing conditions. Our approach considers two representative architectural reconfiguration decisions that impact the system's reliability: reallocation of components to processes and changing the number of component replicas. We have realized the approach as part of a framework intended for mission-critical settings, called REsilient SItuated SofTware system (RESIST), and evaluated it using a mobile emergency response system.","1939-3520","","10.1109/TSE.2013.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6574866","Context awareness;software architecture;self-adaptive systems;reliability;mobility","Mobile communication;Software reliability;Context awareness;Reliability engineering;Software  architecture;Computer architecture","embedded systems;mobile computing;software architecture;software reliability","proactive self-adaptation;mission-critical software;embedded software;mobile software;unpredictability degree;dynamism degree;execution context;reliability requirements;software reliability analysis approach;architectural reconfiguration decisions;component reallocation;component replicas;RESIST approach;resilient situated software system;mobile emergency response system","","9","","52","","5 Aug 2013","","","IEEE","IEEE Journals"
"SymbexNet: Testing Network Protocol Implementations with Symbolic Execution and Rule-Based Specifications","J. Song; C. Cadar; P. Pietzuch","Department of Computer and Information Security, Sejong University, Seoul, Republic of Korea; Department of Computing, Imperial College London, London, SW7 2AZ, U.K.; Department of Computer and Information Security, Sejong University, Seoul, Republic of Korea","IEEE Transactions on Software Engineering","8 Jul 2014","2014","40","7","695","709","Implementations of network protocols, such as DNS, DHCP and Zeroconf, are prone to flaws, security vulnerabilities and interoperability issues caused by developer mistakes and ambiguous requirements in protocol specifications. Detecting such problems is not easy because (i) many bugs manifest themselves only after prolonged operation; (ii) reasoning about semantic errors requires a machine-readable specification; and (iii) the state space of complex protocol implementations is large. This article presents a novel approach that combines symbolic execution and rule-based specifications to detect various types of flaws in network protocol implementations. The core idea behind our approach is to (1) automatically generate high-coverage test input packets for a network protocol implementation using single- and multi-packet exchange symbolic execution (targeting stateless and stateful protocols, respectively) and then (2) use these packets to detect potential violations of manual rules derived from the protocol specification, and check the interoperability of different implementations of the same network protocol. We present a system based on these techniques, SymbexNet, and evaluate it on multiple implementations of two network protocols: Zeroconf, a service discovery protocol, and DHCP, a network configuration protocol. SymbexNet is able to discover non-trivial bugs as well as interoperability problems, most of which have been confirmed by the developers.","1939-3520","","10.1109/TSE.2014.2323977","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6815719","Symbolic execution;network security;testing;interoperability testing","Protocols;IP networks;Interoperability;Servers;Concrete;Testing;Computer bugs","formal specification;open systems;program debugging;program testing","SymbexNet;testing network protocol implementations;symbolic execution;rule based specifications;DNS;DHCP;Zeroconf;interoperability issues;security vulnerabilities;protocol specifications;semantic errors;machine readable specification;protocol implementations;protocol specification;network protocol;interoperability problems","","9","","50","","14 May 2014","","","IEEE","IEEE Journals"
"Synthesizing Modal Transition Systems from Triggered Scenarios","G. E. Sibay; V. Braberman; S. Uchitel; J. Kramer","Imperial College London, London; University of Buenos Aires, Buenos Aires; Imperial College London, London and University of Buenos Aires, Buenos Aires; Imperial College, London","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","975","1001","Synthesis of operational behavior models from scenario-based specifications has been extensively studied. The focus has been mainly on either existential or universal interpretations. One noteworthy exception is Live Sequence Charts (LSCs), which provides expressive constructs for conditional universal scenarios and some limited support for nonconditional existential scenarios. In this paper, we propose a scenario-based language that supports both existential and universal interpretations for conditional scenarios. Existing model synthesis techniques use traditional two-valued behavior models, such as Labeled Transition Systems. These are not sufficiently expressive to accommodate specification languages with both existential and universal scenarios. We therefore shift the target of synthesis to Modal Transition Systems (MTS), an extension of labeled Transition Systems that can distinguish between required, unknown, and proscribed behavior to capture the semantics of existential and universal scenarios. Modal Transition Systems support elaboration of behavior models through refinement, which complements an incremental elicitation process suitable for specifying behavior with scenario-based notations. The synthesis algorithm that we define constructs a Modal Transition System that uses refinement to characterize all the Labeled Transition Systems models that satisfy a mixed, conditional existential and universal scenario-based specification. We show how this combination of scenario language, synthesis, and Modal Transition Systems supports behavior model elaboration.","1939-3520","","10.1109/TSE.2012.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311408","Scenarios;MTS;synthesis;partial behavior models","Semantics;Analytical models;Online banking;Merging;Unified modeling language;Indexes;Cognition","formal verification;reasoning about programs","modal transition systems;triggered scenarios;operational behavior models;scenario-based specifications;live sequence charts;LSC;conditional universal scenarios;nonconditional existential scenarios;scenario-based language;model synthesis techniques;two-valued behavior models;specification languages;MTS;incremental elicitation process;scenario-based notations;conditional existential scenario-based specification;universal scenario-based specification;labeled transition system models;behavior model elaboration","","13","","40","","24 Sep 2012","","","IEEE","IEEE Journals"
"Finding Atomicity-Violation Bugs through Unserializable Interleaving Testing","S. Lu; S. Park; Y. Zhou","University of Wisconsin-Madison, Madison; University of California, San Diego, La Jolla; University of California, San Diego, La Jolla","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","844","860","Multicore hardware is making concurrent programs pervasive. Unfortunately, concurrent programs are prone to bugs. Among different types of concurrency bugs, atomicity violations are common and important. How to test the interleaving space and expose atomicity-violation bugs is an open problem. This paper makes three contributions. First, it designs and evaluates a hierarchy of four interleaving coverage criteria using 105 real-world concurrency bugs. This study finds a coverage criterion (Unserializable Interleaving Coverage) that balances the complexity and the capability of exposing atomicity-violation bugs well. Second, it studies stress testing to understand why this common practice cannot effectively expose atomicity-violation bugs from the perspective of unserializable interleaving coverage. Third, it designs CTrigger following the unserializable interleaving coverage criterion. CTrigger uses trace analysis to identify feasible unserializable interleavings, and then exercises low-probability interleavings to expose atomicity-violation bugs. We evaluate CTrigger with real-world atomicity-violation bugs from seven applications. CTrigger efficiently exposes these bugs within 1-235 seconds, two to four orders of magnitude faster than stress testing. Without CTrigger, some of these bugs do not manifest even after seven days of stress testing. Furthermore, once a bug is exposed, CTrigger can reliably reproduce it, usually within 5 seconds, for diagnosis.","1939-3520","","10.1109/TSE.2011.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5740930","Testing and debugging;debugging aids;diagnostics;testing strategies;test coverage of code;concurrent programming;bug characteristics","Computer bugs;Testing;Instruction sets;Concurrent computing;Stress;Complexity theory;Synchronization","formal verification;multiprocessing systems;probability;program debugging;ubiquitous computing","finding atomicity violation bugs;unserializable interleaving testing;multicore hardware;pervasive concurrent programs;concurrency bugs;unserializable interleaving coverage;trace analysis;low probability interleavings","","17","","48","","5 Apr 2011","","","IEEE","IEEE Journals"
"Developing a Single Model and Test Prioritization Strategies for Event-Driven Software","R. C. Bryce; S. Sampath; A. M. Memon","Utah State University, Logan; University of Maryland, Baltimore; University of Maryland, College Park","IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","48","64","Event-Driven Software (EDS) can change state based on incoming events; common examples are GUI and Web applications. These EDSs pose a challenge to testing because there are a large number of possible event sequences that users can invoke through a user interface. While valuable contributions have been made for testing these two subclasses of EDS, such efforts have been disjoint. This work provides the first single model that is generic enough to study GUI and Web applications together. In this paper, we use the model to define generic prioritization criteria that are applicable to both GUI and Web applications. Our ultimate goal is to evolve the model and use it to develop a unified theory of how all EDS should be tested. An empirical study reveals that the GUI and Web-based applications, when recast using the new model, show similar behavior. For example, a criterion that gives priority to all pairs of event interactions did well for GUI and Web applications; another criterion that gives priority to the smallest number of parameter value settings did poorly for both. These results reinforce our belief that these two subclasses of applications should be modeled and studied together.","1939-3520","","10.1109/TSE.2010.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401169","Combinatorial interaction testing;covering arrays;event-driven software (EDS);t-way interaction coverage;test suite prioritization;user-session testing;Web application testing;GUI testing.","Software testing;Graphical user interfaces;Application software;Computer science;User interfaces;Protocols;Embedded software;Information systems;Educational institutions;Abstracts","graphical user interfaces;Internet;program testing;service-oriented architecture","event-driven software;test prioritization strategy;EDS;GUI testing;Web application testing;graphical user interface","","73","1","28","","29 Jan 2010","","","IEEE","IEEE Journals"
"Forecasting Risk Impact on ERP Maintenance with Augmented Fuzzy Cognitive Maps","J. L. Salmeron; C. Lopez","University Pablo de Olavide, Seville; Pablo de Olavide University, Seville","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","439","452","Worldwide, firms have made great efforts to implement Enterprise Resource Planning (ERP) systems. Despite these efforts, ERP adoption success is not guaranteed. Successful adoption of an ERP system also depends on proper system maintenance. For this reason, companies should follow a maintenance strategy that drives the ERP system toward success. However, in general, ERP maintenance managers do not know what conditions they should target to successfully maintain their ERP systems. Furthermore, numerous risks threaten these projects, but they are normally dealt with intuitively. To date, there has been limited literature published regarding ERP maintenance risks or ERP maintenance success. To address this need, we have built a dynamic simulation tool that allows ERP managers to foresee the impact of risks on maintenance goals. This research would help professionals manage their ERP maintenance projects. Moreover, it covers a significant gap in the literature.","1939-3520","","10.1109/TSE.2011.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680917","ERP;fuzzy cognitive maps;risk management;simulation;software maintenance.","Decision support systems","cognition;enterprise resource planning;forecasting theory;fuzzy set theory;project management;risk analysis;software maintenance;software management","enterprise resource planning system;ERP adoption success;ERP system maintenance;ERP maintenance risks;dynamic simulation tool;ERP maintenance project management;augmented fuzzy cognitive maps;risk impact forecasting","","55","","111","","6 Jan 2011","","","IEEE","IEEE Journals"
"The Impact of Classifier Configuration and Classifier Combination on Bug Localization","S. W. Thomas; M. Nagappan; D. Blostein; A. E. Hassan","Queen's University, Kingston; Queen's University, Kingston; Queen's University, Kingston; Queen's University, Kingston","IEEE Transactions on Software Engineering","25 Sep 2013","2013","39","10","1427","1443","Bug localization is the task of determining which source code entities are relevant to a bug report. Manual bug localization is labor intensive since developers must consider thousands of source code entities. Current research builds bug localization classifiers, based on information retrieval models, to locate entities that are textually similar to the bug report. Current research, however, does not consider the effect of classifier configuration, i.e., all the parameter values that specify the behavior of a classifier. As such, the effect of each parameter or which parameter values lead to the best performance is unknown. In this paper, we empirically investigate the effectiveness of a large space of classifier configurations, 3,172 in total. Further, we introduce a framework for combining the results of multiple classifier configurations since classifier combination has shown promise in other domains. Through a detailed case study on over 8,000 bug reports from three large-scale projects, we make two main contributions. First, we show that the parameters of a classifier have a significant impact on its performance. Second, we show that combining multiple classifiers--whether those classifiers are hand-picked or randomly chosen relative to intelligently defined subspaces of classifiers--improves the performance of even the best individual classifiers.","1939-3520","","10.1109/TSE.2013.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6520844","Software maintenance;bug localization;information retrieval;VSM;LSI;LDA;classifier combination","Large scale integration;Measurement;Vectors;Information retrieval;Matrix decomposition;Indexes;Resource management","information retrieval;pattern classification;program debugging","classifier configuration;classifier combination;source code entity determination;bug report;bug localization classifiers;information retrieval models;parameter value;classifier parameter","","44","","62","","27 May 2013","","","IEEE","IEEE Journals"
"Input Domain Reduction through Irrelevant Variable Removal and Its Effect on Local, Global, and Hybrid Search-Based Structural Test Data Generation","P. McMinn; M. Harman; K. Lakhotia; Y. Hassoun; J. Wegener","University of Sheffield, Sheffield; University College London, London; University College London, London; King's College London, London; Berner & Mattner Systemtechnik GmbH, Berlin","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","453","477","Search-Based Test Data Generation reformulates testing goals as fitness functions so that test input generation can be automated by some chosen search-based optimization algorithm. The optimization algorithm searches the space of potential inputs, seeking those that are “fit for purpose,” guided by the fitness function. The search space of potential inputs can be very large, even for very small systems under test. Its size is, of course, a key determining factor affecting the performance of any search-based approach. However, despite the large volume of work on Search-Based Software Testing, the literature contains little that concerns the performance impact of search space reduction. This paper proposes a static dependence analysis derived from program slicing that can be used to support search space reduction. The paper presents both a theoretical and empirical analysis of the application of this approach to open source and industrial production code. The results provide evidence to support the claim that input domain reduction has a significant effect on the performance of local, global, and hybrid search, while a purely random search is unaffected.","1939-3520","","10.1109/TSE.2011.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5710949","Search-based software testing;evolutionary testing;automated test data generation;input domain reduction.","Input variables;Software testing;Optimization;Algorithm design and analysis;Search problems;Software algorithms","automatic test pattern generation;optimisation;program compilers;program slicing;program testing;public domain software;search problems","input domain reduction;irrelevant variable removal;hybrid search-based structural test data generation;fitness functions;test input generation;search-based optimization algorithm;key determining factor;search-based software testing;search space reduction;static dependence analysis;program slicing;open source approach;industrial production code","","33","","52","","10 Feb 2011","","","IEEE","IEEE Journals"
"A Practical Approach to Size Estimation of Embedded Software Components","K. Lind; R. Heldal","Saab Automobile AB, Trollhättan; Chalmers University of Technology, Göteborg","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","993","1007","To estimate software code size early in the development process is important for developing cost-efficient embedded systems. We have applied the COSMIC Functional Size Measurement (FSM) method for size estimation of embedded software components in the automotive industry. Correlational studies were conducted using data from two automotive companies. The studies show strong correlation between functional size and software code size, which is important for obtaining accurate estimation results. This paper presents the characteristics and results of our work, and aims to provide a practical framework for how to use COSMIC FSM for size estimation purposes. We investigate the results from our earlier correlational studies, and conduct further studies to identify such a framework. Based on these activities, we conclude that a clear purpose of the estimation process, a well-defined domain allowing categorization of software, consistent content and quality of requirements, and historical data from implemented software are key factors for size estimation of embedded software components.","1939-3520","","10.1109/TSE.2011.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5999672","Real-time and embedded systems;software product metrics;COSMIC FSM;software components","Software;Estimation;Vehicles;Size measurement;Automotive engineering;Industries;Memory management","automotive engineering;object-oriented programming;production engineering computing;software cost estimation;software metrics","software code size estimation;embedded software components;development process;cost-efficient embedded systems;COSMIC functional size measurement method;FSM method;automotive industry;automotive companies;domain allowing categorization;consistent content;requirements quality;historical data;software product metrics","","7","","48","","25 Aug 2011","","","IEEE","IEEE Journals"
"Aligning Qualitative, Real-Time, and Probabilistic Property Specification Patterns Using a Structured English Grammar","M. Autili; L. Grunske; M. Lumpe; P. Pelliccione; A. Tang","Dipartimento di Ingegneria e Scienze dell’Informazione e Matematica, Università dell’Aquila, Aquila, Italy; Institute of Software Technology, University of Stuttgart, Stuttgart, Germany; Swinburne University of Technology, Hawthorn, Australia; Dipartimento di Ingegneria e Scienze dell’Informazione e Matematica, Università dell’Aquila, Aquila, Italy; Swinburne University of Technology, Hawthorn, Australia","IEEE Transactions on Software Engineering","14 Jul 2015","2015","41","7","620","638","Formal methods offer an effective means to assert the correctness of software systems through mathematical reasoning. However, the need to formulate system properties in a purely mathematical fashion can create pragmatic barriers to the application of these techniques. For this reason, Dwyer et al. invented property specification patterns which is a system of recurring solutions to deal with the temporal intricacies that would make the construction of reactive systems very hard otherwise. Today, property specification patterns provide general rules that help practitioners to qualify order and occurrence, to quantify time bounds, and to express probabilities of events. Nevertheless, a comprehensive framework combining qualitative, real-time, and probabilistic property specification patterns has remained elusive. The benefits of such a framework are twofold. First, it would remove the distinction between qualitative and quantitative aspects of events; and second, it would provide a structure to systematically discover new property specification patterns. In this paper, we report on such a framework and present a unified catalogue that combines all known plus 40 newly identified or extended patterns. We also offer a natural language front-end to map patterns to a temporal logic of choice. To demonstrate the virtue of this new framework, we applied it to a variety of industrial requirements, and use PSPWizard, a tool specifically developed to work with our unified pattern catalogue, to automatically render concrete instances of property specification patterns to formulae of an underlying temporal logic of choice.","1939-3520","","10.1109/TSE.2015.2398877","PRESTO; European Commission; DFG; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7029714","Specification Patterns;Real-time Properties;Probabilistic Properties;Specification patterns;real-time properties;probabilistic properties","Probabilistic logic;Real-time systems;Natural languages;Software;Grammar;Electronic mail;Educational institutions","formal specification;natural language processing;probability;temporal logic","qualitative property specification pattern;real-time property specification pattern;probabilistic property specification pattern;structured English grammar;formal methods;software system correctness;mathematical reasoning;temporal intricacies;order qualification;occurrence qualification;time bound quantification;event probability;event qualitative aspect;event quantitative aspect;natural language front-end;pattern mapping;temporal logic;PSPWizard;unified pattern catalogue","","48","1","47","","3 Feb 2015","","","IEEE","IEEE Journals"
"OBEY: Optimal Batched Refactoring Plan Execution for Class Responsibility Redistribution","H. C. Jiau; L. W. Mar; J. C. Chen","National Cheng Kung University, Tainan; National Cheng Kung University, Tainan; National Cheng Kung University, Tainan","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1245","1263","The redistribution of class responsibilities is a common reengineering practice in object-oriented (OO) software evolution. During the redistribution, developers frequently construct batched refactoring plans for moving multiple methods and fields among various classes. With an objective of carefully maintaining the cohesion and coupling degree of the class design, executing a batched refactoring plan without introducing any objective-violating side effect into the refactored code is essential. However, using most refactoring engines for batched refactoring plan execution introduces coupling-increasing Middle Man bad smell in the final refactored code and therefore makes the refactoring execution suboptimal in achieving the redistribution objective. This work proposes Obey, a methodology for optimal batched refactoring plan execution. Obey analyzes a batched refactoring plan, identifies Middle Man symptoms that cause suboptimal execution, and renovates the plan for optimal execution. We have conducted an empirical study on three open-source software projects to confirm the effectiveness of Obey in a practical context.","1939-3520","","10.1109/TSE.2013.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6493333","Reengineering;class responsibility redistribution;batched refactoring execution;change impact analysis;optimization","Couplings;Engines;Software systems;Measurement;Optimization;Context","object-oriented programming;software maintenance","OBEY methodology;optimal batched refactoring plan execution;class responsibility redistribution;software reengineering practice;object-oriented software evolution;OO software evolution;refactoring engine;coupling-increasing middle man bad smell;open-source software project","","7","","74","","3 Apr 2013","","","IEEE","IEEE Journals"
"Model Checking Probabilistic and Stochastic Extensions of the π-Calculus","G. Norman; C. Palamidessi; D. Parker; P. Wu","Oxford University, Oxford; INRIA Saclay and École Polytechnique, Paris; Oxford University, Oxford; University College London, Ipswich","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","209","223","We present an implementation of model checking for probabilistic and stochastic extensions of the pi-calculus, a process algebra which supports modelling of concurrency and mobility. Formal verification techniques for such extensions have clear applications in several domains, including mobile ad-hoc network protocols, probabilistic security protocols and biological pathways. Despite this, no implementation of automated verification exists. Building upon the pi-calculus model checker MMC, we first show an automated procedure for constructing the underlying semantic model of a probabilistic or stochastic pi-calculus process. This can then be verified using existing probabilistic model checkers such as PRISM. Secondly, we demonstrate how for processes of a specific structure a more efficient, compositional approach is applicable, which uses our extension of MMC on each parallel component of the system and then translates the results into a high-level modular description for the PRISM tool. The feasibility of our techniques is demonstrated through a number of case studies from the pi-calculus literature.","1939-3520","","10.1109/TSE.2008.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4626962","Model checking;Markov processes;Stochastic processes;Model checking;Markov processes;Stochastic processes","Stochastic processes;Biological system modeling;Protocols;Stochastic systems;Calculus;Algebra;Formal verification;Mobile ad hoc networks;Mobile communication;Communication system security","formal verification;pi calculus;probability;stochastic processes","model checking;probabilisty;stochastic extension;pi-calculus;process algebra;formal verification;mobile ad-hoc network protocol;probabilistic security protocol;biological pathway;semantic model;high-level modular description","","16","","43","","19 Sep 2008","","","IEEE","IEEE Journals"
"Pert: The Application-Aware Tailoring of Java Object Persistence","P. Liu; C. Zhang","Hong Kong University of Science and Technology, Hong Kong; Hong Kong University of Science and Technology, Hong Kong","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","909","922","Persistence is a widely used technique which allows the objects that represent the results of lengthy computations to outlive the process that creates it in order to considerably speed up subsequent program executions. We observe that conventional persistence techniques usually do not consider the application contexts of the persistence operations, where not all of the object states need to be persisted. Leveraging this observation, we have designed and implemented a framework called Pert, which first performs static program analysis to estimate the actual usage of the persisted object, given the context of its usage in the program. The Pert runtime uses the statically computed information to efficiently make tailoring decisions to prune the redundant and unused object states during the persistence operations. Our evaluation result shows that the Pert-based optimization can speed up the conventional persistence operations by 1 to 45 times. The amount of persisted data is also dramatically reduced, as the result of the application-aware tailoring.","1939-3520","","10.1109/TSE.2011.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5963692","Object persistence;program analysis;performance optimization","Runtime;Anodes;Optimization;Context;Libraries;Java;Algorithm design and analysis","Java;optimisation","application aware tailoring;Java object persistence;lengthy computations;subsequent program executions;persistence techniques;static program analysis;Pert based optimization","","2","","20","","28 Jul 2011","","","IEEE","IEEE Journals"
"QoS Assurance for Dynamic Reconfiguration of Component-Based Software Systems","W. Li","Central Quneensland University, Rockhampton","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","658","676","A major challenge of dynamic reconfiguration is Quality of Service (QoS) assurance, which is meant to reduce application disruption to the minimum for the system's transformation. However, this problem has not been well studied. This paper investigates the problem for component-based software systems from three points of view. First, the whole spectrum of QoS characteristics is defined. Second, the logical and physical requirements for QoS characteristics are analyzed and solutions to achieve them are proposed. Third, prior work is classified by QoS characteristics and then realized by abstract reconfiguration strategies. On this basis, quantitative evaluation of the QoS assurance abilities of existing work and our own approach is conducted through three steps. First, a proof-of-concept prototype called the reconfigurable component model is implemented to support the representation and testing of the reconfiguration strategies. Second, a reconfiguration benchmark is proposed to expose the whole spectrum of QoS problems. Third, each reconfiguration strategy is tested against the benchmark and the testing results are evaluated. The most important conclusion from our investigation is that the classified QoS characteristics can be fully achieved under some acceptable constraints.","1939-3520","","10.1109/TSE.2011.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5740932","Change management;componentware;dynamic reconfiguration;modeling the QoS assurance process;system evolution.","Quality of service;Encryption;Protocols;Connectors;Receivers;Benchmark testing","quality of service;software quality","QoS assurance;dynamic reconfiguration;component based software systems;Quality of Service;application disruption;physical requirements;logical requirements;abstract reconfiguration;quantitative evaluation;reconfigurable component;reconfiguration benchmark","","21","","39","","5 Apr 2011","","","IEEE","IEEE Journals"
"Aspect-Oriented Refactoring of Legacy Applications: An Evaluation","M. Mortensen; S. Ghosh; J. Bieman","Google, Boulder; Colorado State University, Fort Collins; Colorado State University, Fort Collins","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","118","140","The primary claimed benefits of aspect-oriented programming (AOP) are that it improves the understandability and maintainability of software applications by modularizing crosscutting concerns. Before there is widespread adoption of AOP, developers need further evidence of the actual benefits as well as costs. Applying AOP techniques to refactor legacy applications is one way to evaluate costs and benefits. We replace crosscutting concerns with aspects in three industrial applications to examine the effects on qualities that affect the maintainability of the applications. We study several revisions of each application, identifying crosscutting concerns in the initial revision and also crosscutting concerns that are added in later revisions. Aspect-oriented refactoring reduced code size and improved both change locality and concern diffusion. Costs include the effort required for application refactoring and aspect creation, as well as a decrease in performance.","1939-3520","","10.1109/TSE.2010.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5661792","Aspect-oriented programming;crosscutting concerns;legacy systems;refactoring;maintainability.","Software measurement;Maintenance engineering;Legacy systems;Java;Programming;Aspect-oriented programming","aspect-oriented programming;software maintenance","aspect-oriented refactoring;legacy applications;primary claimed benefits;aspect-oriented programming;software understandability;software maintainability;crosscutting concerns;AOP techniques;cost evaluation;benefits evaluation;code size;change locality;concern diffusion;application refactoring;aspect creation","","14","","37","","10 Dec 2010","","","IEEE","IEEE Journals"
"Counterexample Generation in Probabilistic Model Checking","T. Han; J. Katoen; D. Berteun","RWTH Aachen University, Aachen and University of Twente, Enschede; RWTH Aachen University, Aachen and University of Twente, Enschede; RWTH Aachen University, Aachen and University of Twente, Enschede","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","241","257","Providing evidence for the refutation of a property is an essential, if not the most important, feature of model checking. This paper considers algorithms for counterexample generation for probabilistic CTL formulae in discrete-time Markov chains. Finding the strongest evidence (i.e., the most probable path) violating a (bounded) until-formula is shown to be reducible to a single-source (hop-constrained) shortest path problem. Counterexamples of smallest size that deviate most from the required probability bound can be obtained by applying (small amendments to) k-shortest (hop-constrained) paths algorithms. These results can be extended to Markov chains with rewards, to LTL model checking, and are useful for Markov decision processes. Experimental results show that typically the size of a counterexample is excessive. To obtain much more compact representations, we present a simple algorithm to generate (minimal) regular expressions that can act as counterexamples. The feasibility of our approach is illustrated by means of two communication protocols: leader election in an anonymous ring network and the Crowds protocol.","1939-3520","","10.1109/TSE.2009.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4770111","Model checking;Diagnostics","Protocols;Logic;Biological system modeling;Quantum computing;Feedback;Biology computing;Distributed computing;Computer Society;Shortest path problem;Nominations and elections","decision theory;formal verification;Markov processes;probabilistic logic;probability;temporal logic;trees (mathematics)","counterexample generation;probabilistic model checking;property refutation;discrete-time Markov chain;single-source shortest path problem;k-shortest path algorithm;Markov decision process;linear temporal logic;computation tree logic","","57","","61","","2 Feb 2009","","","IEEE","IEEE Journals"
"A Controlled Experiment for Evaluating the Impact of Coupling on the Maintainability of Service-Oriented Software","M. Perepletchikov; C. Ryan","RMIT University, Melbourne; RMIT University, Melbourne","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","449","465","One of the goals of Service-Oriented Computing (SOC) is to improve software maintainability as businesses become more agile, and thus underlying processes and rules change more frequently. This paper presents a controlled experiment examining the relationship between coupling in service-oriented designs, as measured using a recently proposed suite of SOC-specific coupling metrics and software maintainability in terms of the specific subcharacteristics of analyzability, changeability, and stability. The results indicate a statistically significant causal relationship between the investigated coupling metrics and the maintainability of service-oriented software. As such, the investigated metrics can facilitate coupling related design decisions with the aim of producing more maintainable service-oriented software products.","1939-3520","","10.1109/TSE.2010.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5482590","Services systems;design concepts;maintainability;product metrics;empirical studies.","Software maintenance;Programming;Software measurement;Logic;Software design;Stability analysis;Product design;Application software;Costs;Software metrics","service-oriented architecture;software maintenance;software metrics","software maintainability improvement;service-oriented computing;service-oriented designs;specific coupling metrics;specific subcharacteristics;statistically significant causal relationship;service-oriented software products","","28","","48","","7 Jun 2010","","","IEEE","IEEE Journals"
"AutoSense: A Framework for Automated Sensitivity Analysis of Program Data","B. Nongpoh; R. Ray; S. Dutta; A. Banerjee","Department of Computer Science & Engineering, National Institute of Technology Meghalaya, Shillong, India; Department of Computer Science & Engineering, National Institute of Technology Meghalaya, Shillong, India; Department of Computer Science & Engineering, Jadavpur University, Kolkata, India; Advanced Computing and Microelectronics Unit, Indian Statistical Institute, Kolkata, India","IEEE Transactions on Software Engineering","8 Dec 2017","2017","43","12","1110","1124","In recent times, approximate computing is being increasingly adopted across the computing stack, from algorithms to computing hardware, to gain energy and performance efficiency by trading accuracy within acceptable limits. Approximation aware programming languages have been proposed where programmers can annotate data with type qualifiers (e.g., precise and approx) to denote its reliability. However, programmers need to judiciously annotate so that the accuracy loss remains within the desired limits. This can be non-trivial for large applications where error resilient and non-resilient program data may not be easily identifiable. Mis-annotation of even one data as error resilient/insensitive may result in an unacceptable output. In this paper, we present AutoSense, a framework to automatically classify resilient (insensitive) program data versus the sensitive ones with probabilistic reliability guarantee. AutoSense implements a combination of dynamic and static analysis methods for data sensitivity analysis. The dynamic analysis is based on statistical hypothesis testing, while the static analysis is based on classical data flow analysis. Experimental results compare our automated data classification with reported manual annotations on popular benchmarks used in approximate computing literature. AutoSense achieves promising reliability results compared to manual annotations and earlier methods, as evident from the experimental results.","1939-3520","","10.1109/TSE.2017.2654251","National Institute of Technology Meghalaya and Visvesvaraya Ph.D. Scheme; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7820185","Approximate computing;sensitivity analysis;hypothesis testing;sequential probability ratio test","Quality of service;Sensitivity analysis;Approximate computing;Probabilistic logic;Sequential analysis","data flow analysis;pattern classification;probability;program diagnostics;program verification;sensitivity analysis;statistical analysis","approximate computing literature;AutoSense;automated sensitivity analysis;probabilistic reliability;energy efficiency;manual annotations;automated data classification;classical data flow analysis;dynamic analysis;data sensitivity analysis;static analysis;resilient program data;accuracy loss;approximation aware programming languages;trading accuracy;performance efficiency;computing hardware;computing stack","","4","","31","Traditional","17 Jan 2017","","","IEEE","IEEE Journals"
"Dynamic Analysis for Diagnosing Integration Faults","L. Mariani; F. Pastore; M. Pezze","University of Milano Bicocca, Milan; University of Milano Bicocca, Milan; University of Milan Bicocca, Milano","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","486","508","Many software components are provided with incomplete specifications and little access to the source code. Reusing such gray-box components can result in integration faults that can be difficult to diagnose and locate. In this paper, we present Behavior Capture and Test (BCT), a technique that uses dynamic analysis to automatically identify the causes of failures and locate the related faults. BCT augments dynamic analysis techniques with model-based monitoring. In this way, BCT identifies a structured set of interactions and data values that are likely related to failures (failure causes), and indicates the components and the operations that are likely responsible for failures (fault locations). BCT advances scientific knowledge in several ways. It combines classic dynamic analysis with incremental finite state generation techniques to produce dynamic models that capture complementary aspects of component interactions. It uses an effective technique to filter false positives to reduce the effort of the analysis of the produced data. It defines a strategy to extract information about likely causes of failures by automatically ranking and relating the detected anomalies so that developers can focus their attention on the faults. The effectiveness of BCT depends on the quality of the dynamic models extracted from the program. BCT is particularly effective when the test cases sample the execution space well. In this paper, we present a set of case studies that illustrate the adequacy of BCT to analyze both regression testing failures and rare field failures. The results show that BCT automatically filters out most of the false alarms and provides useful information to understand the causes of failures in 69 percent of the case studies.","1939-3520","","10.1109/TSE.2010.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5611554","Dynamic Analysis;diagnosis;fault localization;false positive filters;regression failure analysis;field failure analysis.","Automata;Monitoring;Analytical models;Engines;Software;Testing;Inference algorithms","fault diagnosis;object-oriented programming;program testing;software fault tolerance","software components;Integration Faults;behavior capture and test technique;BCT;dynamic analysis;model-based monitoring;incremental finite state generation techniques","","54","","71","","28 Oct 2010","","","IEEE","IEEE Journals"
"How We Refactor, and How We Know It","E. Murphy-Hill; C. Parnin; A. P. Black","North Carolina State University, Raleigh; Georgia Institute of Technology, Atlanta; Portland State University, Portland","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","5","18","Refactoring is widely practiced by developers, and considerable research and development effort has been invested in refactoring tools. However, little has been reported about the adoption of refactoring tools, and many assumptions about refactoring practice have little empirical support. In this paper, we examine refactoring tool usage and evaluate some of the assumptions made by other researchers. To measure tool usage, we randomly sampled code changes from four Eclipse and eight Mylyn developers and ascertained, for each refactoring, if it was performed manually or with tool support. We found that refactoring tools are seldom used: 11 percent by Eclipse developers and 9 percent by Mylyn developers. To understand refactoring practice at large, we drew from a variety of data sets spanning more than 39,000 developers, 240,000 tool-assisted refactorings, 2,500 developer hours, and 12,000 version control commits. Using these data, we cast doubt on several previously stated assumptions about how programmers refactor, while validating others. Finally, we interviewed the Eclipse and Mylyn developers to help us understand why they did not use refactoring tools and to gather ideas for future research.","1939-3520","","10.1109/TSE.2011.41","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6112738","Refactoring;refactoring tools;floss refactoring;root-canal refactoring.","Java;Software tools;Refactoring","software maintenance;software tools","research and development;refactoring tools;randomly sampled code;Eclipse developers;Mylyn developers","","204","","22","","27 Dec 2011","","","IEEE","IEEE Journals"
"Software Numerical Instability Detection and Diagnosis by Combining Stochastic and Infinite-Precision Testing","E. Tang; X. Zhang; N. T. Müller; Z. Chen; X. Li","State Key Laboratory for Novel Software Technology and Software Institute of Nanjing University, Jiangsu, China; Department of Computer Science, Purdue University, 305 North University Street, West Lafayette, IN; Abteilung Informatik, University of Trier, Trier, Germany; State Key Laboratory for Novel Software Technology and Software Institute of Nanjing University, Jiangsu, China; State Key Laboratory for Novel Software Technology and Software Institute of Nanjing University, Jiangsu, China","IEEE Transactions on Software Engineering","13 Oct 2017","2017","43","10","975","994","Numerical instability is a well-known problem that may cause serious runtime failures. This paper discusses the reason of instability in software development process, and presents a toolchain that not only detects the potential instability in software, but also diagnoses the reason for such instability. We classify the reason of instability into two categories. When it is introduced by software requirements, we call the instability caused by problem . In this case, it cannot be avoided by improving software development, but requires inspecting the requirements, especially the underlying mathematical properties. Otherwise, we call the instability caused by practice. We design our toolchain as four loosely-coupled tools, which combine stochastic arithmetic with infinite-precision testing. Each tool in our toolchain can be configured with different strategies according to the properties of the analyzed software. We evaluate our toolchain on subjects from literature. The results show that it effectively detects and separates the instabilities caused by problems from others. We also conduct an evaluation on the latest version of GNU Scientific Library, and the toolchain finds a few real bugs in the well-maintained and widely deployed numerical library. With the help of our toolchain, we report the details and fixing advices to the GSL buglist.","1939-3520","","10.1109/TSE.2016.2642956","National Basic Research Program of China 973 Program; NSF Award; National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7792694","Numerical analysis;infinite-precision arithmetic;stochastic arithmetic;software testing","Software;Software algorithms;Algorithm design and analysis;Libraries;Computer bugs;Software testing","fault diagnosis;formal specification;mathematics computing;numerical stability;program debugging;program testing;software quality;software reliability;software tools;stochastic processes","software requirements;toolchain;loosely-coupled tools;stochastic arithmetic;numerical library;software development process;potential instability;mathematical properties;infinite-precision testing;software numerical instability detection;software numerical instability diagnosis;runtime failures;GNU scientific library;GSL buglist","","2","","64","Traditional","21 Dec 2016","","","IEEE","IEEE Journals"
"Preventing Temporal Violations in Scientific Workflows: Where and How","X. Liu; Y. Yang; Y. Jiang; J. Chen","Swinburne University of Technology, Melbourne; Anhui University, Hefei and Swinburne University of Technology, Melbourne; Hefei University of Technology, Hefei and University of Pittsburgh, Pittsburgh; University of Technology, Sydney and Swinburne University of Technology, Melbourne","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","805","825","Due to the dynamic nature of the underlying high-performance infrastructures for scientific workflows such as grid and cloud computing, failures of timely completion of important scientific activities, namely, temporal violations, often take place. Unlike conventional exception handling on functional failures, nonfunctional QoS failures such as temporal violations cannot be passively recovered. They need to be proactively prevented through dynamically monitoring and adjusting the temporal consistency states of scientific workflows at runtime. However, current research on workflow temporal verification mainly focuses on runtime monitoring, while the adjusting strategy for temporal consistency states, namely, temporal adjustment, has so far not been thoroughly investigated. For this issue, two fundamental problems of temporal adjustment, namely, where and how, are systematically analyzed and addressed in this paper. Specifically, a novel minimum probability time redundancy-based necessary and sufficient adjustment point selection strategy is proposed to address the problem of where and an innovative genetic-algorithm-based effective and efficient local rescheduling strategy is proposed to tackle the problem of how. The results of large-scale simulation experiments with generic workflows and specific real-world applications demonstrate that our temporal adjustment strategy can remarkably prevent the violations of both local and global temporal constraints in scientific workflows.","1939-3520","","10.1109/TSE.2010.99","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5645643","Workflow management;exception handling;reliability;software verification;statistical methods.","Decision support systems;Software reliability;Quality of service;Workflow management software","genetic algorithms;middleware;quality of service;workflow management software","temporal violation prevention;scientific workflows;grid computing;cloud computing;nonfunctional QoS failures;workflow temporal verification;adjustment point selection;rescheduling strategy;generic workflows","","39","","53","","29 Nov 2010","","","IEEE","IEEE Journals"
"Software Architecture Reconstruction: A Process-Oriented Taxonomy","S. Ducasse; D. Pollet","INRIA, Lille Nord Europe; University of Lille 1, Francr","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","573","591","To maintain and understand large applications, it is important to know their architecture. The first problem is that unlike classes and packages, architecture is not explicitly represented in the code. The second problem is that successful applications evolve over time, so their architecture inevitably drifts. Reconstructing the architecture and checking whether it is still valid is therefore an important aid. While there is a plethora of approaches and techniques supporting architecture reconstruction, there is no comprehensive software architecture reconstruction state of the art and it is often difficult to compare the approaches. This paper presents a state of the art in software architecture reconstruction approaches.","1939-3520","","10.1109/TSE.2009.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815276","Software architecture reconstruction.","Software architecture;Taxonomy;Computer architecture;Application software;Data mining;Programming;Europe;Packaging;Cognitive science;Bridges","software architecture;software maintenance;software packages","software architecture reconstruction;process-oriented taxonomy;software development","","168","2","181","","17 Apr 2009","","","IEEE","IEEE Journals"
"Software Reliability Analysis Using Weakest Preconditions in Linear Assignment Programs","H. Luo; X. Liu; X. Chen; T. Long; R. Jiang","Department of Measurement and Control Engineering, School of Manufacturing Science and Engineering, Sichuan University, Chengdu, P.R.China; School of Computer Science, McGill University, Montreal H3A0E9, Canada; School of Computer Science, McGill University, Montreal H3A0E9, Canada; Department of Control Engineering, Chengdu University of Information Technology, Shuangliu, P.R.China; School of Electrical Engineering and Information, Sichuan University, Chengdu, P.R.China","IEEE Transactions on Software Engineering","15 Sep 2016","2016","42","9","866","885","Weakest preconditions derived from triple axiomatic semantics have been widely used to prove the correctness of programs. They can also be applied to evaluate the reliability of software. However, deducing a weakest precondition, as well as determining its propagation path, encounters challenges such as unknown constraint conditions, symbol computation and means of representation. To address these challenges, in this paper, we utilize the disjunctive normal form of if-else branch structure to capture reasonable propagation paths of the weakest precondition. Meanwhile, by removing the sequential dependencies, we demonstrate how to get the weakest precondition of loop-structure by leveraging program function. Moreover, we extensively explore three modeling characteristics (i.e., path extension, innermost connection and condition leap) for deducing the weakest precondition of structured programs. Finally, taking the definition of program node and storage structure of weakest precondition as bases, we design a serial of modeling algorithms. Based on symbol computation and recursive call technology with Depth-First Search (DFS), our algorithms can not only be used to deduce the weakest precondition, but also to capture the propagate path of the weakest precondition. Experiments illustrate the efficacy and effectiveness of our proposed models and designed deductive algorithms.","1939-3520","","10.1109/TSE.2016.2521379","Research Foundation of Young Teachers in Sichuan University of P.R. China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7398131","Weakest precondition;path extension;innermost connection;condition leap;node;cell-structure","Algorithm design and analysis;Semantics;Software reliability;Computational modeling;Computer bugs;Cognition","linear programming;search problems;software reliability","software reliability analysis;weakest preconditions;linear assignment program;triple axiomatic semantics;program correctness;propagation path;if-else branch structure;loop-structure precondition;path extension characteristic;innermost connection characteristic;condition leap characteristic;symbol computation;recursive call technology;depth-first search;DFS;deductive algorithms","","1","","31","","3 Feb 2016","","","IEEE","IEEE Journals"
"Empirical Studies of Pair Programming for CS/SE Teaching in Higher Education: A Systematic Literature Review","N. Salleh; E. Mendes; J. Grundy","International Islamic University of Malaysia, Kuala Lumpur and University of Auckland, Auckland; University of Auckland, Auckland; Swinburne University of Technology, Hawthorn","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","509","525","The objective of this paper is to present the current evidence relative to the effectiveness of pair programming (PP) as a pedagogical tool in higher education CS/SE courses. We performed a systematic literature review (SLR) of empirical studies that investigated factors affecting the effectiveness of PP for CS/SE students and studies that measured the effectiveness of PP for CS/SE students. Seventy-four papers were used in our synthesis of evidence, and 14 compatibility factors that can potentially affect PP's effectiveness as a pedagogical tool were identified. Results showed that students' skill level was the factor that affected PP's effectiveness the most. The most common measure used to gauge PP's effectiveness was time spent on programming. In addition, students' satisfaction when using PP was overall higher than when working solo. Our meta-analyses showed that PP was effective in improving students' grades on assignments. Finally, in the studies that used quality as a measure of effectiveness, the number of test cases succeeded, academic performance, and expert opinion were the quality measures mostly applied. The results of this SLR show two clear gaps in this research field: 1) a lack of studies focusing on pair compatibility factors aimed at making PP an effective pedagogical tool and 2) a lack of studies investigating PP for software design/modeling tasks in conjunction with programming tasks.","1939-3520","","10.1109/TSE.2010.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5482588","Empirical studies;pair programming;systematic review.","Programming profession;Education;Educational programs;Computer science;Performance evaluation;Time measurement;Testing;Software design;Collaborative work;Algorithm design and analysis","educational technology;further education;software prototyping;teaching","pair programming;CS/SE teaching;higher education;systematic literature review;PP","","135","","75","","7 Jun 2010","","","IEEE","IEEE Journals"
"A System for Profiling and Monitoring Database Access Patterns by Application Programs for Anomaly Detection","L. Bossi; E. Bertino; S. R. Hussain","Department of Computer Science, Purdue University, West Lafayette, IN; Department of Computer Science, Purdue University, West Lafayette, IN; Department of Computer Science, Purdue University, West Lafayette, IN","IEEE Transactions on Software Engineering","12 May 2017","2017","43","5","415","431","Database Management Systems (DBMSs) provide access control mechanisms that allow database administrators (DBAs) to grant application programs access privileges to databases. Though such mechanisms are powerful, in practice finer-grained access control mechanism tailored to the semantics of the data stored in the DMBS is required as a first class defense mechanism against smart attackers. Hence, custom written applications which access databases implement an additional layer of access control. Therefore, securing a database alone is not enough for such applications, as attackers aiming at stealing data can take advantage of vulnerabilities in the privileged applications and make these applications to issue malicious database queries. An access control mechanism can only prevent application programs from accessing the data to which the programs are not authorized, but it is unable to prevent misuse of the data to which application programs are authorized for access. Hence, we need a mechanism able to detect malicious behavior resulting from previously authorized applications. In this paper, we present the architecture of an anomaly detection mechanism, DetAnom, that aims to solve such problem. Our approach is based the analysis and profiling of the application in order to create a succinct representation of its interaction with the database. Such a profile keeps a signature for every submitted query and also the corresponding constraints that the application program must satisfy to submit the query. Later, in the detection phase, whenever the application issues a query, a module captures the query before it reaches the database and verifies the corresponding signature and constraints against the current context of the application. If there is a mismatch, the query is marked as anomalous. The main advantage of our anomaly detection mechanism is that, in order to build the application profiles, we need neither any previous knowledge of application vulnerabilities nor any example of possible attacks. As a result, our mechanism is able to protect the data from attacks tailored to database applications such as code modification attacks, SQL injections, and also from other data-centric attacks as well. We have implemented our mechanism with a software testing technique called concolic testing and the PostgreSQL DBMS. Experimental results show that our profiling technique is close to accurate, requires acceptable amount of time, and the detection mechanism incurs low runtime overhead.","1939-3520","","10.1109/TSE.2016.2598336","Northrop Grumman Systems Corporation; Department of Homeland Security (DHS); Science and Technology Directorate; Homeland Security Advanced Research Projects Agency; Cyber Security Division; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7534833","Database;insider attacks;anomaly detection;application profile;SQL injection","Databases;Access control;Software testing;Software;Engines","authorisation;database management systems;digital signatures;program diagnostics;program testing;query processing;software architecture","database access patterns profiling;database access patterns monitoring;application programs;anomaly detection mechanism architecture;database management systems;DBMS;database administrator;DBA;defense mechanism;smart attackers;access control mechanism;malicious behavior detection;DetAnom;signature;query submission;software testing technique;concolic testing;PostgreSQL","","13","","40","","5 Aug 2016","","","IEEE","IEEE Journals"
"A Classification Framework for Software Component Models","I. Crnkovic; S. Sentilles; A. Vulgarakis; M. R. V. Chaudron","Mälardalen University, Västerås; Mälardalen University, Västerås; Mälardalen University, Västerås; Universiteit Leiden, Leiden","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","593","615","In the last decade, a large number of different software component models have been developed, with different aims and using different principles and technologies. This has resulted in a number of models which have many similarities, but also principal differences, and in many cases unclear concepts. Component-based development has not succeeded in providing standard principles, as has, for example, object-oriented development. In order to increase the understanding of the concepts and to differentiate component models more easily, this paper identifies, discusses, and characterizes fundamental principles of component models and provides a Component Model Classification Framework based on these principles. Further, the paper classifies a large number of component models using this framework.","1939-3520","","10.1109/TSE.2010.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5587419","Software components;software component models;component lifecycle;extra-functional properties;component composition.","Data models;Bismuth;Packaging","object-oriented programming;pattern classification","software component models;component based development;object oriented development;component model classification framework","","121","6","53","","27 Sep 2010","","","IEEE","IEEE Journals"
"Modular Software Model Checking for Distributed Systems","W. Leungwattanakit; C. Artho; M. Hagiya; Y. Tanabe; M. Yamamoto; K. Takahashi","Department of Mathematics and Informatics, Faculty of Science, Chiba University, 1-3-3 Yayoicho, Inage Ward, Chiba, Japan; Research Institute for Secure Systems at the National Institute of Advanced Industrial Science and Technology (AIST), Amagasaki, Japan; Department of Computer Science, University of Tokyo, Science Building No. 7, 7-3-1 Hongo, Tokyo, Japan; National Institute of Informatics (NII), 2-1-2 Hitotsubashi, Japan; Department of Mathematics and Informatics, Faculty of Science, Chiba University, 1-3-3 Yayoicho, Inage Ward, Chiba, Japan; Research Institute for Secure Systems at the National Institute of Advanced Industrial Science and Technology (AIST), Amagasaki, Japan","IEEE Transactions on Software Engineering","14 May 2014","2014","40","5","483","501","Distributed systems are complex, being usually composed of several subsystems running in parallel. Concurrent execution and inter-process communication in these systems are prone to errors that are difficult to detect by traditional testing, which does not cover every possible program execution. Unlike testing, model checking can detect such faults in a concurrent system by exploring every possible state of the system. However, most model-checking techniques require that a system be described in a modeling language. Although this simplifies verification, faults may be introduced in the implementation. Recently, some model checkers verify program code at runtime but tend to be limited to stand-alone programs. This paper proposes cache-based model checking, which relaxes this limitation to some extent by verifying one process at a time and running other processes in another execution environment. This approach has been implemented as an extension of Java PathFinder, a Java model checker. It is a scalable and promising technique to handle distributed systems. To support a larger class of distributed systems, a checkpointing tool is also integrated into the verification system. Experimental results on various distributed systems show the capability and scalability of cache-based model checking.","1939-3520","","10.1109/TSE.2013.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6645368","Software model checking;software verification;distributed systems;checkpointing","Model checking;Software;Java;Checkpointing;Synchronization;Scalability;Message systems","cache storage;checkpointing;concurrency control;distributed processing;Java;program testing;program verification","modular software model checking;distributed systems;parallel subsystems;concurrent execution;interprocess communication;program execution;fault detection;model-checking techniques;modeling language;program code verification;stand-alone programs;cache-based model checking;execution environment;Java PathFinder extension;Java model checker;checkpointing tool","","16","","50","","23 Oct 2013","","","IEEE","IEEE Journals"
"RELAI Testing: A Technique to Assess and Improve Software Reliability","D. Cotroneo; R. Pietrantuono; S. Russo","Dipartimento di Ingegneria Elettrica e delle Tecnologie dell’Informazione (DIETI), Università di Napoli Federico II, Via Claudio 21, Naples, Italy; Dipartimento di Ingegneria Elettrica e delle Tecnologie dell’Informazione (DIETI), Università di Napoli Federico II, Via Claudio 21, Naples, Italy; Dipartimento di Ingegneria Elettrica e delle Tecnologie dell’Informazione (DIETI), Università di Napoli Federico II, Via Claudio 21, Naples, Italy","IEEE Transactions on Software Engineering","12 May 2016","2016","42","5","452","475","Testing software to assess or improve reliability presents several practical challenges. Conventional operational testing is a fundamental strategy that simulates the real usage of the system in order to expose failures with the highest occurrence probability. However, practitioners find it unsuitable for assessing/achieving very high reliability levels; also, they do not see the adoption of a “real” usage profile estimate as a sensible idea, being it a source of non-quantifiable uncertainty. Oppositely, debug testing aims to expose as many failures as possible, but regardless of their impact on runtime reliability. These strategies are used either to assess or to improve reliability, but cannot improve and assess reliability in the same testing session. This article proposes Reliability Assessment and Improvement (RELAI) testing, a new technique thought to improve the delivered reliability by an adaptive testing scheme, while providing, at the same time, a continuous assessment of reliability attained through testing and fault removal. The technique also quantifies the impact of a partial knowledge of the operational profile. RELAI is positively evaluated on four software applications compared, in separate experiments, with techniques conceived either for reliability improvement or for reliability assessment, demonstrating substantial improvements in both cases.","1939-3520","","10.1109/TSE.2015.2491931","European Commission; FP7 Marie Curie Industry-Academia Partnerships and Pathways (IAPP); MIUR; SVEVIA; COSMIC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7299696","Software Testing;Reliability;Operational Testing;Random Testing;Sampling;Operational Profile;Software testing;reliability;operational testing;random testing;sampling;operational profile","Testing;Software reliability;Software;Uncertainty;Estimation error","probability;program debugging;program testing;software reliability","RELAI testing;software testing;operational testing;nonquantifiable uncertainty;debug testing;software failures;runtime reliability;reliability assessment and improvement testing;software reliability;adaptive testing scheme;continuous reliability assessment;fault removal;software applications","","14","","65","","16 Oct 2015","","","IEEE","IEEE Journals"
"Verifying Linearizability via Optimized Refinement Checking","Y. Liu; W. Chen; Y. A. Liu; J. Sun; S. J. Zhang; J. S. Dong","Nanyang Technological University, Singapore; Microsoft Research Asia, Beijing; State University of New York at Stony Brook, Stony Brook; Singapore University of Technology and Design, Singapore; National University of Singapore, Singapore; National University of Singapore, Singapore","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","1018","1039","Linearizability is an important correctness criterion for implementations of concurrent objects. Automatic checking of linearizability is challenging because it requires checking that: (1) All executions of concurrent operations are serializable, and (2) the serialized executions are correct with respect to the sequential semantics. In this work, we describe a method to automatically check linearizability based on refinement relations from abstract specifications to concrete implementations. The method does not require that linearization points in the implementations be given, which is often difficult or impossible. However, the method takes advantage of linearization points if they are given. The method is based on refinement checking of finite-state systems specified as concurrent processes with shared variables. To tackle state space explosion, we develop and apply symmetry reduction, dynamic partial order reduction, and a combination of both for refinement checking. We have built the method into the PAT model checker, and used PAT to automatically check a variety of implementations of concurrent objects, including the first algorithm for scalable nonzero indicators. Our system is able to find all known and injected bugs in these implementations.","1939-3520","","10.1109/TSE.2012.82","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363443","Linearizability;refinement;model checking;PAT","History;Sun;Educational institutions;Optimization;Electronic mail;Semantics","concurrency control;formal specification;program debugging;program verification;programming language semantics;refinement calculus","linearizability verification;optimized refinement checking;concurrent objects;automatic linearizability checking;concurrent operations;serialized executions;sequential semantics;refinement relations;linearization points;finite-state systems;shared variables;symmetry reduction;dynamic partial-order reduction;PAT model checker;scalable nonzero indicators;bug detection","","18","","62","","29 Nov 2012","","","IEEE","IEEE Journals"
"GossipKit: A Unified ComponentFramework for Gossip","F. Taïani; S. Lin; G. S. Blair","University of Rennes 1 / IRISA Rennes, France; SAP Labs, China; University of Lancaster, United Kingdom","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","2","123","136","Although the principles of gossip protocols are relatively easy to grasp, their variety can make their design and evaluation highly time consuming. This problem is compounded by the lack of a unified programming framework for gossip, which means developers cannot easily reuse, compose, or adapt existing solutions to fit their needs, and have limited opportunities to share knowledge and ideas. In this paper, we consider how component frameworks, which have been widely applied to implement middleware solutions, can facilitate the development of gossip-based systems in a way that is both generic and simple. We show how such an approach can maximize code reuse, simplify the implementation of gossip protocols, and facilitate dynamic evolution and redeployment.Also known as “epidemic” protocols.","1939-3520","","10.1109/TSE.2013.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6645372","Distributed systems;components;frameworks;protocols","Protocols;Peer-to-peer computing;Programming;Wireless sensor networks;Ad hoc networks;Software;Assembly","distributed processing;object-oriented programming;protocols","GossipKit;unified component framework;gossip protocols;protocol design;protocol evaluation;unified programming framework;middleware solutions;gossip-based systems;code reuse;epidemic protocols","","3","","77","","23 Oct 2013","","","IEEE","IEEE Journals"
"Optimizing Ordered Throughput Using Autonomic Cloud Bursting Schedulers","S. Kailasam; N. Gnanasambandam; J. Dharanipragada; N. Sharma","Indian Institute of Technology Madras, Chennai; Xerox Research Center Webster, New York; Indian Institute of Technology Madras, Chennai; Xerox Research Center Webster, New York","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1564","1581","Optimizing ordered throughput not only improves the system efficiency but also makes cloud bursting transparent to the user. This is critical from the perspective of user fairness in customer-facing systems, correctness in stream processing systems, and so on. In this paper, we consider optimizing ordered throughput for near real-time, data-intensive, independent computations using cloud bursting. Intercloud computation of data-intensive applications is a challenge due to large data transfer requirements, low intercloud bandwidth, and best-effort traffic on the Internet. The system model we consider is comprised of two processing stages. The first stage uses cloud bursting opportunistically for parallel processing, while the second stage (sequential) expects the output of the first stage to be in the same order as the arrival sequence. We propose three scheduling heuristics as part of an autonomic cloud bursting approach that adapt to changing workload characteristics, variation in bandwidth, and available resources to optimize ordered throughput. We also characterize the operational regimes for cloud bursting as stabilization mode versus acceleration mode, depending on the workload characteristics like the size of data to be transferred for a given compute load. The operational regime characterization helps in deciding how many instances can be optimally utilized in the external cloud.","1939-3520","","10.1109/TSE.2013.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6520852","Cloud bursting;ordered throughput;autonomic;data-intensive","Cloud computing;Optimization;Scheduling","cloud computing;fault tolerant computing;parallel processing;scheduling","external cloud;operational regime characterization;data size;acceleration mode;stabilization mode;bandwidth variation;workload characteristics;scheduling heuristics;arrival sequence;parallel processing;Internet traffic;intercloud bandwidth;large data transfer requirements;data-intensive applications;intercloud computation;near real-time data-intensive independent computation;stream processing system correctness;customer-facing systems;user fairness;system efficiency improvement;autonomic cloud bursting schedulers;ordered throughput optimization","","16","","41","","27 May 2013","","","IEEE","IEEE Journals"
"Comparing the Defect Reduction Benefits of Code Inspection and Test-Driven Development","J. W. Wilkerson; J. F. Nunamaker; R. Mercer","Pennsylvania State University, Erie, Erie; University of Arizona, Tucson; University of Arizona, Tucson","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","547","560","This study is a quasi experiment comparing the software defect rates and implementation costs of two methods of software defect reduction: code inspection and test-driven development. We divided participants, consisting of junior and senior computer science students at a large Southwestern university, into four groups using a two-by-two, between-subjects, factorial design and asked them to complete the same programming assignment using either test-driven development, code inspection, both, or neither. We compared resulting defect counts and implementation costs across groups. We found that code inspection is more effective than test-driven development at reducing defects, but that code inspection is also more expensive. We also found that test-driven development was no more effective at reducing defects than traditional programming methods.","1939-3520","","10.1109/TSE.2011.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5750007","Agile programming;code inspections and walk throughs;reliability;test-driven development;testing strategies;empirical study.","Inspection;Software;Testing;Java;Writing;Programming profession","program testing;system recovery","defect reduction benefits;code inspection;test driven development;quasi experiment;software defect rates;software defect reduction;senior computer science students;junior computer science students;programming assignment","","17","","47","","15 Apr 2011","","","IEEE","IEEE Journals"
"Designing Autonomic Management Systems by Using Reactive Control Techniques","N. Berthier; É. Rutten; N. De Palma; S. M. Gueye","ERODS team, University of Grenoble LIG Bât. C, 220 rue de la Chimie, St Martin d'Hères, France; LIG/INRIA Grenoble - Rhône-Alpes, Inovallée, 655 av. de l'Europe, Montbonnot, St Ismier, France; ERODS team, University of Grenoble, LIG Bât. C, 220 rue de la Chimie, St Martin d'Hères, France; ERODS team, University of Grenoble, LIG Bât. C, 220 rue de la Chimie, St Martin d'Hères, France","IEEE Transactions on Software Engineering","14 Jul 2016","2016","42","7","640","657","The ever growing complexity of software systems has led to the emergence of automated solutions for their management. The software assigned to this work is usually called an Autonomic Management System (AMS). It is ordinarily designed as a composition of several managers, which are pieces of software evaluating the dynamics of the system under management through measurements (e.g., workload, memory usage), taking decisions, and acting upon it so that it stays in a set of acceptable operating states. However, careless combination of managers may lead to inconsistencies in the taken decisions, and classical approaches dealing with these coordination problems often rely on intricate and ad hoc solutions. To tackle this problem, we take a global view and underscore that AMSs are intrinsically reactive, as they react to flows of monitoring data by emitting flows of reconfiguration actions. Therefore we propose a new approach for the design of AMSs, based on synchronous programming and discrete controller synthesis techniques. They provide us with high-level languages for modeling the system to manage, as well as means for statically guaranteeing the absence of logical coordination problems. Hence, they suit our main contribution, which is to obtain guarantees at design time about the absence of logical inconsistencies in the taken decisions. We detail our approach, illustrate it by designing an AMS for a realistic multi-tier application, and evaluate its practicality with an implementation.","1939-3520","","10.1109/TSE.2015.2510004","French ANR project Ctrl-Green; ANR INFRA; MINALOGIC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7360217","Autonomic computing;coordination;discrete control;reactive programming","Software;Programming;Automata;Sensor systems;Actuators","software management;software performance evaluation","autonomic management systems;reactive control techniques;software systems;AMS;software evaluation;software measurements;ad hoc solutions;monitoring data flow;emitting flows;synchronous programming;discrete controller synthesis techniques;logical coordination problems;realistic multitier application","","4","","47","","17 Dec 2015","","","IEEE","IEEE Journals"
"Validating Second-Order Mutation at System Level","P. Reales Mateo; M. Polo Usaola; J. L. Fernández Alemán","University of Castilla-La Mancha, Ciudad Real; University of Castilla-La Mancha, Ciudad Real; University of Murcia, Murcia","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","570","587","Mutation has been recognized to be an effective software testing technique. It is based on the insertion of artificial faults in the system under test (SUT) by means of a set of mutation operators. Different operators can mutate each program statement in several ways, which may produce a huge number of mutants. This leads to very high costs for test case execution and result analysis. Several works have approached techniques for cost reduction in mutation testing, like n-order mutation where each mutant contains n artificial faults instead of one. There are two approaches to n-order mutation: increasing the effectiveness of mutation by searching for good n-order mutants, and decreasing the costs of mutation testing by reducing the mutants set through the combination of the first-order mutants into n-order mutants. This paper is focused on the second approach. However, this second use entails a risk: the possibility of leaving undiscovered faults in the SUT, which may distort the perception of the test suite quality. This paper describes an empirical study of different combination strategies to compose second-order mutants at system level as well as a cost-risk analysis of n-order mutation at system level.","1939-3520","","10.1109/TSE.2012.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6216382","Empirical evaluation;high-order mutation;mutation testing","Algorithm design and analysis;Concrete;Educational institutions;Benchmark testing;Optimization;Software testing","program testing;software fault tolerance","second order mutation;system level;software testing technique;system under test;SUT;mutation operators;test case execution;cost risk analysis","","13","","53","","12 Jun 2012","","","IEEE","IEEE Journals"
"An Efficient and Scalable Approach to Correct Class Model Refinement","W. Shen; K. Wang; A. Egyed","Western Michigan University, Kalamazoo; Siemens PLM Software, Ann Arbor; Johannes Kepler University, Linz","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","515","533","Today, programmers benefit immensely from Integrated Development Environments (IDEs), where errors are highlighted within seconds of their introduction. Yet, designers rarely benefit from such an instant feedback in modeling tools. This paper focuses on the refinement of UML-style class models with instant feedback on correctness. Following the Model-Driven Architecture (MDA) paradigm, we strongly believe in the benefit of maintaining high-level and low-level models separately to 1) document the lower level model and 2) continuously ensure the correctness of the low-level model during later evolution (i.e., high- or low-level models may be evolved independently). However, currently the refinement and subsequent evolution lack automated support, let alone an instant feedback on their correctness (i.e., consistency). Traditional approaches to consistency checking fail here because of the computational cost of comparing class models. Our proposed instant approach first transforms the low-level model into an intermediate model that is then easier comparable with the high-level model. The key to computational scalability is the separation of transformation and comparison so that each can react optimally to changes-changes that could happen concurrently in both the high- and low-level class models. We evaluate our approach on eight third-party design models. The empirical data show that the separation of transformation and comparison results in a 6 to 11-fold performance gain and a ninefold reduction in producing irrelevant feedback. While this work emphasizes the refinement of class models, we do believe that the concepts are more generally applicable to other kinds of modeling languages, where transformation and subsequent comparison are computationally expensive.","1939-3520","","10.1109/TSE.2009.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815278","Class models;consistency checking;refinement;separation of concerns;and UML.","Feedback;Programming profession;Unified modeling language;Software systems;Error correction;Computational efficiency;Concurrent computing;Scalability;Performance gain;System recovery","software architecture;Unified Modeling Language","class model refinement;integrated development environment;UML-style class models;Unified Modeling Language;model-driven architecture;computational scalability","","8","","43","","17 Apr 2009","","","IEEE","IEEE Journals"
"Precise Calling Context Encoding","W. N. Sumner; Y. Zheng; D. Weeratunge; X. Zhang","Purdue University, West Lafayette; Purdue University, West Lafayette; Purdue University, West Lafayette; Purdue University, West Lafayette","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1160","1177","Calling contexts (CCs) are very important for a wide range of applications such as profiling, debugging, and event logging. Most applications perform expensive stack walking to recover contexts. The resulting contexts are often explicitly represented as a sequence of call sites and hence are bulky. We propose a technique to encode the current calling context of any point during an execution. In particular, an acyclic call path is encoded into one number through only integer additions. Recursive call paths are divided into acyclic subsequences and encoded independently. We leverage stack depth in a safe way to optimize encoding: If a calling context can be safely and uniquely identified by its stack depth, we do not perform encoding. We propose an algorithm to seamlessly fuse encoding and stack depth-based identification. The algorithm is safe because different contexts are guaranteed to have different IDs. It also ensures contexts can be faithfully decoded. Our experiments show that our technique incurs negligible overhead (0-6.4 percent). For most medium-sized programs, it can encode all contexts with just one number. For large programs, we are able to encode most calling contexts to a few numbers. We also present our experience of applying context encoding to debugging crash-based failures.","1939-3520","","10.1109/TSE.2011.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5963696","Calling context;context sensitivity;profiling;path encoding;calling context encoding;call graph","Context;Encoding;Instruments;Image edge detection;Runtime;Decoding;Software algorithms","optimisation;program compilers;program debugging","precise calling context encoding;CC;profiling;event logging;stack walking;context recovery;call sites;recursive call paths;acyclic subsequences;encoding optimization;stack depth-based identification;ID;medium-sized programs;crash-based failure debugging","","12","","54","","28 Jul 2011","","","IEEE","IEEE Journals"
"A Uniform Representation of Hybrid Criteria for Regression Testing","S. Sampath; R. Bryce; A. M. Memon","University of Maryland, Baltimore; University of North Texas, Denton; University of Maryland, Baltimore","IEEE Transactions on Software Engineering","25 Sep 2013","2013","39","10","1326","1344","Regression testing tasks of test case prioritization, test suite reduction/minimization, and regression test selection are typically centered around criteria that are based on code coverage, test execution costs, and code modifications. Researchers have developed and evaluated new individual criteria; others have combined existing criteria in different ways to form what we--and some others--call hybrid criteria. In this paper, we formalize the notion of combining multiple criteria into a hybrid. Our goal is to create a uniform representation of such combinations so that they can be described unambiguously and shared among researchers. We envision that such sharing will allow researchers to implement, study, extend, and evaluate the hybrids using a common set of techniques and tools. We precisely formulate three hybrid combinations, Rank, Merge, and Choice, and demonstrate their usefulness in two ways. First, we recast, in terms of our formulations, others' previously reported work on hybrid criteria. Second, we use our previous results on test case prioritization to create and evaluate new hybrid criteria. Our findings suggest that hybrid criteria of others can be described using our Merge and Rank formulations, and that the hybrid criteria we developed most often outperformed their constituent individual criteria.","1939-3520","","10.1109/TSE.2013.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6484067","Test case prioritization;test criteria;hybrid test criteria;web testing;GUI testing","Testing;Fault detection;Educational institutions;Genetic algorithms;Vectors;Loss measurement;Minimization","program testing;regression analysis","uniform representation;hybrid test criteria;regression testing;rank-merge-and-choice hybrid combination;test case prioritization;merge-and-rank formulations","","21","","74","","21 Mar 2013","","","IEEE","IEEE Journals"
"The Use of Summation to Aggregate Software Metrics Hinders the Performance of Defect Prediction Models","F. Zhang; A. E. Hassan; S. McIntosh; Y. Zou","School of Computing, Queen's University, Kingston, ON, Canada; School of Computing, Queen's University, Kingston, ON, Canada; Department of Electrical and Computer Engineering, McGill University, Montréal, QC, Canada; Department of Electrical and Computer Engineering, Queen's University, Kingston, ON, Canada","IEEE Transactions on Software Engineering","12 May 2017","2017","43","5","476","491","Defect prediction models help software organizations to anticipate where defects will appear in the future. When training a defect prediction model, historical defect data is often mined from a Version Control System (VCS, e.g., Subversion), which records software changes at the file-level. Software metrics, on the other hand, are often calculated at the class- or method-level (e.g., McCabe's Cyclomatic Complexity). To address the disagreement in granularity, the class- and method-level software metrics are aggregated to file-level, often using summation (i.e., McCabe of a file is the sum of the McCabe of all methods within the file). A recent study shows that summation significantly inflates the correlation between lines of code (Sloc) and cyclomatic complexity (Cc) in Java projects. While there are many other aggregation schemes (e.g., central tendency, dispersion), they have remained unexplored in the scope of defect prediction. In this study, we set out to investigate how different aggregation schemes impact defect prediction models. Through an analysis of 11 aggregation schemes using data collected from 255 open source projects, we find that: (1) aggregation schemes can significantly alter correlations among metrics, as well as the correlations between metrics and the defect count; (2) when constructing models to predict defect proneness, applying only the summation scheme (i.e., the most commonly used aggregation scheme in the literature) only achieves the best performance (the best among the 12 studied configurations) in 11 percent of the studied projects, while applying all of the studied aggregation schemes achieves the best performance in 40 percent of the studied projects; (3) when constructing models to predict defect rank or count, either applying only the summation or applying all of the studied aggregation schemes achieves similar performance, with both achieving the closest to the best performance more often than the other studied aggregation schemes; and (4) when constructing models for effort-aware defect prediction, the mean or median aggregation schemes yield performance values that are significantly closer to the best performance than any of the other studied aggregation schemes. Broadly speaking, the performance of defect prediction models are often underestimated due to our community's tendency to only use the summation aggregation scheme. Given the potential benefit of applying additional aggregation schemes, we advise that future defect prediction models should explore a variety of aggregation schemes.","1939-3520","","10.1109/TSE.2016.2599161","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7539677","Defect prediction;aggregation scheme;software metrics","Predictive models;Correlation;Software metrics;Indexes;Software;Data models","data aggregation;data mining;Java;public domain software;software metrics","software metrics aggregation;defect prediction models;software organizations;historical defect data mining;version control system;software changes recording;McCabe cyclomatic complexity;granularity disagreement;class-level software metrics;method-level software metrics;lines of code;Sloc;Cc;Java projects;open source projects;effort-aware defect prediction;summation","","31","","87","","10 Aug 2016","","","IEEE","IEEE Journals"
"Effects of Personality on Pair Programming","J. E. Hannay; E. Arisholm; H. Engvik; D. I. K. Sjoberg","Simula Research Laboratory, Lysaker and University of Oslo, Oslo; Simula Research Laboratory, Lysaker and University of Oslo, Oslo; University of Oslo, Oslo; University of Oslo, Oslo","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","61","80","Personality tests in various guises are commonly used in recruitment and career counseling industries. Such tests have also been considered as instruments for predicting the job performance of software professionals both individually and in teams. However, research suggests that other human-related factors such as motivation, general mental ability, expertise, and task complexity also affect the performance in general. This paper reports on a study of the impact of the Big Five personality traits on the performance of pair programmers together with the impact of expertise and task complexity. The study involved 196 software professionals in three countries forming 98 pairs. The analysis consisted of a confirmatory part and an exploratory part. The results show that: (1) Our data do not confirm a meta-analysis-based model of the impact of certain personality traits on performance and (2) personality traits, in general, have modest predictive value on pair programming performance compared with expertise, task complexity, and country. We conclude that more effort should be spent on investigating other performance-related predictors such as expertise, and task complexity, as well as other promising predictors, such as programming skill and learning. We also conclude that effort should be spent on elaborating on the effects of personality on various measures of collaboration, which, in turn, may be used to predict and influence performance. Insights into such malleable, rather than static, factors may then be used to improve pair programming performance.","1939-3520","","10.1109/TSE.2009.41","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5089333","Pair programming;personality;Big Five;expertise;task complexity;performance.","Programming profession;Collaborative work;Keyboards;Books;Recruitment;Engineering profession;Employee welfare;Software testing;Instruments;Software performance","human factors;personnel;programming;recruitment;team working","personality tests;pair programming;recruitment industries;career counseling industries;job performance;software professionals;personality traits;task complexity;meta-analysis-based model;performance-related predictors","","64","","121","","19 Jun 2009","","","IEEE","IEEE Journals"
"Automated Extraction and Clustering of Requirements Glossary Terms","C. Arora; M. Sabetzadeh; L. Briand; F. Zimmer","SnT Centre for Security, Reliability, and Trust, University of Luxembourg, Alphonse Weicker, Luxembourg; SnT Centre for Security, Reliability, and Trust, University of Luxembourg, Alphonse Weicker, Luxembourg; SnT Centre for Security, Reliability, and Trust, University of Luxembourg, Alphonse Weicker, Luxembourg; SES Techcom, Betzdorf, Luxembourg","IEEE Transactions on Software Engineering","13 Oct 2017","2017","43","10","918","945","A glossary is an important part of any software requirements document. By making explicit the technical terms in a domain and providing definitions for them, a glossary helps mitigate imprecision and ambiguity. A key step in building a glossary is to decide upon the terms to include in the glossary and to find any related terms. Doing so manually is laborious, particularly for large requirements documents. In this article, we develop an automated approach for extracting candidate glossary terms and their related terms from natural language requirements documents. Our approach differs from existing work on term extraction mainly in that it clusters the extracted terms by relevance, instead of providing a flat list of terms. We provide an automated, mathematically-based procedure for selecting the number of clusters. This procedure makes the underlying clustering algorithm transparent to users, thus alleviating the need for any user-specified parameters. To evaluate our approach, we report on three industrial case studies, as part of which we also examine the perceptions of the involved subject matter experts about the usefulness of our approach. Our evaluation notably suggests that: (1) Over requirements documents, our approach is more accurate than major generic term extraction tools. Specifically, in our case studies, our approach leads to gains of 20 percent or more in terms of recall when compared to existing tools, while at the same time either improving precision or leaving it virtually unchanged. And, (2) the experts involved in our case studies find the clusters generated by our approach useful as an aid for glossary construction.","1939-3520","","10.1109/TSE.2016.2635134","Luxembourg’s National Research Fund; European Research Council; European Union’s Horizon 2020 research and innovation program; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7765062","Requirements glossaries;term extraction;natural language processing;clustering;case study research","Terminology;Servers;Pipelines;Natural languages;Monitoring;Software;Clustering algorithms","natural language processing;pattern clustering;text analysis","natural language requirements documents;mathematically-based procedure;user-specified parameters;candidate glossary terms;technical terms;clustering algorithm;automated approach;software requirements document;requirements glossary terms;glossary construction;generic term extraction tools","","11","","100","Traditional","2 Dec 2016","","","IEEE","IEEE Journals"
"Efficient Dynamic Updates of Distributed Components Through Version Consistency","L. Baresi; C. Ghezzi; X. Ma; V. P. L. Manna","Dipartimento di Elettronica, Informazione e Bioingegneria, Politecnico di Milano, Milano, Italy; Dipartimento di Elettronica, Informazione e Bioingegneria, Politecnico di Milano, Milano, Italy; State Key Laboratory for Novel Software Technology and the Collaborative Innovation Center of Novel Software Technology and Industrialization, Nanjing University, Nanjing, Jiangsu, China; Holst Centre/imec the Netherlands, Eindhoven, AE, The Netherlands","IEEE Transactions on Software Engineering","14 Apr 2017","2017","43","4","340","358","Modern component-based distributed software systems are increasingly required to offer non-stop service and thus their updates must be carried out at runtime. Different authors have already proposed solutions for the safe management of dynamic updates. Our contribution aims at improving their efficiency without compromising safety. We propose a new criterion, called version consistency, which defines when a dynamic update can be safely and efficiently applied to the components that execute distributed transactions. Version consistency ensures that distributed transactions be served as if they were operated on a single coherent version of the system despite possible concurrent updates. The paper presents a distributed algorithm for checking version consistency efficiently, formalizes the proposed approach by means of a graph transformation system, and verifies its correctness through model checking. The paper also presents ConUp, a novel prototype framework that supports the approach and offers a viable, concrete solution for the use of version consistency. Both the approach and ConUp are evaluated on a significant third-party application. Obtained results witness the benefits of the proposed solution with respect to both timeliness and disruption.","1939-3520","","10.1109/TSE.2016.2592913","The 973 Program of China; NSFC; EEB-Edifici a zero consumo energetico in distretti urbani intelligenti; Italian Technology Cluster For Smart Communities; Telecom Italia; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7516718","Component-based distributed system;dynamic update;version-consistency","Portals;Runtime;Software systems;Safety;Model checking;Concrete","distributed programming;formal verification;graph theory","distributed components;version consistency;distributed software systems;dynamic update;graph transformation system","","9","","41","","19 Jul 2016","","","IEEE","IEEE Journals"
"An Autonomous Engine for Services Configuration and Deployment","F. Cuadrado; J. C. Duenas; R. Garcia-Carmona","Queen Mary University of London, London; Universidad Politécnica de Madrid, Madrid; Universidad Politécnica de Madrid, Madrid","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","520","536","The runtime management of the infrastructure providing service-based systems is a complex task, up to the point where manual operation struggles to be cost effective. As the functionality is provided by a set of dynamically composed distributed services, in order to achieve a management objective multiple operations have to be applied over the distributed elements of the managed infrastructure. Moreover, the manager must cope with the highly heterogeneous characteristics and management interfaces of the runtime resources. With this in mind, this paper proposes to support the configuration and deployment of services with an automated closed control loop. The automation is enabled by the definition of a generic information model, which captures all the information relevant to the management of the services with the same abstractions, describing the runtime elements, service dependencies, and business objectives. On top of that, a technique based on satisfiability is described which automatically diagnoses the state of the managed environment and obtains the required changes for correcting it (e.g., installation, service binding, update, or configuration). The results from a set of case studies extracted from the banking domain are provided to validate the feasibility of this proposal.","1939-3520","","10.1109/TSE.2011.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5728830","Autonomic systems;model-based management;satisfiability;service configuration.","Runtime;Containers;Servers;Web services;Context;Business;Engines","computability;fault tolerant computing;service-oriented architecture","autonomous engine;services configuration;runtime management;service-based systems;dynamically composed distributed services;distributed elements;runtime resources;automated closed control loop;generic information model;runtime elements;service dependencies;business objectives;satisfiability;banking domain","","10","","38","","10 Mar 2011","","","IEEE","IEEE Journals"
"TACO: Efficient SAT-Based Bounded Verification Using Symmetry Breaking and Tight Bounds","J. P. Galeotti; N. Rosner; C. G. López Pombo; M. F. Frias","Universidad de Buenos Aires and CONICET, Argentina; Universidad de Buenos Aires, Argentina; Universidad de Buenos Aires and CONICET, Argentina; Instituto Tecnológico de Buenos Aires and CONICET, Argentina","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1283","1307","SAT-based bounded verification of annotated code consists of translating the code together with the annotations to a propositional formula, and analyzing the formula for specification violations using a SAT-solver. If a violation is found, an execution trace exposing the failure is exhibited. Code involving linked data structures with intricate invariants is particularly hard to analyze using these techniques. In this paper, we present Translation of Annotated COde (TACO), a prototype tool which implements a novel, general, and fully automated technique for the SAT-based analysis of JML-annotated Java sequential programs dealing with complex linked data structures. We instrument code analysis with a symmetry-breaking predicate which, on one hand, reduces the size of the search space by ignoring certain classes of isomorphic models and, on the other hand, allows for the parallel, automated computation of tight bounds for Java fields. Experiments show that the translations to propositional formulas require significantly less propositional variables, leading to an improvement of the efficiency of the analysis of orders of magnitude, compared to the noninstrumented SAT--based analysis. We show that in some cases our tool can uncover bugs that cannot be detected by state-of-the-art tools based on SAT-solving, model checking, or SMT-solving.","1939-3520","","10.1109/TSE.2013.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6482141","Static analysis;SAT-based code analysis;Alloy;KodKod;DynAlloy","Metals;Java;Cost accounting;Instruments;Analytical models;Contracts;Context","computability;formal specification;formal verification;program diagnostics;program interpreters","TACO tool;translation-of-annotated code tool;SAT-based bounded verification;satisfiability;code translation;specification violation;JML-annotated Java sequential program;data structure;code analysis;symmetry-breaking predicate;isomorphic model;automated tight bound computation;model checking;SAT-solving;SMT-solving","","26","","47","","19 Mar 2013","","","IEEE","IEEE Journals"
"On Fault Representativeness of Software Fault Injection","R. Natella; D. Cotroneo; J. A. Duraes; H. S. Madeira","Federico II University of Naples, Naples; Federico II University of Naples, Naples; Rua Pedro Nunes-Quinta da Nora, Coimbra; University of Coimbra, Polo II-Pinhal de Marrocos, Coimbra","IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","80","96","The injection of software faults in software components to assess the impact of these faults on other components or on the system as a whole, allowing the evaluation of fault tolerance, is relatively new compared to decades of research on hardware fault injection. This paper presents an extensive experimental study (more than 3.8 million individual experiments in three real systems) to evaluate the representativeness of faults injected by a state-of-the-art approach (G-SWFIT). Results show that a significant share (up to 72 percent) of injected faults cannot be considered representative of residual software faults as they are consistently detected by regression tests, and that the representativeness of injected faults is affected by the fault location within the system, resulting in different distributions of representative/nonrepresentative faults across files and functions. Therefore, we propose a new approach to refine the faultload by removing faults that are not representative of residual software faults. This filtering is essential to assure meaningful results and to reduce the cost (in terms of number of faults) of software fault injection campaigns in complex software. The proposed approach is based on classification algorithms, is fully automatic, and can be used for improving fault representativeness of existing software fault injection approaches.","1939-3520","","10.1109/TSE.2011.124","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6122035","Software fault injection;experimental dependability evaluation;software reliability;fault-tolerant systems","Software;Testing;Fault tolerance;Fault tolerant systems;Hardware;Fault location;Emulation","software fault tolerance","fault representativeness;software components;software fault injection approaches;fault tolerance;hardware fault injection;G-SWFIT;regression tests;fault location;nonrepresentative faults;classification algorithms","","87","","62","","3 Jan 2012","","","IEEE","IEEE Journals"
"Scalable and Effective Test Generation for Role-Based Access Control Systems","A. Masood; R. Bhatti; A. Ghafoor; A. P. Mathur","Air University, Islamabad; Oracle, Redwood Shores; Purdue University, West Lafayette; Purdue University, West Lafayette","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","654","668","Conformance testing procedures for generating tests from the finite state model representation of Role-Based Access Control (RBAC) policies are proposed and evaluated. A test suite generated using one of these procedures has excellent fault detection ability but is astronomically large. Two approaches to reduce the size of the generated test suite were investigated. One is based on a set of six heuristics and the other directly generates a test suite from the finite state model using random selection of paths in the policy model. Empirical studies revealed that the second approach to test suite generation, combined with one or more heuristics, is most effective in the detection of both first-order mutation and malicious faults and generates a significantly smaller test suite than the one generated directly from the finite state models.","1939-3520","","10.1109/TSE.2009.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4967616","Role-Based Access Control (RBAC);finite state models;fault model;first-order mutants;malicious faults.","System testing;Access control;Fault detection;Application software;Genetic mutations;Permission;Aerospace electronics;Computer Society;Authentication;Operating systems","authorisation;fault tolerance;finite state machines","for role-based access control system;conformance testing;finite state model;malicious fault detection;first-order mutant","","21","1","30","","26 May 2009","","","IEEE","IEEE Journals"
"Elaborating Requirements Using Model Checking and Inductive Learning","D. Alrajeh; J. Kramer; A. Russo; S. Uchitel","Imperial College London, London; Imperial College London, London; Imperial College London, London; Imperial College London, London","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","361","383","The process of Requirements Engineering (RE) includes many activities, from goal elicitation to requirements specification. The aim is to develop an operational requirements specification that is guaranteed to satisfy the goals. In this paper, we propose a formal, systematic approach for generating a set of operational requirements that are complete with respect to given goals. We show how the integration of model checking and inductive learning can be effectively used to do this. The model checking formally verifies the satisfaction of the goals and produces counterexamples when incompleteness in the operational requirements is detected. The inductive learning process then computes operational requirements from the counterexamples and user-provided positive examples. These learned operational requirements are guaranteed to eliminate the counterexamples and be consistent with the goals. This process is performed iteratively until no goal violation is detected. The proposed framework is a rigorous, tool-supported requirements elaboration technique which is formally guided by the engineer's knowledge of the domain and the envisioned system.","1939-3520","","10.1109/TSE.2012.41","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6216384","Requirements elaboration;goal operationalization;behavior model refinement;model checking;inductive learning","Wheels;Computational modeling;Software;Adaptation models;Calculus;Switches;Semantics","formal specification;formal verification;learning by example","model checking;requirement engineering;RE;goal elicitation;requirement specification;operational requirements specification;formal verification;inductive learning process;tool-supported requirements elaboration","","14","","52","","12 Jun 2012","","","IEEE","IEEE Journals"
"Test Code Quality and Its Relation to Issue Handling Performance","D. Athanasiou; A. Nugroho; J. Visser; A. Zaidman","Software Improvement Group, Amstelplein 1, 1096HA Amsterdam, The Netherlands; Software Improvement Group, Amstelplein 1, 1096HA Amsterdam, The Netherlands; Software Improvement Group, Amstelplein 1, 1096HA Amsterdam, The Netherlands; Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technology, Mekelweg 4, 2628CD Delft, The Netherlands","IEEE Transactions on Software Engineering","10 Nov 2014","2014","40","11","1100","1125","Automated testing is a basic principle of agile development. Its benefits include early defect detection, defect causelocalization and removal of fear to apply changes to the code. Therefore, maintaining high quality test code is essential. This study introduces a model that assesses test code quality by combining source code metrics that reflect three main aspects of test codequality: completeness, effectiveness and maintainability. The model is inspired by the Software Quality Model of the SoftwareImprovement Group which aggregates source code metrics into quality ratings based on benchmarking. To validate the model we assess the relation between test code quality, as measured by the model, and issue handling performance. An experiment isconducted in which the test code quality model is applied to $18$  open source systems. The test quality ratings are tested for correlation with issue handling indicators, which are obtained by mining issue repositories. In particular, we study the (1) defect resolution speed, (2) throughput and (3) productivity issue handling metrics. The results reveal a significant positive correlation between test code quality and two out of the three issue handling metrics (throughput and productivity), indicating that good test code quality positively influences issue handling performance.","1939-3520","","10.1109/TSE.2014.2342227","NWO TestRoots project; RAAK-PRO project EQuA; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6862882","Testing;defects;bugs;metrics;measurement","Measurement;Software;Productivity;Throughput;Benchmark testing;Correlation","","","","42","","90","","23 Jul 2014","","","IEEE","IEEE Journals"
"Identifying Renaming Opportunities by Expanding Conducted Rename Refactorings","H. Liu; Q. Liu; Y. Liu; Z. Wang","School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China; School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China; School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China; School of Computer Science and Technology, Beijing Institute of Technology, Beijing, China","IEEE Transactions on Software Engineering","15 Sep 2015","2015","41","9","887","900","To facilitate software refactoring, a number of approaches and tools have been proposed to suggest where refactorings should be conducted. However, identification of such refactoring opportunities is usually difficult because it often involves difficult semantic analysis and it is often influenced by many factors besides source code. For example, whether a software entity should be renamed depends on the meaning of its original name (natural language understanding), the semantics of the entity (source code semantics), experience and preference of developers, and culture of companies. As a result, it is difficult to identify renaming opportunities. To this end, in this paper we propose an approach to identify renaming opportunities by expanding conducted renamings. Once a rename refactoring is conducted manually or with tool support, the proposed approach recommends to rename closely related software entities whose names are similar to that of the renamed entity. The rationale is that if an engineer makes a mistake in naming a software entity it is likely for her to make the same mistake in naming similar and closely related software entities. The main advantage of the proposed approach is that it does not involve difficult semantic analysis of source code or complex natural language understanding. Another advantage of this approach is that it is less influenced by subjective factors, e.g., experience and preference of software engineers. The proposed approach has been evaluated on four open-source applications. Our evaluation results show that the proposed approach is accurate in recommending entities to be renamed (average precision 82 percent) and in recommending new names for such entities (average precision 93 percent). Evaluation results also suggest that a substantial percentage (varying from 20 to 23 percent) of rename refactorings are expansible.","1939-3520","","10.1109/TSE.2015.2427831","National Natural Science Foundation of China; Program for New Century Excellent Talents in University; Beijing Higher Education Young Elite Teacher Project; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7097720","Software Refactoring;Rename;Code Smells;Refactoring Opportunity;Identification;Software refactoring;rename;code smells;refactoring opportunity;identification","Semantics;Natural languages;Open source software;Engines;Context;IEEE Potentials","software maintenance","renaming opportunities identification;conducted rename refactorings;software refactoring;semantic analysis;software entity naming","","10","","36","","29 Apr 2015","","","IEEE","IEEE Journals"
"The Risks of Coverage-Directed Test Case Generation","G. Gay; M. Staats; M. Whalen; M. P. E. Heimdahl","Department of Computer Science & Engineering, University of South Carolina; Google, Inc; Department of Computer Science and Engineering, University of Minnesota; Department of Computer Science and Engineering, University of Minnesota","IEEE Transactions on Software Engineering","11 Aug 2015","2015","41","8","803","819","A number of structural coverage criteria have been proposed to measure the adequacy of testing efforts. In the avionics and other critical systems domains, test suites satisfying structural coverage criteria are mandated by standards. With the advent of powerful automated test generation tools, it is tempting to simply generate test inputs to satisfy these structural coverage criteria. However, while techniques to produce coverage-providing tests are well established, the effectiveness of such approaches in terms of fault detection ability has not been adequately studied. In this work, we evaluate the effectiveness of test suites generated to satisfy four coverage criteria through counterexample-based test generation and a random generation approach-where tests are randomly generated until coverage is achieved-contrasted against purely random test suites of equal size. Our results yield three key conclusions. First, coverage criteria satisfaction alone can be a poor indication of fault finding effectiveness, with inconsistent results between the seven case examples (and random test suites of equal size often providing similar-or even higher-levels of fault finding). Second, the use of structural coverage as a supplement-rather than a target-for test generation can have a positive impact, with random test suites reduced to a coverage-providing subset detecting up to 13.5 percent more faults than test suites generated specifically to achieve coverage. Finally, Observable MC/DC, a criterion designed to account for program structure and the selection of the test oracle, can-in part-address the failings of traditional structural coverage criteria, allowing for the generation of test suites achieving higher levels of fault detection than random test suites of equal size. These observations point to risks inherent in the increase in test automation in critical systems, and the need for more research in how coverage criteria, test generation approaches, the test oracle used, and system structure jointly influence test effectiveness.","1939-3520","","10.1109/TSE.2015.2421011","NASA; NSF; Fonds National de la Recherche, Luxembourg; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7081779","Software Testing;System Testing;Software testing;system testing","Testing;Aerospace electronics;NASA;Standards;Fault detection;Measurement;Software packages","program testing;risk management;software fault tolerance","risks;coverage-directed test case generation;structural coverage criteria;automated test generation tools;fault detection;counterexample-based test generation;random generation approach;random test suites;coverage criteria satisfaction;fault finding effectiveness;observable MC/DC;program structure;test oracle selection;test automation;critical systems;system structure;software testing","","50","","56","","8 Apr 2015","","","IEEE","IEEE Journals"
"Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback","X. Yuan; A. M. Memon","University of Maryland, College Park; University of Maryland, College Park","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","81","95","This paper presents a fully automatic model-driven technique to generate test cases for graphical user interfaces (GUIs)-based applications. The technique uses feedback from the execution of a ¿seed test suite,¿ which is generated automatically using an existing structural event interaction graph model of the GUI. During its execution, the runtime effect of each GUI event on all other events pinpoints event semantic interaction (ESI) relationships, which are used to automatically generate new test cases. Two studies on eight applications demonstrate that the feedback-based technique 1) is able to significantly improve existing techniques and helps identify serious problems in the software and 2) the ESI relationships captured via GUI state yield test suites that most often detect more faults than their code, event, and event-interaction-coverage equivalent counterparts.","1939-3520","","10.1109/TSE.2009.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306073","GUI testing;automated testing;model-based testing;GUITAR testing system.","Graphical user interfaces;Runtime;State feedback;Automatic testing;Software testing;System testing;Application software;Costs;Fault diagnosis;Event detection","graphical user interfaces;program testing;software quality","event sequence based test cases;graphical user interfaces;GUI runtime state feedback;automatic model driven technique;event interaction coverage equivalent counterparts;software quality;event semantic interaction relationships","","70","2","49","","30 Oct 2009","","","IEEE","IEEE Journals"
"Model Checking Timed and Stochastic Properties with CSL^{TA}","S. Donatelli; S. Haddad; J. Sproston","Università di Torino, Torino; LSV, CBRS and École Normale Supérieure de Cachan, Cachan; Università di Torino, Torino","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","224","240","Markov chains are a well-known stochastic process that provide a balance between being able to adequately model the system's behavior and being able to afford the cost of the model solution. The definition of stochastic temporal logics like continuous stochastic logic (CSL) and its variant asCSL, and of their model-checking algorithms, allows a unified approach to the verification of systems, allowing the mix of performance evaluation and probabilistic verification. In this paper we present the stochastic logic CSLTA, which is more expressive than CSL and asCSL, and in which properties can be specified using automata (more precisely, timed automata with a single clock). The extension with respect to expressiveness allows the specification of properties referring to the probability of a finite sequence of timed events. A typical example is the responsiveness property ""with probability at least 0.75, a message sent at time 0 by a system A will be received before time 5 by system B and the acknowledgment will be back at A before time 7"", a property that cannot be expressed in either CSL or asCSL. We also present a model-checking algorithm for CSLTA.","1939-3520","","10.1109/TSE.2008.108","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721440","Model checking;Markov processes;Temporal logic","Stochastic processes;Stochastic systems;Costs;Automata;Probabilistic logic;Quality of service;Unified modeling language;Telecommunication computing;Clocks;Delay","formal logic;formal verification;Markov processes;probability","timed properties;stochastic properties;Markov chains;stochastic process;stochastic temporal logics;continuous stochastic logic;model checking algorithm;systems verification;performance evaluation;probabilistic verification;finite sequence;timed events","","54","","30","","22 Dec 2008","","","IEEE","IEEE Journals"
"Common Trends in Software Fault and Failure Data","M. Hamill; K. Goseva-Popstojanova","West Virginia University, Morgantown; West Virginia University, Morgantown","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","484","496","The benefits of the analysis of software faults and failures have been widely recognized. However, detailed studies based on empirical data are rare. In this paper, we analyze the fault and failure data from two large, real-world case studies. Specifically, we explore: 1) the localization of faults that lead to individual software failures and 2) the distribution of different types of software faults. Our results show that individual failures are often caused by multiple faults spread throughout the system. This observation is important since it does not support several heuristics and assumptions used in the past. In addition, it clearly indicates that finding and fixing faults that lead to such software failures in large, complex systems are often difficult and challenging tasks despite the advances in software development. Our results also show that requirement faults, coding faults, and data problems are the three most common types of software faults. Furthermore, these results show that contrary to the popular belief, a significant percentage of failures are linked to late life cycle activities. Another important aspect of our work is that we conduct intra- and interproject comparisons, as well as comparisons with the findings from related studies. The consistency of several main trends across software systems in this paper and several related research efforts suggests that these trends are likely to be intrinsic characteristics of software faults and failures rather than project specific.","1939-3520","","10.1109/TSE.2009.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4760152","Software faults and failures;fault location;fault types;software fault distribution;software reliability;empirical studies.","Failure analysis;Software quality;Programming;Software systems;Fault location;Software reliability;Fault detection;Humans;Terminology;Computer bugs","software fault tolerance;system recovery;systems analysis","software fault analysis;software failure data;complex system;software development;requirement fault;coding fault;software life cycle activity;software system","","67","","26","","23 Jan 2009","","","IEEE","IEEE Journals"
"Software Reliability and Testing Time Allocation: An Architecture-Based Approach","R. Pietrantuono; S. Russo; K. S. Trivedi","Federico II University of Naples, Naples; Federico II University of Naples, Naples; Duke University, Durham","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","323","337","With software systems increasingly being employed in critical contexts, assuring high reliability levels for large, complex systems can incur huge verification costs. Existing standards usually assign predefined risk levels to components in the design phase, to provide some guidelines for the verification. It is a rough-grained assignment that does not consider the costs and does not provide sufficient modeling basis to let engineers quantitatively optimize resources usage. Software reliability allocation models partially address such issues, but they usually make so many assumptions on the input parameters that their application is difficult in practice. In this paper, we try to reduce this gap, proposing a reliability and testing resources allocation model that is able to provide solutions at various levels of detail, depending upon the information the engineer has about the system. The model aims to quantitatively identify the most critical components of software architecture in order to best assign the testing resources to them. A tool for the solution of the model is also developed. The model is applied to an empirical case study, a program developed for the European Space Agency, to verify model's prediction abilities and evaluate the impact of the parameter estimation errors on the prediction accuracy.","1939-3520","","10.1109/TSE.2010.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383374","Reliability;software architecture;software testing.","Software reliability;Software testing;Reliability engineering;Predictive models;Software systems;Guidelines;Cost function;Application software;System testing;Resource management","program testing;software architecture;software reliability","software reliability;testing time allocation;architecture-based approach;rough-grained assignment","","48","","40","","15 Jan 2010","","","IEEE","IEEE Journals"
"Dynamic Software Updating Using a Relaxed Consistency Model","H. Chen; J. Yu; C. Hang; B. Zang; P. Yew","Fudan University, Shanghai; University of Michigan, Ann Arbor; Microsoft (China) Ltd., Shanghai; Fudan University, Shanghai; University of Minnesota at Twin Cities, Minneapolis","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","679","694","Software is inevitably subject to changes. There are patches and upgrades that close vulnerabilities, fix bugs, and evolve software with new features. Unfortunately, most traditional dynamic software updating approaches suffer some level of limitations; few of them can update multithreaded applications when involving data structure changes, while some of them lose binary compatibility or incur nonnegligible performance overhead. This paper presents POLUS, a software maintenance tool capable of iteratively evolving running unmodified multithreaded software into newer versions, yet with very low performance overhead. The main idea in POLUS is a relaxed consistency model that permits the concurrent activity of the old and new code. POLUS borrows the idea of cache-coherence protocol in computer architecture and uses a ”bidirectional write-through” synchronization protocol to ensure system consistency. To demonstrate the applicability of POLUS, we report our experience in using POLUS to dynamically update three prevalent server applications: vsftpd, sshd, and Apache HTTP server. Performance measurements show that POLUS incurs negligible runtime overhead on the three applications-a less than 1 percent performance degradation (but 5 percent for one case). The time to apply an update is also minimal.","1939-3520","","10.1109/TSE.2010.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551162","Maintainability;reliability;runtime environments.","Software;Synchronization;Protocols;Bidirectional control;Registers;Runtime","computer architecture;hypermedia;multi-threading;program testing;software maintenance;software tools;transport protocols","dynamic software update;relaxed consistency model;data structure;binary compatibility;nonnegligible performance;POLUS;software maintenance tool;iteratively evolving running unmodified multithreaded software;concurrent activity;cache-coherence protocol;computer architecture;bidirectional write-through synchronization protocol;prevalent server application;HTTP server","","27","4","42","","19 Aug 2010","","","IEEE","IEEE Journals"
"Patterns of Knowledge in API Reference Documentation","W. Maalej; M. P. Robillard","University of Hamburg, Germany; McGill University, Montréal","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1264","1282","Reading reference documentation is an important part of programming with application programming interfaces (APIs). Reference documentation complements the API by providing information not obvious from the API syntax. To improve the quality of reference documentation and the efficiency with which the relevant information it contains can be accessed, we must first understand its content. We report on a study of the nature and organization of knowledge contained in the reference documentation of the hundreds of APIs provided as a part of two major technology platforms: Java SDK 6 and .NET 4.0. Our study involved the development of a taxonomy of knowledge types based on grounded methods and independent empirical validation. Seventeen trained coders used the taxonomy to rate a total of 5,574 randomly sampled documentation units to assess the knowledge they contain. Our results provide a comprehensive perspective on the patterns of knowledge in API documentation: observations about the types of knowledge it contains and how this knowledge is distributed throughout the documentation. The taxonomy and patterns of knowledge we present in this paper can be used to help practitioners evaluate the content of their API documentation, better organize their documentation, and limit the amount of low-value content. They also provide a vocabulary that can help structure and facilitate discussions about the content of APIs.","1939-3520","","10.1109/TSE.2013.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6473801","API documentation;software documentation;empirical study;content analysis;grounded method;data mining;pattern mining;Java;.NET","Documentation;Taxonomy;Encoding;Reliability;Java;Software;Sociology","application program interfaces;learning (artificial intelligence);pattern classification","knowledge taxonomy;.NET 4.0 API;Java SDK 6 API;knowledge organization;knowledge nature;reference documentation efficiency;reference documentation quality;application program interface;API reference documentation;knowledge pattern","","65","","35","","7 Mar 2013","","","IEEE","IEEE Journals"
"Reverse Engineering Input Syntactic Structure from Program Execution and Its Applications","Z. Lin; X. Zhang; D. Xu","Purdue University, West Lafayette; Purdue University, West Lafayette; Purdue University, West Lafayette","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","688","703","Program input syntactic structure is essential for a wide range of applications such as test case generation, software debugging, and network security. However, such important information is often not available (e.g., most malware programs make use of secret protocols to communicate) or not directly usable by machines (e.g., many programs specify their inputs in plain text or other random formats). Furthermore, many programs claim they accept inputs with a published format, but their implementations actually support a subset or a variant. Based on the observations that input structure is manifested by the way input symbols are used during execution and most programs take input with top-down or bottom-up grammars, we devise two dynamic analyses, one for each grammar category. Our evaluation on a set of real-world programs shows that our technique is able to precisely reverse engineer input syntactic structure from execution. We apply our technique to hierarchical delta debugging (HDD) and network protocol reverse engineering. Our technique enables the complete automation of HDD, in which programmers were originally required to provide input grammars, and improves the runtime performance of HDD. Our client study on network protocol reverse engineering also shows that our technique supersedes existing techniques.","1939-3520","","10.1109/TSE.2009.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5210120","Input syntactic structure;reverse engineering;control dependence;grammar inference;delta debugging;top-down grammar;bottom-up grammar.","Reverse engineering;Application software;Protocols;Computer science;Software debugging;Information security;Runtime;XML;Software testing;Automation","data structures;grammars;program debugging;protocols;reverse engineering","program input syntactic structure;test case generation;software debugging;network security;bottom-up grammars;top-down grammars;hierarchical delta debugging;network protocol reverse engineering;HDD automation","","12","1","36","","21 Aug 2009","","","IEEE","IEEE Journals"
"Replicating and Re-Evaluating the Theory of Relative Defect-Proneness","M. D. Syer; M. Nagappan; B. Adams; A. E. Hassan","School of Computing, Queen’s University, Kingston, ON, Canada; School of Computing, Queen’s University, Kingston, ON, Canada; Genie Informatique et Genie Logiciel, Ecole Polytechnique de Montreal, Campus de l’Universite de Montreal; School of Computing, Queen’s University, Kingston, ON, Canada","IEEE Transactions on Software Engineering","10 Feb 2015","2015","41","2","176","197","A good understanding of the factors impacting defects in software systems is essential for software practitioners, because it helps them prioritize quality improvement efforts (e.g., testing and code reviews). Defect prediction models are typically built using classification or regression analysis on product and/or process metrics collected at a single point in time (e.g., a release date). However, current defect prediction models only predict if a defect will occur, but not when, which makes the prioritization of software quality improvements efforts difficult. To address this problem, Koru et al. applied survival analysis techniques to a large number of software systems to study how size (i.e., lines of code) influences the probability that a source code module (e.g., class or file) will experience a defect at any given time. Given that 1) the work of Koru et al. has been instrumental to our understanding of the size-defect relationship, 2) the use of survival analysis in the context of defect modelling has not been well studied and 3) replication studies are an important component of balanced scholarly debate, we present a replication study of the work by Koru et al. In particular, we present the details necessary to use survival analysis in the context of defect modelling (such details were missing from the original paper by Koru et al.). We also explore how differences between the traditional domains of survival analysis (i.e., medicine and epidemiology) and defect modelling impact our understanding of the size-defect relationship. Practitioners and researchers considering the use of survival analysis should be aware of the implications of our findings.","1939-3520","","10.1109/TSE.2014.2361131","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6914599","Survival Analysis;Cox Models;Defect Modelling;Survival analysis;Cox models;defect modelling","Analytical models;Hazards;Software;Measurement;Data models;Mathematical model;Predictive models","program diagnostics;software quality;software reliability","relative defect-proneness theory;survival analysis techniques;source code module;size-defect relationship;defect modelling;software system defects","","7","","47","","1 Oct 2014","","","IEEE","IEEE Journals"
"Evaluation and Measurement of Software Process Improvement—A Systematic Literature Review","M. Unterkalmsteiner; T. Gorschek; A. K. M. M. Islam; C. K. Cheng; R. B. Permadi; R. Feldt","Blekinge Institute of Technology, Karlskrona; Blekinge Institute of Technology, Karlskrona; University of Kaiserslautern, Kaiserslautern; General Electrics Healthcare, Freiburg; Amadeus S.A.S, Sophia Antipolis; Blekinge Institute of Technology, Karlskrona","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","398","424","BACKGROUND-Software Process Improvement (SPI) is a systematic approach to increase the efficiency and effectiveness of a software development organization and to enhance software products. OBJECTIVE-This paper aims to identify and characterize evaluation strategies and measurements used to assess the impact of different SPI initiatives. METHOD-The systematic literature review includes 148 papers published between 1991 and 2008. The selected papers were classified according to SPI initiative, applied evaluation strategies, and measurement perspectives. Potential confounding factors interfering with the evaluation of the improvement effort were assessed. RESULTS-Seven distinct evaluation strategies were identified, wherein the most common one, “Pre-Post Comparison,” was applied in 49 percent of the inspected papers. Quality was the most measured attribute (62 percent), followed by Cost (41 percent), and Schedule (18 percent). Looking at measurement perspectives, “Project” represents the majority with 66 percent. CONCLUSION-The evaluation validity of SPI initiatives is challenged by the scarce consideration of potential confounding factors, particularly given that “Pre-Post Comparison” was identified as the most common evaluation strategy, and the inaccurate descriptions of the evaluation context. Measurements to assess the short and mid-term impact of SPI initiatives prevail, whereas long-term measurements in terms of customer satisfaction and return on investment tend to be less used.","1939-3520","","10.1109/TSE.2011.26","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5728832","Process implementation and change;process measurement;metrics/measurement;systematic literature review.","Software;Software measurement;Systematics;Current measurement;Data mining;Organizations","software process improvement","software process improvement;SPI;software development organization;customer satisfaction;return on investment","","117","","266","","10 Mar 2011","","","IEEE","IEEE Journals"
"Where Do Configuration Constraints Stem From? An Extraction Approach and an Empirical Study","S. Nadi; T. Berger; C. Kästner; K. Czarnecki","Department of Computer Science, Technische Universität Darmstadt, Darmstadt, Hessen, Germany; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ON; School of Computer Science, Carnegie Mellon University, Pittsburgh, PA; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ON","IEEE Transactions on Software Engineering","11 Aug 2015","2015","41","8","820","841","Highly configurable systems allow users to tailor software to specific needs. Valid combinations of configuration options are often restricted by intricate constraints. Describing options and constraints in a variability model allows reasoning about the supported configurations. To automate creating and verifying such models, we need to identify the origin of such constraints. We propose a static analysis approach, based on two rules, to extract configuration constraints from code. We apply it on four highly configurable systems to evaluate the accuracy of our approach and to determine which constraints are recoverable from the code. We find that our approach is highly accurate (93% and 77% respectively) and that we can recover 28% of existing constraints. We complement our approach with a qualitative study to identify constraint sources, triangulating results from our automatic extraction, manual inspections, and interviews with 27 developers. We find that, apart from low-level implementation dependencies, configuration constraints enforce correct runtime behavior, improve users' configuration experience, and prevent corner cases. While the majority of constraints is extractable from code, our results indicate that creating a complete model requires further substantial domain knowledge and testing. Our results aim at supporting researchers and practitioners working on variability model engineering, evolution, and verification techniques.","1939-3520","","10.1109/TSE.2015.2415793","NSERC; ARTEMIS JU; NSF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7065312","Variability models;Reverse-engineering;qualitative studies;Variability models;reverse-engineering;qualitative studies;static analyses;configuration constraints","Feature extraction;Kernel;Accuracy;Linux;Manuals;Interviews","configuration management;program diagnostics","configuration constraints;extraction approach;configuration combination;variability model;static analysis approach;configuration constraints extraction;constraint sources identification;variability model engineering;variability model evolution;variability model verification techniques","","31","","80","","23 Mar 2015","","","IEEE","IEEE Journals"
"HYDRA: Massively Compositional Model for Cross-Project Defect Prediction","X. Xia; D. Lo; S. J. Pan; N. Nagappan; X. Wang","College of Computer Science and Technology, Zhejiang University Hangzhou, Zhejiang, China; School of Information Systems, Singapore Management University, Singapore; School of Computer Engineering, Nanyang Technological University, Singapore; Testing, Verification and Measurement Research, Microsoft Research, Redmond, WA; College of Computer Science and Technology, Zhejiang University Hangzhou, Zhejiang, China","IEEE Transactions on Software Engineering","13 Oct 2016","2016","42","10","977","998","Most software defect prediction approaches are trained and applied on data from the same project. However, often a new project does not have enough training data. Cross-project defect prediction, which uses data from other projects to predict defects in a particular project, provides a new perspective to defect prediction. In this work, we propose a HYbrid moDel Reconstruction Approach (HYDRA) for cross-project defect prediction, which includes two phases: genetic algorithm (GA) phase and ensemble learning (EL) phase. These two phases create a massive composition of classifiers. To examine the benefits of HYDRA, we perform experiments on 29 datasets from the PROMISE repository which contains a total of 11,196 instances (i.e., Java classes) labeled as defective or clean. We experiment with logistic regression as the underlying classification algorithm of HYDRA. We compare our approach with the most recently proposed cross-project defect prediction approaches: TCA+ by Nam et al., Peters filter by Peters et al., GP by Liu et al., MO by Canfora et al., and CODEP by Panichella et al. Our results show that HYDRA achieves an average F1-score of 0.544. On average, across the 29 datasets, these results correspond to an improvement in the F1-scores of 26.22 , 34.99, 47.43, 28.61, and 30.14 percent over TCA+, Peters filter, GP, MO, and CODEP, respectively. In addition, HYDRA on average can discover 33 percent of all bugs if developers inspect the top 20 percent lines of code, which improves the best baseline approach (TCA+) by 44.41 percent. We also find that HYDRA improves the F1-score of Zero-R which predict all the instances to be defective by 5.42 percent, but improves Zero-R by 58.65 percent when inspecting the top 20 percent lines of code. In practice, Zero-R can be hard to use since it simply predicts all of the instances to be defective, and thus developers have to inspect all of the instances to find the defective ones. Moreover, we notice the improvement of HYDRA over other baseline approaches in terms of F1-score and when inspecting the top 20 percent lines of code are substantial, and in most cases the improvements are significant and have large effect sizes across the 29 datasets.","1939-3520","","10.1109/TSE.2016.2543218","National Basic Research Program of China; NSFC; National Key Technology R&D Program; Ministry of Science and Technology of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7435328","Cross-project defect prediction;transfer learning;genetic algorithm;ensemble learning","Genetic algorithms;Predictive models;Training;Buildings;Architecture;Data models;Measurement","genetic algorithms;learning (artificial intelligence);pattern classification;regression analysis;software fault tolerance","HYDRA model;massively compositional model;cross-project defect prediction;software defect prediction approach;hybrid model reconstruction approach;genetic algorithm phase;GA phase;phase and ensemble learning phase;EL phase;PROMISE repository;logistic regression;classification algorithm","","117","","58","","17 Mar 2016","","","IEEE","IEEE Journals"
"Data Mining Techniques for Software Effort Estimation: A Comparative Study","K. Dejaeger; W. Verbeke; D. Martens; B. Baesens","Katholieke Universiteit Leuven, Leuven; Katholieke Universiteit Leuven, Leuven; University of Antwerp, Antwerp; Katholieke Universiteit Leuven, Leuven and University of Southampton, Highfield Southampton","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","375","397","A predictive model is required to be accurate and comprehensible in order to inspire confidence in a business setting. Both aspects have been assessed in a software effort estimation setting by previous studies. However, no univocal conclusion as to which technique is the most suited has been reached. This study addresses this issue by reporting on the results of a large scale benchmarking study. Different types of techniques are under consideration, including techniques inducing tree/rule-based models like M5 and CART, linear models such as various types of linear regression, nonlinear models (MARS, multilayered perceptron neural networks, radial basis function networks, and least squares support vector machines), and estimation techniques that do not explicitly induce a model (e.g., a case-based reasoning approach). Furthermore, the aspect of feature subset selection by using a generic backward input selection wrapper is investigated. The results are subjected to rigorous statistical testing and indicate that ordinary least squares regression in combination with a logarithmic transformation performs best. Another key finding is that by selecting a subset of highly predictive attributes such as project size, development, and environment related attributes, typically a significant increase in estimation accuracy can be obtained.","1939-3520","","10.1109/TSE.2011.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928350","Data mining;software effort estimation;regression.","Software;Estimation;Data models;Data mining;Cognition;Artificial neural networks;Regression tree analysis","data mining;program testing;regression analysis;software cost estimation","data mining techniques;software effort estimation;predictive model;rule-based models;CART;M5;linear regression;nonlinear models;estimation techniques;feature subset selection;generic backward input selection wrapper;rigorous statistical testing;ordinary least squares regression;logarithmic transformation","","110","1","108","","23 Jun 2011","","","IEEE","IEEE Journals"
"Aspect-Oriented Race Detection in Java","E. Bodden; K. Havelund","Technical University Darmstadt, Darmstadt; California Institute of Technology, Pasadena","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","509","527","In the past, researchers have developed specialized programs to aid programmers in detecting concurrent programming errors such as deadlocks, livelocks, starvation, and data races. In this work, we propose a language extension to the aspect-oriented programming language AspectJ, in the form of three new pointcuts, lock(), unlock(), and maybeShared(). These pointcuts allow programmers to monitor program events where locks are granted or handed back, and where values are accessed that may be shared among multiple Java threads. We decide thread locality using a static thread-local-objects analysis developed by others. Using the three new primitive pointcuts, researchers can directly implement efficient monitoring algorithms to detect concurrent-programming errors online. As an example, we describe a new algorithm which we call RACER, an adaption of the well-known ERASER algorithm to the memory model of Java. We implemented the new pointcuts as an extension to the AspectBench Compiler, implemented the RACER algorithm using this language extension, and then applied the algorithm to the NASA K9 Rover Executive and two smaller programs. Our experiments demonstrate that our implementation is effective in finding subtle data races. In the Rover Executive, RACER finds 12 data races, with no false warnings. Only one of these races was previously known.","1939-3520","","10.1109/TSE.2010.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406531","Race detection;runtime verification;aspect-oriented programming;semantic pointcuts;static analysis.","Java;Programming profession;Computer languages;System recovery;Monitoring;Runtime;Protection;Instruments;Libraries","aspect-oriented programming;concurrency control;Java;multi-threading;program compilers;program debugging","aspect-oriented race detection;concurrent programming error detection;aspect-oriented programming language;AspectJ;multiple Java threads;static thread-local-objects analysis;ERASER algorithm;primitive pointcuts;AspectBench compiler;RACER algorithm;NASA K9 Rover Executive","","18","","52","","5 Feb 2010","","","IEEE","IEEE Journals"
"To Be Optimal or Not in Test-Case Prioritization","D. Hao; L. Zhang; L. Zang; Y. Wang; X. Wu; T. Xie","Key Laboratory of High Confidence Software Technologies, Ministry of Education, Peking University, Beijing, P. R. China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Peking University, Beijing, P. R. China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Peking University, Beijing, P. R. China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Peking University, Beijing, P. R. China; Key Laboratory of High Confidence Software Technologies, Ministry of Education, Peking University, Beijing, P. R. China; Department of Computer Science, University of Illinois at Urbana-Champaign","IEEE Transactions on Software Engineering","12 May 2016","2016","42","5","490","505","Software testing aims to assure the quality of software under test. To improve the efficiency of software testing, especially regression testing, test-case prioritization is proposed to schedule the execution order of test cases in software testing. Among various test-case prioritization techniques, the simple additional coverage-based technique, which is a greedy strategy, achieves surprisingly competitive empirical results. To investigate how much difference there is between the order produced by the additional technique and the optimal order in terms of coverage, we conduct a study on various empirical properties of optimal coverage-based test-case prioritization. To enable us to achieve the optimal order in acceptable time for our object programs, we formulate optimal coverage-based test-case prioritization as an integer linear programming (ILP) problem. Then we conduct an empirical study for comparing the optimal technique with the simple additional coverage-based technique. From this empirical study, the optimal technique can only slightly outperform the additional coverage-based technique with no statistically significant difference in terms of coverage, and the latter significantly outperforms the former in terms of either fault detection or execution time. As the optimal technique schedules the execution order of test cases based on their structural coverage rather than detected faults, we further implement the ideal optimal test-case prioritization technique, which schedules the execution order of test cases based on their detected faults. Taking this ideal technique as the upper bound of test-case prioritization, we conduct another empirical study for comparing the optimal technique and the simple additional technique with this ideal technique. From this empirical study, both the optimal technique and the additional technique significantly outperform the ideal technique in terms of coverage, but the latter significantly outperforms the former two techniques in terms of fault detection. Our findings indicate that researchers may need take cautions in pursuing the optimal techniques in test-case prioritization with intermediate goals.","1939-3520","","10.1109/TSE.2015.2496939","National 973 Program of China; National Natural Science Foundation of China; National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7314957","Test-Case Prioritization;Integer Linear Programming;Greedy Algorithm;Empirical Study;Test-case prioritization;integer linear programming;greedy algorithm;empirical study","Software;Measurement;Schedules;Fault detection;Integer linear programming;Software testing","integer programming;linear programming;program testing","test-case prioritization techniques;software testing;software quality;regression testing;simple additional coverage-based technique;optimal coverage-based test-case prioritization;integer linear programming;ILP problem","","34","","47","","2 Nov 2015","","","IEEE","IEEE Journals"
"Domain-Specific Service Selection for Composite Services","O. Moser; F. Rosenberg; S. Dustdar","Vienna University of Technology, Vienna; IBM T.J. Watson Research Center, Hawthorne; Vienna University of Technology, Vienna","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","828","843","We propose a domain-specific service selection mechanism and system implementation to address the issue of runtime adaptation of composite services that implement mission-critical business processes. To this end, we leverage quality of service (QoS) as a means to specify rigid dependability requirements. QoS does not include only common attributes such as availability or response time but also attributes specific to certain business domains and processes. Therefore, we combine both domain-agnostic and domain-specific QoS attributes in an adaptive QoS model. For specifying the service selection strategy, we propose a domain-specific language called VieDASSL to specify so-called selectors. This language can be used to specify selector implementations based on the available QoS attributes. Both the QoS model implementation and the selectors can be adapted at runtime to deal with changing business and QoS requirements. Our approach is implemented on top of an existing WS-BPEL engine. We demonstrate its feasibility by implementing a case study from the telecommunication domain.","1939-3520","","10.1109/TSE.2011.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6231591","Service composition;quality of service;monitoring;service selection;domain specific languages","Quality of service;Runtime;Business;Adaptation models;Time factors;Availability;Engines","business data processing;quality of service;reliability;specification languages;Web services","domain-specific service selection mechanism;composite services;runtime adaptation;mission-critical business processes;quality of service;domain-agnostic QoS attributes;domain-specific QoS attributes;adaptive QoS model;domain-specific language;VieDASSL;selectors;business requirements;QoS requirements;WS-BPEL engine;telecommunication;Web services","","24","","56","","3 Jul 2012","","","IEEE","IEEE Journals"
"Bayesian Approaches to Matching Architectural Diagrams","D. Kimelman; M. Kimelman; D. Mandelin; D. Yellin","IBM Thomas J. Watson Research Center, Yorktown Heights; Independent Consultant; Mozilla Corporation, Mountain View; IBM Israel Software Lab, Jerusalem","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","248","274","IT system architectures and many other kinds of structured artifacts are often described by formal models or informal diagrams. In practice, there are often a number of versions of a model or diagram, such as a series of revisions, divergent variants, or multiple views of a system. Understanding how versions correspond or differ is crucial, and thus, automated assistance for matching models and diagrams is essential. We have designed a framework for finding these correspondences automatically based on Bayesian methods. We represent models and diagrams as graphs whose nodes have attributes such as name, type, connections to other nodes, and containment relations, and we have developed probabilistic models for rating the quality of candidate correspondences based on various features of the nodes in the graphs. Given the probabilistic models, we can find high-quality correspondences using search algorithms. Preliminary experiments focusing on architectural models suggest that the technique is promising.","1939-3520","","10.1109/TSE.2009.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5232811","Bayesian techniques;IT system architecture;modeling tools;change control.","Bayesian methods;Context modeling;Large-scale systems;Network topology;Centralized control;Merging;Collaboration;Adaptation model;Application software;Security","Bayes methods;configuration management;graphs;probability;software architecture","Bayesian methods;formal models;informal diagrams;IT system architectures;divergent variants;graphs;probabilistic models;architectural diagram matching;search algorithms","","4","","37","","4 Sep 2009","","","IEEE","IEEE Journals"
"Rate-Based Queueing Simulation Model of Open Source Software Debugging Activities","C. Lin; Y. Li","Department of Computer Science and Information Engineering, National Chiayi University, Chiayi, Taiwan; Laboratory of Industrial Engineering, Ecole Centrale Paris, Paris, France","IEEE Transactions on Software Engineering","10 Nov 2014","2014","40","11","1075","1099","Open source software (OSS) approach has become increasingly prevalent for software development. As the widespread utilization of OSS, the reliability of OSS products becomes an important issue. By simulating the testing and debugging processes of software life cycle, the rate-based queueing simulation model has shown its feasibility for closed source software (CSS) reliability assessment. However, the debugging activities of OSS projects are different in many ways from those of CSS projects and thus the simulation approach needs to be calibrated for OSS projects. In this paper, we first characterize the debugging activities of OSS projects. Based on this, we propose a new rate-based queueing simulation framework for OSS reliability assessment including the model and the procedures. Then a decision model is developed to determine the optimal version-updating time with respect to two objectives: minimizing the time for version update, and maximizing OSS reliability. To illustrate the proposed framework, three real datasets from Apache and GNOME projects are used. The empirical results indicate that our framework is able to effectively approximate the real scenarios. Moreover, the influences of the core contributor staffing levels are analyzed and the optimal version-updating times are obtained.","1939-3520","","10.1109/TSE.2014.2354032","National Science Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6891380","Queueing theory;rate-based simulation;open source software (OSS);bug reporting;report judgment;bug fixing;optimal version-updating time;non-homogeneous continuous time Markov chain (NHCTMC);multi-attribute utility theory (MAUT)","Software reliability;Debugging;Software;Stochastic processes;Analytical models;Cascading style sheets","configuration management;program debugging;program testing;project management;public domain software;queueing theory;software reliability","open source software;OSS approach;software development;OSS products reliability;testing processes;debugging processes;software life cycle;rate-based queueing simulation model;closed source software;CSS reliability assessment;debugging activities;OSS projects;decision model;optimal version-updating time","","14","","50","","4 Sep 2014","","","IEEE","IEEE Journals"
"Random Testing: Theoretical Results and Practical Implications","A. Arcuri; M. Z. Iqbal; L. Briand","Simula, Oslo; Simula Research Laboratory, Lysaker; Simula Research Laboratory, Lysaker","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","258","277","A substantial amount of work has shed light on whether random testing is actually a useful testing technique. Despite its simplicity, several successful real-world applications have been reported in the literature. Although it is not going to solve all possible testing problems, random testing appears to be an essential tool in the hands of software testers. In this paper, we review and analyze the debate about random testing. Its benefits and drawbacks are discussed. Novel results addressing general questions about random testing are also presented, such as how long does random testing need, on average, to achieve testing targets (e.g., coverage), how does it scale, and how likely is it to yield similar results if we rerun it on the same testing problem (predictability). Due to its simplicity that makes the mathematical analysis of random testing tractable, we provide precise and rigorous answers to these questions. Results show that there are practical situations in which random testing is a viable option. Our theorems are backed up by simulations and we show how they can be applied to most types of software and testing criteria. In light of these results, we then assess the validity of empirical analyzes reported in the literature and derive guidelines for both practitioners and scientists.","1939-3520","","10.1109/TSE.2011.121","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6104067","Coupon collector;random testing;theory;Schur function;predictability;partition testing;adaptive random testing.","Testing;Software;Upper bound;Color;Random variables;Algorithm design and analysis;Generators","program testing;software tools","random testing;software testing;software tool;mathematical analysis;partition testing","","76","","52","","13 Dec 2011","","","IEEE","IEEE Journals"
"Linear and Branching System Metrics","L. de Alfaro; M. Faella; M. Stoelinga","University of California, Santa Cruz, Santa Cruz; Università di Napoli, Napoli; University of Twente, Enschede","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","258","273","We extend the classical system relations of trace inclusion, trace equivalence, simulation, and bisimulation to a quantitative setting in which propositions are interpreted not as boolean values, but as elements of arbitrary metric spaces. Trace inclusion and equivalence give rise to asymmetrical and symmetrical linear distances, while simulation and bisimulation give rise to asymmetrical and symmetrical branching distances. We study the relationships among these distances and we provide a full logical characterization of the distances in terms of quantitative versions of LTL and mu-calculus. We show that, while trace inclusion (respectively, equivalence) coincides with simulation (respectively, bisimulation) for deterministic boolean transition systems, linear and branching distances do not coincide for deterministic metric transition systems. Finally, we provide algorithms for computing the distances over finite systems, together with a matching lower complexity bound.","1939-3520","","10.1109/TSE.2008.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721438","Logics of programs;Specification techniques;Modal logic","Logic;Extraterrestrial measurements;Cost accounting;Computational modeling;Reasoning about programs;Formal languages;Software tools;Digital audio players;Clocks;Automata","Boolean functions;formal specification;process algebra;program diagnostics;program verification;software metrics;temporal logic","linear system metrics;branching system metric;software trace inclusion;software trace equivalence;software bisimulation;LTL;mu-calculus;deterministic Boolean transition system;software verification;linear temporal logic property;system specification","","59","","18","","22 Dec 2008","","","IEEE","IEEE Journals"
"Reducing Masking Effects in CombinatorialInteraction Testing: A Feedback DrivenAdaptive Approach","C. Yilmaz; E. Dumlu; M. B. Cohen; A. Porter","Faculty of Engineering and Natural Sciences, Sabanci University, Istanbul, Turkey; Borsa Istanbul, Istanbul, Turkey; Department of Computer Science and Engineering, University of Nebraska-Lincoln, NE; Department of Computer Science , University of Maryland, College Park, MD","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","1","43","66","The configuration spaces of modern software systems are too large to test exhaustively. Combinatorial interaction testing (CIT) approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations. The basic justification for CIT approaches is that they can cost-effectively exercise all system behaviors caused by the settings of t or fewer options. We conjecture, however, that in practice some of these behaviors are not actually tested because of unanticipated masking effects - test case failures that perturb system execution so as to prevent some behaviors from being exercised. While prior research has identified this problem, most solutions require knowing the masking effects a priori. In practice this is impractical, if not impossible. In this work, we reduce the harmful consequences of masking effects. First we define a novel interaction testing criterion, which aims to ensure that each test case has a fair chance to test all valid t-way combinations of option settings. We then introduce a feedback driven adaptive combinatorial testing process (FDA-CIT) to materialize this criterion in practice. At each iteration of FDA-CIT, we detect potential masking effects, heuristically isolate their likely causes (i.e., fault characterization), and then generate new samples that allow previously masked combinations to be tested in configurations that avoid the likely failure causes. The iterations end when the new interaction testing criterion has been satisfied. This paper compares two different fault characterization approaches - an integral part of the proposed approach, and empirically assesses their effectiveness and efficiency in removing masking effects on two widely used open source software systems. It also compares FDA-CIT against error locating arrays, a state of the art approach for detecting and locating failures. Furthermore, the scalability of the proposed approach is evaluated by comparing it with perfect test scenarios, in which all masking effects are known a priori. Our results suggest that masking effects do exist in practice, and that our approach provides a promising and efficient way to work around them, without requiring that masking effects be known a priori.","1939-3520","","10.1109/TSE.2013.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6654147","Combinatorial testing;adaptive testing;covering arrays;software quality assurance","Testing;Adaptive arrays;Educational institutions;Scalability;Servers;Electronic mail;Software systems","program testing;public domain software;software fault tolerance","perfect test scenarios;fault location;fault detection;error locating arrays;open source software systems;fault characterization approaches;potential masking effects detection;t-way combinations;FDA-CIT process;interaction testing criterion;system execution;test case failures;covering arrays;software systems;configuration spaces;feedback driven adaptive approach;CIT approach;combinatorial interaction testing;masking effects reduction","","26","","44","","4 Nov 2013","","","IEEE","IEEE Journals"
"Automatic Contract Insertion with CCBot","S. A. Carr; F. Logozzo; M. Payer","Purdue University, West Lafayette, IN; FaceBook, Seattle, WA; Purdue University, West Lafayette, IN","IEEE Transactions on Software Engineering","11 Aug 2017","2017","43","8","701","714","Existing static analysis tools require significant programmer effort. On large code bases, static analysis tools produce thousands of warnings. It is unrealistic to expect users to review such a massive list and to manually make changes for each warning. To address this issue we propose CCBot (short for CodeContracts Bot), a new tool that applies the results of static analysis to existing code through automatic code transformation. Specifically, CCBot instruments the code with method preconditions, postconditions, and object invariants which detect faults at runtime or statically using a static contract checker. The only configuration the programmer needs to perform is to give CCBot the file paths to code she wants instrumented. This allows the programmer to adopt contract-based static analysis with little effort. CCBot's instrumented version of the code is guaranteed to compile if the original code did. This guarantee means the programmer can deploy or test the instrumented code immediately without additional manual effort. The inserted contracts can detect common errors such as null pointer dereferences and out-of-bounds array accesses. CCBot is a robust large-scale tool with an open-source C# implementation. We have tested it on real world projects with tens of thousands of lines of code. We discuss several projects as case studies, highlighting undiscovered bugs found by CCBot, including 22 new contracts that were accepted by the project authors.","1939-3520","","10.1109/TSE.2016.2625248","NSF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7736073","Contract-based verification;automated patching;assertions;class invariants","Contracts;C# languages;Instruments;Computer bugs;Reactive power;Semantics;Runtime","C# language;program compilers;program diagnostics;program verification;software fault tolerance","automatic contract insertion;CCBot;static analysis tools;CodeContracts Bot;automatic code transformation;object invariants;fault detection;static contract checker;file paths;contract-based static analysis;null pointer dereferences;out-of-bounds array accesses;open-source C# implementation;contract-based verification","","2","","43","","4 Nov 2016","","","IEEE","IEEE Journals"
"Exception Handling for Repair in Service-Based Processes","G. Friedrich; M. G. Fugini; E. Mussi; B. Pernici; G. Tagni","Alpen-Adria Universität Klagenfurt, Kalgenfurt; Politecnico di Milano, Milano; Politecnico di Milano, Milano; Politecnico di Milano, Milano; Vrije Universiteit Amsterdam, Amsterdam","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","198","215","This paper proposes a self-healing approach to handle exceptions in service-based processes and to repair the faulty activities with a model-based approach. In particular, a set of repair actions is defined in the process model, and repairability of the process is assessed by analyzing the process structure and the available repair actions. During execution, when an exception arises, repair plans are generated by taking into account constraints posed by the process structure, dependencies among data, and available repair actions. The paper also describes the main features of the prototype developed to validate the proposed repair approach for composed Web services; the self-healing architecture for repair handling and the experimental results are illustrated.","1939-3520","","10.1109/TSE.2010.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383376","Exception handling;failures;faults;repair;self-healing processes;Web services;process management.","Web services;Prototypes;Service oriented architecture;Logic design;Proposals","exception handling;program verification;software fault tolerance;software maintenance;software prototyping;Web services","exception handling;service based process repairing;Web services;self-healing architecture;process structure analysis;prototype development","","73","","60","","15 Jan 2010","","","IEEE","IEEE Journals"
"Enforcing Exception Handling Policies with a Domain-Specific Language","E. A. Barbosa; A. Garcia; M. P. Robillard; B. Jakobus","OPUS Research Group, Informatics Department, Pontifical Catholic University of Rio de Janeiro, Rua Marquês de São Vicente, 255-Gávea, Rio de Janeiro, Brazil; OPUS Research Group, Informatics Department, Pontifical Catholic University of Rio de Janeiro, Rua Marquês de São Vicente, 255-Gávea, Rio de Janeiro, Brazil; School of Computer Science, McGill University, Montreal, Canada; OPUS Research Group, Informatics Department, Pontifical Catholic University of Rio de Janeiro, Rua Marquês de São Vicente, 255-Gávea, Rio de Janeiro, Brazil","IEEE Transactions on Software Engineering","10 Jun 2016","2016","42","6","559","584","Current software projects deal with exceptions in implementation and maintenance phases without a clear definition of exception handling policies. We call an exception handling policy the set of design decisions that govern the use of exceptions in a software project. Without an explicit exception handling policy, developers can remain unaware of the originally intended use of exceptions. In this paper, we present Exception Handling Policies Language (EPL), a domain-specific language to specify and verify exception handling policies. The evaluation of EPL was based on a user-centric observational study and case studies. The user-centric study was performed to observe how potential users of the language actually use it. With this study, we could better understand the trade-offs related to different language design decisions based on concrete and well-documented observations and experiences reported by participants. We identified some language characteristics that hindered its use and that motivated new language constructs. In addition, we performed case studies with one open-source project and two industry-strength systems to investigate how specifying and verifying exception handling policies may assist in detecting exception handling problems. The results show that violations of exception handling policies help to indicate potential faults in the exception handling code.","1939-3520","","10.1109/TSE.2015.2506164","Fundação Carlos Chagas Filho de Amparo à Pesquisa do Estado do Rio de Janeiro (FAPERJ); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7348692","Exception handling;Exception handling policy;Policy specification;Domain-specific language;Exception handling;exception handling policy;policy specification;domain-specific language","Java;Software reliability;Robustness;Software systems","exception handling;formal specification;formal verification;programming languages;project management;public domain software;software maintenance","industry-strength systems;open-source project;user-centric study;exception handling policy verification;exception handling policy specification;EPL evaluation;language design decisions;maintenance phase;implementation phase;software projects;domain-specific language;exception handling policies language","","8","","46","","7 Dec 2015","","","IEEE","IEEE Journals"
"Automatic Source Code Summarization of Context for Java Methods","P. W. McBurney; C. McMillan","College of Computer Science and Engineering, University Notre Dame, Notre Dame, IN; Computer Science, University of Notre Dame, South Bend, VA","IEEE Transactions on Software Engineering","11 Feb 2016","2016","42","2","103","119","Source code summarization is the task of creating readable summaries that describe the functionality of software. Source code summarization is a critical component of documentation generation, for example as Javadocs formed from short paragraphs attached to each method in a Java program. At present, a majority of source code summarization is manual, in that the paragraphs are written by human experts. However, new automated technologies are becoming feasible. These automated techniques have been shown to be effective in select situations, though a key weakness is that they do not explain the source code's context. That is, they can describe the behavior of a Java method, but not why the method exists or what role it plays in the software. In this paper, we propose a source code summarization technique that writes English descriptions of Java methods by analyzing how those methods are invoked. We then performed two user studies to evaluate our approach. First, we compared our generated summaries to summaries written manually by experts. Then, we compared our summaries to summaries written by a state-of-the-art automatic summarization tool. We found that while our approach does not reach the quality of human-written summaries, we do improve over the state-of-the-art summarization tool in several dimensions by a statistically-significant margin.","1939-3520","","10.1109/TSE.2015.2465386","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181703","Source code summarization;automatic documentation;program comprehension;Source code summarization;automatic documentation;program comprehension","Context;Documentation;Java;Natural languages;Software;Generators;XML","Java;object-oriented methods","source code summarization technique;Java methods;software functionality;documentation generation;Javadocs;Java program;user studies;automatic summarization tool;human-written summaries","","46","","51","","6 Aug 2015","","","IEEE","IEEE Journals"
"Fault Localization for Dynamic Web Applications","S. Artzi; J. Dolby; F. Tip; M. Pistoia","IBM Software Group, Littleton; IBM Thomas J. Watson Research Center, Yorktown Heights; IBM Thomas J. Watson Research Center, Yorktown Heights; IBM Thomas J. Watson Research Center, Yorktown Heights","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","314","335","In recent years, there has been significant interest in fault-localization techniques that are based on statistical analysis of program constructs executed by passing and failing executions. This paper shows how the Tarantula, Ochiai, and Jaccard fault-localization algorithms can be enhanced to localize faults effectively in web applications written in PHP by using an extended domain for conditional and function-call statements and by using a source mapping. We also propose several novel test-generation strategies that are geared toward producing test suites that have maximal fault-localization effectiveness. We implemented various fault-localization techniques and test-generation strategies in Apollo, and evaluated them on several open-source PHP applications. Our results indicate that a variant of the Ochiai algorithm that includes all our enhancements localizes 87.8 percent of all faults to within 1 percent of all executed statements, compared to only 37.4 percent for the unenhanced Ochiai algorithm. We also found that all the test-generation strategies that we considered are capable of generating test suites with maximal fault-localization effectiveness when given an infinite time budget for test generation. However, on average, a directed strategy based on path-constraint similarity achieves this maximal effectiveness after generating only 6.5 tests, compared to 46.8 tests for an undirected test-generation strategy.","1939-3520","","10.1109/TSE.2011.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5975173","Fault localization;statistical debugging;program analysis;web applications;PHP.","HTML;Databases;Servers;Open source software;Browsers;Algorithm design and analysis;Concrete","program testing;software fault tolerance;statistical analysis","fault localization;dynamic Web applications;statistical analysis;source mapping;fault localization effectiveness;test generation strategies;path constraint;Tarantula;Ochiai;Jaccard;Apollo;open-source PHP applications","","15","","50","","4 Aug 2011","","","IEEE","IEEE Journals"
"An Empirical Comparison of Model Validation Techniques for Defect Prediction Models","C. Tantithamthavorn; S. McIntosh; A. E. Hassan; K. Matsumoto","Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Japan; Department of Electrical and Computer Engineering, Montreal, QC, McGill UniversityCanada; School of Computing, Queen’s University, Kingston, ON, Canada; Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Japan","IEEE Transactions on Software Engineering","9 Jan 2017","2017","43","1","1","18","Defect prediction models help software quality assurance teams to allocate their limited resources to the most defect-prone modules. Model validation techniques, such as $k$ -fold cross-validation, use historical data to estimate how well a model will perform in the future. However, little is known about how accurate the estimates of model validation techniques tend to be. In this paper, we investigate the bias and variance of model validation techniques in the domain of defect prediction. Analysis of 101 public defect datasets suggests that 77 percent of them are highly susceptible to producing unstable results– - selecting an appropriate model validation technique is a critical experimental design choice. Based on an analysis of 256 studies in the defect prediction literature, we select the 12 most commonly adopted model validation techniques for evaluation. Through a case study of 18 systems, we find that single-repetition holdout validation tends to produce estimates with 46-229 percent more bias and 53-863 percent more variance than the top-ranked model validation techniques. On the other hand, out-of-sample bootstrap validation yields the best balance between the bias and variance of estimates in the context of our study. Therefore, we recommend that future defect prediction studies avoid single-repetition holdout validation, and instead, use out-of-sample bootstrap validation.","1939-3520","","10.1109/TSE.2016.2584050","JSPS; Advancing Strategic International Networks to Accelerate the Circulation of Talented Researchers; Interdisciplinary Global Networks for Accelerating Theory and Practice in Software Ecosystem; JSPS Fellows; Natural Sciences and Engineering Research Council of Canada (NSERC); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7497471","Defect prediction models;model validation techniques;bootstrap validation;cross validation;holdout validation","Predictive models;Data models;Analytical models;Context;Context modeling;Software;Logistics","","","","150","","122","","22 Jun 2016","","","IEEE","IEEE Journals"
"Self-Management of Adaptable Component-Based Applications","L. Rosa; L. Rodrigues; A. Lopes; M. Hiltunen; R. Schlichting","INESC-ID and Universidade Técnica de Lisboa, Lisboa; INESC-ID and Universidade Técnica de Lisboa, Lisboa; University of Lisbon, Lisbon; AT&T Labs-Research, Florham Park; AT&T Labs Research, Florham Park","IEEE Transactions on Software Engineering","25 Feb 2013","2013","39","3","403","421","The problem of self-optimization and adaptation in the context of customizable systems is becoming increasingly important with the emergence of complex software systems and unpredictable execution environments. Here, a general framework for automatically deciding on when and how to adapt a system whenever it deviates from the desired behavior is presented. In this framework, the system's target behavior is described as a high-level policy that establishes goals for a set of performance indicators. The decision process is based on information provided independently for each component that describes the available adaptations, their impact on performance indicators, and any limitations or requirements. The technique consists of both offline and online phases. Offline, rules are generated specifying component adaptations that may help to achieve the established goals when a given change in the execution context occurs. Online, the corresponding rules are evaluated when a change occurs to choose which adaptations to perform. Experimental results using a prototype framework in the context of a web-based application demonstrate the effectiveness of this approach.","1939-3520","","10.1109/TSE.2012.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6197201","Adaptive systems;self-management;autonomic computing;goal policies","Runtime;Context;Software systems;Optimization;Catalogs","fault tolerant computing;optimisation","adaptable component based applications;customizable systems;complex software systems;unpredictable execution environments;desired behavior;target behavior;performance indicators;decision process;Web based application;autonomic computing","","21","","28","","8 May 2012","","","IEEE","IEEE Journals"
"A Taxonomy and Qualitative Comparison of Program Analysis Techniques for Security Assessment of Android Software","A. Sadeghi; H. Bagheri; J. Garcia; S. Malek","School of Information and Computer Sciences, University of California, Irvine, CA; Department of Computer Science and Engineering, University of Nebraska, Lincoln, NE; School of Information and Computer Sciences, University of California, Irvine, CA; School of Information and Computer Sciences, University of California, Irvine, CA","IEEE Transactions on Software Engineering","13 Jun 2017","2017","43","6","492","530","In parallel with the meteoric rise of mobile software, we are witnessing an alarming escalation in the number and sophistication of the security threats targeted at mobile platforms, particularly Android, as the dominant platform. While existing research has made significant progress towards detection and mitigation of Android security, gaps and challenges remain. This paper contributes a comprehensive taxonomy to classify and characterize the state-of-the-art research in this area. We have carefully followed the systematic literature review process, and analyzed the results of more than 300 research papers, resulting in the most comprehensive and elaborate investigation of the literature in this area of research. The systematic analysis of the research literature has revealed patterns, trends, and gaps in the existing literature, and underlined key challenges and opportunities that will shape the focus of future research efforts.","1939-3520","","10.1109/TSE.2016.2615307","National Science Foundation; Defense Advanced Research Projects Agency; Army Research Office; Department of Homeland Security; Air Force Office of Scientific Research; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7583740","Taxonomy and survey;security assessment;android platform;program analysis","Androids;Humanoid robots;Security;Taxonomy;Mobile communication;Malware;Systematics","Android (operating system);mobile computing;program diagnostics;security of data","taxonomy;program analysis;security assessment;Android software;mobile software;security threats;mobile platforms;dominant platform;Android security","","51","","517","","5 Oct 2016","","","IEEE","IEEE Journals"
"A Systematic Review of the Application and Empirical Investigation of Search-Based Test Case Generation","S. Ali; L. C. Briand; H. Hemmati; R. K. Panesar-Walawege","Simula Research Laboratory, Lysaker and University of Oslo, Norway; Simula Research Laboratory, Lysaker and University of Oslo, Norway; Simula Research Laboratory, Lysaker and University of Oslo, Norway; Simula Research Laboratory, Lysaker and University of Oslo, Norway","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","742","762","Metaheuristic search techniques have been extensively used to automate the process of generating test cases, and thus providing solutions for a more cost-effective testing process. This approach to test automation, often coined “Search-based Software Testing” (SBST), has been used for a wide variety of test case generation purposes. Since SBST techniques are heuristic by nature, they must be empirically investigated in terms of how costly and effective they are at reaching their test objectives and whether they scale up to realistic development artifacts. However, approaches to empirically study SBST techniques have shown wide variation in the literature. This paper presents the results of a systematic, comprehensive review that aims at characterizing how empirical studies have been designed to investigate SBST cost-effectiveness and what empirical evidence is available in the literature regarding SBST cost-effectiveness and scalability. We also provide a framework that drives the data collection process of this systematic review and can be the starting point of guidelines on how SBST techniques can be empirically assessed. The intent is to aid future researchers doing empirical studies in SBST by providing an unbiased view of the body of empirical evidence and by guiding them in performing well-designed and executed empirical studies.","1939-3520","","10.1109/TSE.2009.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5210118","Evolutionary computing and genetic algorithms;frameworks;heuristics design;review and evaluation;test generation;testing strategies;validation.","System testing;Automatic testing;Software testing;Automation;Costs;Logic testing;Scalability;Guidelines;Genetic algorithms;Algorithm design and analysis","program testing;search problems","search based test case generation;metaheuristic search technique;cost effective testing process;test automation;search based software testing","","215","","55","","21 Aug 2009","","","IEEE","IEEE Journals"
"Name-Based Analysis of Equally Typed Method Arguments","M. Pradel; T. R. Gross","ETH Zurich, Zurich; ETH Zurich, Zurich","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1127","1143","When calling a method that requires multiple arguments, programmers must pass the arguments in the expected order. For statically typed languages, the compiler helps programmers by checking that the type of each argument matches the type of the formal parameter. Unfortunately, types are futile for methods with multiple parameters of the same type. How can a programmer check that equally typed arguments are passed in the correct order? This paper presents two simple, yet effective, static program analyses that detect problems related to the order of equally typed arguments. The key idea is to leverage identifier names to infer the semantics of arguments and their intended positions. The analyses reveal problems that affect the correctness, understandability, and maintainability of a program, such as accidentally reversed arguments and misleading parameter names. Most parts of the analyses are language-agnostic. We evaluate the approach with 24 real-world programs written in Java and C. Our results show the analyses to be effective and efficient. One analysis reveals anomalies in the order of equally typed arguments; it finds 54 relevant problems with a precision of 82 percent. The other analysis warns about misleading parameter names and finds 31 naming bugs with a precision of 39 percent.","1939-3520","","10.1109/TSE.2013.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6419711","Testing and debugging;maintenance;documentation;static program analysis;anomaly detection;method arguments","Java;Access control;Engines;Feature extraction;Context;Robustness;Program processors","C language;Java;program diagnostics","name-based analysis;equally typed method argument;statically typed language;formal parameter;static program analysis;program correctness;program understandability;program maintainability;Java language;C language","","9","","40","","24 Jan 2013","","","IEEE","IEEE Journals"
"Invariant-Based Automatic Testing of Modern Web Applications","A. Mesbah; A. van Deursen; D. Roest","University of British Columbia, Vancouver; Delft University of Technology, Delft; Delft University of Technology, Delft","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","35","53","Ajax-based Web 2.0 applications rely on stateful asynchronous client/server communication, and client-side runtime manipulation of the DOM tree. This not only makes them fundamentally different from traditional web applications, but also more error-prone and harder to test. We propose a method for testing Ajax applications automatically, based on a crawler to infer a state-flow graph for all (client-side) user interface states. We identify Ajax-specific faults that can occur in such states (related to, e.g., DOM validity, error messages, discoverability, back-button compatibility) as well as DOM-tree invariants that can serve as oracles to detect such faults. Our approach, called Atusa, is implemented in a tool offering generic invariant checking components, a plugin-mechanism to add application-specific state validators, and generation of a test suite covering the paths obtained during crawling. We describe three case studies, consisting of six subjects, evaluating the type of invariants that can be obtained for Ajax applications as well as the fault revealing capabilities, scalability, required manual effort, and level of automation of our testing approach.","1939-3520","","10.1109/TSE.2011.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5728834","Automated testing;web applications;Ajax.","Web and internet services;Browsers;User interfaces;Robots;Servers","automatic testing;client-server systems;Internet;Java;program testing;trees (mathematics);user interfaces;XML","invariant-based automatic testing;AJAX-based Web 2.0 application;stateful asynchronous client-server communication;client-side runtime manipulation;state-flow graph;user interface;AJAX-specific fault identification;DOM-tree invariant;fault detection;generic invariant checking component;application-specific state validator;fault revealing capability","","70","1","40","","10 Mar 2011","","","IEEE","IEEE Journals"
"Trustrace: Mining Software Repositories to Improve the Accuracy of Requirement Traceability Links","N. Ali; Y. Guéhéneuc; G. Antoniol","École Polytechnique de Montréal, Montréal; École Polytechnique de Montréal, Montréal; École Polytechnique de Montréal, Montréal","IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","725","741","Traceability is the only means to ensure that the source code of a system is consistent with its requirements and that all and only the specified requirements have been implemented by developers. During software maintenance and evolution, requirement traceability links become obsolete because developers do not/cannot devote effort to updating them. Yet, recovering these traceability links later is a daunting and costly task for developers. Consequently, the literature has proposed methods, techniques, and tools to recover these traceability links semi-automatically or automatically. Among the proposed techniques, the literature showed that information retrieval (IR) techniques can automatically recover traceability links between free-text requirements and source code. However, IR techniques lack accuracy (precision and recall). In this paper, we show that mining software repositories and combining mined results with IR techniques can improve the accuracy (precision and recall) of IR techniques and we propose Trustrace, a trust--based traceability recovery approach. We apply Trustrace on four medium-size open-source systems to compare the accuracy of its traceability links with those recovered using state-of-the-art IR techniques from the literature, based on the Vector Space Model and Jensen-Shannon model. The results of Trustrace are up to 22.7 percent more precise and have 7.66 percent better recall values than those of the other techniques, on average. We thus show that mining software repositories and combining the mined data with existing results from IR techniques improves the precision and recall of requirement traceability links.","1939-3520","","10.1109/TSE.2012.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6341764","Traceability;requirements;feature;source code;repositories;experts;trust-based model","Accuracy;Data mining;Software maintenance;Information retrieval;Open source software;Principal component analysis","data mining;data privacy;information retrieval;software maintenance","software repository mining;requirement traceability link;traceability method;software maintenance;software evolution;information retrieval technique;IR technique;precision accuracy;recall accuracy;Trustrace approach;trust-based traceability recovery approach;medium-size open-source system;vector space model;Jensen-Shannon model","","45","","41","","10 Nov 2012","","","IEEE","IEEE Journals"
"Proactive and Reactive Runtime Service Discovery: A Framework and Its Evaluation","A. Zisman; G. Spanoudakis; J. Dooley; I. Siveroni","City University London, London; City University London, London; University of Essex, Colchester; City University London, London","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","954","974","The identification of services during the execution of service-based applications to replace services in them that are no longer available and/or fail to satisfy certain requirements is an important issue. In this paper, we present a framework to support runtime service discovery. This framework can execute service discovery queries in pull and push mode. In pull mode, it executes queries when a need for finding a replacement service arises. In push mode, queries are subscribed to the framework to be executed proactively and, in parallel with the operation of the application, to identify adequate services that could be used if the need for replacing a service arises. Hence, the proactive (push) mode of query execution makes it more likely to avoid interruptions in the operation of service-based applications when a service in them needs to be replaced at runtime. In both modes of query execution, the identification of services relies on distance-based matching of structural, behavioral, quality, and contextual characteristics of services and applications. A prototype implementation of the framework has been developed and an evaluation was carried out to assess the performance of the framework. This evaluation has shown positive results, which are discussed in the paper.","1939-3520","","10.1109/TSE.2012.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6375710","Web-services discovery;composite web services;context-aware QoS model;application development in services","Runtime;Context;Servers;Educational institutions;Database languages;Unified modeling language;Informatics","quality of service;query processing;software quality;ubiquitous computing;Web services","proactive runtime service discovery;reactive runtime service discovery;service identification;service-based applications;service discovery queries execution;pull mode;push mode;replacement service;distance-based matching;structural characteristics;behavioral characteristics;quality characteristics;contextual characteristics;composite Web-services discovery;context-aware QoS model","","23","","62","","10 Dec 2012","","","IEEE","IEEE Journals"
"Whitening SOA Testing via Event Exposure","C. Ye; H. Jacobsen","University of Toronto, Toronto; University of Toronto, Toronto","IEEE Transactions on Software Engineering","25 Sep 2013","2013","39","10","1444","1465","Whitening the testing of service-oriented applications can provide service consumers confidence on how well an application has been tested. However, to protect business interests of service providers and to prevent information leakage, the implementation details of services are usually invisible to service consumers. This makes it challenging to determine the test coverage of a service composition as a whole and design test cases effectively. To address this problem, we propose an approach to whiten the testing of service compositions based on events exposed by services. By deriving event interfaces to explore only necessary test coverage information from service implementations, our approach allows service consumers to determine test coverage based on selected events exposed by services at runtime without releasing the service implementation details. We also develop an approach to design test cases effectively based on event interfaces concerning both effectiveness and information leakage. The experimental results show that our approach outperforms existing testing approaches for service compositions with up to 49 percent more test coverage and an up to 24 percent higher fault-detection rate. Moreover, our solution can trade off effectiveness, efficiency, and information leakage for test case generation.","1939-3520","","10.1109/TSE.2013.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6495456","Web service composition;white-box testing;event interface;events","Testing;Service-oriented architecture;Books;Runtime;Catalogs;Jacobian matrices","program testing;service-oriented architecture;Web services","SOA testing whitening;service-oriented architecture;event exposure;service consumers;service providers;service composition;test coverage;test case design approach;fault-detection rate;test case generation;information leakage;Web services","","22","","84","","8 Apr 2013","","","IEEE","IEEE Journals"
"A Semi-Automatic Approach for Extracting Software Product Lines","M. T. Valente; V. Borges; L. Passos","University of Minas Gerais, Belo Horizonte; COTEMIG, Brazil; University of Waterloo, Waterloo","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","737","754","The extraction of nontrivial software product lines (SPL) from a legacy application is a time-consuming task. First, developers must identify the components responsible for the implementation of each program feature. Next, they must locate the lines of code that reference the components discovered in the previous step. Finally, they must extract those lines to independent modules or annotate them in some way. To speed up product line extraction, this paper describes a semi-automatic approach to annotate the code of optional features in SPLs. The proposed approach is based on an existing tool for product line development, called CIDE, that enhances standard IDEs with the ability to associate background colors with the lines of code that implement a feature. We have evaluated and successfully applied our approach to the extraction of optional features from three nontrivial systems: Prevayler (an in-memory database system), JFreeChart (a chart library), and ArgoUML (a UML modeling tool).","1939-3520","","10.1109/TSE.2011.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928352","Software product lines;virtual separation of concerns;refactoring tools;annotations","Feature extraction;Color;Image color analysis;Multithreading;Semantics;Software;Context","feature extraction;product development;software maintenance;software reusability;Unified Modeling Language","semiautomatic approach;software product lines extraction;SPL;legacy application;program feature;code lines localization;optional feature code annotation;product line development;CIDE;background colors;optional feature extraction;Prevayler nontrivial systems;JFreeChart nontrivial systems;ArgoUML nontrivial systems","","13","","46","","23 Jun 2011","","","IEEE","IEEE Journals"
"Systematic Elaboration of Scalability Requirements through Goal-Obstacle Analysis","L. Duboc; E. Letier; D. S. Rosenblum","State University of Rio de Janeiro, Rio de Janeiro; University College London, London; National University of Singapore, Singapore","IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","119","140","Scalability is a critical concern for many software systems. Despite the recognized importance of considering scalability from the earliest stages of development, there is currently little support for reasoning about scalability at the requirements level. This paper presents a goal-oriented approach for eliciting, modeling, and reasoning about scalability requirements. The approach consists of systematically identifying scalability-related obstacles to the satisfaction of goals, assessing the likelihood and severity of these obstacles, and generating new goals to deal with them. The result is a consolidated set of requirements in which important scalability concerns are anticipated through the precise, quantified specification of scaling assumptions and scalability goals. The paper presents results from applying the approach to a complex, large-scale financial fraud detection system.","1939-3520","","10.1109/TSE.2012.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6152130","Requirements/specifications;analysis;performance measures;quality analysis and evaluation;goal-oriented requirements engineering;KAOS;scalability","Scalability;Software;Batch production systems;Educational institutions;Analytical models;Natural languages","financial data processing;fraud;large-scale systems;reasoning about programs;systems analysis","systematic elaboration;goal-obstacle analysis;software systems;reasoning about scalability;scalability requirement elicitation;scalability requirement modeling;systematic scalability-related obstacle identification;goal satisfaction;complex large-scale financial fraud detection system;goal-oriented requirements engineering","","16","","56","","14 Feb 2012","","","IEEE","IEEE Journals"
"On the Positive Effect of Reactive Programming on Software Comprehension: An Empirical Study","G. Salvaneschi; S. Proksch; S. Amann; S. Nadi; M. Mezini","Department of Computer Science, Reactive Systems Group, Technische Universität Darmstadt, Darmstadt, Germany; Department of Computer Science, Software Technology Group, Technische Universität Darmstadt, Darmstadt, Germany; Department of Computer Science, Software Technology Group, Technische Universität Darmstadt, Darmstadt, Germany; Department of Computing Science, AB, University of AlbertaCanada; Department of Computer Science, Software Technology Group, Technische Universität Darmstadt, Darmstadt, Germany","IEEE Transactions on Software Engineering","8 Dec 2017","2017","43","12","1125","1143","Starting from the first investigations with strictly functional languages, reactive programming has been proposed as the programming paradigm for reactive applications. Over the years, researchers have enriched reactive languages with more powerful abstractions, embedded these abstractions into mainstream languages-including object-oriented languages-and applied reactive programming to several domains, such as GUIs, animations, Web applications, robotics, and sensor networks. However, an important assumption behind this line of research is that, beside other claimed advantages, reactive programming makes a wide class of otherwise cumbersome applications more comprehensible. This claim has never been evaluated. In this paper, we present the first empirical study that evaluates the effect of reactive programming on comprehension. The study involves 127 subjects and compares reactive programming to the traditional object-oriented style with the Observer design pattern. Our findings show that program comprehension is significantly enhanced by the reactive-programming paradigm-a result that suggests to further develop research in this field.","1939-3520","","10.1109/TSE.2017.2655524","European Research Council; German Federal Ministry of Education and Research; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7827078","Reactive programming;empirical study;controlled experiment;software comprehension","Programming;Runtime;Software development;Robot sensing systems","functional languages;object-oriented languages;object-oriented programming","object-oriented languages;software comprehension;functional languages;observer design pattern;program comprehension;reactive languages;reactive programming","","8","","72","Traditional","19 Jan 2017","","","IEEE","IEEE Journals"
"Generating Test Cases for Real-Time Systems Based on Symbolic Models","W. L. Andrade; P. D. L. Machado","Federal University of Campina Grande, Campina Grande; Federal University of Campina Grande, Campina Grande","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1216","1229","The state space explosion problem is one of the challenges to be faced by test case generation techniques, particularly when data values need to be enumerated. This problem gets even worse for real-time systems (RTS) that also have time constraints. The usual solution in this context, based on finite state machines or time automata, consists of enumerating data values (restricted to finite domains) while treating time symbolically. In this paper, a symbolic model for conformance testing of real-time systems software named TIOSTS that addresses both data and time symbolically is presented. Moreover, a test case generation process is defined to select more general test cases with variables and parameters that can be instantiated at testing execution time. Generation is based on a combination of symbolic execution and constraint solving for the data part and symbolic analysis for timed aspects. Furthermore, the practical application of the process is investigated through a case study.","1939-3520","","10.1109/TSE.2013.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6475130","Real-time systems and embedded systems;formal methods;symbolic execution;testing strategies","Testing;Clocks;Cost accounting;Real-time systems;Data models;Automata;Semantics","conformance testing;finite state machines;program testing;real-time systems","test case generation techniques;real-time systems;symbolic models;state space explosion problem;RTS;time constraints;finite state machines;time automata;conformance testing;TIOSTS;symbolic execution;constraint solving;data part;symbolic analysis;timed aspects","","9","1","38","","6 Mar 2013","","","IEEE","IEEE Journals"
"Symbolic Crosschecking of Data-Parallel Floating-Point Code","P. Collingbourne; C. Cadar; P. H. J. Kelly","Google Inc,; Department of Computing, Imperial College London, London, United Kingdom; Department of Computing, Imperial College London, London, United Kingdom","IEEE Transactions on Software Engineering","8 Jul 2014","2014","40","7","710","737","We present a symbolic execution-based technique for cross-checking programs accelerated using SIMD or OpenCL against an unaccelerated version, as well as a technique for detecting data races in OpenCL programs. Our techniques are implemented in KLEE-CL, a tool based on the symbolic execution engine KLEE that supports symbolic reasoning on the equivalence between expressions involving both integer and floating-point operations. While the current generation of constraint solvers provide effective support for integer arithmetic, the situation is different for floating-point arithmetic, due to the complexity inherent in such computations. The key insight behind our approach is that floating-point values are only reliably equal if they are essentially built by the same operations. This allows us to use an algorithm based on symbolic expression matching augmented with canonicalisation rules to determine path equivalence. Under symbolic execution, we have to verify equivalence along every feasible control-flow path. We reduce the branching factor of this process by aggressively merging conditionals, if-converting branches into select operations via an aggressive phi-node folding transformation. To support the Intel Streaming SIMD Extension (SSE) instruction set, we lower SSE instructions to equivalent generic vector operations, which in turn are interpreted in terms of primitive integer and floating-point operations. To support OpenCL programs, we symbolically model the OpenCL environment using an OpenCL runtime library targeted to symbolic execution. We detect data races by keeping track of all memory accesses using a memory log, and reporting a race whenever we detect that two accesses conflict. By representing the memory log symbolically, we are also able to detect races associated with symbolically-indexed accesses of memory objects. We used KLEE-CL to prove the bounded equivalence between scalar and data-parallel versions of floating-point programs and find a number of issues in a variety of open source projects that use SSE and OpenCL, including mismatches between implementations, memory errors, race conditions and a compiler bug.","1939-3520","","10.1109/TSE.2013.2297120","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6698391","Data-parallel code;floating point;symbolic execution;SIMD;OpenCL;KLEE-CL","Vectors;Kernel;Computational modeling;Computer architecture;Semantics;Programming;Parallel processing","data handling;floating point arithmetic;parallel processing;program debugging","symbolic crosschecking;data parallel floating point code;symbolic execution based technique;crosschecking programs;SIMD;OpenCL programs;KLEE-CL;symbolic execution engine;symbolic reasoning;floating-point operations;integer operations;integer arithmetic;floating point arithmetic;symbolic expression matching;phi node folding transformation;intel streaming SIMD extension;SSE instruction set;equivalent generic vector operations;floating point operations;primitive integer operations;OpenCL environment;memory accesses;memory log;open source projects;floating-point programs;compiler bug;memory errors;race conditions","","9","","55","","2 Jan 2014","","","IEEE","IEEE Journals"
"Asymptotic Perturbation Bounds for Probabilistic Model Checking with Empirically Determined Probability Parameters","G. Su; Y. Feng; T. Chen; D. S. Rosenblum","Department of Computer Science, School of Computing, National University of Singapore; Quantum Computation and Intelligent Systems, University of Technology Sydney; Department of Computer Science, Middlesex University London; Department of Computer Science, School of Computing, National University of Singapore","IEEE Transactions on Software Engineering","14 Jul 2016","2016","42","7","623","639","Probabilistic model checking is a verification technique that has been the focus of intensive research for over a decade. One important issue with probabilistic model checking, which is crucial for its practical significance but is overlooked by the state-of-the-art largely, is the potential discrepancy between a stochastic model and the real-world system it represents when the model is built from statistical data. In the worst case, a tiny but nontrivial change to some model quantities might lead to misleading or even invalid verification results. To address this issue, in this paper, we present a mathematical characterization of the consequences of model perturbations on the verification distance. The formal model that we adopt is a parametric variant of discrete-time Markov chains equipped with a vector norm to measure the perturbation. Our main technical contributions include a closed-form formulation of asymptotic perturbation bounds, and computational methods for two arguably most useful forms of those bounds, namely linear bounds and quadratic bounds. We focus on verification of reachability properties but also address automata-based verification of omega-regular properties. We present the results of a selection of case studies that demonstrate that asymptotic perturbation bounds can accurately estimate maximum variations of verification results induced by model perturbations.","1939-3520","","10.1109/TSE.2015.2508444","Ministry of Education - Singapore; Australian Research Council; National Natural Science Foundation of China; CAS/SAFEA; State Key Laboratory of Novel Software Technology at Nanjing University; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7355393","Asymptotic perturbation bound;discrete-time Markov chain;numerical iteration;optimization;parametric Markov chain;perturbation analysis;probabilistic model checking;quadratic programming","Model checking;Markov processes;Probabilistic logic;Computational modeling;Mathematical model;Perturbation methods","automata theory;formal verification;linear programming;Markov processes;probability;quadratic programming;reachability analysis","probabilistic model checking;empirically determined probability parameters;verification technique;stochastic model;real-world system;statistical data;mathematical characterization;model perturbations;verification distance;formal model;parametric discrete-time Markov chains;vector norm;perturbation measure;closed-form formulation;asymptotic perturbation bounds;computational methods;linear bounds;quadratic bounds;reachability property verification;automata-based verification;omega-regular properties;maximum verification variation estimation","","4","","53","","17 Dec 2015","","","IEEE","IEEE Journals"
"Coverage Estimation in Model Checking with Bitstate Hashing","S. Ikeda; M. Jibiki; Y. Kuno","NEC Corporation, Kawasaki; National Institute of Information and Communication Technology, Koganei; University of Tsukuba, Bunkyo","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","477","486","Explicit-state model checking which is conducted by state space search has difficulty in exploring satisfactory state space because of its memory requirements. Though bitstate hashing achieves memory efficiency, it cannot guarantee complete verification. Thus, it is desirable to provide a reliability indicator such as a coverage estimate. However, the existing approaches for coverage estimation are not very accurate when a verification run covers a small portion of state space. This mainly stems from the lack of information that reflects characteristics of models. Therefore, we propose coverage estimation methods using a growth curve that approximates an increase in reached states by enlarging a bloom filter. Our approaches improve estimation accuracy by leveraging the statistics from multiple verification runs. Coverage is estimated by fitting the growth curve to these statistics. Experimental results confirm the validity of the proposed growth curve and the applicability of our approaches to practical models. In fact, for practical models, our approaches outperformed the conventional ones when the actual coverage is relatively low.","1939-3520","","10.1109/TSE.2012.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226428","Coverage estimation;model checking;bitstate hashing","Estimation;Reliability;Probabilistic logic;Accuracy;Mathematical model;Space exploration;Equations","curve fitting;file organisation;formal verification;statistics","bitstate hashing;explicit-state model checking;state space search;memory requirement;memory efficiency;formal verification;growth curve fitting;Bloom filter;statistics;coverage estimation;reliability indicator","","1","","19","","26 Jun 2012","","","IEEE","IEEE Journals"
"Using Timed Automata for Modeling Distributed Systems with Clocks: Challenges and Solutions","G. Rodriguez-Navas; J. Proenza","Universitat de les Illes Balears, Palma de Mallorca; Universitat de les Illes Balears, Palma de Mallorca","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","857","868","The application of model checking for the formal verification of distributed embedded systems requires the adoption of techniques for realistically modeling the temporal behavior of such systems. This paper discusses how to model with timed automata the different types of relationships that may be found among the computer clocks of a distributed system, namely, ideal clocks, drifting clocks, and synchronized clocks. For each kind of relationship, a suitable modeling pattern is thoroughly described and formally verified.","1939-3520","","10.1109/TSE.2012.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6374193","Embedded systems;real-time systems;clock synchronization;model checking;timed automata;hybrid automata","Real-time systems;Automata;Formal verification;Distributed processing;Embedded systems","automata theory;distributed processing;embedded systems;formal verification","timed automata;modeling distributed systems;model checking;formal verification;distributed embedded systems;temporal behavior;distributed system computer clocks;ideal clocks;drifting clocks;synchronized clocks","","12","","27","","4 Dec 2012","","","IEEE","IEEE Journals"
"Engineering Privacy","S. Spiekermann; L. F. Cranor","Humboldt University, Berin; Carnegie Mellon University, Pittsburgh","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","67","82","In this paper we integrate insights from diverse islands of research on electronic privacy to offer a holistic view of privacy engineering and a systematic structure for the discipline's topics. First we discuss privacy requirements grounded in both historic and contemporary perspectives on privacy. We use a three-layer model of user privacy concerns to relate them to system operations (data transfer, storage and processing) and examine their effects on user behavior. In the second part of the paper we develop guidelines for building privacy-friendly systems. We distinguish two approaches: ""privacy-by-policy"" and ""privacy-by-architecture."" The privacy-by-policy approach focuses on the implementation of the notice and choice principles of fair information practices (FIPs), while the privacy-by-architecture approach minimizes the collection of identifiable personal data and emphasizes anonymization and client-side data storage and processing. We discuss both approaches with a view to their technical overlaps and boundaries as well as to economic feasibility. The paper aims to introduce engineers and computer scientists to the privacy research domain and provide concrete guidance on how to design privacy-friendly systems.","1939-3520","","10.1109/TSE.2008.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4657365","Privacy;Legal Aspects of Computing;Security and Protection;Requirements/Specifications;Privacy;Legal Aspects of Computing;Security and Protection;Requirements/Specifications","Design engineering;Protection;Systems engineering and theory;Data privacy;Companies;Social network services;Law;Radiofrequency identification;Guidelines;Memory","data privacy;security of data","electronic privacy;privacy engineering;user privacy;privacy-friendly systems;privacy-by-policy;privacy-by-architecture","","214","","116","","24 Oct 2008","","","IEEE","IEEE Journals"
"Predicting Vulnerable Software Components via Text Mining","R. Scandariato; J. Walden; A. Hovsepyan; W. Joosen","IBBT-DistriNet, KU Leuven, 3001 Leuven, Belgium; Department of Computer Science, Northern Kentucky University, Highland Heights, KY; IBBT-DistriNet, KU Leuven, 3001 Leuven, Belgium; IBBT-DistriNet, KU Leuven, 3001 Leuven, Belgium","IEEE Transactions on Software Engineering","9 Oct 2014","2014","40","10","993","1006","This paper presents an approach based on machine learning to predict which components of a software application contain security vulnerabilities. The approach is based on text mining the source code of the components. Namely, each component is characterized as a series of terms contained in its source code, with the associated frequencies. These features are used to forecast whether each component is likely to contain vulnerabilities. In an exploratory validation with 20 Android applications, we discovered that a dependable prediction model can be built. Such model could be useful to prioritize the validation activities, e.g., to identify the components needing special scrutiny.","1939-3520","","10.1109/TSE.2014.2340398","EU FP7; Research Fund KU Leuven; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6860243","Vulnerabilities;prediction model;machine learning","Software;Predictive models;Measurement;Security;Androids;Humanoid robots;Text mining","data mining;learning (artificial intelligence);program verification;security of data","vulnerable software component;text mining;machine learning;security vulnerability;source code;Android application","","119","","40","","18 Jul 2014","","","IEEE","IEEE Journals"
"Customizing the Representation Capabilities of Process Models: Understanding the Effects of Perceived Modeling Impediments","B. M. Samuel; L. A. Watkins III; A. Ehle; V. Khatri","Ivey Business School, Western University 1255 Western Road, London, ON, Canada; Kelley School of Business, Indiana University 1309 East 10th Street BU 570, Bloomington, IN; Kelley School of Business, Indiana University 1309 East 10th Street BU 570, Bloomington, IN; Kelley School of Business, Indiana University 1309 East 10th Street BU 570, Bloomington, IN","IEEE Transactions on Software Engineering","7 Jan 2015","2015","41","1","19","39","Process modeling is useful during the analysis and design of systems. Prior research acknowledges both impediments to process modeling that limits its use as well as customizations that can be employed to help improve the creation of process models. However, no research to date has provided a rich examination of the linkages between perceived process modeling impediments and process modeling customizations. In order to help address this gap, we first conceptualized perceived impediments to using process models as a “lack of fit” between process modeling and another factor: (1) the role the process model is intended for; and (2) the task at hand. We conducted a case study at two large health insurance carriers to understand why the lack of fit existed and then show different types of process modeling customizations used to address the lack of fit and found a variety of “physical” and “process” customizations employed to overcome the lack of fits. We generalize our findings into propositions for future research that examine the dynamic interaction between process models and their need to be understood by individuals during systems analysis and design.","1939-3520","","10.1109/TSE.2014.2354043","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898868","Software process models;requirements/specifications management;requirements/specifications process;requirements/specification stools;UML;use cases;activity diagrams","Unified modeling language;Analytical models;Organizations;Software;Interviews;Context","formal specification;software process improvement","process model representation capability customization;system design;system analysis;process model creation improvement;perceived process modeling impediments;process modeling customizations;lack-of-fit;health insurance carriers;physical customization;process customization;dynamic process model interaction","","5","","97","","15 Sep 2014","","","IEEE","IEEE Journals"
"Clone Management for Evolving Software","H. A. Nguyen; T. T. Nguyen; N. H. Pham; J. Al-Kofahi; T. N. Nguyen","Iowa State University, Ames; Iowa State University, Ames; Iowa State University, Ames; Iowa State University, Ames; Iowa State University, Ames","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1008","1026","Recent research results suggest a need for code clone management. In this paper, we introduce JSync, a novel clone management tool. JSync provides two main functions to support developers in being aware of the clone relation among code fragments as software systems evolve and in making consistent changes as they create or modify cloned code. JSync represents source code and clones as (sub)trees in Abstract Syntax Trees, measures code similarity based on structural characteristic vectors, and describes code changes as tree editing scripts. The key techniques of JSync include the algorithms to compute tree editing scripts, to detect and update code clones and their groups, to analyze the changes of cloned code to validate their consistency, and to recommend relevant clone synchronization and merging. Our empirical study on several real-world systems shows that JSync is efficient and accurate in clone detection and updating, and provides the correct detection of the defects resulting from inconsistent changes to clones and the correct recommendations for change propagation across cloned code.","1939-3520","","10.1109/TSE.2011.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6007141","Clone management;clone consistency analysis;clone synchronization;clone merging","Cloning;Feature extraction;Software systems;Synchronization;Vegetation;Merging;Databases","Java;program compilers","evolving software;code clone management;JSync;clone management tool;code fragments;software systems;source code;abstract syntax trees;structural characteristic vectors;tree editing scripts;change propagation","","57","","50","","1 Sep 2011","","","IEEE","IEEE Journals"
"Automated Behavioral Testing of Refactoring Engines","G. Soares; R. Gheyi; T. Massoni","Federal University of Campina Grande, Campina Grande; Federal University of Campina Grande, Campina Grande; Federal University of Campina Grande, Campina Grande","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","147","162","Refactoring is a transformation that preserves the external behavior of a program and improves its internal quality. Usually, compilation errors and behavioral changes are avoided by preconditions determined for each refactoring transformation. However, to formally define these preconditions and transfer them to program checks is a rather complex task. In practice, refactoring engine developers commonly implement refactorings in an ad hoc manner since no guidelines are available for evaluating the correctness of refactoring implementations. As a result, even mainstream refactoring engines contain critical bugs. We present a technique to test Java refactoring engines. It automates test input generation by using a Java program generator that exhaustively generates programs for a given scope of Java declarations. The refactoring under test is applied to each generated program. The technique uses SafeRefactor, a tool for detecting behavioral changes, as an oracle to evaluate the correctness of these transformations. Finally, the technique classifies the failing transformations by the kind of behavioral change or compilation error introduced by them. We have evaluated this technique by testing 29 refactorings in Eclipse JDT, NetBeans, and the JastAdd Refactoring Tools. We analyzed 153,444 transformations, and identified 57 bugs related to compilation errors, and 63 bugs related to behavioral changes.","1939-3520","","10.1109/TSE.2012.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6175911","Refactoring;automated testing;program generation","Java;Metals;Engines;Computer bugs;Testing;Automatic programming;Unified modeling language","automatic programming;Java;program testing","automated behavioral testing;compilation errors;refactoring transformation;refactoring engine developers;Java refactoring engines;Java program generator;SafeRefactor;JastAdd refactoring tools","","59","","49","","3 Apr 2012","","","IEEE","IEEE Journals"
"Grammar Recovery from Parse Trees and Metrics-Guided Grammar Refactoring","N. A. Kraft; E. B. Duffy; B. A. Malloy","University of Alabama, Tuscaloosa; Clemson University, Clemson; Clemson University, Clemson","IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","780","794","Many software development tools that assist with tasks such as testing and maintenance are specific to a particular development language and require a parser for that language. Because a grammar is required to develop a parser, construction of these software development tools is dependent upon the availability of a grammar for the development language. However, a grammar is not always available for a language and, in these cases, acquiring a grammar is the most difficult, costly, and time-consuming phase of tool construction. In this paper, we describe a methodology for grammar recovery from a hard-coded parser. Our methodology is comprised of manual instrumentation of the parser, a technique for automatic grammar recovery from parse trees, and a semi-automatic metrics-guided approach to refactoring an iterative grammar to obtain a recursive grammar. We present the results of a case study in which we recover and refactor a grammar from version 4.0.0 of the GNU C++ parser and then refactor the recovered grammar using our metrics-guided approach. Additionally, we present an evaluation of the recovered and refactored grammar by comparing it to the ISO C++98 grammar.","1939-3520","","10.1109/TSE.2009.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5278661","Grammar;grammar recovery;grammar refactoring;grammar metrics;parse tree.","Programming;Software testing;Instruments;Software maintenance;Java;Computer Society;Manuals;Iterative methods;ISO;Debugging","C++ language;grammars;software maintenance;software metrics;system recovery","grammar recovery;parse trees;metrics-guided grammar refactoring;software development tools;hard-coded parser;iterative grammar;recursive grammar;GNU C++ parser;ISO C++98 grammar","","7","","49","","6 Oct 2009","","","IEEE","IEEE Journals"
"Identifying Extract Method Refactoring Opportunities Based on Functional Relevance","S. Charalampidou; A. Ampatzoglou; A. Chatzigeorgiou; A. Gkortzis; P. Avgeriou","Institute of Mathematics and Computer Science, University of Groningen, Groningen, Netherlands; Institute of Mathematics and Computer Science, University of Groningen, Groningen, Netherlands; Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece; Institute of Mathematics and Computer Science, University of Groningen, Groningen, Netherlands; Institute of Mathematics and Computer Science, University of Groningen, Groningen, Netherlands","IEEE Transactions on Software Engineering","13 Oct 2017","2017","43","10","954","974","`Extract Method' is considered one of the most frequently applied and beneficial refactorings, since the corresponding Long Method smell is among the most common and persistent ones. Although Long Method is conceptually related to the implementation of diverse functionalities within a method, until now, this relationship has not been utilized while identifying refactoring opportunities. In this paper we introduce an approach (accompanied by a tool) that aims at identifying source code chunks that collaborate to provide a specific functionality, and propose their extraction as separate methods. The accuracy of the proposed approach has been empirically validated both in an industrial and an open-source setting. In the former case, the approach was capable of identifying functionally related statements within two industrial long methods (approx. 500 LoC each), with a recall rate of 93 percent. In the latter case, based on a comparative study on open-source data, our approach ranks better compared to two well-known techniques of the literature. To assist software engineers in the prioritization of the suggested refactoring opportunities the approach ranks them based on an estimate of their fitness for extraction. The provided ranking has been validated in both settings and proved to be strongly correlated with experts' opinion.","1939-3520","","10.1109/TSE.2016.2645572","ITEA2; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7801138","Design tools and techniques;object-oriented programming;metrics/measurement","Measurement;Open source software;Mathematics;Data mining;Computer science;Syntactics","public domain software;software maintenance","open-source data;functional relevance;beneficial refactorings;diverse functionalities;specific functionality;open-source setting;functionally related statements;industrial long methods;refactoring opportunities;Extract Method;Long Method smell;source code chunks","","3","","44","Traditional","28 Dec 2016","","","IEEE","IEEE Journals"
"DECAF: A Platform-Neutral Whole-System Dynamic Binary Analysis Platform","A. Henderson; L. K. Yan; X. Hu; A. Prakash; H. Yin; S. McCamant","Department of Electrical Engineering and Computer Science, Syracuse University, Syracuse, NY; Department of RIG, Rome Laboratory, Rome, NY; Department of Electrical Engineering and Computer Science, Syracuse University, Syracuse, NY; Department of Electrical Engineering and Computer Science, Syracuse University, Syracuse, NY; Department of Electrical Engineering and Computer Science, Syracuse University, Syracuse, NY; Department of Computer Science & Engineering, University of Minnesota (Twin Cities), Minneapolis, MN","IEEE Transactions on Software Engineering","13 Feb 2017","2017","43","2","164","184","Dynamic binary analysis is a prevalent and indispensable technique in program analysis. While several dynamic binary analysis tools and frameworks have been proposed, all suffer from one or more of: prohibitive performance degradation, a semantic gap between the analysis code and the program being analyzed, architecture/OS specificity, being user-mode only, and lacking APIs. We present DECAF, a virtual machine based, multi-target, whole-system dynamic binary analysis framework built on top of QEMU. DECAF provides Just-In-Time Virtual Machine Introspection and a plugin architecture with a simple-to-use event-driven programming interface. DECAF implements a new instruction-level taint tracking engine at bit granularity, which exercises fine control over the QEMU Tiny Code Generator (TCG) intermediate representation to accomplish on-the-fly optimizations while ensuring that the taint propagation is sound and highly precise. We perform a formal analysis of DECAF's taint propagation rules to verify that most instructions introduce neither false positives nor false negatives. We also present three platform-neutral plugins-Instruction Tracer, Keylogger Detector, and API Tracer, to demonstrate the ease of use and effectiveness of DECAF in writing cross-platform and system-wide analysis tools. Implementation of DECAF consists of 9,550 lines of C++ code and 10,270 lines of C code and we evaluate DECAF using CPU2006 SPEC benchmarks and show average overhead of 605 percent for system wide tainting and 12 percent for VMI.","1939-3520","","10.1109/TSE.2016.2589242","US National Science Foundation; US National Science Foundation; McAfee Inc.; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7506264","Dynamic binary analysis;dynamic taint analysis;virtual machine introspection","Instruments;Virtual machining;Kernel;Semantics;Computer architecture;Registers;Context","application program interfaces;C++ language;program compilers;program diagnostics;software architecture;software performance evaluation;software portability;software tools;source code (software);virtual machines","DECAF;platform-neutral whole-system dynamic binary analysis platform;program analysis;dynamic binary analysis tools;prohibitive performance degradation;code analysis;architecture-OS specificity;virtual machine based multitarget whole-system dynamic binary analysis;QEMU;just-in-time virtual machine introspection;plug-in architecture;event-driven programming interface;instruction-level taint tracking engine;QEMU tiny code generator;TCG;on-the-fly optimizations;taint propagation;formal analysis;platform-neutral plugins;instruction tracer;keylogger detector;API tracer;cross-platform analysis tools;system- wide analysis tools;C++ code;C code;CPU2006 SPEC benchmarks;system wide tainting","","16","","43","","7 Jul 2016","","","IEEE","IEEE Journals"
"Automated Synthesis and Dynamic Analysis of Tradeoff Spaces for Object-Relational Mapping","H. Bagheri; C. Tang; K. Sullivan","Department of Computer Science and Engineering, University of Nebraska-Lincoln, Lincoln, NE; Department of Computer Sciences, University of Virginia, Charlottesville, VA 22903; Department of Computer Sciences, University of Virginia, Charlottesville, VA 22903","IEEE Transactions on Software Engineering","13 Feb 2017","2017","43","2","145","163","Producing software systems that achieve acceptable tradeoffs among multiple non-functional properties remains a significant engineering problem. We propose an approach to solving this problem that combines synthesis of spaces of design alternatives from logical specifications and dynamic analysis of each point in the resulting spaces. We hypothesize that this approach has potential to help engineers understand important tradeoffs among dynamically measurable properties of system components at meaningful scales within reach of existing synthesis tools. To test this hypothesis, we developed tools to enable, and we conducted, a set of experiments in the domain of relational databases for object-oriented data models. For each of several data models, we used our approach to empirically test the accuracy of a published suite of metrics to predict tradeoffs based on the static schema structure alone. The results show that exhaustive synthesis and analysis provides a superior view of the tradeoff spaces for such designs. This work creates a path forward toward systems that achieve significantly better tradeoffs among important system properties.","1939-3520","","10.1109/TSE.2016.2587646","National Science Foundation; US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7506009","Specification-driven synthesis;tradespace analysis;ORM;static analysis;dynamic analysis;relational logic","Data models;Load modeling;Object oriented modeling;Semantics;Relational databases;Measurement","data models;formal specification;object-oriented methods;program diagnostics","object-relational mapping;automated tradeoff space synthesis;dynamic tradeoff space analysis;software systems;nonfunctional properties;logical specifications;dynamic analysis;dynamically measurable properties;relational databases;object-oriented data models;static schema structure;system properties","","9","","44","","7 Jul 2016","","","IEEE","IEEE Journals"
"Round-Up: Runtime Verification of Quasi Linearizability for Concurrent Data Structures","L. Zhang; A. Chattopadhyay; C. Wang","Bradley Department of Electrical and Computer Engineering, Virginia Polytechnic Institute and State University (Virginia Tech), Blacksburg, VA; Bradley Department of Electrical and Computer Engineering, Virginia Polytechnic Institute and State University (Virginia Tech), Blacksburg, VA; Bradley Department of Electrical and Computer Engineering, Virginia Polytechnic Institute and State University (Virginia Tech), Blacksburg, VA","IEEE Transactions on Software Engineering","8 Dec 2015","2015","41","12","1202","1216","We propose a new method for runtime checking of a relaxed consistency property called quasi linearizability for concurrent data structures.Quasi linearizability generalizes the standard notion of linearizability by introducing nondeterminism into the parallel computations quantitatively and then exploiting such nondeterminism to improve the runtime performance. However, ensuring the quantitative aspects of this correctness condition in the low-level code of the concurrent data structure implementation is a difficult task.Our runtime verification method is the first fully automated method for checking quasi linearizability in the C/C++ code of concurrent data structures. It guarantees that all the reported quasi linearizability violations manifested by the concurrent executions are real violations. We have implemented our method in a software tool based on the LLVM compiler and a systematic concurrency testing tool called Inspect. Our experimental evaluation shows that the new method is effective in detecting quasi linearizability violations in the source code implementations of concurrent data structures.","1939-3520","","10.1109/TSE.2015.2467371","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7192659","Runtime verification;linearizability;serializability;atomicity;relaxed consistency;systematic concurrency testing;partial order reduction;Runtime verification;linearizability;serializability;atomicity;relaxed consistency;systematic concurrency testing;partial order reduction","History;Data structures;Legal aspects;Runtime;Concurrent computing","C++ language;data structures;program compilers;software tools","source code;Inspect;systematic concurrency testing tool;LLVM compiler;software tool;concurrent executions;quasi linearizability violations;C/C++ code;fully automated method;runtime verification method;low-level code;correctness condition;nondeterminism;relaxed consistency property;runtime checking;concurrent data structures","","3","","48","","12 Aug 2015","","","IEEE","IEEE Journals"
"Task Environment Complexity, Global Team Dispersion, Process Capabilities, and Coordination in Software Development","G. Lee; J. A. Espinosa; W. H. DeLone","American University, Washington; American University, Washington; American University, Washington","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1753","1771","Software development teams are increasingly global. Team members are separated by multiple boundaries such as geographic location, time zone, culture, and organization, presenting substantial coordination challenges. Global software development becomes even more challenging when user requirements change dynamically. However, little empirical research has investigated how team dispersion across multiple boundaries and user requirements dynamism, which collectively increase task environment complexity, influence team coordination and software development success in the global context. Further, we have a limited understanding of how software process capabilities such as rigor, standardization, agility, and customizability mitigate the negative effects of global team dispersion and user requirements dynamism. To address these important issues, we test a set of relevant hypotheses using field survey data obtained from both project managers and stakeholders. Our results show that global team dispersion and user requirements dynamism have a negative effect on coordination effectiveness. We find that the negative effect of global team dispersion on coordination effectiveness decreases as process standardization increases and that the negative effect of user requirements dynamism on coordination effectiveness decreases as process agility increases. We find that coordination effectiveness has a positive effect on global software development success in terms of both process and product aspects.","1939-3520","","10.1109/TSE.2013.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6583162","Global boundaries;global software development;user requirements dynamism;software process capability;task environment complexity;team coordination;team dispersion","User centered design;Complexity theory;Dispersion;Global communication;Software development;Process capability;Globalization","software development management;team working","task environment complexity;global team dispersion;process capabilities;coordination;software development teams;geographic location;time zone;culture;organization;global software development;user requirements dynamism;rigor capability;standardization capability;agility capability;customizability capability;coordination effectiveness;process aspect;product aspect","","14","","101","","21 Aug 2013","","","IEEE","IEEE Journals"
"EDZL Schedulability Analysis in Real-Time Multicore Scheduling","J. Lee; I. Shin","The University of Michigan, Ann Arbor; KAIST, Daejeon","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","910","916","In real-time systems, correctness depends not only on functionality but also on timeliness. A great number of scheduling theories have been developed for verification of the temporal correctness of jobs (software) in such systems. Among them, the Earliest Deadline first until Zero-Laxity (EDZL) scheduling algorithm has received growing attention thanks to its effectiveness in multicore real-time scheduling. However, the true potential of EDZL has not yet been fully exploited in its schedulability analysis as the state-of-the-art EDZL analysis techniques involve considerable pessimism. In this paper, we propose a new EDZL multicore schedulability test. We first introduce an interesting observation that suggests an insight toward pessimism reduction in the schedulability analysis of EDZL. We then incorporate it into a well-known existing Earliest Deadline First (EDF) schedulability test, resulting in a new EDZL schedulability test. We demonstrate that the proposed EDZL test not only has lower time complexity than existing EDZL schedulability tests, but also significantly improves the schedulability of EDZL by up to 36.6 percent compared to the best existing EDZL schedulability tests.","1939-3520","","10.1109/TSE.2012.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6374195","Earliest Deadline first until Zero-Laxity (EDZL);real-time scheduling;schedulability analysis;multicore platform;real-time systems","Real-time systems;Silicon;Scheduling algorithms;Scheduling;Exponential distribution;Time factors;Aerospace electronics","multiprocessing systems;processor scheduling;real-time systems","EDZL schedulability analysis;real-time multicore scheduling;correctness;earliest deadline first until zero-laxity scheduling algorithm;time complexity","","10","","22","","4 Dec 2012","","","IEEE","IEEE Journals"
"Supporting Process Model Validation through Natural Language Generation","H. Leopold; J. Mendling; A. Polyvyanyy","WU Vienna, Austria.; WU Vienna, Austria.; Queensland University of Technology, Brisbane, Australia.","IEEE Transactions on Software Engineering","8 Aug 2014","2014","40","8","818","840","The design and development of process-aware information systems is often supported by specifying requirements as business process models. Although this approach is generally accepted as an effective strategy, it remains a fundamental challenge to adequately validate these models given the diverging skill set of domain experts and system analysts. As domain experts often do not feel confident in judging the correctness and completeness of process models that system analysts create, the validation often has to regress to a discourse using natural language. In order to support such a discourse appropriately, so-called verbalization techniques have been defined for different types of conceptual models. However, there is currently no sophisticated technique available that is capable of generating natural-looking text from process models. In this paper, we address this research gap and propose a technique for generating natural language texts from business process models. A comparison with manually created process descriptions demonstrates that the generated texts are superior in terms of completeness, structure, and linguistic complexity. An evaluation with users further demonstrates that the texts are very understandable and effectively allow the reader to infer the process model semantics. Hence, the generated texts represent a useful input for process model validation.","1939-3520","","10.1109/TSE.2014.2327044","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6823180","Business process model validation;natural language text generation;verbalization","Unified modeling language;Natural languages;Business;Analytical models;Adaptation models;Context modeling;Context","information systems;natural language processing","process model validation;linguistic complexity;structure complexity;completeness complexity;natural language text generation;natural-looking text generation;verbalization techniques;process model completeness;process model correctness;business process models;process-aware information systems;natural language generation","","42","","110","","29 May 2014","","","IEEE","IEEE Journals"
"Verification and Trade-Off Analysis of Security Properties in UML System Models","G. Georg; K. Anastasakis; B. Bordbar; S. H. Houmb; I. Ray; M. Toahchoodee","Colorado State University, Fort Collins, CO; University of Birmingham, Birmingham, UK; University of Birmingham, Birmingham, UK; Telenor GBDR, Trondheim, Norway; Colorado State University, Fort Collins, CO; Colorado State University, Fort Collins, CO","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","338","356","Designing secure systems is a nontrivial task. Incomplete or faulty designs can cause security mechanisms to be incorrectly incorporated in a system, allowing them to be bypassed and resulting in a security breach. We advocate the use of the Aspect-Oriented Risk-Driven Development (AORDD) methodology for developing secure systems. This methodology begins with designers defining system assets, identifying potential attacks against them, and evaluating system risks. When a risk is unacceptable, designers must mitigate the associated threat by incorporating security mechanisms methodically into the system design. Designers next formally evaluate the resulting design to ensure that the threat has been mitigated, while still allowing development to meet other project constraints. In this paper, we focus on the AORDD analysis, which consists of: (1) a formal security evaluation and (2) a trade-off analysis that enables system designers to position alternative security solutions against each other. The formal security evaluation uses the Alloy Analyzer to provide assurance that an incorporated security mechanism performs as expected and makes the system resilient to previously identified attacks. The trade-off analysis uses a Bayesian Belief Network topology to allow equally effective security mechanisms to be compared against system security requirements and other factors such as time-to-market and budget constraints.","1939-3520","","10.1109/TSE.2010.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432225","Aspect-oriented modeling (AOM);Bayesian belief network (BBN);security analysis;trade-off analysis.","Unified modeling language;Protection;Standards development;ISO standards;Data security;Design methodology;Bayesian methods;Risk management;Computer security;Computer Society","aspect-oriented programming;belief networks;formal verification;security of data;Unified Modeling Language","trade-off analysis;security properties verification;UML system models;secure systems design;aspect-oriented risk-driven development;AORDD methodology;risk evaluation;formal security evaluation;Alloy Analyzer;Bayesian belief network topology;time-to-market;budget constraints","","19","","51","","18 Mar 2010","","","IEEE","IEEE Journals"
"Programmer-Friendly Refactoring Errors","E. Murphy-Hill; A. P. Black","North Carolina State University, Raleigh; Portland State University, Portland","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1417","1431","Refactoring tools, common to many integrated development environments, can help programmers to restructure their code. These tools sometimes refuse to restructure the programmer's code, instead giving the programmer a textual error message that she must decode if she wishes to understand the reason for the tool's refusal and what corrective action to take. This paper describes a graphical alternative to textual error messages called Refactoring Annotations. It reports on two experiments, one using an integrated development environment and the other using paper mockups, that show that programmers can use Refactoring Annotations to quickly and accurately understand the cause of refactoring errors.","1939-3520","","10.1109/TSE.2011.110","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6072219","Refactoring;refactoring errors;usability;programmers;tools","Taxonomy;Programming;Prototypes;Visualization;Java","computer graphics;software maintenance","programmer-friendly refactoring errors;refactoring tools;textual error message;graphical alternative;textual error messages;refactoring annotations;integrated development environment;paper mockups","","7","","22","","8 Nov 2011","","","IEEE","IEEE Journals"
"A Tool-Supported Methodology for Validation and Refinement of Early-Stage Domain Models","M. Autili; A. Bertolino; G. De Angelis; D. D. Ruscio; A. D. Sandro","Department of Information Engineering Computer Science and Mathematics University of L’Aquila, Italy; CNR-ISTI of Pisa, Italy; CNR-ISTI of Pisa, Italy; Department of Information Engineering Computer Science and Mathematics University of L’Aquila, Italy; Department of Computer Science, University of Toronto, Toronto, ON, Canada","IEEE Transactions on Software Engineering","7 Jan 2016","2016","42","1","2","25","Model-driven engineering (MDE) promotes automated model transformations along the entire development process. Guaranteeing the quality of early models is essential for a successful application of MDE techniques and related tool-supported model refinements. Do these models properly reflect the requirements elicited from the owners of the problem domain? Ultimately, this question needs to be asked to the domain experts. The problem is that a gap exists between the respective backgrounds of modeling experts and domain experts. MDE developers cannot show a model to the domain experts and simply ask them whether it is correct with respect to the requirements they had in mind. To facilitate their interaction and make such validation more systematic, we propose a methodology and a tool that derive a set of customizable questionnaires expressed in natural language from each model to be validated. Unexpected answers by domain experts help to identify those portions of the models requiring deeper attention. We illustrate the methodology and the current status of the developed tool MOTHIA, which can handle UML Use Case, Class, and Activity diagrams. We assess MOTHIA effectiveness in reducing the gap between domain and modeling experts, and in detecting modeling faults on the European Project CHOReOS.","1939-3520","","10.1109/TSE.2015.2449319","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7132782","Domain Modeling;Early Stage Model;Model Driven Engineering;Model Refinement;Model Validation;Natural Language Questionnaires;Semantic Model Quality;Domain modeling;early stage model;model driven engineering;model refinement;model validation;natural language questionnaires;semantic model quality","Unified modeling language;Semantics;Context modeling;Load modeling;Engines;Biological system modeling;Context","natural language processing;Unified Modeling Language","early-stage domain model;model-driven engineering;automated model transformation;MDE technique;tool-supported model refinement;natural language;MOTHIA;UML;activity diagram","","2","","50","","24 Jun 2015","","","IEEE","IEEE Journals"
"Variability Analysis of Requirements: Considering Behavioral Differences and Reflecting Stakeholders’ Perspectives","N. Itzik; I. Reinhartz-Berger; Y. Wand","Department of Information Systems, University of Haifa, Haifa, Israel; Department of Information Systems, University of Haifa, Haifa, Israel; Sauder School of Business, University of British Columbia, Vancouver, BC, Canada","IEEE Transactions on Software Engineering","14 Jul 2016","2016","42","7","687","706","Adoption of Software Product Line Engineering (SPLE) to support systematic reuse of software-related artifacts within product families is challenging, time-consuming and error-prone. Analyzing the variability of existing artifacts needs to reflect different perspectives and preferences of stakeholders in order to facilitate decisions in SPLE adoption. Considering that requirements drive many development methods and activities, we introduce an approach to analyze variability of behaviors as presented in functional requirements. The approach, called semantic and ontological variability analysis (SOVA), uses ontological and semantic considerations to automatically analyze differences between initial states (preconditions), external events (triggers) that act on the system, and final states (post-conditions) of behaviors. The approach generates feature diagrams typically used in SPLE to model variability. Those diagrams are organized according to perspective profiles, reflecting the needs and preferences of the potential stakeholders for given tasks. We conducted an empirical study to examine the usefulness of the approach by comparing it to an existing tool which is mainly based on a latent semantic analysis measurement. SOVA appears to create outputs that are more comprehensible in significantly shorter times. These results demonstrate SOVA's potential to allow for flexible, behavior-oriented variability analysis.","1939-3520","","10.1109/TSE.2015.2512599","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7366597","Software product line engineering;variability analysis;feature diagrams;requirements specifications;ontology","Stakeholders;Software;Semantics;Feature extraction;Software product lines;Systematics","formal specification;ontologies (artificial intelligence);software product lines","behavior-oriented variability analysis;latent semantic analysis measurement;model variability;feature diagrams;SOVA;semantic-and-ontological variability analysis;SPLE adoption;software product line engineering;requirements variability analysis","","23","","53","","25 Dec 2015","","","IEEE","IEEE Journals"
"A Static Approach to Prioritizing JUnit Test Cases","H. Mei; D. Hao; L. Zhang; L. Zhang; J. Zhou; G. Rothermel","Peking University, Beijing; Peking University, Beijing; Peking University, Beijing; Peking University, Beijing; Peking University, Beijing; University of Nebraska, Lincoln","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1258","1275","Test case prioritization is used in regression testing to schedule the execution order of test cases so as to expose faults earlier in testing. Over the past few years, many test case prioritization techniques have been proposed in the literature. Most of these techniques require data on dynamic execution in the form of code coverage information for test cases. However, the collection of dynamic code coverage information on test cases has several associated drawbacks including cost increases and reduction in prioritization precision. In this paper, we propose an approach to prioritizing test cases in the absence of coverage information that operates on Java programs tested under the JUnit framework-an increasingly popular class of systems. Our approach, JUnit test case Prioritization Techniques operating in the Absence of coverage information (JUPTA), analyzes the static call graphs of JUnit test cases and the program under test to estimate the ability of each test case to achieve code coverage, and then schedules the order of these test cases based on those estimates. To evaluate the effectiveness of JUPTA, we conducted an empirical study on 19 versions of four Java programs ranging from 2K-80K lines of code, and compared several variants of JUPTA with three control techniques, and several other existing dynamic coverage-based test case prioritization techniques, assessing the abilities of the techniques to increase the rate of fault detection of test suites. Our results show that the test suites constructed by JUPTA are more effective than those in random and untreated test orders in terms of fault-detection effectiveness. Although the test suites constructed by dynamic coverage-based techniques retain fault-detection effectiveness advantages, the fault-detection effectiveness of the test suites constructed by JUPTA is close to that of the test suites constructed by those techniques, and the fault-detection effectiveness of the test suites constructed by some of JUPTA's variants is better than that of the test suites constructed by several of those techniques.","1939-3520","","10.1109/TSE.2011.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363461","Software testing;regression testing;test case prioritization;JUnit;call graph","Software testing;Regression analysis;Scheduling","Java;program testing;regression analysis;software fault tolerance","static approach;regression testing;test case prioritization techniques;dynamic code coverage information;Java programs;JUnit test case prioritization techniques operating in the absence of coverage information;JUPTA;static call graphs;fault-detection effectiveness;dynamic coverage-based techniques","","74","","44","","29 Nov 2012","","","IEEE","IEEE Journals"
"A Qualitative Study of Application-Level Caching","J. Mertz; I. Nunes","Instituto de Informática, Universidade Federal do Rio Grande do Sul, Porto Alegre-RS, Brazil; Instituto de Informática, Universidade Federal do Rio Grande do Sul, Porto Alegre-RS, Brazil","IEEE Transactions on Software Engineering","15 Sep 2017","2017","43","9","798","816","Latency and cost of Internet-based services are encouraging the use of application-level caching to continue satisfying users' demands, and improve the scalability and availability of origin servers. Despite its popularity, this level of caching involves the manual implementation by developers and is typically addressed in an ad-hoc way, given that it depends on specific details of the application. As a result, application-level caching is a time-consuming and error-prone task, becoming a common source of bugs. Furthermore, it forces application developers to reason about a crosscutting concern, which is unrelated to the application business logic. In this paper, we present the results of a qualitative study of how developers handle caching logic in their web applications, which involved the investigation of ten software projects with different characteristics. The study we designed is based on comparative and interactive principles of grounded theory, and the analysis of our data allowed us to extract and understand how developers address cache-related concerns to improve performance and scalability of their web applications. Based on our analysis, we derived guidelines and patterns, which guide developers while designing, implementing and maintaining application-level caching, thus supporting developers in this challenging task that is crucial for enterprise web applications.","1939-3520","","10.1109/TSE.2016.2633992","CNPq; CNPq; CAPES; BRA; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7762909","Application-level caching;qualitative study;pattern;guideline;web application","Databases;Guidelines;Maintenance engineering;Servers;Software;Scalability;HTML","cache storage;Internet;project management;software management","application-level caching;Internet-based services;caching logic;Web applications;software projects","","3","","59","Traditional","1 Dec 2016","","","IEEE","IEEE Journals"
"Mutable Protection Domains: Adapting System Fault Isolation for Reliability and Efficiency","G. Parmer; R. West","The George Washington University, Washtington, DC; Boston University, Boston","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","875","888","As software systems are becoming increasingly complex, the likelihood of faults and unexpected behaviors will naturally increase. Today, mobile devices to large-scale servers feature many millions of lines of code. Compile-time checks and offline verification methods are unlikely to capture all system states and control flow interactions of a running system. For this reason, many researchers have developed methods to contain faults at runtime by using software and hardware-based techniques to define protection domains. However, these approaches tend to impose isolation boundaries on software components that are static, and thus remain intact while the system is running. An unfortunate consequence of statically structured protection domains is that they may impose undue overhead on the communication between separate components. This paper proposes a new runtime technique that trades communication cost for fault isolation. We describe Mutable Protection Domains (MPDs) in the context of our Composite operating system. MPD dynamically adapts hardware isolation between interacting software components, depending on observed communication “hot-paths,” with the purpose of maximizing fault isolation where possible. In this sense, MPD naturally tends toward a system of maximal component isolation, while collapsing protection domains where costs are prohibitive. By increasing isolation for low-cost interacting components, MPD limits the scope of impact of future unexpected faults. We demonstrate the utility of MPD using a webserver, and identify different hot-paths for different workloads that dictate adaptations to system structure. Experiments show up to 40 percent improvement in throughput compared to a statically organized system, while maintaining high-fault isolation.","1939-3520","","10.1109/TSE.2011.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5928356","Component-based;operating systems;reliability;fault isolation;performance","Kernel;Reliability;Hardware;Servers;Switches","fault tolerant computing;mobile computing;object-oriented programming;operating systems (computers)","mutable protection domains;system fault isolation;software systems;mobile devices;large-scale servers;compile-time checks;offline verification methods;control flow interactions;hardware-based techniques;software -based techniques;software components;MPD;composite operating system;fault isolation;maximal component isolation;mobile computing","","4","","40","","23 Jun 2011","","","IEEE","IEEE Journals"
"An Approach to Checking Consistency between UML Class Model and Its Java Implementation","H. M. Chavez; W. Shen; R. B. France; B. A. Mechling; G. Li","Computer Science, Kalamazoo, MI; Computer Science, Kalamazoo, MI; Computer Science, Fort Collins, United States; Computer Science, Kalamazoo, MI; State Key Lab. of Computer Science, Institute of Software, Beijing, China","IEEE Transactions on Software Engineering","14 Apr 2016","2016","42","4","322","344","Model Driven Engineering (MDE) aims to expedite the software development process by providing support for transforming models to running systems. Many modeling tools provide forward engineering features, which automatically translate a model into a skeletal program that developers must complete. Inconsistencies between a design model and its implementation, however, can arise, particularly when a final implementation is developed dependently on the code from which it was generated. Manually checking that an implementation conforms to its model is a daunting task. Thus, an MDE tool that developers can use to check that implementations conform to their models can significantly improve a developer's productivity. This paper presents a model-based approach for testing whether or not an implementation satisfies the constraints imposed by its design model. Our model-based testing approach aims to efficiently reduce the test input space while supporting branch coverage criteria. To evaluate the approach's ability to uncover inconsistencies, we developed a prototypical tool and applied it to the Eclipse UML2 projects. We were able to uncover inconsistencies between the models and their implementations using the tool.","1939-3520","","10.1109/TSE.2015.2488645","National Natural Science Foundation of China; Open Project of Shanghai Key Lab. of Trustworthy Computing; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7294689","Class Diagrams;UML;Java;Model checking;Class diagrams;UML;Java;model checking","Unified modeling language;Java;Software;Object oriented modeling;Testing;Semantics","","","","3","","43","","8 Oct 2015","","","IEEE","IEEE Journals"
"Automatic Detection of Unsafe Dynamic Component Loadings","T. Kwon; Z. Su","University of California, Davis, Davis; University of California, Davis, Davis","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","293","313","Dynamic loading of software components (e.g., libraries or modules) is a widely used mechanism for an improved system modularity and flexibility. Correct component resolution is critical for reliable and secure software execution. However, programming mistakes may lead to unintended or even malicious components being resolved and loaded. In particular, dynamic loading can be hijacked by placing an arbitrary file with the specified name in a directory searched before resolving the target component. Although this issue has been known for quite some time, it was not considered serious because exploiting it requires access to the local file system on the vulnerable host. Recently, such vulnerabilities have started to receive considerable attention as their remote exploitation became realistic. It is now important to detect and fix these vulnerabilities. In this paper, we present the first automated technique to detect vulnerable and unsafe dynamic component loadings. Our analysis has two phases: 1) apply dynamic binary instrumentation to collect runtime information on component loading (online phase), and 2) analyze the collected information to detect vulnerable component loadings (offline phase). For evaluation, we implemented our technique to detect vulnerable and unsafe component loadings in popular software on Microsoft Windows and Linux. Our evaluation results show that unsafe component loading is prevalent in software on both OS platforms, and it is more severe on Microsoft Windows. In particular, our tool detected more than 4,000 unsafe component loadings in our evaluation, and some can lead to remote code execution on Microsoft Windows.","1939-3520","","10.1109/TSE.2011.108","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6065738","Unsafe component loading;dynamic analysis.","Loading;Instruments;Image resolution;Operating systems;Linux;Security","Linux;object-oriented programming;operating systems (computers);security of data;software libraries;software reliability;system monitoring","automatic detection;unsafe dynamic component loadings;dynamic loading;software components;software libraries;software modules;system modularity;system flexibility;component resolution;software execution;malicious components;arbitrary file;file system;vulnerable host;remote exploitation;automated technique;vulnerable dynamic component loadings;dynamic binary instrumentation;runtime information;vulnerable component loadings;Microsoft Windows;Linux;unsafe component loading;OS platforms;remote code execution","","2","1","50","","1 Nov 2011","","","IEEE","IEEE Journals"
"Formal Specification-Based Inspection for Verification of Programs","S. Liu; Y. Chen; F. Nagoya; J. A. McDermid","Hosei University, Koganei-shi; Shanghai Jiaotong University, Shanghai; Aoyama Gakuin University, Tokyo; University of York, York","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1100","1122","Software inspection is a static analysis technique that is widely used for defect detection, but which suffers from a lack of rigor. In this paper, we address this problem by taking advantage of formal specification and analysis to support a systematic and rigorous inspection method. The aim of the method is to use inspection to determine whether every functional scenario defined in the specification is implemented correctly by a set of program paths and whether every program path of the program contributes to the implementation of some functional scenario in the specification. The method is comprised of five steps: deriving functional scenarios from the specification, deriving paths from the program, linking scenarios to paths, analyzing paths against the corresponding scenarios, and producing an inspection report, and allows for a systematic and automatic generation of a checklist for inspection. We present an example to show how the method can be used, and describe an experiment to evaluate its performance by comparing it to perspective-based reading (PBR). The result shows that our method may be more effective in detecting function-related defects than PBR but slightly less effective in detecting implementation-related defects. We also describe a prototype tool to demonstrate the supportability of the method, and draw some conclusions about our work.","1939-3520","","10.1109/TSE.2011.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6035726","Specification-based program inspection;software inspection;formal specification;program verification","DH-HEMTs;High definition video;Three dimensional displays","formal specification;formal verification","formal specification based inspection;program verification;software inspection;defect detection;automatic generation;systematic generation;perspective based reading;PBR;prototype tool","","21","","80","","6 Oct 2011","","","IEEE","IEEE Journals"
"Providing Architectural Languages and Tools Interoperability through Model Transformation Technologies","I. Malavolta; H. Muccini; P. Pelliccione; D. Tamburri","University of L'Aquila, L'Aquila; University of L'Aquila, L'Aquila; University of L'Aquila, L'Aquila; University of L'Aquila, L'Aquila","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","119","140","Many architectural languages have been proposed in the last 15 years, each one with the chief aim of becoming the ideal language for specifying software architectures. What is evident nowadays, instead, is that architectural languages are defined by stakeholder concerns. Capturing all such concerns within a single, narrowly focused notation is impossible. At the same time, it is also impractical to define and use a ""universal"" notation, such as UML. As a result, many domain-specific notations for architectural modeling have been proposed, each one focusing on a specific application domain, analysis type, or modeling environment. As a drawback, a proliferation of languages exists, each one with its own specific notation, tools, and domain specificity. No effective interoperability is possible to date. Therefore, if a software architect has to model a concern not supported by his own language/tool, he has to manually transform (and, eventually, keep aligned) the available architectural specification into the required language/tool. This paper presents DUALLy, an automated framework that allows architectural languages and tools interoperability. Given a number of architectural languages and tools, they can all interoperate thanks to automated model transformation techniques. DUALLy is implemented as an Eclipse plugin. Putting it in practice, we apply the DUALLy approach to the Darwin/FSP ADL and to a UML2.0 profile for software architectures. By making use of an industrial complex system, we transform a UML software architecture specification in Darwin/FSP, make some verifications by using LTSA, and reflect changes required by the verifications back to the UML specification.","1939-3520","","10.1109/TSE.2009.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5204094","Software architectures;interoperability;domain-specific architectures;design tools and techniques;model transformations.","Software architecture;Unified modeling language;Computer architecture;Application software;Software tools;Computer industry;Architecture description languages;LAN interconnection;Domain specific languages;Software systems","open systems;software architecture;Unified Modeling Language","architectural languages;tools interoperability;automated model transformation techniques;Eclipse plugin;UML2.0 profile;DUALLy approach;Darwin-FSP ADL;industrial complex system;UML software architecture specification","","49","","35","","18 Aug 2009","","","IEEE","IEEE Journals"
"Online Reliability Prediction via Motifs-Based Dynamic Bayesian Networks for Service-Oriented Systems","H. Wang; L. Wang; Q. Yu; Z. Zheng; A. Bouguettaya; M. R. Lyu","School of Computer Science and Engineering and Key Laboratory of Computer Network and Information Integration, Southeast University, SIPAILOU 2, Nanjing, China; School of Computer Science and Engineering and Key Laboratory of Computer Network and Information Integration, Southeast University, SIPAILOU 2, Nanjing, China; College of Computing and Information Sciences, Rochester Institute of Technology, 102 Lomb Memorial Drive, Rochester, NY; School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China; School of Information Technologies, The University of Sydney, NSW, Australia; Department of Computer Science and Engineering, Shenzhen Research Institute, The Chinese University of Hong Kong, Shatin, Hong Kong, China","IEEE Transactions on Software Engineering","12 Jun 2017","2017","43","6","556","579","A service-oriented System of Systems (SoS) considers a system as a service and constructs a robust and value-added SoS by outsourcing external component systems through service composition techniques. Online reliability prediction for the component systems for the purpose of assuring the overall Quality of Service (QoS) is often a major challenge in coping with a loosely coupled SoS operating under dynamic and uncertain running environments. It is also a prerequisite for guaranteeing runtime QoS of a SoS through optimal service selection for reliable system construction. We propose a novel online reliability time series prediction approach for the component systems in a service-oriented SoS. We utilize Probabilistic Graphical Models (PGMs) to yield near-future, time series predictions. We assess the approach via invocation records collected from widely used real Web services. Experimental results have confirmed the effectiveness of the approach.","1939-3520","","10.1109/TSE.2016.2615615","NSFC; Novel Software Technology and Industrialization and Wireless Communications Technology; Australian Research Council’s; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7585067","Online reliability prediction;time series;service-oriented computing;system of systems","Time series analysis;Quality of service;Web services;Throughput;Software reliability;Time factors","belief networks;service-oriented architecture","online reliability prediction;motifs-based dynamic Bayesian networks;service-oriented system of systems;service composition;component systems;quality of service;QoS;uncertain running environments;optimal service selection;reliable system construction;online reliability time series prediction;service-oriented SoS;probabilistic graphical models;PGM;time series predictions;invocation records;real Web services","","17","","70","","6 Oct 2016","","","IEEE","IEEE Journals"
"Enhanced Modeling and Solution of Layered Queueing Networks","G. Franks; T. Al-Omari; M. Woodside; O. Das; S. Derisavi","Carleton University, Ottawa; IBM, Toronto; Carleton University , Ottawa; Ryerson University, Toronto; IBM, Toronto","IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","148","161","Layered queues are a canonical form of extended queueing network for systems with nested multiple resource possession, in which successive depths of nesting define the layers. The model has been applied to most modern distributed systems, which use different kinds of client-server and master-slave relationships, and scales up well. The layered queueing network (LQN) model is described here in a unified fashion, including its many more extensions to match the semantics of sophisticated practical distributed and parallel systems. These include efficient representation of replicated services, parallel and quorum execution, and dependability analysis under failure and reconfiguration. The full LQN model is defined here and its solver is described. A substantial case study to an air traffic control system shows errors (compared to simulation) of a few percent. The LQN model is compared to other models and solutions, and is shown to cover all their features.","1939-3520","","10.1109/TSE.2008.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4620121","Performance;Modeling and prediction;Queuing theory;Performance;Modeling and prediction;Queuing theory","Network servers;Application software;File servers;Master-slave;Failure analysis;Air traffic control;Error correction;Computational modeling;Queueing analysis;Distributed computing","client-server systems;parallel processing;queueing theory","layered queueing network;canonical form;nested multiple resource possession;distributed system;client-server system;master-slave system;semantics matching;parallel system;replicated service;quorum execution;dependability analysis;air traffic control system","","88","","42","","5 Sep 2008","","","IEEE","IEEE Journals"
"Solving the Class Responsibility Assignment Problem in Object-Oriented Analysis with Multi-Objective Genetic Algorithms","M. Bowman; L. C. Briand; Y. Labiche","Carleton University, Ottawa; Simula Research Laboratory, Lysaker and University of Oslo, Norway; Carleton University, Ottawa","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","817","837","In the context of object-oriented analysis and design (OOAD), class responsibility assignment is not an easy skill to acquire. Though there are many methodologies for assigning responsibilities to classes, they all rely on human judgment and decision making. Our objective is to provide decision-making support to reassign methods and attributes to classes in a class diagram. Our solution is based on a multi-objective genetic algorithm (MOGA) and uses class coupling and cohesion measurement for defining fitness functions. Our MOGA takes as input a class diagram to be optimized and suggests possible improvements to it. The choice of a MOGA stems from the fact that there are typically many evaluation criteria that cannot be easily combined into one objective, and several alternative solutions are acceptable for a given OO domain model. Using a carefully selected case study, this paper investigates the application of our proposed MOGA to the class responsibility assignment problem, in the context of object-oriented analysis and domain class models. Our results suggest that the MOGA can help correct suboptimal class responsibility assignment decisions and perform far better than simpler alternative heuristics such as hill climbing and a single-objective GA.","1939-3520","","10.1109/TSE.2010.70","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5530324","Object-oriented analysis and design;class responsibility assignment;UML;genetic algorithm.","Algorithm design and analysis;Genetic algorithms;Object oriented modeling;Context modeling;Unified modeling language;Decision making;Humans;Software quality;Genetic engineering;Laboratories","decision making;genetic algorithms;object-oriented methods","class responsibility assignment problem;object-oriented analysis;multiobjective genetic algorithm;object-oriented design;decision making support;class coupling;cohesion measurement;class diagram;object-oriented domain model;domain class model;hill climbing;single-objective genetic algorithm","","56","","40","","29 Jul 2010","","","IEEE","IEEE Journals"
"First, Debug the Test Oracle","X. Guo; M. Zhou; X. Song; M. Gu; J. Sun","School of Software, Tsinghua University, Beijing, China; School of Software, Tsinghua University, Beijing, China; Department of Electrical and Computer Engineering, Portland State University, Portland, OR; School of Software, Tsinghua University, Beijing, China; School of Software, Tsinghua University, Beijing, China","IEEE Transactions on Software Engineering","13 Oct 2015","2015","41","10","986","1000","Opposing to the oracle assumption, a trustworthy test oracle is not always available in real practice. Since manually written oracles and human judgements are still widely used, testers and programmers are in fact facing a high risk of erroneous test oracles. However, test oracle errors can bring much confusion thus causing extra time consumption in the debugging process. As substantiated by our experiment on the Siemens Test Suite, automatic fault localization algorithms suffer severely from erroneous test oracles, which impede them from reducing debugging time to the full extent. This paper proposes a simple but effective approach to debug the test oracle. Based on the observation that test cases covering similar lines of code usually generate similar results, we are able to identify suspicious test cases that are differently judged by the test oracle from their neighbors. To validate the effectiveness of our approach, experiments are conducted on both the Siemens Test Suite and grep. The results show that averagely over 75 percent of the highlighted test cases are actually test oracle errors. Moreover, performance of fault localization algorithms recovered remarkably with the debugged oracles.","1939-3520","","10.1109/TSE.2015.2425392","NSFC Program; National Key Technologies R&D Program; Postdoctoral Science Foundation of China; National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7091939","test oracle;debugging;spectrum-based fault localization;Test oracle;debugging;spectrum-based fault localization","Accuracy;Debugging;Measurement;Manuals;Error analysis;Software;Algorithm design and analysis","fault diagnosis;program debugging;program testing","test oracle debugging;oracle error testing;Siemens Test Suite;automatic fault localization algorithm","","3","","34","","22 Apr 2015","","","IEEE","IEEE Journals"
"Automating Live Update for Generic Server Programs","C. Giuffrida; C. Iorgulescu; G. Tamburrelli; A. S. Tanenbaum","Vrije Universiteit Amsterdam, De Boelelaan, Amsterdam, Netherlands; École Polytechnique Fédérale de Lausanne, Lausanne, Switzerland; Vrije Universiteit Amsterdam, De Boelelaan, Amsterdam, Netherlands; Vrije Universiteit Amsterdam, De Boelelaan, Amsterdam, Netherlands","IEEE Transactions on Software Engineering","14 Mar 2017","2017","43","3","207","225","The pressing demand to deploy software updates without stopping running programs has fostered much research on live update systems in the past decades. Prior solutions, however, either make strong assumptions on the nature of the update or require extensive and error-prone manual effort, factors which discourage the adoption of live update. This paper presents Mutable Checkpoint-Restart (MCR), a new live update solution for generic (multiprocess and multithreaded) server programs written in C. Compared to prior solutions, MCR can support arbitrary software updates and automate most of the common live update operations. The key idea is to allow the running version to safely reach a quiescent state and then allow the new version to restart as similarly to a fresh program initialization as possible, relying on existing code paths to automatically restore the old program threads and reinitialize a relevant portion of the program data structures. To transfer the remaining data structures, MCR relies on a combination of precise and conservative garbage collection techniques to trace all the global pointers and apply the required state transformations on the fly. Experimental results on popular server programs (Apache httpd, nginx, OpenSSH and vsftpd) confirm that our techniques can effectively automate problems previously deemed difficult at the cost of negligible performance overhead (2 percent on average) and moderate memory overhead (3.9$\times$  on average, without optimizations).","1939-3520","","10.1109/TSE.2016.2584066","European Research Council; ERC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7497481","Live update;DSU;checkpoint-restart;quiescence detection;record-replay;garbage collection","Servers;Data structures;Convergence;Software;Manuals;System recovery;Buildings","","","","5","","57","","22 Jun 2016","","","IEEE","IEEE Journals"
"Conservative Bounds for the pfd of a 1-out-of-2 Software-Based System Based on an Assessor's Subjective Probability of ""Not Worse Than Independence""","B. Littlewood; A. Povyakalo","City University, London, London; City University, London, London","IEEE Transactions on Software Engineering","22 Nov 2013","2013","39","12","1641","1653","We consider the problem of assessing the reliability of a 1-out-of-2 software-based system, in which failures of the two channels cannot be assumed to be independent with certainty. An informal approach to this problem assesses the channel probabilities of failure on demand (pfds) conservatively, and then multiplies these together in the hope that the conservatism will be sufficient to overcome any possible dependence between the channel failures. Our intention here is to place this kind of reasoning on a formal footing. We introduce a notion of ""not worse than independence""' and assume that an assessor has a prior belief about this, expressed as a probability. We obtain a conservative prior system pfd, and show how a conservative posterior system pfd can be obtained following the observation of a number of demands without system failure. We present some illustrative numerical examples, discuss some of the difficulties involved in this way of reasoning, and suggest some avenues of future research.","1939-3520","","10.1109/TSE.2013.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6564279","System reliability;software fault tolerance;1-out-of-2 system;dependent failures;subjective probability","Phase frequency detector;Cognition;Software reliability;Fault tolerant systems;Software reliability;Reliability engineering;Failure analysis","probability;software reliability","conservative bounds;1-out-of-2 software-based system reliability;assessor subjective probability;channel probabilities of failure on demand;formal footing;not worse than independence;conservative posterior system PFD","","6","","14","","19 Jul 2013","","","IEEE","IEEE Journals"
"Multi-Objective Quality-Driven Service Selection—A Fully Polynomial Time Approximation Scheme","I. Trummer; B. Faltings; W. Binder","Artificial Intelligence Laboratory , École Polytechnique Fédérale de Lausanne, Switzerland; Artificial Intelligence Laboratory , École Polytechnique Fédérale de Lausanne, Switzerland; Faculty of Informatics, University of Lugano, Via Giuseppe Buffi 13, Switzerland","IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","2","167","191","The goal of multi-objective quality-driven service selection (QDSS) is to find service selections for a workflow whose quality-of-service (QoS) values are Pareto-optimal. We consider multiple QoS attributes such as response time, cost, and reliability. A selection is Pareto-optimal if no other selection has better QoS values for some attributes and at least equivalent values for all others. Exact algorithms have been proposed that find all Pareto-optimal selections. They suffer however from exponential complexity. Randomized algorithms scale well but do not offer any formal guarantees on result precision. We present the first approximation scheme for QDSS. It aims at the sweet spot between exact and randomized algorithms: It combines polynomial complexity with formal result precision guarantees. A parameter allows to seamlessly trade result precision against efficiency. We formally analyze complexity and precision guarantees and experimentally compare our algorithm against exact and randomized approaches. Comparing with exact algorithms, our approximation scheme allows to reduce optimization time from hours to seconds. Its approximation error remains below 1.4 percent while randomized algorithms come close to the theoretical maximum.","1939-3520","","10.1109/TSE.2013.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6687160","Quality-driven service selection;multi-objective optimization;approximation algorithms","Quality of service;Approximation methods;Approximation algorithms;Polynomials;Complexity theory;Optimization;Motion pictures","Pareto optimisation;polynomial approximation;quality of service;software quality","approximation error;optimization time;polynomial complexity;randomized algorithms;exponential complexity;Pareto optimal selections;least equivalent values;QoS values;Pareto optimal;quality-of-service;QDSS;fully polynomial time approximation scheme;multiobjective quality driven service selection","","35","","35","","18 Dec 2013","","","IEEE","IEEE Journals"
"You Are the Only Possible Oracle: Effective Test Selection for End Users of Interactive Machine Learning Systems","A. Groce; T. Kulesza; C. Zhang; S. Shamasunder; M. Burnett; W. -K. Wong; S. Stumpf; S. Das; A. Shinsel; F. Bice; K. McIntosh","School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; Centre for HCI Design, School of Informatics, City University London, London, United Kingdom; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis","IEEE Transactions on Software Engineering","31 Mar 2014","2014","40","3","307","323","How do you test a program when only a single user, with no expertise in software testing, is able to determine if the program is performing correctly? Such programs are common today in the form of machine-learned classifiers. We consider the problem of testing this common kind of machine-generated program when the only oracle is an end user: e.g., only you can determine if your email is properly filed. We present test selection methods that provide very good failure rates even for small test suites, and show that these methods work in both large-scale random experiments using a “gold standard” and in studies with real users. Our methods are inexpensive and largely algorithm-independent. Key to our methods is an exploitation of properties of classifiers that is not possible in traditional software testing. Our results suggest that it is plausible for time-pressured end users to interactively detect failures-even very hard-to-find failures-without wading through a large number of successful (and thus less useful) tests. We additionally show that some methods are able to find the arguably most difficult-to-detect faults of classifiers: cases where machine learning algorithms have high confidence in an incorrect result.","1939-3520","","10.1109/TSE.2013.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6682887","Machine learning;end-user testing;test suite size","Testing;Software;Training;Training data;Electronic mail;Software algorithms;Machine learning algorithms","interactive systems;learning (artificial intelligence);program testing","effective test selection;interactive machine learning systems;end users;program testing;software testing;machine learned classifiers;machine generated program;email;hard-to-find failures;interactive failure detection","","16","","63","","12 Dec 2013","","","IEEE","IEEE Journals"
"A Two-Component Language for Adaptation: Design, Semantics and Program Analysis","P. Degano; G. Ferrari; L. Galletta","Dipartimento di Informatica, Università di Pisa, Pisa, Italia; Dipartimento di Informatica, Università di Pisa, Pisa, Italia; Dipartimento di Informatica, Università di Pisa, Pisa, Italia","IEEE Transactions on Software Engineering","10 Jun 2016","2016","42","6","505","529","Adaptive systems are designed to modify their behaviour in response to changes of their operational environment. We propose a two-component language for adaptive programming, within the Context-Oriented Programming paradigm. It has a declarative constituent for programming the context and a functional one for computing. We equip our language with a dynamic formal semantics. Since wrong adaptation could severely compromise the correct behaviour of applications and violate their properties, we also introduce a two-phase verification mechanism. It is based on a type and effect system that type-checks programs and computes, as an effect, a sound approximation of their behaviour. The effect is exploited at load time to mechanically verify that programs correctly adapt themselves to all possible running environments.","1939-3520","","10.1109/TSE.2015.2496941","MIUR Prin Project; Università di Pisa PRA project; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7314969","Adaptive Software;Context Oriented Programming;Formal Methods;Datalog;Functional Programming;Semantics;Type Systems;Verification;Adaptive software;context oriented programming;formal methods;datalog;functional programming;semantics;type systems;verification","Context;Programming;Software;Semantics;Standards;Adaptation models;Computer languages","high level languages;program diagnostics;program verification","two-component language;program analysis;adaptive programming;context-oriented programming paradigm;dynamic formal semantics;two-phase verification mechanism;program type-check","","9","","95","","2 Nov 2015","","","IEEE","IEEE Journals"
"GenProg: A Generic Method for Automatic Software Repair","C. Le Goues; T. Nguyen; S. Forrest; W. Weimer","University of Virginia, Charlottesville; University of New Mexico, Albuquerque; University of New Mexico, Albuquerque; University of Virginia, Charlottesville","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","54","72","This paper describes GenProg, an automated method for repairing defects in off-the-shelf, legacy programs without formal specifications, program annotations, or special coding practices. GenProg uses an extended form of genetic programming to evolve a program variant that retains required functionality but is not susceptible to a given defect, using existing test suites to encode both the defect and required functionality. Structural differencing algorithms and delta debugging reduce the difference between this variant and the original program to a minimal repair. We describe the algorithm and report experimental results of its success on 16 programs totaling 1.25 M lines of C code and 120K lines of module code, spanning eight classes of defects, in 357 seconds, on average. We analyze the generated repairs qualitatively and quantitatively to demonstrate that the process efficiently produces evolved programs that repair the defect, are not fragile input memorizations, and do not lead to serious degradation in functionality.","1939-3520","","10.1109/TSE.2011.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6035728","Automatic programming;corrections;testing and debugging.","Maintenance engineering;Encoding;Computer bugs;Automatic programming;Debugging;Syntactics","formal specification;genetic algorithms;software maintenance","GenProg;automatic software repair;defects repair;legacy programs;formal specifications;program annotations;special coding practices;genetic programming","","350","4","75","","6 Oct 2011","","","IEEE","IEEE Journals"
"Autofolding for Source Code Summarization","J. Fowkes; P. Chanthirasegaran; R. Ranca; M. Allamanis; M. Lapata; C. Sutton","School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; Tractable, Oval Office, London, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK; School of Informatics, University of Edinburgh, Edinburgh, UK","IEEE Transactions on Software Engineering","8 Dec 2017","2017","43","12","1095","1109","Developers spend much of their time reading and browsing source code, raising new opportunities for summarization methods. Indeed, modern code editors provide code folding, which allows one to selectively hide blocks of code. However this is impractical to use as folding decisions must be made manually or based on simple rules. We introduce the autofolding problem, which is to automatically create a code summary by folding less informative code regions. We present a novel solution by formulating the problem as a sequence of AST folding decisions, leveraging a scoped topic model for code tokens. On an annotated set of popular open source projects, we show that our summarizer outperforms simpler baselines, yielding a 28 percent error reduction. Furthermore, we find through a case study that our summarizer is strongly preferred by experienced developers. More broadly, we hope this work will aid program comprehension by turning code folding into a usable and valuable tool.","1939-3520","","10.1109/TSE.2017.2664836","Engineering and Physical Sciences Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7843666","Source code summarization, program comprehension, topic modelling","Software development;Natural languages;Source coding;Feature extraction;Complexity theory","public domain software;source code (software)","source code summarization;modern code editors;code folding;autofolding problem;informative code regions;AST folding decisions;code tokens;open source projects","","6","","62","Traditional","6 Feb 2017","","","IEEE","IEEE Journals"
"Generating Domain-Specific Visual Language Tools from Abstract Visual Specifications","J. C. Grundy; J. Hosking; K. N. Li; N. M. Ali; J. Huh; R. L. Li","Swinburne University University of Technology, Hawthorn; Australian National University, Canberra; SolNet Solutions Ltd, Wellington; Universiti Putra Malaysia, Kuala Lumpur; University of Auckland, Auckland; Beefand Lamb New Zealand Ltd, Wellington","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","487","515","Domain-specific visual languages support high-level modeling for a wide range of application domains. However, building tools to support such languages is very challenging. We describe a set of key conceptual requirements for such tools and our approach to addressing these requirements, a set of visual language-based metatools. These support definition of metamodels, visual notations, views, modeling behaviors, design critics, and model transformations and provide a platform to realize target visual modeling tools. Extensions support collaborative work, human-centric tool interaction, and multiplatform deployment. We illustrate application of the metatoolset on tools developed with our approach. We describe tool developer and cognitive evaluations of our platform and our exemplar tools, and summarize key future research directions.","1939-3520","","10.1109/TSE.2012.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6205768","Metatool;domain-specific visual language;software tool;visual specification;model-driven engineering","Visualization;Unified modeling language;Software;Computational modeling;Business;Abstracts;Electronic mail","cognition;formal specification;groupware;simulation languages;software tools;visual languages;visual programming","domain-specific visual language tool generation;abstract visual specifications;high-level modeling;application domains;conceptual requirements;visual language-based metatools;metamodels;visual notations;modeling behaviors;design critics;model transformations;visual modeling tools;collaborative work;human-centric tool interaction;multiplatform deployment;cognitive evaluations","","18","","79","","29 May 2012","","","IEEE","IEEE Journals"
"An Extensible Framework for Improving a Distributed Software System's Deployment Architecture","S. Malek; N. Medvidovic; M. Mikic-Rakic","George Mason University, Fairfax; University of Southern California, Los Angeles; Google Inc., Santa Monica","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","73","100","A distributed system's allocation of software components to hardware nodes (i.e., deployment architecture) can have a significant impact on its quality of service (QoS). For a given system, there may be many deployment architectures that provide the same functionality, but with different levels of QoS. The parameters that influence the quality of a system's deployment architecture are often not known before the system's initial deployment and may change at runtime. This means that redeployment of the software system may be necessary to improve the system's QoS properties. This paper presents and evaluates a framework aimed at finding the most appropriate deployment architecture for a distributed software system with respect to multiple, possibly conflicting QoS dimensions. The framework supports formal modeling of the problem and provides a set of tailorable algorithms for improving a system's deployment. We have realized the framework on top of a visual deployment architecture modeling and analysis environment. The framework has been evaluated for precision and execution-time complexity on a large number of simulated distributed system scenarios, as well as in the context of two third-party families of distributed applications.","1939-3520","","10.1109/TSE.2011.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680912","Software architecture;software deployment;quality of service;self-adaptive software.","Software architecture;Quality of service;Distributed processing","computational complexity;distributed processing;object-oriented methods;quality of service;resource allocation","extensible framework;distributed software system;software component allocation;hardware nodes;quality of service;QoS;tailorable algorithms;system deployment;visual deployment architecture modeling environment;visual deployment architecture analysis environment;precision-time complexity;execution-time complexity","","52","1","66","","6 Jan 2011","","","IEEE","IEEE Journals"
"Language Inclusion Checking of Timed Automata with Non-Zenoness","X. Wang; J. Sun; T. Wang; S. Qin","College of Computer Science, Zhejiang University, Hangzhou, P.R. China; Shenzhen University; College of Computer Science, Zhejiang University of Technology, Hangzhou, P.R. China; School of Computing, Teesside University, Middlesbrough, United Kingdom","IEEE Transactions on Software Engineering","10 Nov 2017","2017","43","11","995","1008","Given a timed automaton P modeling an implementation and a timed automaton S as a specification, the problem of language inclusion checking is to decide whether the language of P is a subset of that of S. It is known to be undecidable. The problem gets more complicated if non-Zenoness is taken into consideration. A run is Zeno if it permits infinitely many actions within finite time. Otherwise it is non-Zeno. Zeno runs might present in both P and S. It is necessary to check whether a run is Zeno or not so as to avoid presenting Zeno runs as counterexamples of language inclusion checking. In this work, we propose a zone-based semi-algorithm for language inclusion checking with non-Zenoness. It is further improved with simulation reduction based on LU-simulation. Though our approach is not guaranteed to terminate, we show that it does in many cases through empirical study. Our approach has been incorporated into the PAT model checker, and applied to multiple systems to show its usefulness.","1939-3520","","10.1109/TSE.2017.2653778","National Natural Science Foundation of China; Singapore University of Technology and Design; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819478","Timed automata;language inclusion;non-Zenoness","Automata;Clocks;Safety;Analytical models;Sun;Real-time systems;Semantics","automata theory;formal specification;formal verification","timed automata;language inclusion checking;nonZenoness;finite time;timed automaton modeling;specification;undecidability;zone-based semi-algorithm;simulation reduction;LU-simulation;PAT model checker","","","","40","Traditional","16 Jan 2017","","","IEEE","IEEE Journals"
"Self-Adapting Reliability in Distributed Software Systems","Y. Brun; J. y. Bang; G. Edwards; N. Medvidovic","School of Computer Science, University of Massachusetts, Amherst, MA; Computer Science Department, University of Southern California, Los Angeles, CA; Computer Science Department, University of Southern California, Los Angeles, CA; Computer Science Department, University of Southern California, Los Angeles, CA","IEEE Transactions on Software Engineering","11 Aug 2015","2015","41","8","764","780","Developing modern distributed software systems is difficult in part because they have little control over the environments in which they execute. For example, hardware and software resources on which these systems rely may fail or become compromised and malicious. Redundancy can help manage such failures and compromises, but when faced with dynamic, unpredictable resources and attackers, the system reliability can still fluctuate greatly. Empowering the system with self-adaptive and self-managing reliability facilities can significantly improve the quality of the software system and reduce reliance on the developer predicting all possible failure conditions. We present iterative redundancy, a novel approach to improving software system reliability by automatically injecting redundancy into the system's deployment. Iterative redundancy self-adapts in three ways: (1) by automatically detecting when the resource reliability drops, (2) by identifying unlucky parts of the computation that happen to deploy on disproportionately many compromised resources, and (3) by not relying on a priori estimates of resource reliability. Further, iterative redundancy is theoretically optimal in its resource use: Given a set of resources, iterative redundancy guarantees to use those resources to produce the most reliable version of that software system possible; likewise, given a desired increase in the system's reliability, iterative redundancy guarantees achieving that reliability using the least resources possible. Iterative redundancy handles even the Byzantine threat model, in which compromised resources collude to attack the system. We evaluate iterative redundancy in three ways. First, we formally prove its self-adaptation, efficiency, and optimality properties. Second, we simulate it at scale using discrete event simulation. Finally, we modify the existing, open-source, volunteer-computing BOINC software system and deploy it on the globally-distributed PlanetLab testbed network to empirically evaluate that iterative redundancy is self-adaptive and more efficient than existing techniques.","1939-3520","","10.1109/TSE.2015.2412134","DARPA; IARPA; National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7058381","Redundancy;reliability;fault-tolerance;iterative redundancy;self-adaptation;optimal redundancy;Redundancy;reliability;fault-tolerance;iterative redundancy;self-adaptation;optimal redundancy","Redundancy;Software reliability;Software systems;Computational modeling;Servers;Reliability engineering","discrete event simulation;distributed processing;public domain software;resource allocation;security of data;software quality;software reliability;system recovery","self-adapting reliability;distributed software systems;hardware resources;software resources;failure management;compromise management;dynamic unpredictable resources;system reliability;self-adaptive reliability;self-managing reliability;software system quality;failure condition;iterative redundancy;resource reliability estimate;Byzantine threat model;compromised resource collusion;optimality property;discrete event simulation;open-source volunteer-computing BOINC software system;globally-distributed PlanetLab testbed network","","7","","53","","11 Mar 2015","","","IEEE","IEEE Journals"
"Active learning and effort estimation: Finding the essential content of software effort estimation data","E. Kocaguneli; T. Menzies; J. Keung; D. Cok; R. Madachy","West Virginia University, Morgantown; West Virginia University, Morgantown; The City University of Hong Kong, Hong Kong; Grammatech Inc., Ithaca; Naval Postgraduate School, Monterrey","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1040","1053","Background: Do we always need complex methods for software effort estimation (SEE)? Aim: To characterize the essential content of SEE data, i.e., the least number of features and instances required to capture the information within SEE data. If the essential content is very small, then 1) the contained information must be very brief and 2) the value added of complex learning schemes must be minimal. Method: Our QUICK method computes the euclidean distance between rows (instances) and columns (features) of SEE data, then prunes synonyms (similar features) and outliers (distant instances), then assesses the reduced data by comparing predictions from 1) a simple learner using the reduced data and 2) a state-of-the-art learner (CART) using all data. Performance is measured using hold-out experiments and expressed in terms of mean and median MRE, MAR, PRED(25), MBRE, MIBRE, or MMER. Results: For 18 datasets, QUICK pruned 69 to 96 percent of the training data (median = 89 percent). K = 1 nearest neighbor predictions (in the reduced data) performed as well as CART's predictions (using all data). Conclusion: The essential content of some SEE datasets is very small. Complex estimation methods may be overelaborate for such datasets and can be simplified. We offer QUICK as an example of such a simpler SEE method.","1939-3520","","10.1109/TSE.2012.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392173","Software cost estimation;active learning;analogy;k-NN","Estimation;Indexes;Labeling;Frequency selective surfaces;Euclidean distance;Complexity theory;Principal component analysis","data handling;learning (artificial intelligence);software cost estimation;statistical analysis","software effort estimation;SEE data content;complex learning scheme;QUICK method;Euclidean distance;CART learner;mean;median;K-nearest neighbor prediction","","42","","50","","21 Dec 2012","","","IEEE","IEEE Journals"
"Reducing Feedback Delay of Software Development Tools via Continuous Analysis","K. Muşlu; Y. Brun; M. D. Ernst; D. Notkin","Department of Computer Science & Engineering, University of Washington, Seattle, WA; School of Computer Science, University of Massachusetts, Amherst, MA; Department of Computer Science & Engineering, University of Washington, Seattle, WA; Department of Computer Science & Engineering, University of Washington, Seattle, WA","IEEE Transactions on Software Engineering","11 Aug 2015","2015","41","8","745","763","During software development, the sooner a developer learns how code changes affect program analysis results, the more helpful that analysis is. Manually invoking an analysis may interrupt the developer's workflow or cause a delay before the developer learns the implications of the change. A better approach is continuous analysis tools that always provide up-to-date results. We present Codebase Replication, a technique that eases the implementation of continuous analysis tools by converting an existing offline analysis into an IDE-integrated, continuous tool with two desirable properties: isolation and currency. Codebase Replication creates and keeps in sync a copy of the developer's codebase. The analysis runs on the copy codebase without disturbing the developer and without being disturbed by the developer's changes. We developed Solstice, an open-source, publicly-available Eclipse plug-in that implements Codebase Replication. Solstice has less than 2.5 milliseconds overhead for most common developer actions. We used Solstice to implement four Eclipse-integrated continuous analysis tools based on the offline versions of FindBugs, PMD, data race detection, and unit testing. Each conversion required on average 710 LoC and 20 hours of implementation effort. Case studies indicate that Solstice-based continuous analysis tools are intuitive and easy-to-use.","1939-3520","","10.1109/TSE.2015.2417161","NSF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7069257","Continuous analysis;Codebase Replication;Solstice;Continuous analysis;Codebase Replication;Solstice","Delays;Software;Testing;Servers;Synchronization;Electronic mail;Interrupters","program diagnostics;program testing;software tools","feedback delay reduction;software development tools;program analysis;codebase replication;offline analysis;IDE-integrated;Solstice;open-source Eclipse plug-in;Eclipse-integrated continuous analysis tools;FindBugs;PMD;data race detection;unit testing","","6","","80","","26 Mar 2015","","","IEEE","IEEE Journals"
"Light-Weight, Inter-Procedural and Callback-Aware Resource Leak Detection for Android Apps","T. Wu; J. Liu; Z. Xu; C. Guo; Y. Zhang; J. Yan; J. Zhang","State Key Laboratory of Computer ScienceInstitute of SoftwareChinese Academy of Sciences; State Key Laboratory of Computer ScienceInstitute of SoftwareChinese Academy of Sciences; State Key Lab. of Comput. Sci., Inst. of Software, Beijing, China; State Key Lab. of Comput. Sci., Inst. of Software, Beijing, China; State Key Lab. of Comput. Sci., Inst. of Software, Beijing, China; State Key Laboratory of Computer ScienceInstitute of SoftwareChinese Academy of Sciences; State Key Laboratory of Computer ScienceInstitute of SoftwareChinese Academy of Sciences","IEEE Transactions on Software Engineering","10 Nov 2016","2016","42","11","1054","1076","Android devices include many embedded resources such as Camera, Media Player and Sensors. These resources require programmers to explicitly request and release them. Missing release operations might cause serious problems such as performance degradation or system crash. This kind of defects is called resource leak. Despite a large body of existing works on testing and analyzing Android apps, there still remain several challenging problems. In this work, we present Relda2, a light-weight and precise static resource leak detection tool. We first systematically collected a resource table, which includes the resources that the Android reference requires developers release manually. Based on this table, we designed a general approach to automatically detect resource leaks. To make a more precise inter-procedural analysis, we construct a Function Call Graph for each Android application, which handles function calls of user-defined methods and the callbacks invoked by the Android framework at the same time. To evaluate Relda2's effectiveness and practical applicability, we downloaded 103 apps from popular app stores and an open source community, and found 67 real resource leaks, which we have confirmed manually.","1939-3520","","10.1109/TSE.2016.2547385","National Basic Research (973); National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7442579","Android apps;resource leak;static analysis;byte-code analysis;inter-procedural analysis","Androids;Humanoid robots;Smart phones;Java;Testing;Leak detection;Computer bugs","Android (operating system);embedded systems;graph theory;program diagnostics;resource allocation","Android application;embedded resources;Relda2;interprocedural analysis;function call graph;static analysis;callback-aware resource leak detection tool","","24","","74","","28 Mar 2016","","","IEEE","IEEE Journals"
"Solving the Large Scale Next Release Problem with a Backbone-Based Multilevel Algorithm","J. Xuan; H. Jiang; Z. Ren; Z. Luo","Dalian University of Technology, Dalian; Dalian University of Technology, Dalian; Dalian University of Technology, Dalian; Dalian University of Technology, Dalian","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1195","1212","The Next Release Problem (NRP) aims to optimize customer profits and requirements selection for the software releases. The research on the NRP is restricted by the growing scale of requirements. In this paper, we propose a Backbone-based Multilevel Algorithm (BMA) to address the large scale NRP. In contrast to direct solving approaches, the BMA employs multilevel reductions to downgrade the problem scale and multilevel refinements to construct the final optimal set of customers. In both reductions and refinements, the backbone is built to fix the common part of the optimal customers. Since it is intractable to extract the backbone in practice, the approximate backbone is employed for the instance reduction while the soft backbone is proposed to augment the backbone application. In the experiments, to cope with the lack of open large requirements databases, we propose a method to extract instances from open bug repositories. Experimental results on 15 classic instances and 24 realistic instances demonstrate that the BMA can achieve better solutions on the large scale NRP instances than direct solving approaches. Our work provides a reduction approach for solving large scale problems in search-based requirements engineering.","1939-3520","","10.1109/TSE.2011.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6261327","The next release problem;backbone;soft backbone;multilevel algorithm;requirements instance generation;search-based requirements engineering","Approximation algorithms;Software;Software algorithms;Algorithm design and analysis;Optimization;Polynomials;Search problems","customer services;formal specification;program debugging;software development management;systems analysis","large scale next release problem;backbone-based multilevel algorithm;customer profit optimization;requirements selection;software releases;BMA;multilevel reductions;optimal customers;instance reduction;soft backbone;open large requirements databases;open bug repositories;large scale NRP instances;search-based requirements engineering;backbone extraction","","44","","69","","6 Aug 2012","","","IEEE","IEEE Journals"
"Engineering Adaptive Model-Driven User Interfaces","P. A. Akiki; A. K. Bandara; Y. Yu","Department of Computer Science, Notre Dame University—Louaize, Zouk Mosbeh, Lebanon; Computing and Communications Department, The Open University, Walton Hall, Milton Keynes, United Kingdom; Computing and Communications Department, The Open University, Walton Hall, Milton Keynes, United Kingdom","IEEE Transactions on Software Engineering","8 Dec 2016","2016","42","12","1118","1147","Software applications that are very large-scale, can encompass hundreds of complex user interfaces (UIs). Such applications are commonly sold as feature-bloated off-the-shelf products to be used by people with variable needs in the required features and layout preferences. Although many UI adaptation approaches were proposed, several gaps and limitations including: extensibility and integration in legacy systems, still need to be addressed in the state-of-the-art adaptive UI development systems. This paper presents Role-Based UI Simplification (RBUIS) as a mechanism for increasing usability through adaptive behavior by providing end-users with a minimal feature-set and an optimal layout, based on the context-of-use. RBUIS uses an interpreted runtime model-driven approach based on the Cedar Architecture, and is supported by the integrated development environment (IDE), Cedar Studio. RBUIS was evaluated by integrating it into OFBiz, an open-source ERP system. The integration method was assessed and measured by establishing and applying technical metrics. Afterwards, a usability study was carried out to evaluate whether UIs simplified with RBUIS show an improvement over their initial counterparts. This study leveraged questionnaires, checking task completion times and output quality, and eye-tracking. The results showed that UIs simplified with RBUIS significantly improve end-user efficiency, effectiveness, and perceived usability.","1939-3520","","10.1109/TSE.2016.2553035","Computing and Communications Department; The Open University; ERC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7451279","Design tools and techniques;software architectures;support for adaptation;user interfaces","Adaptation models;Adaptive systems;User interfaces;Usability;Computer architecture","ergonomics;programming environments;software architecture;software maintenance;user interfaces","IDE;integrated development environment;Cedar architecture;adaptive behavior;system usability;RBUIS;role-based UI simplification;legacy system integration;legacy system extensibility;engineering adaptive model-driven user interface","","15","","85","","12 Apr 2016","","","IEEE","IEEE Journals"
"On the Composability of Design Patterns","H. Zhu; I. Bayley","Oxford Brookes University, Oxford, United Kingdom; Oxford Brookes University, Oxford, United Kingdom","IEEE Transactions on Software Engineering","10 Nov 2015","2015","41","11","1138","1152","In real applications, design patterns are almost always to be found composed with each other. It is crucial that these compositions be validated. This paper examines the notion of validity, and develops a formal method for proving or disproving it, in a context where composition is performed with formally defined operators on formally specified patterns. In particular, for validity, we require that pattern compositions preserve the features, semantics and soundness of the composed patterns. The application of the theory is demonstrated by a formal analysis of overlap-based pattern compositions and a case study of a real pattern-oriented software design.","1939-3520","","10.1109/TSE.2015.2445341","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7123660","Design Patterns;Pattern composition;Composibility;Feature preservation;Semantics preservation;Soundness preservation;Formal methods;Design patterns;pattern composition;composibility;feature preservation;semantics preservation;soundness preservation;formal methods","Semantics;Unified modeling language;Context;Software systems;Software design;Cognition","formal specification;object-oriented methods","design pattern composability;formally specified patterns;formal analysis method;overlap-based pattern compositions;pattern-oriented software design","","9","","70","","15 Jun 2015","","","IEEE","IEEE Journals"
"Session Reliability of Web Systems under Heavy-Tailed Workloads: An Approach Based on Design and Analysis of Experiments","N. Janevski; K. Goseva-Popstojanova","West Virginia University, Morgantown; West Virginia University, Morgantown","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1157","1178","While workload characterization and performance of web systems have been studied extensively, reliability has received much less attention. In this paper, we propose a framework for session reliability modeling which integrates the user view represented by the session layer and the system view represented by the service layer. A unique characteristic of the session layer is that, in addition to the user navigation patterns, it incorporates the session length in number of requests and allows us to account for heavy-tailed workloads shown to exist in real web systems. The service layer is focused on the request reliability as it is observed at the service provider side. It considers the multifier web server architecture and the way components interact in serving each request. Within this framework, we develop a session reliability model and solve it using simulation. Instead of the traditional one-factor-at-a-time sensitivity analysis, we use statistical design and analysis of experiments, which allow us to identify the factors and interactions that have statistically significant effect on session reliability. Our findings indicate that session reliability, which accounts for the distribution of failed requests within sessions, provides better representation of the user perceived quality than the request-based reliability.","1939-3520","","10.1109/TSE.2013.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6409359","Reliability;statistical methods;modeling and prediction;simulation;web servers;Internet applications","Software reliability;Availability;Navigation;Web servers;Reliability engineering;Analytical models","design of experiments;Internet;sensitivity analysis;user interfaces","session reliability;Web system;design-of-experiment;analysis-of-experiment;workload characterization;user view;session layer;system view;service layer;user navigation pattern;heavy-tailed workload;request reliability;multifier Web server architecture;sensitivity analysis;user perceived quality;request-based reliability","","4","","58","","10 Jan 2013","","","IEEE","IEEE Journals"
"An Analysis and Survey of the Development of Mutation Testing","Y. Jia; M. Harman","University College London, London; University College London, London","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","649","678","Mutation Testing is a fault-based software testing technique that has been widely studied for over three decades. The literature on Mutation Testing has contributed a set of approaches, tools, developments, and empirical results. This paper provides a comprehensive analysis and survey of Mutation Testing. The paper also presents the results of several development trend analyses. These analyses provide evidence that Mutation Testing techniques and tools are reaching a state of maturity and applicability, while the topic of Mutation Testing itself is the subject of increasing interest.","1939-3520","","10.1109/TSE.2010.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5487526","Mutation testing;survey.","Genetic mutations;Software testing;Fault detection;History;Books;Programming profession;Computer languages;Java;Educational institutions;Automata","fault diagnosis;program testing","mutation testing development;fault-based software testing technique;empirical results;comprehensive analysis;development trend analysis;mutation testing technique;mutation testing tool","","684","1","264","","17 Jun 2010","","","IEEE","IEEE Journals"
"Static Fault Localization in Model Transformations","L. Burgueño; J. Troya; M. Wimmer; A. Vallecillo","Dept. Lenguajes y Ciencias de la Computación, Universidad de Málaga, Bulevar Louis Pasteur, 35, Malaga, Spain; Vienna University of Technology, Business Informatics Group, Vienna, Austria; Vienna University of Technology, Business Informatics Group, Vienna, Austria; Dept. Lenguajes y Ciencias de la Computación, Universidad de Málaga, Bulevar Louis Pasteur, 35, Malaga, Spain","IEEE Transactions on Software Engineering","12 May 2015","2015","41","5","490","506","As the complexity of model transformations grows, there is an increasing need to count on methods, mechanisms, and tools for checking their correctness, i.e., the alignment between specifications and implementations. In this paper we present a light-weight and static approach for locating the faulty rules in model transformations, based on matching functions that automatically establish these alignments using the metamodel footprints, i.e., the metamodel elements used. The approach is implemented for the combination of Tracts and ATL, both residing in the Eclipse Modeling Framework, and is supported by the corresponding toolkit. An evaluation discussing the accuracy and the limitations of the approach is also provided. Furthermore, we identify the kinds of transformations which are most suitable for validation with the proposed approach and use mutation techniques to evaluate its effectiveness.","1939-3520","","10.1109/TSE.2014.2375201","Spanish Project; Austrian Research Promotion Agency; EC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6967841","Model transformation;transformation testing;model alignment;Model transformation;transformation testing;model alignment","Contracts;Context;Context modeling;Navigation;Testing;Complexity theory;Analytical models","fault tolerant computing;Unified Modeling Language","static fault localization;model transformations;faulty rules;matching functions;metamodel footprints;metamodel elements;Eclipse modeling framework;mutation techniques","","29","","67","","26 Nov 2014","","","IEEE","IEEE Journals"
"A Machine Learning Approach to Software Requirements Prioritization","A. Perini; A. Susi; P. Avesani","Fondazione Bruno Kessler. CIT - IRST, Trento; Fondazione Bruno Kessler. CIT - IRST, Trento; Fondazione Bruno Kessler. CIT - IRST, Trento","IEEE Transactions on Software Engineering","26 Mar 2013","2013","39","4","445","461","Deciding which, among a set of requirements, are to be considered first and in which order is a strategic process in software development. This task is commonly referred to as requirements prioritization. This paper describes a requirements prioritization method called Case-Based Ranking (CBRank), which combines project's stakeholders preferences with requirements ordering approximations computed through machine learning techniques, bringing promising advantages. First, the human effort to input preference information can be reduced, while preserving the accuracy of the final ranking estimates. Second, domain knowledge encoded as partial order relations defined over the requirement attributes can be exploited, thus supporting an adaptive elicitation process. The techniques CBRank rests on and the associated prioritization process are detailed. Empirical evaluations of properties of CBRank are performed on simulated data and compared with a state-of-the-art prioritization method, providing evidence of the method ability to support the management of the tradeoff between elicitation effort and ranking accuracy and to exploit domain knowledge. A case study on a real software project complements these experimental measurements. Finally, a positioning of CBRank with respect to state-of-the-art requirements prioritization methods is proposed, together with a discussion of benefits and limits of the method.","1939-3520","","10.1109/TSE.2012.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6249686","Requirements management;requirements prioritization;machine learning","Approximation methods;Accuracy;Software;Humans;Data models;Boosting","formal specification;learning (artificial intelligence);project management;software development management","machine learning approach;software requirements prioritization;strategic process;software development;case-based ranking;CBRank;project stakeholder preference;requirements ordering approximations;domain knowledge;partial order relations;requirement attributes;adaptive elicitation process;elicitation effort;ranking accuracy;software project","","70","","42","","26 Jul 2012","","","IEEE","IEEE Journals"
"Carving and Replaying Differential Unit Test Cases from System Test Cases","S. Elbaum; H. N. Chin; M. B. Dwyer; M. Jorde","University of Nebraska, Lincoln; University of Nebraska, Lincoln; University of Nebraska, Lincoln; University of Nebraska, Lincoln","IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","29","45","Unit test cases are focused and efficient. System tests are effective at exercising complex usage patterns. Differential unit tests (DUT) are a hybrid of unit and system tests that exploits their strengths. They are generated by carving the system components, while executing a system test case, that influence the behavior of the target unit, and then re-assembling those components so that the unit can be exercised as it was by the system test. In this paper we show that DUTs retain some of the advantages of unit tests, can be automatically generated, and have the potential for revealing faults related to intricate system executions. We present a framework for carving and replaying DUTs that accounts for a wide variety of strategies and tradeoffs, we implement an automated instance of the framework with several techniques to mitigate test cost and enhance flexibility and robustness, and we empirically assess the efficacy of carving and replaying DUTs on three software artifacts.","1939-3520","","10.1109/TSE.2008.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4711061","Testing strategies;Test execution;Test design;Testing strategies;Test execution;Test design","System testing;Software testing;Automatic testing;Costs;Robustness;Packaging;Debugging;Systems engineering and theory;Software systems;Humans","automatic test software;program testing","differential unit test cases;system test cases;complex usage patterns;system components;software artifacts","","25","2","41","","12 Dec 2008","","","IEEE","IEEE Journals"
"Using Declarative Specification to Improve the Understanding, Extensibility, and Comparison of Model-Inference Algorithms","I. Beschastnikh; Y. Brun; J. Abrahamson; M. D. Ernst; A. Krishnamurthy","Department of Computer Science, University of British Columbia, Vancouver, BC, Canada; School of Computer Science, University of Massachusetts, Amherst, MA; Facebook Inc., Seattle, WA; Computer Science & Engineering, University of Washington, Seattle, WA; Computer Science & Engineering, University of Washington, Seattle, WA","IEEE Transactions on Software Engineering","14 Apr 2015","2015","41","4","408","428","It is a staple development practice to log system behavior. Numerous powerful model-inference algorithms have been proposed to aid developers in log analysis and system understanding. Unfortunately, existing algorithms are typically declared procedurally, making them difficult to understand, extend, and compare. This paper presents InvariMint, an approach to specify model-inference algorithms declaratively. We applied the InvariMint declarative approach to two model-inference algorithms. The evaluation results illustrate that InvariMint (1) leads to new fundamental insights and better understanding of existing algorithms, (2) simplifies creation of new algorithms, including hybrids that combine or extend existing algorithms, and (3) makes it easy to compare and contrast previously published algorithms. InvariMint's declarative approach can outperform procedural implementations. For example, on a log of 50,000 events, InvariMint's declarative implementation of the kTails algorithm completes in 12 seconds, while a procedural implementation completes in 18 minutes. We also found that InvariMint's declarative version of the Synoptic algorithm can be over 170 times faster than the procedural implementation.","1939-3520","","10.1109/TSE.2014.2369047","NSERC; Google; Microsoft Research via a SEIF; DARPA; NSF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6951474","Model inference;API mining;specification mining;process mining;declarative specification;inference understanding;inference extensibility;inference comparison;InvariMint;kTails;synoptic;Model inference;API mining;specification mining;process mining;declarative specification;inference understanding;inference extensibility;inference comparison;InvariMint;kTails;synoptic","Inference algorithms;Postal services;Electronic mail;Algorithm design and analysis;Software algorithms;Educational institutions;Approximation algorithms","formal specification;inference mechanisms;system monitoring","log system behavior analysis;model inference algorithm specification;system understanding;InvariMint declarative specification approach;kTails algorithm;synoptic algorithm","","21","","42","","10 Nov 2014","","","IEEE","IEEE Journals"
"Pair Programming and Software Defects--A Large, Industrial Case Study","E. di Bella; I. Fronza; N. Phaphoom; A. Sillitti; G. Succi; J. Vlasenko","University of Genova, Genova; Free University of Bolzano - Bozen, Bolzano; Free University of Bolzano - Bozen, Bolzano; Free University of Bolzano - Bozen, Bolzano; Free University of Bozen - Bolzano, Bolzano; Free University of Bolzano - Bozen, Bolzano","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","930","953","In the last decade, there has been increasing interest in pair programming (PP). However, despite the existing work, there is still a lack of substantial evidence of the effects of PP in industrial environments. To address this issue, we have analyzed the work of a team of 17 industrial developers for 14 months. The team is part of the IT department of a large Italian manufacturing company; it adopts a customized version of extreme programming (XP). We have investigated the effects of PP on software quality in five different scenarios. The results show that PP appears to provide a perceivable but small effect on the reduction of defects in these settings.","1939-3520","","10.1109/TSE.2012.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6331491","Pair programming;software defects;case study","Programming;Software","configuration management;manufacturing industries;production engineering computing;software fault tolerance;software prototyping;software quality;team working","pair programming;software defects;industrial case study;IT department;large Italian manufacturing company;extreme programming;customized version;software quality","","40","","94","","16 Oct 2012","","","IEEE","IEEE Journals"
"Toward a Formalism for Conservative Claims about the Dependability of Software-Based Systems","P. Bishop; R. Bloomfield; B. Littlewood; A. Povyakalo; D. Wright","City University, London and Adelard LLP, London; City University, London and Adelard LLP, London; City University, London; City University, London; City University, London","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","708","717","In recent work, we have argued for a formal treatment of confidence about the claims made in dependability cases for software-based systems. The key idea underlying this work is ""the inevitability of uncertainty"": It is rarely possible to assert that a claim about safety or reliability is true with certainty. Much of this uncertainty is epistemic in nature, so it seems inevitable that expert judgment will continue to play an important role in dependability cases. Here, we consider a simple case where an expert makes a claim about the probability of failure on demand (pfd) of a subsystem of a wider system and is able to express his confidence about that claim probabilistically. An important, but difficult, problem then is how such subsystem (claim, confidence) pairs can be propagated through a dependability case for a wider system, of which the subsystems are components. An informal way forward is to justify, at high confidence, a strong claim, and then, conservatively, only claim something much weaker: ""I'm 99 percent confident that the pfd is less than 10-5, so it's reasonable to be 100 percent confident that it is less than 10-3."" These conservative pfds of subsystems can then be propagated simply through the dependability case of the wider system. In this paper, we provide formal support for such reasoning.","1939-3520","","10.1109/TSE.2010.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5492693","Bayesian probability;safety case;software reliability.","Uncertainty;Software reliability;Phase frequency detector;Battery powered vehicles;Software systems;Software safety;Programming;Power engineering computing;Reliability engineering;Power engineering and energy","probability;software fault tolerance;uncertainty handling","software-based system dependability;software-based system safety;software-based system reliability;probability of failure on demand;conservative claims;formal support","","22","","24","","28 Jun 2010","","","IEEE","IEEE Journals"
"Coverage-Aware Test Database Reduction","J. Tuya; C. de la Riva; M. J. Suárez-Cabal; R. Blanco","Dpto. Informática, University of Oviedo, Campus Universitario de Gijón, Gijón, Spain; Dpto. Informática, University of Oviedo, Campus Universitario de Gijón, Gijón, Spain; Dpto. Informática, University of Oviedo, Campus Universitario de Gijón, Gijón, Spain; Dpto. Informática, University of Oviedo, Campus Universitario de Gijón, Gijón, Spain","IEEE Transactions on Software Engineering","13 Oct 2016","2016","42","10","941","959","Functional testing of applications that process the information stored in databases often requires a careful design of the test database. The larger the test database, the more difficult it is to develop and maintain tests as well as to load and reset the test data. This paper presents an approach to reduce a database with respect to a set of SQL queries and a coverage criterion. The reduction procedures search the rows in the initial database that contribute to the coverage in order to find a representative subset that satisfies the same coverage as the initial database. The approach is automated and efficiently executed against large databases and complex queries. The evaluation is carried out over two real life applications and a well-known database benchmark. The results show a very large degree of reduction as well as scalability in relation to the size of the initial database and the time needed to perform the reduction.","1939-3520","","10.1109/TSE.2016.2519032","Spanish Ministry of Economy and Competitiveness; Principality of Asturias; ERDF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7384760","Test database reduction;test coverage of code;test design;testing tools","Databases;Production;Minimization;Fault detection;Benchmark testing;Scalability","database management systems;design;information storage;program testing;software tools;SQL","coverage-aware test database reduction;functional testing;information storage;SQL queries;coverage criterion;database benchmark;test design;testing tools","","6","","105","","18 Jan 2016","","","IEEE","IEEE Journals"
"Proofs from Tests","N. E. Beckman; A. V. Nori; S. K. Rajamani; R. J. Simmons; S. D. Tetali; A. V. Thakur","Carnegie Mellon University, Pittsburgh; Microsoft Research India, Bangalore; Microsoft Research India, Bangalore; Carnegie Mellon University, Pittsburgh; University of California, Los Angeles, Los Angeles; University of Wisconsin-Madison, Madison","IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","495","508","We present an algorithm DASH to check if a program P satisfies a safety property φ. The unique feature of this algorithm is that it uses only test generation operations, and it refines and maintains a sound program abstraction as a consequence of failed test generation operations. Thus, each iteration of the algorithm is inexpensive, and can be implemented without any global may-alias information. In particular, we introduce a new refinement operator WPα that uses only the alias information obtained by symbolically executing a test to refine abstractions in a sound manner. We present a full exposition of the DASH algorithm and its theoretical properties. We have implemented DASH in a tool called YOGI that plugs into Microsoft's Static Driver Verifier framework. We have used this framework to run YOGI on 69 Windows Vista drivers with 85 properties and find that YOGI scales much better than SLAM, the current engine driving Microsoft's Static Driver Verifier.","1939-3520","","10.1109/TSE.2010.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5444886","Software model checking;directed testing;abstraction refinement.","Acoustic testing;Safety;Performance evaluation;Iterative algorithms;Plugs;Simultaneous localization and mapping;Engines;Instruments;Automatic testing;Algorithm design and analysis","operating systems (computers);program testing;program verification","DASH algorithm;test generation operations;YOGI tool;Microsoft static driver verifier framework;Windows Vista drivers;software model checking","","31","","27","","8 Apr 2010","","","IEEE","IEEE Journals"
"Exemplar: A Source Code Search Engine for Finding Highly Relevant Applications","C. McMillan; M. Grechanik; D. Poshyvanyk; C. Fu; Q. Xie","College of William and Mary, Williamsburg; Accenture Technology Labs, Chicago; College of William and Mary, Williamsburg; Accenture Technology Labs, Chicago; Accenture Technology Labs, Chicago","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1069","1087","A fundamental problem of finding software applications that are highly relevant to development tasks is the mismatch between the high-level intent reflected in the descriptions of these tasks and low-level implementation details of applications. To reduce this mismatch we created an approach called EXEcutable exaMPLes ARchive (Exemplar) for finding highly relevant software projects from large archives of applications. After a programmer enters a natural-language query that contains high-level concepts (e.g., MIME, datasets), Exemplar retrieves applications that implement these concepts. Exemplar ranks applications in three ways. First, we consider the descriptions of applications. Second, we examine the Application Programming Interface (API) calls used by applications. Third, we analyze the dataflow among those API calls. We performed two case studies (with professional and student developers) to evaluate how these three rankings contribute to the quality of the search results from Exemplar. The results of our studies show that the combined ranking of application descriptions and API documents yields the most-relevant search results. We released Exemplar and our case study data to the public.","1939-3520","","10.1109/TSE.2011.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5989838","Source code search engines;information retrieval;concept location;open source software;mining software repositories;software reuse","Search engines;Engines;Software;Java;Cryptography;Vocabulary;Data mining","application program interfaces;data flow analysis;document handling;natural language processing;project management;query processing;software management;software reusability;system documentation","source code search engine;software application;development task;executable examples archive;Exemplar;software project;natural-language query;application programming interface;dataflow;API call;search quality;application description ranking;API document;software reuse","","59","2","52","","18 Aug 2011","","","IEEE","IEEE Journals"
"The ManyBugs and IntroClass Benchmarks for Automated Repair of C Programs","C. Le Goues; N. Holtschulte; E. K. Smith; Y. Brun; P. Devanbu; S. Forrest; W. Weimer","School of Computer Science, Carnegie Mellon University, Pittsburgh, PA; Department of Computer Science at the University of New Mexico, Albuquerque, NM; College of Information and Computer Science, University of Massachusetts at Amherst, MA; College of Information and Computer Science, University of Massachusetts at Amherst, MA; Department of Computer Science, University of California at Davis, Davis, CA; Department of Computer Science at the University of New Mexico, Albuquerque, NM; Department of Computer Science, University of Virginia, Charlottesville, VA","IEEE Transactions on Software Engineering","8 Dec 2015","2015","41","12","1236","1256","The field of automated software repair lacks a set of common benchmark problems. Although benchmark sets are used widely throughout computer science, existing benchmarks are not easily adapted to the problem of automatic defect repair, which has several special requirements. Most important of these is the need for benchmark programs with reproducible, important defects and a deterministic method for assessing if those defects have been repaired. This article details the need for a new set of benchmarks, outlines requirements, and then presents two datasets, ManyBugs and IntroClass, consisting between them of 1,183 defects in 15 C programs. Each dataset is designed to support the comparative evaluation of automatic repair algorithms asking a variety of experimental questions. The datasets have empirically defined guarantees of reproducibility and benchmark quality, and each study object is categorized to facilitate qualitative evaluation and comparisons by category of bug or program. The article presents baseline experimental results on both datasets for three existing repair methods, GenProg, AE, and TrpAutoRepair, to reduce the burden on researchers who adopt these datasets for their own comparative evaluations.","1939-3520","","10.1109/TSE.2015.2454513","AFOSR; US Defense Advanced Research Projects Agency (DARPA); US Department of Energy (DOE); US National Science Foundation (NSF); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7153570","Automated program repair;benchmark;subject defect;reproducibility;ManyBugs;IntroClass;Automated program repair;benchmark;subject defect;reproducibility;ManyBugs;IntroClass","Maintenance engineering;Benchmark testing;Computer bugs;Software systems;Electronic mail","benchmark testing;C language;program debugging;software maintenance;software performance evaluation;software quality","TrpAutoRepair;GenProg;qualitative evaluation;benchmark quality;reproducibility;automatic repair algorithms;defects assessment;deterministic method;benchmark programs;automatic defect repair;computer science;benchmark sets;benchmark problems;automated software repair;C programs;IntroClass benchmarks;ManyBugs benchmarks","","97","","80","","9 Jul 2015","","","IEEE","IEEE Journals"
"Mapping Bug Reports to Relevant Files: A Ranking Model, a Fine-Grained Benchmark, and Feature Evaluation","X. Ye; R. Bunescu; C. Liu","School of Electrical Engineering and Computer Science, Ohio University, Athens, OH; School of Electrical Engineering and Computer Science, Ohio University, Athens, OH; School of Electrical Engineering and Computer Science, Ohio University, Athens, OH","IEEE Transactions on Software Engineering","14 Apr 2016","2016","42","4","379","402","When a new bug report is received, developers usually need to reproduce the bug and perform code reviews to find the cause, a process that can be tedious and time consuming. A tool for ranking all the source files with respect to how likely they are to contain the cause of the bug would enable developers to narrow down their search and improve productivity. This paper introduces an adaptive ranking approach that leverages project knowledge through functional decomposition of source code, API descriptions of library components, the bug-fixing history, the code change history, and the file dependency graph. Given a bug report, the ranking score of each source file is computed as a weighted combination of an array of features, where the weights are trained automatically on previously solved bug reports using a learning-to-rank technique. We evaluate the ranking system on six large scale open source Java projects, using the before-fix version of the project for every bug report. The experimental results show that the learning-to-rank approach outperforms three recent state-of-the-art methods. In particular, our method makes correct recommendations within the top 10 ranked source files for over 70 percent of the bug reports in the Eclipse Platform and Tomcat projects.","1939-3520","","10.1109/TSE.2015.2479232","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7270328","Bug reports;software maintenance;learning to rank;Bug reports;software maintenance;learning to rank","Software;History;Computational modeling;Computer bugs;Collaboration;Benchmark testing;Standards","","","","25","","72","","16 Sep 2015","","","IEEE","IEEE Journals"
"Zebu: A Language-Based Approach for Network Protocol Message Processing","L. Burgy; L. Reveillere; J. Lawall; G. Muller","Princeton University, Princeton; University of Bordeaux, LaBRI, Talence; DIKU, University of Copenhagen, Paris; INRIA-Regal, LIP6, Paris","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","575","591","A network application communicates with other applications according to a set of rules known as a protocol. This communication is managed by the part of the application known as the protocol-handling layer, which enables the manipulation of protocol messages. The protocol-handling layer is a critical component of a network application since it represents the interface between the application and the outside world. It must thus satisfy two constraints: It must be efficient to be able to treat a large number of messages and it must be robust to face various attacks targeting the application itself or the underlying platform. Despite these constraints, the development process of this layer still remains rudimentary and requires a high level of expertise. It includes translating the protocol specification written in a high-level formalism such as ABNF toward low-level code such as C. The gap between these abstraction levels can entail many errors. This paper proposes a new language-based approach to developing protocol-handling layers, to improve their robustness without compromising their performance. Our approach is based on the use of a domain-specific language, Zebu, to specify the protocol-handling layer of network applications that use textual HTTP-like application protocols. The Zebu syntax is very close to that of ABNF, facilitating the adoption of Zebu by domain experts. By annotating the original ABNF specification of a protocol, the Zebu user can dedicate the protocol-handling layer to the needs of a given application. The Zebu compiler first checks the annotated specification for inconsistencies, and then generates a protocol-handling layer according to the annotations. This protocol-handling layer is made up of a set of data structures that represent a message, a parser that fills in these data structures, and various stub functions to access these data structures or drive the parsing of a message.","1939-3520","","10.1109/TSE.2010.64","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5487528","Network protocols;message parsing;message composing;domain-specific languages.","Electronic mail;Data structures;Robustness;Domain specific languages;Access protocols;Streaming media;IP networks;Network servers;Web server;Computer bugs","computational linguistics;formal specification;Internet;program compilers;protocols;specification languages;telecommunication computing","Zebu syntax;language-based approach;network protocol message processing;protocol-handling layer;protocol specification;ABNF;textual HTTP-like application protocols;Zebu compiler;data structures;message parsing;Internet era;domain-specific languages","","9","2","34","","17 Jun 2010","","","IEEE","IEEE Journals"
"Automated Steering of Model-Based Test Oracles to Admit Real Program Behaviors","G. Gay; S. Rayadurgam; M. P. E. Heimdahl","Department of Computer Science & Engineering, University of South Carolina, Columbia, SC; Department of Computer Science and Engineering, University of Minnesota, Minneapolis, MN; Department of Computer Science and Engineering, University of Minnesota, Minneapolis, MN","IEEE Transactions on Software Engineering","12 Jun 2017","2017","43","6","531","555","The test oracle-a judge of the correctness of the system under test (SUT)-is a major component of the testing process. Specifying test oracles is challenging for some domains, such as real-time embedded systems, where small changes in timing or sensory input may cause large behavioral differences. Models of such systems, often built for analysis and simulation, are appealing for reuse as test oracles. These models, however, typically represent an idealized system, abstracting away certain issues such as non-deterministic timing behavior and sensor noise. Thus, even with the same inputs, the model's behavior may fail to match an acceptable behavior of the SUT, leading to many false positives reported by the test oracle. We propose an automated steering framework that can adjust the behavior of the model to better match the behavior of the SUT to reduce the rate of false positives. This model steering is limited by a set of constraints (defining the differences in behavior that are acceptable) and is based on a search process attempting to minimize a dissimilarity metric. This framework allows non-deterministic, but bounded, behavioral differences, while preventing future mismatches by guiding the oracle-within limits-to match the execution of the SUT. Results show that steering significantly increases SUT-oracle conformance with minimal masking of real faults and, thus, has significant potential for reducing false positives and, consequently, testing and debugging costs while improving the quality of the testing process.","1939-3520","","10.1109/TSE.2016.2615311","US National Science Foundation; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7583721","Software testing;test oracles;model-based testing;model-based development;verification","Testing;Analytical models;Computational modeling;Software;Delays;Hardware;Pacemakers","program debugging;program testing;program verification","automated steering;model-based test oracles;real program behaviors;system under test correctness;SUT correctness;model steering;search process;fault masking;debugging costs;testing process quality","","5","","54","","5 Oct 2016","","","IEEE","IEEE Journals"
"Test Case-Aware Combinatorial Interaction Testing","C. Yilmaz","Sabanci University, Istanbul","IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","684","706","The configuration spaces of modern software systems are too large to test exhaustively. Combinatorial interaction testing (CIT) approaches, such as covering arrays, systematically sample the configuration space and test only the selected configurations by using a battery of test cases. Traditional covering arrays, while taking system-wide interoption constraints into account, do not provide a systematic way of handling test case-specific interoption constraints. The basic justification for t-way covering arrays is that they can cost effectively exercise all system behaviors caused by the settings of t or fewer options. In this paper, we hypothesize, however, that in the presence of test case-specific interoption constraints, many such behaviors may not be tested due to masking effects caused by the overlooked test case-specific constraints. For example, if a test case refuses to run in a configuration due to an unsatisfied test case-specific constraint, none of the valid option setting combinations appearing in the configuration will be tested by that test case. To account for test case-specific constraints, we introduce a new combinatorial object, called a test case-aware covering array. A t-way test case-aware covering array is not just a set of configurations, as is the case in traditional covering arrays, but a set of configurations, each of which is associated with a set of test cases such that all test case-specific constraints are satisfied and that, for each test case, each valid combination of option settings for every combination of t options appears at least once in the set of configurations that the test case is associated with. We furthermore present three algorithms to compute test case-aware covering arrays. Two of the algorithms aim to minimize the number of configurations required (one is fast, but produces larger arrays, the other is slower, but produces smaller arrays), whereas the remaining algorithm aims to minimize the number of test runs required. The results of our empirical studies conducted on two widely used highly configurable software systems suggest that test case-specific constraints do exist in practice, that traditional covering arrays suffer from masking effects caused by ignorance of such constraints, and that test case-aware covering arrays are better than other approaches in handling test case-specific constraints, thus avoiding masking effects.","1939-3520","","10.1109/TSE.2012.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311411","Software quality assurance;combinatorial interaction testing;covering arrays","Testing;Servers;Software algorithms;Software systems;Systematics;Computational modeling","program testing;software quality","test case-aware combinatorial interaction testing;software system;CIT approach;interoption constraint;masking effect;t-way test case-aware covering array;highly configurable software system","","14","","34","","24 Sep 2012","","","IEEE","IEEE Journals"
"Reducing Unauthorized Modification of Digital Objects","P. C. Van Oorschot; G. Wurster","Carleton University, Ottawa; Carleton University, Ottawa","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","191","204","We consider the problem of malicious modification of digital objects. We present a protection mechanism designed to protect against unauthorized replacement or modification of digital objects while still allowing authorized updates transparently. We use digital signatures without requiring any centralized public key infrastructure. To explore the viability of our proposal, we apply the approach to file-system binaries, implementing a prototype in Linux which protects operating system and application binaries on disk. To test the prototype and related kernel modifications, we show that it protects against various rootkits currently available while incurring minimal overhead costs. The general approach can be used to restrict updates to general digital objects.","1939-3520","","10.1109/TSE.2011.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5680916","Protection mechanisms;software release management and delivery;system integration and implementation;access controls;file organization;operating systems.","Public key;Digital signatures;Access controls;Malware;File organization;Operating systems","authorisation;digital signatures;file organisation;industrial property;operating system kernels","unauthorized modification reduction;malicious modification problem;unauthorized digital object replacement;digital signatures;file-system binaries;Linux;operating system protection;kernel modification;overhead cost minimisation","","1","1","63","","6 Jan 2011","","","IEEE","IEEE Journals"
"Model-Transformation Design Patterns","K. Lano; S. Kolahdouz-Rahimi","Department of Informatics, King’s College London, London WC2R 2LS, United Kingdom; Department of Informatics, King’s College London, London WC2R 2LS, United Kingdom","IEEE Transactions on Software Engineering","12 Dec 2014","2014","40","12","1224","1259","This paper defines a catalogue of patterns for the specification and design of model transformations, and provides a systematic scheme and classification of these patterns, together with pattern application examples in leading model transformation languages such as ATL, QVT, GrGen.NET, and others. We consider patterns for improving transformation modularization and efficiency and for reducing data storage requirements. We define a metamodel-based formalization of model transformation design patterns, and measurement-based techniques to guide the selection of patterns. We also provide an evaluation of the effectiveness of transformation patterns on a range of different case studies.","1939-3520","","10.1109/TSE.2014.2354344","Engineering and Physical Sciences Research Council; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6891324","Model transformations;design patterns;model-driven development","Unified modeling language;Software development;Systematics;Analytical models;Semantics;Complexity theory;Syntactics","formal specification;object-oriented programming;pattern classification","metamodel-based formalization;data storage;transformation modularization improvement;GrGen.NET;QVT;ATL;model transformation languages;pattern application;pattern classification;systematic scheme;model-transformation design patterns","","30","","72","","4 Sep 2014","","","IEEE","IEEE Journals"
"A General Software Defect-Proneness Prediction Framework","Q. Song; Z. Jia; M. Shepperd; S. Ying; J. Liu","Xi'an Jiaotong University, Xi'an; Xi'an Jiaotong University, Xi'an; Brunel University, Uxbridge; Wuhan University, Wuhan; Wuhan University, Wuhan","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","356","370","BACKGROUND - Predicting defect-prone software components is an economically important activity and so has received a good deal of attention. However, making sense of the many, and sometimes seemingly inconsistent, results is difficult. OBJECTIVE - We propose and evaluate a general framework for software defect prediction that supports 1) unbiased and 2) comprehensive comparison between competing prediction systems. METHOD - The framework is comprised of 1) scheme evaluation and 2) defect prediction components. The scheme evaluation analyzes the prediction performance of competing learning schemes for given historical data sets. The defect predictor builds models according to the evaluated learning scheme and predicts software defects with new data according to the constructed model. In order to demonstrate the performance of the proposed framework, we use both simulation and publicly available software defect data sets. RESULTS - The results show that we should choose different learning schemes for different data sets (i.e., no scheme dominates), that small details in conducting how evaluations are conducted can completely reverse findings, and last, that our proposed framework is more effective and less prone to bias than previous approaches. CONCLUSIONS - Failure to properly or fully evaluate a learning scheme can be misleading; however, these problems may be overcome by our proposed framework.","1939-3520","","10.1109/TSE.2010.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5611551","Software defect prediction;software defect-proneness prediction;machine learning;scheme evaluation.","Software;Training data;Predictive models;Buildings;Data models;Prediction algorithms;Training","learning (artificial intelligence);software fault tolerance;software performance evaluation","software defect proneness prediction framework;scheme evaluation;competing learning schemes;defect predictor","","160","1","44","","28 Oct 2010","","","IEEE","IEEE Journals"
"Formal Analysis of the Probability of Interaction Fault Detection Using Random Testing","A. Arcuri; L. Briand","Simula Research Laboratory, Lysaker; Simula Research Laboratory, Lysaker","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1088","1099","Modern systems are becoming highly configurable to satisfy the varying needs of customers and users. Software product lines are hence becoming a common trend in software development to reduce cost by enabling systematic, large-scale reuse. However, high levels of configurability entail new challenges. Some faults might be revealed only if a particular combination of features is selected in the delivered products. But testing all combinations is usually not feasible in practice, due to their extremely large numbers. Combinatorial testing is a technique to generate smaller test suites for which all combinations of t features are guaranteed to be tested. In this paper, we present several theorems describing the probability of random testing to detect interaction faults and compare the results to combinatorial testing when there are no constraints among the features that can be part of a product. For example, random testing becomes even more effective as the number of features increases and converges toward equal effectiveness with combinatorial testing. Given that combinatorial testing entails significant computational overhead in the presence of hundreds or thousands of features, the results suggest that there are realistic scenarios in which random testing may outperform combinatorial testing in large systems. Furthermore, in common situations where test budgets are constrained and unlike combinatorial testing, random testing can still provide minimum guarantees on the probability of fault detection at any interaction level. However, when constraints are present among features, then random testing can fare arbitrarily worse than combinatorial testing. As a result, in order to have a practical impact, future research should focus on better understanding the decision process to choose between random testing and combinatorial testing, and improve combinatorial testing in the presence of feature constraints.","1939-3520","","10.1109/TSE.2011.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5999671","Combinatorial testing;random testing;interaction testing;theory;constraint;feature diagram;lower bound","Software;Context;Fault detection;Feature extraction;Scalability;Benchmark testing","cost reduction;customer satisfaction;probability;program testing;program verification;random processes;software cost estimation;software fault tolerance","interaction fault detection probability;formal analysis;random testing;customer satisfaction;user satisfaction;software product lines;software development;cost reduction;large-scale reusability;combinatorial testing;computational overhead;feature constraints","","36","","37","","25 Aug 2011","","","IEEE","IEEE Journals"
"GK-Tail+ An Efficient Approach to Learn Software Models","L. Mariani; M. Pezzè; M. Santoro","Department of Informatics, Systems and Communication, University of Milano Bicocca, Milano, Italy; Faculty of Informatics, Universitá della Svizzera Italiana, Lugano, Switzerland; Faculty of Informatics, Universitá della Svizzera Italiana, Lugano, Switzerland","IEEE Transactions on Software Engineering","11 Aug 2017","2017","43","8","715","738","Inferring models of program behavior from execution samples can provide useful information about a system, also in the increasingly common case of systems that evolve and adapt in their lifetime, and without requiring large developers' effort. Techniques for learning models of program behavior from execution traces shall address conflicting challenges of recall, specificity and performance: They shall generate models that comprehensively represent the system behavior (recall) while limiting the amount of illegal behaviors that may be erroneously accepted by the model (specificity), and should infer the models within a reasonable time budget to process industrial scale systems (performance). In our early work, we designed GK-tail, an approach that can infer guarded finite state machines that model the behavior of object-oriented programs in terms of sequences of method calls and constraints on the parameter values. GK-tail addresses well two of the three main challenges, since it infers guarded finite state machines with a high level of recall and specificity, but presents severe limitations in terms of performance that reduce its scalability. In this paper, we present GK-tail+, a new approach to infer guarded finite state machines from execution traces of object-oriented programs. GK-tail+ proposes a new set of inference criteria that represent the core element of the inference process: It largely reduces the inference time of GK-tail while producing guarded finite state machines with a comparable level of recall and specificity. Thus, GK-tail+ advances the preliminary results of GK-tail by addressing all the three main challenges of learning models of program behavior from execution traces.","1939-3520","","10.1109/TSE.2016.2623623","The H2020 Learn project; ERC Consolidator Grant 2014 program; ERC; Swiss National Foundation; SNF; ASysT: Automatic System Testing; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7728088","Dynamic model learning;software models;state based models;guarded finite state machines;specification mining","Object oriented modeling;Merging;Analytical models;Adaptation models;Software systems;Limiting","finite state machines;learning (artificial intelligence);object-oriented programming","GK-Tail+;software models;inferring models;program behavior;learning models;system behavior;illegal behaviors;reasonable time budget;industrial scale systems;object-oriented programs;guarded finite state machines;inference criteria;inference process;inference time;execution traces","","9","","55","","1 Nov 2016","","","IEEE","IEEE Journals"
"Seer: A Lightweight Online Failure Prediction Approach","B. Ozcelik; C. Yilmaz","freelance software developer; Faculty of Engineering and Natural Sciences, Sabanci University, Istanbul, Turkey","IEEE Transactions on Software Engineering","7 Jan 2016","2016","42","1","26","46","Online failure prediction approaches aim to predict the manifestation of failures at runtime before the failures actually occur. Existing approaches generally refrain themselves from collecting internal execution data, which can further improve the prediction quality. One reason behind this general trend is the runtime overhead incurred by the measurement instruments that collect the data. Since these approaches are targeted at deployed software systems, excessive runtime overhead is generally undesirable. In this work we conjecture that large cost reductions in collecting internal execution data for online failure prediction may derive from pushing the substantial parts of the data collection work onto the hardware. To test this hypothesis, we present a lightweight online failure prediction approach, called Seer, in which most of the data collection work is performed by fast hardware performance counters. The hardware-collected data is augmented with further data collected by a minimal amount of software instrumentation that is added to the systems software. In our empirical evaluations conducted on three open source projects, Seer performed significantly better than other related approaches in predicting the manifestation of failures.","1939-3520","","10.1109/TSE.2015.2442577","Marie Curie International Reintegration; European Community Framework Programme; Scientific and Technological Research Council of Turkey; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7120143","Online failure prediction;hardware performance counters;software quality assurance;software reliability;Online failure prediction;hardware performance counters;software quality assurance;software reliability","Radiation detectors;Hardware;Runtime;Predictive models;Instruments;Software;Indexes","data handling;public domain software;quality assurance;software cost estimation;software quality;software reliability;system recovery","Seer;lightweight online failure prediction;internal execution data collection;prediction quality improvement;measurement instruments;software systems;runtime overhead;cost reduction;fast hardware performance counters;software instrumentation;open source projects;software quality assurance;software reliability","","10","","60","","9 Jun 2015","","","IEEE","IEEE Journals"
"Deriving Bisimulation Relations from Path Extension Based Equivalence Checkers","K. Banerjee; D. Sarkar; C. Mandal","Intel Parallel Computing Lab, Bangalore, Karnataka, India; Department of Computer Science and Engineering, Indian Institute of Technology Kharagpur, India; Department of Computer Science and Engineering, Indian Institute of Technology Kharagpur, India","IEEE Transactions on Software Engineering","13 Oct 2017","2017","43","10","946","953","Constructing bisimulation relations between programs as a means of translation validation has been an active field of study. The problem is in general undecidable. Currently available mechanisms suffer from drawbacks such as non-termination and significant restrictions on the structures of programs to be checked. We have developed a path extension based equivalence checking method as an alternative translation validation technique to alleviate these drawbacks. In this work, path extension based equivalence checking of programs (flowcharts) is leveraged to establish a bisimulation relation between a program and its translated version by constructing the relation from the outputs of the equivalence checker.","1939-3520","","10.1109/TSE.2016.2645687","Tata Consultancy Services (TCS); Department of Science and Technology (DST); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7801117","Translation validation;bisimulation relation;equivalence checking;path extension based equivalence checker","Computational modeling;Inference algorithms;Processor scheduling;Computer science;Electronic mail;Optimization;Integrated circuit modeling","bisimulation equivalence;flowcharting;program interpreters;program verification","bisimulation relation;equivalence checker;path extension based equivalence checking method;alternative translation validation technique;program checking;flowcharts","","","","19","Traditional","28 Dec 2016","","","IEEE","IEEE Journals"
"Forecasting Java Software Evolution Trends Employing Network Models","T. Chaikalis; A. Chatzigeorgiou","Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece; Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece","IEEE Transactions on Software Engineering","10 Jun 2015","2015","41","6","582","602","The evolution of networks representing systems in various domains, including social networks, has been extensively studied enabling the development of growth models which govern their behavior over time. The architecture of software systems can also be naturally represented in the form of networks, whose properties change as software evolves. In this paper we attempt to model several aspects of graphs representing object-oriented software systems as they evolve over a number of versions. The goal is to develop a prediction model by considering global phenomena such as preferential attachment, past evolutionary trends such as the tendency of classes to create fewer relations as they age, as well as domain knowledge in terms of principles that have to be followed in object-oriented design. The derived models can provide insight into the future trends of software and potentially form the basis for eliciting improved or novel laws of software evolution. The forecasting power of the proposed model is evaluated against the actual evolution of 10 open-source projects and the achieved accuracy in the prediction of several network and software properties, which reflect the underlying system design, appears to be promising.","1939-3520","","10.1109/TSE.2014.2381249","European Union (European Social Fund—ESF); National Strategic Reference Framework; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6985636","Graphs and networks;Restructuring;reverse engineering;reengineering;Software Architectures;Objectoriented design methods;Graphs and networks;restructuring;reverse engineering;and reengineering;software architectures;object-oriented design methods","Object oriented modeling;Predictive models;Forecasting;Software systems;Analytical models;Market research","graph theory;Java;object-oriented programming;social networking (online);software architecture;software maintenance","Java software evolution trend;social network;software system architecture;object-oriented software system;prediction model;preferential attachment","","20","","96","","18 Dec 2014","","","IEEE","IEEE Journals"
"The Effect of GoF Design Patterns on Stability: A Case Study","A. Ampatzoglou; A. Chatzigeorgiou; S. Charalampidou; P. Avgeriou","Institute of Mathematics and Computer Science, University of Groningen, Groningen, Netherlands; Department of Applied Informatics, University of Macedonia, Thessaloniki, Greece; Institute of Mathematics and Computer Science, University of Groningen, Groningen, Netherlands; Institute of Mathematics and Computer Science, University of Groningen, Groningen, Netherlands","IEEE Transactions on Software Engineering","11 Aug 2015","2015","41","8","781","802","Stability refers to a software system's resistance to the “ripple effect”, i.e., propagation of changes. In this paper, we investigate the stability of classes that participate in instances/occurrences of GoF design patterns. We examine whether the stability of such classes is affected by (a) the pattern type, (b) the role that the class plays in the pattern, (c) the number of pattern occurrences in which the class participates, and (d) the application domain. To this end, we conducted a case study on about 65.000 Java open-source classes, where we performed change impact analysis on classes that participate in zero, one (single pattern), or more than one (coupled) pattern occurrences. The results suggest that, the application of design patterns can provide the expected “shielding” of certain pattern-participating classes against changes, depending on their role in the pattern. Moreover, classes that participate in coupled pattern occurrences appear to be the least stable. The results can be used for assessing the benefits and liabilities of the use of patterns and for testing and refactoring prioritization, because less stable classes are expected to require more effort while testing, and urge for refactoring activities that would make them more resistant to change propagation.","1939-3520","","10.1109/TSE.2015.2414917","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7066925","D.2.2 Design Tools and Techniques;D.2.3.a Object-oriented programming,;D.2.8 Metrics/Measurement;Design Tools and Techniques;Object-oriented programming;Metrics/Measurement","Stability analysis;Couplings;Abstracts;Measurement;Production facilities;Open source software","Java;object-oriented programming;public domain software","GoF design pattern;stability;software system resistance;ripple effect;Java open-source class;change impact analysis;coupled pattern occurrence;pattern-participating class;refactoring prioritization;refactoring activity;change propagation","","34","","53","","24 Mar 2015","","","IEEE","IEEE Journals"
"Capsule-Based User Interface Modeling for Large-Scale Applications","D. Milicev; Z. Mijailovic","University of Belgrade, Belgrade; SOL Software, Belgrade","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1190","1207","We present a novel approach to modeling and implementing user interfaces (UI) of large business applications. The approach is based on the concept of capsule, a profiled structured class from UML which models a simple UI component or a coherent UI fragment of logically and functionally coupled components or other fragments with a clear interface. Consequently, the same modeling concept of capsule with internal structure can be reapplied recursively at successively lower levels of detail within a model, starting from high architectural modeling levels down to the lowest levels of modeling simple UI components. The interface of capsules is defined in terms of pins, while the functional coupling of capsules is specified declaratively by simply wiring their pins. Pins and wires transport messages between capsules, ensuring strict encapsulation. The approach includes a method for formal coupling of capsules' behavior with the underlying object space that provides proper impedance matching between the UI and the business logic while preserving clear separation of concerns between them. We also briefly describe an implementation of a framework that supports the proposed method, including a rich library of ready-to-use capsules, and report on our experience in applying the approach in large-scale industrial systems.","1939-3520","","10.1109/TSE.2013.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6464270","Graphical user interface (GUI);Unified Modeling Language (UML);modeling;model-driven development;software architecture;business applications;data-centric applications;information systems","Unified modeling language;Business;Couplings;Complexity theory;Object oriented modeling;Buildings;User interfaces","business data processing;Unified Modeling Language;user interfaces","profiled structured class;ready-to-use capsule library;object space;business logic;functional capsule coupling;capsule interface;UI component;UI fragment;Unified Modeling Language;UML;capsule concept;business application;capsule-based user interface modeling","","3","","43","","18 Feb 2013","","","IEEE","IEEE Journals"
"Synthesizing Multithreaded Code from Real-Time Object-Oriented Models via Schedulability-Aware Thread Derivation","S. Kim","Department of Information Communications Engineering, Hankuk University of Foreign Studies, Global Campus, San 89, Mohyun-myun, Cheoin-gu, Yongin-si, South Korea","IEEE Transactions on Software Engineering","2 May 2014","2014","40","4","413","426","One of the major difficulties in developing embedded systems with object-oriented modeling is to translate a designed model into code that satisfies required real-time performance. This paper proposes scenario-based implementation synthesis architecture with timing guarantee (SISAtime) that addresses these difficulties. The problems that SISAtime must solve are: how to synthesize multithreaded-code from a real-time object-oriented model; and how to design supporting development tools and runtime system architecture while ensuring that the scenarios in the system have minimal response times and the code satisfies the given timing constraints with a minimal number of threads. SISAtime provides a new scheduling algorithm which minimizes scenario response times. SISAtime also provides a new thread derivation method that derives tasks and maps tasks to threads while automatically assigning task scheduling attributes. We have fully implemented SISAtime by extending the RoseRT development tool that uses UML 2.0 as a modeling language, and we applied it to an existing industrial private branch exchange system. The performance evaluation results show that the response times, context switches, and the number of threads of the system with SISAtime were reduced by 21.6, 33.2, and 65.2 percent, respectively, compared to the system with the best known existing thread derivation method.","1939-3520","","10.1109/TSE.2013.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6617637","Multitasking;object-oriented design methods;real-time systems and embedded systems;system integration and implementation","Unified modeling language;Object oriented modeling;Message systems;Timing;Time factors;Real-time systems;Ports (Computers)","embedded systems;multi-threading;object-oriented methods;scheduling;software architecture;software performance evaluation;Unified Modeling Language","multithreaded code synthesis;real-time object-oriented models;schedulability-aware thread derivation;embedded systems;real-time performance evaluation;scenario-based implementation synthesis architecture-with-timing guarantee;SISAtime;development tools;runtime system architecture;timing constraints;scenario response time minimization;thread derivation method;task derivation;task mapping;automatic task scheduling attribute assignment;RoseRT development tool;UML 2.0;modeling language;industrial private branch exchange system;context switches","","5","","42","","2 Oct 2013","","","IEEE","IEEE Journals"
"Defining and Evaluating a Measure of Open Source Project Survivability","U. Raja; M. J. Tretter","The University of Alabama, Tuscaloosa; Texas A&M University, College Station","IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","163","174","In this paper, we define and validate a new multidimensional measure of Open Source Software (OSS) project survivability, called Project Viability. Project viability has three dimensions: vigor, resilience, and organization. We define each of these dimensions and formulate an index called the Viability Index (VI) to combine all three dimensions. Archival data of projects hosted at SourceForge.net are used for the empirical validation of the measure. An Analysis Sample (n=136) is used to assign weights to each dimension of project viability and to determine a suitable cut-off point for VI. Cross-validation of the measure is performed on a hold-out Validation Sample (n=96). We demonstrate that project viability is a robust and valid measure of OSS project survivability that can be used to predict the failure or survival of an OSS project accurately. It is a tangible measure that can be used by organizations to compare various OSS projects and to make informed decisions regarding investment in the OSS domain.","1939-3520","","10.1109/TSE.2011.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6127835","Evaluation framework;external validity;open source software;project evaluation;software measurement;software survivability.","Software measurement;Indexes;Maintenance engineering","project management;public domain software;software metrics","open source project survivability;multidimensional measure;open source software project survivability;project viability;vigor;resilience;organization;viability index","","18","","69","","10 Jan 2012","","","IEEE","IEEE Journals"
"Mining Version Histories for Detecting Code Smells","F. Palomba; G. Bavota; M. D. Penta; R. Oliveto; D. Poshyvanyk; A. De Lucia","University of Salerno, Fisciano, SA, Italy; Free University of Bozen-Bolzano, Bolzano, Italy; University of Sannio, Benevento, Italy; University of Molise, Pesche, IS, Italy; College of William and Mary, Williamsburg, VA; University of Salerno, Fisciano, SA, Italy","IEEE Transactions on Software Engineering","13 May 2015","2015","41","5","462","489","Code smells are symptoms of poor design and implementation choices that may hinder code comprehension, and possibly increase changeand fault-proneness. While most of the detection techniques just rely on structural information, many code smells are intrinsically characterized by how code elements change overtime. In this paper, we propose Historical Information for Smell deTection (HIST), an approach exploiting change history information to detect instances of five different code smells, namely Divergent Change, Shotgun Surgery, Parallel Inheritance, Blob, and Feature Envy. We evaluate HIST in two empirical studies. The first, conducted on 20 open source projects, aimed at assessing the accuracy of HIST in detecting instances of the code smells mentioned above. The results indicate that the precision of HIST ranges between 72 and 86 percent, and its recall ranges between 58 and 100 percent. Also, results of the first study indicate that HIST is able to identify code smells that cannot be identified by competitive approaches solely based on code analysis of a single system's snapshot. Then, we conducted a second study aimed at investigating to what extent the code smells detected by HIST (and by competitive code analysis techniques) reflect developers' perception of poor design and implementation choices. We involved 12 developers of four open source projects that recognized more than 75 percent of the code smell instances identified by HIST as actual design/implementation problems.","1939-3520","","10.1109/TSE.2014.2372760","EU; grants; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6963448","Code smells;mining software repositories;empirical studies;Code smells;mining software repositories;empirical studies","History;Feature extraction;Surgery;Accuracy;Association rules;Detectors","data mining;program compilers;public domain software","code smell detection;historical information for smell detection;divergent change;shotgun surgery;parallel inheritance;blob;feature envy;HIST;code analysis;single system snapshot;open source project;mining version history","","112","","55","","20 Nov 2014","","","IEEE","IEEE Journals"
"Structural Complexity and Programmer Team Strategy: An Experimental Test","N. Ramasubbu; C. F. Kemerer; J. Hong","University of Pittsburgh, Pittsburgh; University of Pittsburgh, Pittsburgh and King Abdul Aziz University, Saudi Arabia; Singapore Management University, Singapore","IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1054","1068","This study develops and empirically tests the idea that the impact of structural complexity on perfective maintenance of object-oriented software is significantly determined by the team strategy of programmers (independent or collaborative). We analyzed two key dimensions of software structure, coupling and cohesion, with respect to the maintenance effort and the perceived ease-of-maintenance by pairs of programmers. Hypotheses based on the distributed cognition and task interdependence theoretical frameworks were tested using data collected from a controlled lab experiment employing professional programmers. The results show a significant interaction effect between coupling, cohesion, and programmer team strategy on both maintenance effort and perceived ease-of-maintenance. Highly cohesive and low-coupled programs required lower maintenance effort and were perceived to be easier to maintain than the low-cohesive programs and high-coupled programs. Further, our results would predict that managers who strategically allocate maintenance tasks to either independent or collaborative programming teams depending on the structural complexity of software could lower their team's maintenance effort by as much as 70 percent over managers who use simple uniform resource allocation policies. These results highlight the importance of achieving congruence between team strategies employed by collaborating programmers and the structural complexity of software.","1939-3520","","10.1109/TSE.2011.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5999673","Object-oriented programming;complexity measures;software quality;software productivity;programming teams;maintenance process;CK metrics;software management","Maintenance engineering;Complexity theory;Couplings;Collaboration;Software;Programming profession","computational complexity;object-oriented programming;resource allocation;software maintenance","programmer team strategy;structural complexity;object-oriented software;perfective maintenance;software structure;perceived ease-of-maintenance;distributed cognition;task interdependence;controlled lab experiment;professional programmers;significant interaction;low-cohesive programs;high-coupled programs;collaborative programming teams;resource allocation policies","","10","","62","","25 Aug 2011","","","IEEE","IEEE Journals"
"Mutation-Driven Generation of Unit Tests and Oracles","G. Fraser; A. Zeller","Saarland University, Saarbrücken; Saarland University, Saarbrücken","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","278","292","To assess the quality of test suites, mutation analysis seeds artificial defects (mutations) into programs; a nondetected mutation indicates a weakness in the test suite. We present an automated approach to generate unit tests that detect these mutations for object-oriented classes. This has two advantages: First, the resulting test suite is optimized toward finding defects modeled by mutation operators rather than covering code. Second, the state change caused by mutations induces oracles that precisely detect the mutants. Evaluated on 10 open source libraries, our μtest prototype generates test suites that find significantly more seeded defects than the original manually written test suites.","1939-3520","","10.1109/TSE.2011.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6019060","Mutation analysis;test case generation;unit testing;test oracles;assertions;search-based testing.","Testing;Genetic algorithms;Biological cells;Software;Software algorithms;Generators;Libraries","automatic test pattern generation;object-oriented programming;optimisation;program testing","mutation driven generation;unit test;oracle;test suites quality;artificial defects;automated test case generation;object-oriented classes;optimization;mutation operators;open source libraries","","139","","52","","15 Sep 2011","","","IEEE","IEEE Journals"
"Model Checking Software with First Order Logic Specifications Using AIG Solvers","M. A. Noureddine; F. A. Zaraket","Department of Computer Science, University of Illinois at Urbana Champaign, IL; Department of Electrical and Computer Engineering, American University of Beirut, Beirut, Lebanon","IEEE Transactions on Software Engineering","11 Aug 2016","2016","42","8","741","763","Static verification techniques leverage Boolean formula satisfiability solvers such as SAT and SMT solvers that operate on conjunctive normal form and first order logic formulae, respectively, to validate programs. They force bounds on variable ranges and execution time and translate the program and its specifications into a Boolean formula. They are limited to programs of relatively low complexity for the following reasons. (1) A small increase in the bounds can cause a large increase in the size of the translated formula. (2) Boolean satisfiability solvers are restricted to using optimizations that apply at the level of the formula. Finally, (3) the Boolean formulae often need to be regenerated with higher bounds to ensure the correctness of the translation. We present a method that uses And-Inverter-Graph (AIG) sequential circuits, and AIG synthesis and verification frameworks to validate programs. An AIG is a Boolean formula with memory elements, logically complete negated conjunction gates, and a hierarchical structure. Encoding the validation problem of a program as an AIG (1) typically provides a more succinct representation than a Boolean formulae encoding with no memory elements, (2) preserves the high-level structure of the program, and (3) enables the use of a number of powerful automated analysis techniques that have no counterparts for other Boolean formulae such as CNF. Our method takes an imperative program with a first order logic specification consisting of a precondition and a postcondition pair, and a bound on the program variable ranges, and produces an AIG with a designated output that is ${true}$  when the program violates the specification. Our method uses AIG synthesis reduction techniques to reduce the AIG, and then uses AIG verification techniques to check the satisfiability of the designated output. The results show that our method can validate designs that are not possible with other state of the art techniques, and with bounds that are an order of magnitude larger.","1939-3520","","10.1109/TSE.2016.2520468","University Research Board; American University of Beirut; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7389426","Software verification;static analysis;Boolean satisfiability solvers;Hoare triplet","Sequential circuits;Model checking;Software;Encoding;Optimization;Radiation detectors;Interpolation","","","","2","","57","","21 Jan 2016","","","IEEE","IEEE Journals"
"Tools for the Rapid Prototyping of Provably Correct Ambient Intelligence Applications","A. Coronato; G. De Pietro","National Research Council (CNR), Naples; National Research Council (CNR), Naples","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","975","991","Ambient Intelligence technologies have not yet been widely adopted in safety critical scenarios. This principally has been due to fact that acceptable degrees of dependability have not been reached for the applications that rely on such technologies. However, the new critical application domains, like Ambient Assisted Living and Smart Hospitals, which are currently emerging, are increasing the need for methodologies and tools that can improve the reliability of the final systems. This paper presents a middleware architecture for safety critical Ambient Intelligence applications which provides the developer with services for runtime verification. It is now possible to continuously monitor and check the running system against correctness properties defined at design time. Moreover, a visual tool which allows the formal design of several of the characteristics of an Ambient Intelligence application and the automatic generation of setting up parameters and code for the middleware infrastructure is also presented.","1939-3520","","10.1109/TSE.2011.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5963693","Safety critical ambient intelligence systems;middleware infrastructures;designing tools","Calculus;Runtime;Middleware;Ambient intelligence;Monitoring;Biomembranes;Mobile communication","middleware;safety-critical software;software prototyping;ubiquitous computing","rapid prototyping;ambient intelligence applications;safety critical scenarios;new critical application domains;ambient assisted living;smart hospitals;middleware architecture;runtime verification;visual tool;formal design;automatic generation;pervasive computing","","15","","48","","28 Jul 2011","","","IEEE","IEEE Journals"
"Making CEGAR More Efficient in Software Model Checking","C. Tian; Z. Duan; Z. Duan","ICTT and ISN Laboratory, Xidian University, Xi’an, China; ICTT and ISN Laboratory, Xidian University, Xi’an, China; ICTT and ISN Laboratory, Xidian University, Xi’an, China","IEEE Transactions on Software Engineering","12 Dec 2014","2014","40","12","1206","1223","Counter-example guided abstraction refinement (CEGAR) is widely used in software model checking. With an abstract model, the state space is largely reduced, however, a counterexample found in such a model that does not satisfy the desired property may not exist in the concrete model. Therefore, how to check whether a reported counterexample is spurious is a key problem in the abstraction-refinement loop. Next, in the case that a spurious counterexample is found, the abstract model needs to be further refined where an NP-hard state separation problem is often involved. Thus, how to refine the abstract model efficiently has attracted a great attention in the past years. In this paper, by re-analyzing spurious counterexamples, a new formal definition of spurious paths is given. Based on it, efficient algorithms for detecting spurious counterexamples are presented. By the new algorithms, when dealing with infinite counterexamples, the finite prefix to be analyzed will be polynomially shorter than the one dealt with by the existing algorithms. Moreover, in practical terms, the new algorithms can naturally be parallelized that enables multi-core processors contributes more in spurious counterexample checking. In addition, a novel refining approach by adding extra Boolean variables to the abstract model is presented. With this approach, not only the NP-hard state separation problem can be avoided, but also a smaller refined abstract model can be obtained. Experimental results show that the new algorithms perform well in practice.","1939-3520","","10.1109/TSE.2014.2357442","NSFC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6895263","Model checking;formal verification;abstraction;refinement;CEGAR","Model checking;Software design;Computational modeling;Benchmark testing","multiprocessing systems;parallel algorithms;program verification","Boolean variables;spurious counterexample checking;multicore processors;parallelized algorithms;polynomially-shorter finite prefix;infinite counterexamples;spurious counterexample detection;spurious paths;spurious counterexample reanalysis;NP-hard state separation problem;abstraction-refinement loop;state space reduction;abstract model;counter-example guided abstraction refinement;software model checking;CEGAR","","16","","30","","11 Sep 2014","","","IEEE","IEEE Journals"
"Architecture-Based Reliability Prediction with the Palladio Component Model","F. Brosch; H. Koziolek; B. Buhnova; R. Reussner","FZI Forschungszentrum Informatik, Karlsruhe; ABB Corporate Research, Ladenburg; Masaryk University, Brno; Karlsruhe Institute of Technology (KIT), Karlsruhe","IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1319","1339","With the increasing importance of reliability in business and industrial software systems, new techniques of architecture-based reliability engineering are becoming an integral part of the development process. These techniques can assist system architects in evaluating the reliability impact of their design decisions. Architecture-based reliability engineering is only effective if the involved reliability models reflect the interaction and usage of software components and their deployment to potentially unreliable hardware. However, existing approaches either neglect individual impact factors on reliability or hard-code them into formal models, which limits their applicability in component-based development processes. This paper introduces a reliability modeling and prediction technique that considers the relevant architectural factors of software systems by explicitly modeling the system usage profile and execution environment and automatically deriving component usage profiles. The technique offers a UML-like modeling notation whose models are automatically transformed into a formal analytical model. Our work builds upon the Palladio Component Model (PCM), employing novel techniques of information propagation and reliability assessment. We validate our technique with sensitivity analyses and simulation in two case studies. The case studies demonstrate effective support of usage profile analysis and architectural configuration ranking, together with the employment of reliability-improving architecture tactics.","1939-3520","","10.1109/TSE.2011.94","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6018968","Software architectures;quality analysis and evaluation;reliability;design tools and techniques","Unified modeling language;Software reliability;Markov processes;Phase change materials;Software architecture;Software quality;Design methodology","object-oriented programming;software architecture;software reliability;Unified Modeling Language","architecture based reliability prediction;palladio component model;industrial software system;architecture based reliability engineering;assist system architects;reliability impact;software component;component based development process;reliability modeling;system usage profile;execution environment;component usage profiles;UML like modeling notation;formal analytical model;information propagation;reliability assessment;sensitivity analysis;usage profile analysis;architectural configuration ranking;architecture tactics","","50","","63","","15 Sep 2011","","","IEEE","IEEE Journals"
"Specifying Dynamic Analyses by Extending Language Semantics","A. Lienhard; T. Girba; O. Nierstrasz","University of Bern, Bern; University of Bern, Bern; University of Bern, Bern","IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","694","706","Dynamic analysis is increasingly attracting attention for debugging, profiling, and program comprehension. Ten to twenty years ago, many dynamic analyses investigated only simple method execution traces. Today, in contrast, many sophisticated dynamic analyses exist, for instance, for detecting memory leaks, analyzing ownership properties, measuring garbage collector performance, or supporting debugging tasks. These analyses depend on complex program instrumentations and analysis models, making it challenging to understand, compare, and reproduce the proposed approaches. While formal specifications and proofs are common in the field of static analysis, most dynamic analyses are specified using informal, textual descriptions. In this paper, we propose a formal framework using operational semantics that allows researchers to precisely specify their dynamic analysis. Our goal is to provide an accessible and reusable basis on which researchers who may not be familiar with rigorous specifications of dynamic analyses can build. By extending the provided semantics, one can concisely specify how runtime events are captured and how this data is transformed to populate the analysis model. Furthermore, our approach provides the foundations to reason about properties of a dynamic analysis.","1939-3520","","10.1109/TSE.2011.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5740933","Dynamic analysis;formal definitions and theory;tracing;debugging.","Semantics;Runtime;Arrays;Context;Analytical models;Performance analysis;Syntactics","formal specification;program debugging;programming language semantics","dynamic analysis specification;program debugging;memory leaks detection;ownership properties;garbage collector performance;complex program instrumentations;formal specifications;textual descriptions;informal descriptions;language semantics extending;program comprehension;program profiling","","","","26","","5 Apr 2011","","","IEEE","IEEE Journals"
"The Effects of Time Constraints on Test Case Prioritization: A Series of Controlled Experiments","H. Do; S. Mirarab; L. Tahvildari; G. Rothermel","North Dakota State University, Fargo; IBM, Vancouver; University of Waterloo, Waterloo; University of Nebraska—Lincoln, Lincoln","IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","593","617","Regression testing is an expensive process used to validate modified software. Test case prioritization techniques improve the cost-effectiveness of regression testing by ordering test cases such that those that are more important are run earlier in the testing process. Many prioritization techniques have been proposed and evidence shows that they can be beneficial. It has been suggested, however, that the time constraints that can be imposed on regression testing by various software development processes can strongly affect the behavior of prioritization techniques. If this is correct, a better understanding of the effects of time constraints could lead to improved prioritization techniques and improved maintenance and testing processes. We therefore conducted a series of experiments to assess the effects of time constraints on the costs and benefits of prioritization techniques. Our first experiment manipulates time constraint levels and shows that time constraints do play a significant role in determining both the cost-effectiveness of prioritization and the relative cost-benefit trade-offs among techniques. Our second experiment replicates the first experiment, controlling for several threats to validity including numbers of faults present, and shows that the results generalize to this wider context. Our third experiment manipulates the number of faults present in programs to examine the effects of faultiness levels on prioritization and shows that faultiness level affects the relative cost-effectiveness of prioritization techniques. Taken together, these results have several implications for test engineers wishing to cost-effectively regression test their software systems. These include suggestions about when and when not to prioritize, what techniques to employ, and how differences in testing processes may relate to prioritization cost--effectiveness.","1939-3520","","10.1109/TSE.2010.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5482587","Regression testing;test case prioritization;cost-benefits;Bayesian networks;empirical studies.","Time factors;Software testing;Automatic testing;Maintenance engineering;Programming;System testing;Computer Society;Software systems;Bayesian methods;Software quality","belief networks;program testing;regression analysis;software fault tolerance","time constraints;test case prioritization techniques;regression testing;various software development processes;cost-benefit trade-offs;Bayesian networks","","83","","62","","7 Jun 2010","","","IEEE","IEEE Journals"
"The Impact of View Histories on Edit Recommendations","S. Lee; S. Kang; S. Kim; M. Staats","Department of Computer Science, KAIST, Daejeon 305-701, Republic of Korea, Guseong-dong, Yuseong-gu; Department of Computer Science, KAIST, Daejeon 305-701, Republic of Korea, Guseong-dong, Yuseong-gu; Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Hong Kong, China; is with the Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg","IEEE Transactions on Software Engineering","11 Mar 2015","2015","41","3","314","330","Recommendation systems are intended to increase developer productivity by recommending files to edit. These systems mine association rules in software revision histories. However, mining coarse-grained rules using only edit histories produces recommendations with low accuracy, and can only produce recommendations after a developer edits a file. In this work, we explore the use of finer-grained association rules, based on the insight that view histories help characterize the contexts of files to edit. To leverage this additional context and fine-grained association rules, we have developed MI, a recommendation system extending ROSE, an existing edit-based recommendation system. We then conducted a comparative simulation of ROSE and MI using the interaction histories stored in the Eclipse Bugzilla system. The simulation demonstrates that MI predicts the files to edit with significantly higher recommendation accuracy than ROSE (about 63 over 35 percent), and makes recommendations earlier, often before developers begin editing. Our results clearly demonstrate the value of considering both views and edits in systems to recommend files to edit, and results in more accurate, earlier, and more flexible recommendations.","1939-3520","","10.1109/TSE.2014.2362138","National Research Foundation of Korea; National Research Foundation of Korea; Ministry of Education; Ministry of Science, ICT & Future Planning; Information Technology Research Center; National IT Industry Promotion Agency; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6926851","Programming environments/construction tools;interactive environments;software maintenance;data mining;association rules;programmer interaction histories;Programming environments/construction tools;interactive environments;software maintenance;data mining;association rules;programmer interaction histories","Context;History;Association rules;Software;Accuracy;Predictive models","data mining;interactive programming;recommender systems","association rules mining;software revision histories;coarse grained rules mining;edit histories;finer grained association rules;MI;ROSE;edit-based recommendation system;programmer interaction histories","","11","","38","","16 Oct 2014","","","IEEE","IEEE Journals"
"Model-Based Test Oracle Generation for Automated Unit Testing of Agent Systems","L. Padgham; Z. Zhang; J. Thangarajah; T. Miller","RMIT University, Melbourne; RMIT University, Melbourne; RMIT University, Melbourne; University of Melbourne, Melbourne","IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1230","1244","Software testing remains the most widely used approach to verification in industry today, consuming between 30-50 percent of the entire development cost. Test input selection for intelligent agents presents a problem due to the very fact that the agents are intended to operate robustly under conditions which developers did not consider and would therefore be unlikely to test. Using methods to automatically generate and execute tests is one way to provide coverage of many conditions without significantly increasing cost. However, one problem using automatic generation and execution of tests is the oracle problem: How can we automatically decide if observed program behavior is correct with respect to its specification? In this paper, we present a model-based oracle generation method for unit testing belief-desire-intention agents. We develop a fault model based on the features of the core units to capture the types of faults that may be encountered and define how to automatically generate a partial, passive oracle from the agent design models. We evaluate both the fault model and the oracle generation by testing 14 agent systems. Over 400 issues were raised, and these were analyzed to ascertain whether they represented genuine faults or were false positives. We found that over 70 percent of issues raised were indicative of problems in either the design or the code. Of the 19 checks performed by our oracle, faults were found by all but 5 of these checks. We also found that 8 out the 11 fault types identified in our fault model exhibited at least one fault. The evaluation indicates that the fault model is a productive conceptualization of the problems to be expected in agent unit testing and that the oracle is able to find a substantial number of such faults with relatively small overhead in terms of false positives.","1939-3520","","10.1109/TSE.2013.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6464272","Test oracles;unit testing;BDI agents","Testing;Context;Object oriented modeling;Computational modeling;Fault diagnosis;Arrays;Robustness","fault diagnosis;multi-agent systems;program testing","model-based test oracle generation;agent system automated unit testing;software testing;test input selection;intelligent agents;test automatic generation;test execution;belief-desire-intention agents;fault model;core units;agent design models","","26","1","31","","18 Feb 2013","","","IEEE","IEEE Journals"
"Better Debugging via Output Tracing and Callstack-Sensitive Slicing","S. Horwitz; B. Liblit; M. Polishchuk","University of Wisconsin-Madison, Madison; University of Wisconsin-Madison, Madison; Microsoft Corporation, Redmond","IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","7","19","Debugging often involves 1) finding the point of failure (the first statement that produces bad output) and 2) finding and fixing the actual bug. Print statements and debugger break points can help with step 1. Slicing the program back from values used at the point of failure can help with step 2. However, neither approach is ideal: Debuggers and print statements can be clumsy and time-consuming and backward slices can be almost as large as the original program. This paper addresses both problems. We present callstack-sensitive slicing, which reduces slice sizes by leveraging the series of calls active when a program fails. We also show how slice intersections may further reduce slice sizes. We then describe a set of tools that identifies points of failure for programs that produce bad output. Finally, we apply our point-of-failure tools to a suite of buggy programs and evaluate callstack-sensitive slicing and slice intersection as applied to debugging. Callstack-sensitive slicing is very effective: On average, a callstack-sensitive slice is about 0.31 time the size of the corresponding full slice, down to just 0.06 time in the best case. Slice intersection is less impressive, on average, but may sometimes prove useful in practice.","1939-3520","","10.1109/TSE.2009.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5282499","Static program slicing;callstack-sensitive analysis;points of failure;output tracing and attribution.","Debugging;Programming profession;Computer crashes;Failure analysis;Testing;Linux","program debugging;program slicing;software reliability","callstack-sensitive slicing;program debugging;program slicing;point-of-failure tools;buggy programs;slice intersection","","21","","38","","9 Oct 2009","","","IEEE","IEEE Journals"
"A Flowchart Language for Quantum Programming","M. Ying; Y. Feng","University of Technology, Sydney and Tsinghua University, Beijing; University of Technology, Sydney and Tsinghua University, Beijing","IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","466","485","Several high-level quantum programming languages have been proposed in the previous research. In this paper, we define a low-level flowchart language for quantum programming, which can be used in implementation of high-level quantum languages and in design of quantum compilers. The formal semantics of the flowchart language is given, and the notion of correctness for programs written in this language is introduced. A structured quantum programming theorem is presented, which provides a technique of translating quantum flowchart programs into programs written in a high-level language, namely, a quantum extension of the while-language.","1939-3520","","10.1109/TSE.2010.94","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5611555","Quantum programming;flowchart language;while-language;structured programming.","Quantum computing;Semantics;Quantum mechanics;Programming;Computer languages;Probabilistic logic;Computers","flowcharting;formal languages;program compilers;program interpreters;programming language semantics;quantum computing","high level quantum programming language;low level flowchart language;quantum compiler design;formal semantics;structured quantum programming theorem;quantum flowchart program translation","","8","1","34","","28 Oct 2010","","","IEEE","IEEE Journals"
"Using Reduced Execution Flow Graph to Identify Library Functions in Binary Code","J. Qiu; X. Su; P. Ma","School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China; School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China; School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China","IEEE Transactions on Software Engineering","11 Feb 2016","2016","42","2","187","202","Discontinuity and polymorphism of a library function create two challenges for library function identification, which is a key technique in reverse engineering. A new hybrid representation of dependence graph and control flow graph called Execution Flow Graph (EFG) is introduced to describe the semantics of binary code. Library function identification turns to be a subgraph isomorphism testing problem since the EFG of a library function instance is isomorphic to the sub-EFG of this library function. Subgraph isomorphism detection is time-consuming. Thus, we introduce a new representation called Reduced Execution Flow Graph (REFG) based on EFG to speed up the isomorphism testing. We have proved that EFGs are subgraph isomorphic as long as their corresponding REFGs are subgraph isomorphic. The high efficiency of the REFG approach in subgraph isomorphism detection comes from fewer nodes and edges in REFGs and new lossless filters for excluding the unmatched subgraphs before detection. Experimental results show that precisions of both the EFG and REFG approaches are higher than the state-of-the-art tool and the REFG approach sharply decreases the processing time of the EFG approach with consistent precision and recall.","1939-3520","","10.1109/TSE.2015.2470241","National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7210204","Reverse engineering;static analysis;inline function;library function identification;subgraph isomorphism and graph mining;Reverse engineering;static analysis;inline function;library function identification;subgraph isomorphism and graph mining","Libraries;Registers;Binary codes;Testing;Joining processes;Flow graphs;Reverse engineering","binary codes;graph theory;reverse engineering;software libraries","reduced execution flow graph;library function identification;binary code;reverse engineering;hybrid representation;dependence graph;control flow graph;subgraph isomorphism testing problem;library function instance;subgraph isomorphism detection;REFG;lossless filters","","13","","29","","19 Aug 2015","","","IEEE","IEEE Journals"
"A Multi-Site Joint Replication of a Design Patterns Experiment Using Moderator Variables to Generalize across Contexts","J. L. Krein; L. Prechelt; N. Juristo; A. Nanthaamornphong; J. C. Carver; S. Vegas; C. D. Knutson; K. D. Seppi; D. L. Eggett","Department of Computer Science, Provo, UT; Institut für Informatik, Germany; Computing School, Spain; Department of Information and Communication Technology, Thailand; Department of Computer Science, Tuscaloosa, AL; Computing School, Spain; Department of Computer Science, Provo, UT; Department of Computer Science, Provo, UT; Department of Statistics, Provo, UT","IEEE Transactions on Software Engineering","14 Apr 2016","2016","42","4","302","321","Context. Several empirical studies have explored the benefits of software design patterns, but their collective results are highly inconsistent. Resolving the inconsistencies requires investigating moderators—i.e., variables that cause an effect to differ across contexts. Objectives. Replicate a design patterns experiment at multiple sites and identify sufficient moderators to generalize the results across prior studies. Methods. We perform a close replication of an experiment investigating the impact (in terms of time and quality) of design patterns (Decorator and Abstract Factory) on software maintenance. The experiment was replicated once previously, with divergent results. We execute our replication at four universities—spanning two continents and three countries—using a new method for performing distributed replications based on closely coordinated, small-scale instances (“joint replication”). We perform two analyses: 1) a  post-hoc analysis of moderators, based on frequentist and Bayesian statistics; 2) an a priori  analysis of the original hypotheses, based on frequentist statistics. Results. The main effect differs across the previous instances of the experiment and across the sites in our distributed replication. Our analysis of moderators (including developer experience and pattern knowledge) resolves the differences sufficiently to allow for cross-context (and cross-study) conclusions. The final conclusions represent 126 participants from five universities and 12 software companies, spanning two continents and at least four countries. Conclusions. The Decorator pattern is found to be preferable to a simpler solution during maintenance, as long as the developer has at least some prior knowledge of the pattern. For Abstract Factory, the simpler solution is found to be mostly equivalent to the pattern solution. Abstract Factory is shown to require a higher level of knowledge and/or experience than Decorator for the pattern to be beneficial.","1939-3520","","10.1109/TSE.2015.2488625","Spanish Ministry of Economy and Competitiveness; LLC; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7294706","Design patterns;software maintenance;moderator variables;multi-site;joint replication;controlled experiment;Design patterns;software maintenance;moderator variables;multi-site;joint replication;controlled experiment","Production facilities;Design methodology;Training;Context modeling","","","","4","","42","","8 Oct 2015","","","IEEE","IEEE Journals"
"Integer Parameter Synthesis for Real-Time Systems","A. Jovanović; D. Lime; O. H. Roux","Ecole Centrale de Nantes - IRCCyN UMR CNRS 6597, Nantes, France; Ecole Centrale de Nantes - IRCCyN UMR CNRS 6597, Nantes, France; Ecole Centrale de Nantes - IRCCyN UMR CNRS 6597, Nantes, France","IEEE Transactions on Software Engineering","12 May 2015","2015","41","5","445","461","We provide a subclass of parametric timed automata (PTA) that we can actually and efficiently analyze, and we argue that it retains most of the practical usefulness of PTA for the modeling of real-time systems. The currently most useful known subclass of PTA, L/U automata, has a strong syntactical restriction for practical purposes, and we show that the associated theoretical results are mixed. We therefore advocate for a different restriction scheme: since in classical timed automata, real-valued clocks are always compared to integers for all practical purposes, we also search for parameter values as bounded integers. We show that the problem of the existence of parameter values such that some TCTL property is satisfied is PSPACE-complete. In such a setting, we can of course synthesize all the values of parameters and we give symbolic algorithms, for reachability and unavoidability properties, to do it efficiently, i.e., without an explicit enumeration. This also has the practical advantage of giving the result as symbolic constraints between the parameters. We finally report on a few experimental results to illustrate the practical usefulness of our approach.","1939-3520","","10.1109/TSE.2014.2357445","ANR; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6895298","Timed automata;parameters;synthesis;model-checking;real-time systems;symbolic algorithms","Cost accounting;Automata;Clocks;Radiation detectors;Upper bound;Delays;Real-time systems","automata theory;reachability analysis;real-time systems","integer parameter synthesis;real-time systems;parametric timed automata;PTA;real-valued clocks;TCTL property;PSPACE-complete;symbolic algorithms;reachability;symbolic constraints","","38","","36","","11 Sep 2014","","","IEEE","IEEE Journals"
"Automatically Generating Test Cases for Specification Mining","V. Dallmeier; N. Knopp; C. Mallon; G. Fraser; S. Hack; A. Zeller","Universität des Saarlandes, Saarbrücken; Universität des Saarlandes, Saarbrücken; Universität des Saarlandes, Saarbrücken; Universität des Saarlandes, Saarbrücken; Universität des Saarlandes, Saarbrücken; Universität des Saarlandes, Saarbrücken","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","243","257","Dynamic specification mining observes program executions to infer models of normal program behavior. What makes us believe that we have seen sufficiently many executions? The TAUTOKO (“Tautoko” is the Mãori word for “enhance, enrich.”) typestate miner generates test cases that cover previously unobserved behavior, systematically extending the execution space, and enriching the specification. To our knowledge, this is the first combination of systematic test case generation and typestate mining-a combination with clear benefits: On a sample of 800 defects seeded into six Java subjects, a static typestate verifier fed with enriched models would report significantly more true positives and significantly fewer false positives than the initial models.","1939-3520","","10.1109/TSE.2011.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6044587","Specification mining;test case generation;typestate analysis.","Testing;Java;Instruments;Schedules;Software;Heuristic algorithms;Fault detection","automatic test pattern generation;data mining;formal specification;Java;program verification","automatic test case generation;dynamic specification mining;program executions;normal program behavior;TAUTOKO;typestate mining;Java;static typestate verifier","","44","","31","","13 Oct 2011","","","IEEE","IEEE Journals"
"Timed Automata Modeling and Verification for Publish-Subscribe Structures Using Distributed Resources","V. Valero; G. Díaz; M. Cambronero","Department of Computer Science, University of Castilla-La Mancha, Albacete, Spain; Department of Computer Science, University of Castilla-La Mancha, Albacete, Spain; Department of Computer Science, University of Castilla-La Mancha, Albacete, Spain","IEEE Transactions on Software Engineering","9 Jan 2017","2017","43","1","76","99","In this paper we present a Timed Automata model for the Publish/Subscribe paradigm in the context of Web Service Compositions with distributed resources, on the basis of an algebraic language inspired by the WSRF standard constructions. This framework allows a set of participants in a Web Service composition to interact with one another and also to manage a collection of distributed resources. The model includes operations for clients to publish, discover and subscribe to resources, so as to be notified when the resource property values fulfill certain conditions (topic-based subscription). Simulation and model-checking techniques can therefore be applied to the obtained network of timed automata, in order to check whether certain properties of interest are satisfied. A specific case study is finally presented to illustrate the model and the verification of the relevant properties on the obtained timed automata model.","1939-3520","","10.1109/TSE.2016.2560842","Spanish Government; FEDER; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7463051","Publish/subscribe;formal modeling;timed automata;verification;model checking","Web services;Automata;Unified modeling language;Semantics;Clocks;Probabilistic logic;Context modeling","algebra;automata theory;formal verification;message passing;middleware;resource allocation;Web services","timed automata modeling;timed automata verification;publish-subscribe structures;resource distribution;publish-subscribe paradigm;Web service compositions;algebraic language;WSRF standard constructions;resource property values;topic-based subscription;model checking","","7","","24","","29 Apr 2016","","","IEEE","IEEE Journals"
"Inferring Loop Invariants by Mutation, Dynamic Analysis, and Static Checking","J. P. Galeotti; C. A. Furia; E. May; G. Fraser; A. Zeller","Saarland University, Saarbrücken, Germany; ETH Zurich, Switzerland; Google Inc, London, United Kingdom; Department of Computer Science, University of Sheffield, United Kingdom; Saarland University, Saarbrücken, Germany","IEEE Transactions on Software Engineering","13 Oct 2015","2015","41","10","1019","1037","Verifiers that can prove programs correct against their full functional specification require, for programs with loops, additional annotations in the form of loop invariants-properties that hold for every iteration of a loop. We show that significant loop invariant candidates can be generated by systematically mutating postconditions; then, dynamic checking (based on automatically generated tests) weeds out invalid candidates, and static checking selects provably valid ones. We present a framework that automatically applies these techniques to support a program prover, paving the way for fully automatic verification without manually written loop invariants: Applied to 28 methods (including 39 different loops) from various java.util classes (occasionally modified to avoid using Java features not fully supported by the static checker), our DYNAMATE prototype automatically discharged 97 percent of all proof obligations, resulting in automatic complete correctness proofs of 25 out of the 28 methods-outperforming several state-of-the-art tools for fully automatic verification.","1939-3520","","10.1109/TSE.2015.2431688","European Research Council; European Union’s Seventh Framework Programme; ERC; EU FP7; Swiss SNF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7105412","Loop invariants;inference;automatic verification;functional properties;dynamic analysis;Loop invariants;inference;automatic verification;functional properties;dynamic analysis","Heuristic algorithms;Java;Generators;Detectors;Arrays;Prototypes;Instruments","formal specification;Java;program control structures;program testing;program verification;system monitoring","loop invariant inference;mutation;dynamic analysis;static checking;functional specification;program prover;automatic verification;Java.util classes;DYNAMATE prototype;automatic complete correctness proofs;test automatic generation","","13","","80","","11 May 2015","","","IEEE","IEEE Journals"
"Evaluating Complexity, Code Churn, and Developer Activity Metrics as Indicators of Software Vulnerabilities","Y. Shin; A. Meneely; L. Williams; J. A. Osborne","DePaul University, Chicago; North Carolina State University, Raleigh; North Carolina State University, Raleigh; North Carolina State University, Raleigh","IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","772","787","Security inspection and testing require experts in security who think like an attacker. Security experts need to know code locations on which to focus their testing and inspection efforts. Since vulnerabilities are rare occurrences, locating vulnerable code locations can be a challenging task. We investigated whether software metrics obtained from source code and development history are discriminative and predictive of vulnerable code locations. If so, security experts can use this prediction to prioritize security inspection and testing efforts. The metrics we investigated fall into three categories: complexity, code churn, and developer activity metrics. We performed two empirical case studies on large, widely used open-source projects: the Mozilla Firefox web browser and the Red Hat Enterprise Linux kernel. The results indicate that 24 of the 28 metrics collected are discriminative of vulnerabilities for both projects. The models using all three types of metrics together predicted over 80 percent of the known vulnerable files with less than 25 percent false positives for both projects. Compared to a random selection of files for inspection and testing, these models would have reduced the number of files and the number of lines of code to inspect or test by over 71 and 28 percent, respectively, for both projects.","1939-3520","","10.1109/TSE.2010.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5560680","Fault prediction;software metrics;software security;vulnerability prediction.","Fault diagnosis;Software security;Complexity theory;Predictive models;Charge coupled devices","Linux;online front-ends;program testing;public domain software;software fault tolerance;software metrics","code churn;software vulnerabilities;developer activity metrics;security inspection;software metrics;source code;vulnerable code locations;open-source projects;Mozilla Firefox Web browser;Red Hat enterprise Linux kernel","","224","2","43","","2 Sep 2010","","","IEEE","IEEE Journals"
"Examining the Potentially Confounding Effect of Class Size on the Associations between Object-Oriented Metrics and Change-Proneness","Y. Zhou; H. Leung; B. Xu","State Key Laboratory for Novel Software Technology and Nanjing University, Jiangsu; Hong Kong Polytechnic University, Hong Kong; State Key Laboratory for Novel Software Technology and Nanjing University, Jiangsu","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","607","623","Previous research shows that class size can influence the associations between object-oriented (OO) metrics and fault-proneness and therefore proposes that it should be controlled as a confounding variable when validating OO metrics on fault-proneness. Otherwise, their true associations may be distorted. However, it has not been determined whether this practice is equally applicable to other external quality attributes. In this paper, we use three size metrics, two of which are available during the high-level design phase, to examine the potentially confounding effect of class size on the associations between OO metrics and change-proneness. The OO metrics that are investigated include cohesion, coupling, and inheritance metrics. Our results, based on Eclipse, indicate that: 1) The confounding effect of class size on the associations between OO metrics and change-proneness, in general, exists, regardless of whichever size metric is used; 2) the confounding effect of class size generally leads to an overestimate of the associations between OO metrics and change-proneness; and 3) for many OO metrics, the confounding effect of class size completely accounts for their associations with change-proneness or results in a change of the direction of the associations. These results strongly suggest that studies validating OO metrics on change-proneness should also consider class size as a confounding variable.","1939-3520","","10.1109/TSE.2009.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4967613","Object-oriented;metrics;validation;class size;confounding;change-proneness.","Size control;Maintenance;Predictive models;Size measurement;Laboratories","inheritance;object-oriented programming;program verification;programming environments;software maintenance;software metrics;software quality","object-oriented metrics;change-proneness;fault-proneness;potentially confounding class size effect;high-level design phase;external quality attribute;cohesion metrics;coupling metrics;inheritance metrics;Eclipse;program validation","","70","","57","","26 May 2009","","","IEEE","IEEE Journals"
"An Empirical Methodology to Evaluate Vulnerability Discovery Models","F. Massacci; V. H. Nguyen","DISI, University of Trento, Trento, TN, Italy; DISI, University of Trento, Trento, TN, Italy","IEEE Transactions on Software Engineering","12 Dec 2014","2014","40","12","1147","1162","Vulnerability discovery models (VDMs) operate on known vulnerability data to estimate the total number of vulnerabilities that will be reported after a software is released. VDMs have been proposed by industry and academia, but there has been no systematic independent evaluation by researchers who are not model proponents. Moreover, the traditional evaluation methodology has some issues that biased previous studies in the field. In this work we propose an empirical methodology that systematically evaluates the performance of VDMs along two dimensions (quality and predictability) and addresses all identified issues of the traditional methodology. We conduct an experiment to evaluate most existing VDMs on popular web browsers' vulnerability data. Our comparison shows that the results obtained by the proposed methodology are more informative than those by the traditional methodology. Among evaluated VDMs, the simplest linear model is the most appropriate choice in terms of both quality and predictability for the first 6-12 months since a release date. Otherwise, logistics-based models are better choices.","1939-3520","","10.1109/TSE.2014.2354037","Seventh Framework Programme; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6891367","Software security;empirical evaluation;vulnerability discovery model;vulnerability analysis","Data models;Computer security;Operating systems;Browsers;Computer bugs;Predictive models","online front-ends;security of data;software quality","empirical methodology;vulnerability discovery model evaluation;VDM;quality;predictability;Web browser vulnerability data;logistics-based model;time 6 month to 12 month","","25","","54","","4 Sep 2014","","","IEEE","IEEE Journals"
"An Integrative Economic Optimization Approach to Systems Development Risk Management","M. Benaroch; J. Goldstein","Syracuse University, Syracuse; Syracuse University, Syracuse","IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","638","653","Despite significant research progress on the problem of managing systems development risk, we are yet to see this problem addressed from an economic optimization perspective. Doing so entails answering the question: What mitigations should be planned and deployed throughout the life of a systems development project in order to control risk and maximize project value? We introduce an integrative economic optimization approach to solving this problem. The approach is integrative since it bridges two complementary research streams: one takes a traditional microlevel technical view on the software development endeavor alone, another takes a macrolevel business view on the entire life cycle of a systems project. Bridging these views requires recognizing explicitly that value-based risk management decisions pertaining to one level impact and can be impacted by decisions pertaining to the other level. The economic optimization orientation follows from reliance on real options theory in modeling risk management decisions within a dynamic stochastic optimization setting. Real options theory is well suited to formalizing the impacts of risk as well as the asymmetric and contingent economic benefits of mitigations, in a way that enables their optimal balancing. We also illustrate how the approach is applied in practice to a small realistic example.","1939-3520","","10.1109/TSE.2009.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815277","Risk management;systems development;economics.","Risk management;Programming;Control systems;Bridges;Costs;Risk analysis;Research and development management;Stochastic processes;Information analysis;Information management","business data processing;dynamic programming;macroeconomics;project management;risk management;software prototyping;stochastic programming","integrative economic optimization approach;system development risk management;system development project life cycle;microlevel technical view;software development;macrolevel business view;value-based risk management decision;dynamic stochastic optimization setting;real option theory","","6","","43","","17 Apr 2009","","","IEEE","IEEE Journals"
"An Ontology-Based Product Architecture Derivation Approach","H. A. Duran-Limon; C. A. Garcia-Rios; F. E. Castillo-Barrera; R. Capilla","Department of Information Systems, University of Guadalajara, CUCEA, Mexico; Department of Information Systems, University of Guadalajara, CUCEA, Mexico; School of Engineering, Autonomous University of San Luis Potosi, Mexico; Department of Computer Science, Rey Juan Carlos University of Madrid, Spain","IEEE Transactions on Software Engineering","9 Dec 2015","2015","41","12","1153","1168","Software product line (SPL) engineering has proven to improve software quality and shorten development cycles, cost and time. In product line engineering, product derivation is concerned with the realization of the variability at the implementation level. However, the majority of research works focuses on instantiating the variants selected in the final product, while the derivation at the architecture level has been poorly explored. As product line engineers often customize the product architecture by hand during the application engineering phase, the derivation and customization processes of the product line architecture (PLA) might be in some cases error-prone. Consequently, in this research we present an Ontology-based product Architecture Derivation (OntoAD) framework which automates the derivation of product-specific architectures from an SPL architecture. Our solution uses a language-independent model to specify the product line architecture and a model-driven engineering approach for architecture derivation activities. We use an ontology formalism to reason about the automatic generation of model-to-model transformation rules based on the selection of features and we illustrate our approach using a voice over IP motivating example. Finally, we report results about scalability and performance regarding the size of the variability model.","1939-3520","","10.1109/TSE.2015.2449854","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7134799","Software Product Lines;Feature Models;Software Architecture;Product Derivation;Architecture Derivation;Ontologies;Model-Driven Engineering;Scalability;Software product lines;feature models;software architecture;product derivation;architecture derivation;ontologies;model-driven engineering;scalability","Unified modeling language;Computer architecture;Ontologies;Software product lines;Software architecture;Scalability","ontologies (artificial intelligence);software architecture;software product lines;software quality","ontology-based product architecture derivation approach;software product line engineering;SPL engineering;software quality;software development cycles;software development cost;software development time;product derivation;product customization;product line architecture;PLA;OntoAD;product-specific architectures;SPL architecture;language-independent model;model-driven engineering;architecture derivation activities;model-to-model transformation rules;features selection;voice over IP","","3","","53","","25 Jun 2015","","","IEEE","IEEE Journals"
"GoPrime: A Fully Decentralized Middleware for Utility-Aware Service Assembly","M. Caporuscio; V. Grassi; M. Marzolla; R. Mirandola","Department of Computer Science, Linnaeus University, Växjö, Sweden; Informatica, Sistemi e Produzione, University of Roma “Tor Vergata,”, Roma, Italy; Dipartimento di Informatica Scienza e Ingegneria, University of Bologna, Bologna, Italy; Dipartimento di Elettronica, Informazione e Bioingegneria, Politecnico di Milano, Milano, Italy","IEEE Transactions on Software Engineering","11 Feb 2016","2016","42","2","136","152","Modern applications, e.g., for pervasive computing scenarios, are increasingly reliant on systems built from multiple distributed components, which must be suitably composed to meet some specified functional and non-functional requirements. A key challenge is how to efficiently and effectively manage such complex systems. The use of self-management capabilities has been suggested as a possible way to address this challenge. To cope with the scalability and robustness issues of large distributed systems, self-management should ideally be architected in a decentralized way, where the overall system behavior emerges from local decisions and interactions. Within this context, we propose GOPRIME, a fully decentralized middleware solution for the adaptive self-assembly of distributed services. The GOPRIME goal is to build and maintain an assembly of services that, besides functional requirements, fulfils also global quality-of-service and structural requirements. The key aspect of GOPRIME is the use of a gossip protocol to achieve decentralized information dissemination and decision making. To show the validity of our approach, we present results from the experimentation of a prototype implementation of GOPRIME in a mobile health application, and an extensive set of simulation experiments that assess the effectiveness of GOPRIME in terms of scalability, robustness and convergence speed.","1939-3520","","10.1109/TSE.2015.2476797","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7243346","Service-oriented architecture;pervasive computing;runtime adaptation;quality of service;gossip protocol;Service-oriented architecture;pervasive computing;runtime adaptation;quality of service;gossip protocol","Assembly;Compounds;Quality of service;Peer-to-peer computing;Scalability;Middleware;Robustness","distributed processing;middleware;ubiquitous computing","GOPRIME;fully decentralized middleware;utility-aware service assembly;pervasive computing;distributed components;self-management capabilities;gossip protocol;decentralized information dissemination;decision making;mobile health application","","11","","30","","4 Sep 2015","","","IEEE","IEEE Journals"
"Usability through Software Design","L. Carvajal; A. M. Moreno; M. Sánchez-Segura; A. Seffah","Universidad Politécnica de Madrid, Madrid; Universidad Politécnica de Madrid, Madrid; Carlos III University of Madrid, Leganes; Concordia University, Montreal","IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1582","1596","Over the past two decades, the HCI community has proposed specific features that software applications should include to overcome some of the most common usability problems. However, incorporating such usability features into software applications may not be a straightforward process for software developers who have not been trained in usability (i.e., determining when, how, and why usability features should been considered). We have defined a set of usability guidelines for software development to help software engineers incorporate particular usability features into their applications. In this paper, we focus on the software design artifacts provided by the guidelines. We detail the structure of the proposed design artifacts and how they should be used according to the software development process and software architecture used in each application. We have tested our guidelines in an academic setting. Preliminary validation shows that the use of the guidelines reduces development time, improves the quality of the resulting designs, and significantly decreases the perceived complexity of the usability features from the developers' perspective.","1939-3520","","10.1109/TSE.2013.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6523225","Software usability;software design;software design patterns","Usability;Guidelines;Human computer interaction;Unified modeling language;Communities","human computer interaction;object-oriented methods;software architecture;software quality;user interfaces","software usability;software design patterns;HCI community;human computer interaction;software development process;software design artifacts;software architecture;integral software development quality aspect","","17","","24","","4 Jun 2013","","","IEEE","IEEE Journals"
"DESSERT: a DividE-and-conquer methodology for identifying categorieS, choiceS, and choicE Relations for Test case generation","T. Y. Chen; P. Poon; S. Tang; T. H. Tse","Swinburne University of Technology, Melbourne; The Hong Kong Polytechnic University, Hong Kong; Swinburne University of Technology, Melbourne; The University of Hong Kong, Hong Kong","IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","794","809","This paper extends the choce relation framework, abbreviated as choc'late, which assists software testers in the application of category/choice methods to testing. choc'late assumes that the tester is able to construct a single choice relation table from the entire specification; this table then forms the basis for test case generation using the associated algorithms. This assumption, however, may not hold true when the specification is complex and contains many specification components. For such a specification, the tester may construct a preliminary choice relation table from each specification component, and then consolidate all the preliminary tables into a final table to be processed by choc'late for test case generation. However, it is often difficult to merge these preliminary tables because such merging may give rise to inconsistencies among choice relations or overlaps among choices. To alleviate this problem, we introduce a DividE-and-conquer methodology for identifying categorieS, choiceS, and choicE Relations for Test case generation, abbreviated as dessert. The theoretical framework and the associated algorithms are discussed. To demonstrate the viability and effectiveness of our methodology, we describe case studies using the specifications of three real-life commercial software systems.","1939-3520","","10.1109/TSE.2011.69","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5963695","Black-box testing;category-partition method;choice relation framework;choice relation table;software testing;test case generation","Awards activities;Electronic mail;Software systems;Encoding;Software testing","divide and conquer methods;formal specification;program testing","DESSERT;divide-and-conquer methodology;category identification;choice identification;choice relation identification;test case generation;specification components;real-life commercial software systems;software testing;CHOC'LATE;black-box testing","","12","","18","","28 Jul 2011","","","IEEE","IEEE Journals"
"Program Behavior Discovery and Verification: A Graph Grammar Approach","C. Zhao; J. Kong; K. Zhang","The University of Texas at Dallas, Richardson; North Dakota State University, Fargo; The University of Texas at Dallas, Richardson","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","431","448","Discovering program behaviors and functionalities can ease program comprehension and verification. Existing program analysis approaches have used text mining algorithms to infer behavior patterns or formal models from program execution. When one tries to identify the hierarchical composition of a program behavior at different abstraction levels, textual descriptions are not informative and expressive enough. To address this, we present a semi-automatic graph grammar approach to retrieving the hierarchical structure of the program behavior. The hierarchical structure is built on recurring substructures in a bottom-up fashion. We formulate the behavior discovery and verification problem as a graph grammar induction and parsing problem, i.e., automatically iteratively mining qualified patterns and then constructing graph rewriting rules. Furthermore, using the induced grammar to parse the behavioral structure of a new program could verify if the program has the same behavioral properties specified by the grammar.","1939-3520","","10.1109/TSE.2010.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383371","Visual language;graph grammar induction;program comprehension;reengineering.","Software maintenance;Reverse engineering;Learning automata;Software systems;Data mining;Clustering algorithms;Pattern analysis;Algorithm design and analysis;Text mining;Documentation","data mining;graph grammars;program verification","program behavior discovery;program behavior verification;program comprehension;text mining algorithms;behavior patterns;formal models;program execution;semi-automatic graph grammar approach;graph rewriting rules;mining qualified patterns","","17","","60","","15 Jan 2010","","","IEEE","IEEE Journals"
"An Attack Surface Metric","P. K. Manadhata; J. M. Wing","Symantec Research Labs, Culver City; Carnegie Mellon University, Pittsburgh and US National Science Foundation, Arlington","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","371","386","Measurement of software security is a long-standing challenge to the research community. At the same time, practical security metrics and measurements are essential for secure software development. Hence, the need for metrics is more pressing now due to a growing demand for secure software. In this paper, we propose using a software system's attack surface measurement as an indicator of the system's security. We formalize the notion of a system's attack surface and introduce an attack surface metric to measure the attack surface in a systematic manner. Our measurement method is agnostic to a software system's implementation language and is applicable to systems of all sizes; we demonstrate our method by measuring the attack surfaces of small desktop applications and large enterprise systems implemented in C and Java. We conducted three exploratory empirical studies to validate our method. Software developers can mitigate their software's security risk by measuring and reducing their software's attack surfaces. Our attack surface reduction approach complements the software industry's traditional code quality improvement approach for security risk mitigation and is useful in multiple phases of the software development lifecycle. Our collaboration with SAP demonstrates the use of our metric in the software development process.","1939-3520","","10.1109/TSE.2010.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5482589","Code design;life cycle;product metrics;protection mechanisms;risk mitigation;software security.","Software measurement;Security;Programming;Software systems;Size measurement;Time measurement;Pressing;Application software;Java;Software quality","C language;Java;security;software metrics","attack surface metric;software security;security metrics;software development;implementation language;C language;Java language","","268","7","53","","7 Jun 2010","","","IEEE","IEEE Journals"
"Improving Multi-Objective Test Case Selection by Injecting Diversity in Genetic Algorithms","A. Panichella; R. Oliveto; M. D. Penta; A. De Lucia","Department of Mathematics and Computer Science, University of Salerno, Fisciano, Salerno, Italy; Department of Bioscience and Territory, University of Molise, Pesche, Isernia, Italy; Department of Engineering, University of Sannio, Benevento, Italy; Department of Mathematics and Computer Science, University of Salerno, Fisciano, Salerno, Italy","IEEE Transactions on Software Engineering","14 Apr 2015","2015","41","4","358","383","A way to reduce the cost of regression testing consists of selecting or prioritizing subsets of test cases from a test suite according to some criteria. Besides greedy algorithms, cost cognizant additional greedy algorithms, multi-objective optimization algorithms, and multi-objective genetic algorithms (MOGAs), have also been proposed to tackle this problem. However, previous studies have shown that there is no clear winner between greedy and MOGAs, and that their combination does not necessarily produce better results. In this paper we show that the optimality of MOGAs can be significantly improved by diversifying the solutions (sub-sets of the test suite) generated during the search process. Specifically, we introduce a new MOGA, coined as DIversity based Genetic Algorithm (DIV-GA), based on the mechanisms of orthogonal design and orthogonal evolution that increase diversity by injecting new orthogonal individuals during the search process. Results of an empirical study conducted on eleven programs show that DIV-GA outperforms both greedy algorithms and the traditional MOGAs from the optimality point of view. Moreover, the solutions (sub-sets of the test suite) provided by DIV-GA are able to detect more faults than the other algorithms, while keeping the same test execution cost.","1939-3520","","10.1109/TSE.2014.2364175","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6936894","Test Case Selection;Regression Testing;Orthogonal Design;Singular Value Decomposition;Genetic Algorithms;Empirical Studies;Test case selection;regression testing;orthogonal design;singular value decomposition;genetic algorithms;empirical studies","Optimization;Greedy algorithms;Testing;Linear programming;Genetic algorithms;Genetics;Sociology","genetic algorithms;greedy algorithms;program testing;search problems","multiobjective test case selection improvement;regression testing cost reduction;test case subset prioritization;test case subset selection;greedy algorithms;multiobjective optimization algorithms;multiobjective genetic algorithms;MOGA optimality improvement;test suite subsets;search process;diversity-based genetic algorithm;DIV-GA;orthogonal design mechanism;orthogonal evolution mechanism;empirical analysis","","51","","76","","27 Oct 2014","","","IEEE","IEEE Journals"
"Efficient Consistency Measurement Based on Behavioral Profiles of Process Models","M. Weidlich; J. Mendling; M. Weske","Hasso Plattner Institute, Potsdam; Humboldt-Universität zu Berlin, Berlin; Hasso Plattner Institute, Berlin","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","410","429","Engineering of process-driven business applications can be supported by process modeling efforts in order to bridge the gap between business requirements and system specifications. However, diverging purposes of business process modeling initiatives have led to significant problems in aligning related models at different abstract levels and different perspectives. Checking the consistency of such corresponding models is a major challenge for process modeling theory and practice. In this paper, we take the inappropriateness of existing strict notions of behavioral equivalence as a starting point. Our contribution is a concept called behavioral profile that captures the essential behavioral constraints of a process model. We show that these profiles can be computed efficiently, i.e., in cubic time for sound free-choice Petri nets w.r.t. their number of places and transitions. We use behavioral profiles for the definition of a formal notion of consistency which is less sensitive to model projections than common criteria of behavioral equivalence and allows for quantifying deviation in a metric way. The derivation of behavioral profiles and the calculation of a degree of consistency have been implemented to demonstrate the applicability of our approach. We also report the findings from checking consistency between partially overlapping models of the SAP reference model.","1939-3520","","10.1109/TSE.2010.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5611557","Process model analysis;process model alignment;behavioral abstraction;consistency checking;consistency measures.","Unified modeling language;Business;Analytical models;Semantics;Computational modeling;Petri nets;Software","commerce;corporate modelling;Petri nets","efficient consistency measurement;behavioral profiles;process-driven business applications;business requirements;system specifications;business process modeling;behavioral constraints;Petri nets;SAP reference model","","113","","82","","28 Oct 2010","","","IEEE","IEEE Journals"
"Developer Micro Interaction Metrics for Software Defect Prediction","T. Lee; J. Nam; D. Han; S. Kim; H. Peter In","Korea University, Seoul, South Korea; University of Waterloo, ON, Canada; University Colleage London, London, United Kingdom; Hong Kong University of Science and Technology, Hong Kong, China; Korea University, Seoul, South Korea","IEEE Transactions on Software Engineering","10 Nov 2016","2016","42","11","1015","1035","To facilitate software quality assurance, defect prediction metrics, such as source code metrics, change churns, and the number of previous defects, have been actively studied. Despite the common understanding that developer behavioral interaction patterns can affect software quality, these widely used defect prediction metrics do not consider developer behavior. We therefore propose micro interaction metrics (MIMs), which are metrics that leverage developer interaction information. The developer interactions, such as file editing and browsing events in task sessions, are captured and stored as information by Mylyn, an Eclipse plug-in. Our experimental evaluation demonstrates that MIMs significantly improve overall defect prediction accuracy when combined with existing software measures, perform well in a cost-effective manner, and provide intuitive feedback that enables developers to recognize their own inefficient behaviors during software development.","1939-3520","","10.1109/TSE.2016.2550458","Next-Generation Information Computing Development Program; National Research Foundation of Korea; Ministry of Education, Science and Technology; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7447797","Defect prediction;software quality;software metrics;developer interaction;Mylyn","Software quality;Software metrics;Quality assurance;Complexity theory","software maintenance;software metrics;software quality","developer microinteraction metrics;software quality assurance;software defect prediction;defect prediction metrics;developer behavioral interaction patterns;MIM metric;developer interaction information;Mylyn plug-in;Eclipse plug-in;software development","","25","","66","","5 Apr 2016","","","IEEE","IEEE Journals"
"A fluid model for layered queueing networks","M. Tribastone","Ludwig-Maximilians University of Munich, Munich","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","744","756","Layered queueing networks are a useful tool for the performance modeling and prediction of software systems that exhibit complex characteristics such as multiple tiers of service, fork/join interactions, and asynchronous communication. These features generally result in nonproduct form behavior for which particularly efficient approximations based on mean value analysis (MVA) have been devised. This paper reconsiders the accuracy of such techniques by providing an interpretation of layered queueing networks as fluid models. Mediated by an automatic translation into a stochastic process algebra, PEPA, a network is associated with a set of ordinary differential equations (ODEs) whose size is insensitive to the population levels in the system under consideration. A substantial numerical assessment demonstrates that this approach significantly improves the quality of the approximation for typical performance indices such as utilization, throughput, and response time. Furthermore, backed by established theoretical results of asymptotic convergence, the error trend shows monotonic decrease with larger population sizes-a behavior which is found to be in sharp contrast with that of approximate mean value analysis, which instead tends to increase.","1939-3520","","10.1109/TSE.2012.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6314480","Modeling and prediction;Markov processes;PEPA;ordinary differential equations;queueing networks;mean value analysis","Approximation methods;Unified modeling language;Stochastic processes;Sociology;Statistics;Servers;Accuracy","approximation theory;differential equations;queueing theory;software performance evaluation","performance modeling;performance prediction;software systems;layered queueing networks;nonproduct form behavior;mean value analysis;MVA;fluid models;automatic translation;stochastic process algebra;PEPA;ordinary differential equations;numerical assessment;approximation quality;performance indices;asymptotic convergence","","22","","33","","27 Sep 2012","","","IEEE","IEEE Journals"
"Local versus Global Lessons for Defect Prediction and Effort Estimation","T. Menzies; A. Butcher; D. Cok; A. Marcus; L. Layman; F. Shull; B. Turhan; T. Zimmermann","West Virginia University, Morgantown; West Virginia University, Morgantown; GrammaTech, Ithaca; Wayne State University, Detroit; Fraunhofer Center, College Park; Fraunhofer Center, College Park; University of Oulu, Oulu; Microsoft Research, Redmond","IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","822","834","Existing research is unclear on how to generate lessons learned for defect prediction and effort estimation. Should we seek lessons that are global to multiple projects or just local to particular projects? This paper aims to comparatively evaluate local versus global lessons learned for effort estimation and defect prediction. We applied automated clustering tools to effort and defect datasets from the PROMISE repository. Rule learners generated lessons learned from all the data, from local projects, or just from each cluster. The results indicate that the lessons learned after combining small parts of different data sources (i.e., the clusters) were superior to either generalizations formed over all the data or local lessons formed from particular projects. We conclude that when researchers attempt to draw lessons from some historical data source, they should 1) ignore any existing local divisions into multiple sources, 2) cluster across all available data, then 3) restrict the learning of lessons to the clusters from other sources that are nearest to the test data.","1939-3520","","10.1109/TSE.2012.83","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363444","Data mining;clustering;defect prediction;effort estimation","Estimation;Data models;Context;Java;Telecommunications;Measurement;Software","automatic test pattern generation;data mining;pattern clustering","defect prediction;effort estimation;global lessons;local lessons;automated clustering tools;PROMISE repository;data source;learned lesson generated rule;defect dataset","","105","","71","","29 Nov 2012","","","IEEE","IEEE Journals"
"Class Schema Evolution for Persistent Object-Oriented Software: Model, Empirical Study, and Automated Support","M. Piccioni; M. Oriol; B. Meyer","ETH Zurich, Zurich; ABB Corporate Research, Industrial Software Systems, Baden-Dättwil and University of York, York; ETH Zurich, Zurich","IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","184","196","With the wide support for object serialization in object-oriented programming languages, persistent objects have become commonplace and most large object-oriented software systems rely on extensive amounts of persistent data. Such systems also evolve over time. Retrieving previously persisted objects from classes whose schema has changed is, however, difficult, and may lead to invalidating the consistency of the application. The ESCHER framework addresses these issues through an IDE-integrated approach that handles class schema evolution by managing versions of the code and generating transformation functions automatically. The infrastructure also enforces class invariants to prevent the introduction of potentially corrupt objects. This paper describes a model for class attribute changes, a measure for class evolution robustness, four empirical studies, and the design and implementation of the ESCHER system.","1939-3520","","10.1109/TSE.2011.123","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6122034","Versioning;persistence;serialization;object-oriented class schema evolution;IDE integration","Object oriented modeling;Java;Databases;Software;Robustness;Dictionaries;Atomic measurements","object-oriented languages;object-oriented programming;persistent objects","persistent object-oriented software;object serialization;object-oriented programming languages;object-oriented software systems;IDE-integrated approach;class schema evolution;automatic transformation function generation;potentially corrupt objects;class evolution robustness;ESCHER system implementation;ESCHER system design","","6","","43","","3 Jan 2012","","","IEEE","IEEE Journals"
"On the Accuracy, Efficiency, and Reusability of Automated Test Oracles for Android Devices","Y. Lin; J. F. Rojas; E. T. -. Chu; Y. Lai","Department of Computer Science, National Chiao Tung University, University Road, Hsinchu, Taiwan; Department of Computer Science, National Chiao Tung University, University Road, Hsinchu, Taiwan; Department of Computer Science and Information Engineering, National Yunlin University of Science and Technology, Yunlin, Taiwan; Department of Information Management, National Taiwan University of Science and Technology, Keelung Road, Taipei, Taiwan","IEEE Transactions on Software Engineering","9 Oct 2014","2014","40","10","957","970","Automated GUI testing consists of simulating user events and validating the changes in the GUI in order to determine if an Android application meets specifications. Traditional record-replay testing tools mainly focus on facilitating the test case writing process but not the replay and verification process. The accuracy of testing tools degrades significantly when the device under test (DUT) is under heavy load. In order to improve the accuracy, our previous work, SPAG, uses event batching and smart wait function to eliminate the uncertainty of the replay process and adopts GUI layout information to verify the testing results. SPAG maintains an accuracy of up to 99.5 percent and outperforms existing methods. In this work, we propose smart phone automated GUI testing tool with camera (SPAG-C), an extension of SPAG, to test an Android hardware device. Our goal is to further reduce the time required to record test cases and increase reusability of the test oracle without compromising test accuracy. In the record stage, SPAG captures screenshots from device's frame buffer and writes verification commands into the test case. Unlike SPAG, SPAG-C captures the screenshots from an external camera instead of frame buffer. In the replay stage, SPAG-C automatically performs image comparison while SPAG simply performs a string comparison to verify the test results. In order to make SPAG-C reusable for different devices and to allow bettersynchronization at the time of capturing images, we develop a new architecture that uses an external camera and Web services to decouple the test oracle. Our experiments show that recording a test case using SPAG-C's automatic verification is as fast as SPAG's but more accurate. Moreover, SPAG-C is 50 to 75 percent faster than SPAG in achieving the same test accuracy. With reusability, SPAG-C reduces the testing time from days to hours for heterogeneous devices.","1939-3520","","10.1109/TSE.2014.2331982","National Science Council (NSC) and Institute of Information Industry (III) in Taiwan; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6840332","Reusable software;test execution;testing tools;user interfaces","Graphical user interfaces;Testing;Androids;Humanoid robots;Accuracy;Smart phones;Performance evaluation","graphical user interfaces;program testing;smart phones;software reusability;Web services","automated test oracles;Android devices;user events;Android application;traditional record-replay testing tools;test case writing process;replay process;verification process;device under test;DUT;event batching;smart wait function;GUI layout information;smart phone automated GUI testing tool;with camera;SPAG-C;Android hardware device;test accuracy;frame buffer;replay stage;image comparison;capturing images;Web services;automatic verification","","20","","35","","19 Jun 2014","","","IEEE","IEEE Journals"
"The Impact of Design and Code Reviews on Software Quality: An Empirical Study Based on PSP Data","C. F. Kemerer; M. C. Paulk","University of Pittsburgh, Pittsburgh; Carnegie Mellon University, Pittsburgh","IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","534","550","This research investigates the effect of review rate on defect removal effectiveness and the quality of software products, while controlling for a number of potential confounding factors. Two data sets of 371 and 246 programs, respectively, from a personal software process (PSP) approach were analyzed using both regression and mixed models. Review activities in the PSP process are those steps performed by the developer in a traditional inspection process. The results show that the PSP review rate is a significant factor affecting defect removal effectiveness, even after accounting for developer ability and other significant process variables. The recommended review rate of 200 LOC/hour or less was found to be an effective rate for individual reviews, identifying nearly two-thirds of the defects in design reviews and more than half of the defects in code reviews.","1939-3520","","10.1109/TSE.2009.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4815279","Code reviews;design reviews;inspections;software process;software quality;defects;software measurement;mixed models;personal software process (PSP).","Software quality;Inspection;Business continuity;Software performance;Computer Society;Lab-on-a-chip;Software design;Software measurement;Costs;Job shop scheduling","program debugging;program testing;regression analysis;software metrics;software process improvement;software quality","design review impact;code review impact;software product quality;empirical study;PSP review rate;personal software process improvement approach;defect removal effectiveness;regression model;mixed model;inspection process;software measurement;business chain reaction","","51","1","55","","17 Apr 2009","","","IEEE","IEEE Journals"
"Which Crashes Should I Fix First?: Predicting Top Crashes at an Early Stage to Prioritize Debugging Efforts","D. Kim; X. Wang; S. Kim; A. Zeller; S. C. Cheung; S. Park","Sogang University, Seoul; The Hong Kong University of Science and Technology, Hong Kong; The Hong Kong University of Science and Technology, Hong Kong; Saarland University, Saarbrücken; The Hong Kong University of Science and Technology, Hong Kong; Sogang University, Seoul","IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","430","447","Many popular software systems automatically report failures back to the vendors, allowing developers to focus on the most pressing problems. However, it takes a certain period of time to assess which failures occur most frequently. In an empirical investigation of the Firefox and Thunderbird crash report databases, we found that only 10 to 20 crashes account for the large majority of crash reports; predicting these “top crashes” thus could dramatically increase software quality. By training a machine learner on the features of top crashes of past releases, we can effectively predict the top crashes well before a new release. This allows for quick resolution of the most important crashes, leading to improved user experience and better allocation of maintenance efforts.","1939-3520","","10.1109/TSE.2011.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5711013","Top crash;machine learning;crash reports;social network analysis;data mining.","Fires;Feature extraction;Software;Testing;Computer bugs;Training","program debugging;software maintenance;software quality;system recovery","debugging;software systems;software failures;Firefox crash report databases;Thunderbird crash report databases;software quality;software maintenance","","44","","59","","10 Feb 2011","","","IEEE","IEEE Journals"
"Exception Handling Patterns for Process Modeling","B. S. Lerner; S. Christov; L. J. Osterweil; R. Bendraou; U. Kannengiesser; A. Wise","Mount Holyoke College, South Hadley; University of Massachusetts, Amherst; University of Massachusetts, Amherst; Université Pierre & Marie Curie, Paris; NICTA, Alexandria and University of New South Wales, Sydney; University of Massachusetts, Amherst","IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","162","183","Process modeling allows for analysis and improvement of processes that coordinate multiple people and tools working together to carry out a task. Process modeling typically focuses on the normative process, that is, how the collaboration transpires when everything goes as desired. Unfortunately, real-world processes rarely proceed that smoothly. A more complete analysis of a process requires that the process model also include details about what to do when exceptional situations arise. We have found that, in many cases, there are abstract patterns that capture the relationship between exception handling tasks and the normative process. Just as object-oriented design patterns facilitate the development, documentation, and maintenance of object-oriented programs, we believe that process patterns can facilitate the development, documentation, and maintenance of process models. In this paper, we focus on the exception handling patterns that we have observed over many years of process modeling. We describe these patterns using three process modeling notations: UML 2.0 Activity Diagrams, BPMN, and Little-JIL. We present both the abstract structure of the pattern as well as examples of the pattern in use. We also provide some preliminary statistical survey data to support the claim that these patterns are found commonly in actual use and discuss the relative merits of the three notations with respect to their ability to represent these patterns.","1939-3520","","10.1109/TSE.2010.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383369","Exception handling patterns;process modeling;process modeling languages.","Object oriented modeling;Documentation;Humans;Pattern analysis;Collaborative work;Unified modeling language;Collaboration;Data processing;Manufacturing processes;Medical services","exception handling;groupware;object-oriented programming;software maintenance;system documentation","exception handling patterns;process modeling;collaboration process;normative process;object-oriented design patterns;object-oriented programs;process development;process documentation;process maintenance;UML 2.0 activity diagrams;BPMN;Little-JIL","","77","","51","","15 Jan 2010","","","IEEE","IEEE Journals"
"A Genetic Algorithm-Based Stress Test Requirements Generator Tool and Its Empirical Evaluation","V. Garousi","University of Calgary, Calgary","IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","778","797","Genetic algorithms (GAs) have been applied previously to UML-driven stress test requirements generation with the aim of increasing chances of discovering faults relating to network traffic in distributed real-time systems. However, since evolutionary algorithms are heuristic, their performance can vary across multiple executions, which may affect robustness and scalability. To address this, we present the design and technical detail of a UML-driven, GA-based stress test requirements generation tool, together with its empirical analysis. The main goal is to analyze and improve the applicability, efficiency, and effectiveness and also to validate the design choices of the GA used in the tool. Findings of the empirical evaluation reveal that the tool is robust and reasonably scalable when it is executed on large-scale experimental design models. The study also reveals the main bottlenecks and limitations of the tools, e.g., there is a performance bottleneck when the system under test has a large number of sequence diagrams which could be triggered independently from each other. In addition, issues specific to stress testing, e.g., the impact of variations in task arrival pattern types, reveal that the tool generally generates effective test requirements, although the features of those test requirements might be different in different runs (e.g., different stress times from the test start time might be chosen). While the use of evolutionary algorithms to generate software test cases has been widely reported, the extent, depth, and detail of the empirical findings presented in this paper are novel and suggest that the proposed approach is effective and efficient in generating stress test requirements. It is hoped that the findings of this empirical study will help other SBSE researchers with the empirical evaluation of their own techniques and tools.","1939-3520","","10.1109/TSE.2010.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5383373","Index Term—Search-based testing;genetic algorithms;stress testing;test tools;test automation;empirical analysis.","Stress;System testing;Robustness;Genetic algorithms;Telecommunication traffic;Real time systems;Evolutionary computation;Scalability;Large-scale systems;Design for experiments","distributed algorithms;genetic algorithms;program testing;real-time systems;Unified Modeling Language","genetic algorithm;UML;distributed real time system;empirical analysis;software test cases;stress test requirement generation","","18","1","32","","15 Jan 2010","","","IEEE","IEEE Journals"
"Verifying Synchronization for Atomicity Violation Fixing","Q. Shi; J. Huang; Z. Chen; B. Xu","State Key Lab. for Novel Software Technology, Nanjing University, Nanjing, China; Texas A&M University, College Station, TX; State Key Lab. for Novel Software Technology, Nanjing University, Nanjing, China; State Key Lab. for Novel Software Technology, Nanjing University, Nanjing, China","IEEE Transactions on Software Engineering","11 Mar 2016","2016","42","3","280","296","Atomicity is a fundamental property to guarantee the isolation of a work unit (i.e., a sequence of related events in a thread) from concurrent threads. However, ensuring atomicity is often very challenging due to complex thread interactions. We present an approach to help developers verify whether such work units, which have triggered bugs due to certain violations of atomicity, are sufficiently synchronized or not by locks introduced for fixing the bugs. A key feature of our approach is that it combines the fortes of both bug-driven and change-aware techniques, which enables it to effectively verify synchronizations by testing only a minimal set of suspicious atomicity violations without any knowledge on the to-be-isolated work units, thus being more efficient and practical than other approaches. Besides, unlike existing approaches, our approach effectively utilizes all the inferred execution traces even they may not be completely feasible, such that the verification algorithm can converge much faster. We demonstrate via extensive evaluation that our approach is much more effective and efficient than the state-of-the-arts. Besides, we show that although there have existed sound automatic fixing techniques for atomicity violations, our approach is still necessary and useful for quality assurance of concurrent programs, because the assumption behind our approach is much weaker. We have also investigated one of the largest bug databases and found that insufficient synchronizations are common and difficult to be found in software development.","1939-3520","","10.1109/TSE.2015.2477820","National Basic Research Program of China; National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7254228","Atomicity violations;insufficient synchronization;fix;dynamic trace analysis;maximal sound verification;Atomicity violations;insufficient synchronization;fix;dynamic trace analysis;maximal sound verification","Synchronization;Schedules;Optimization;Java;Computer bugs;Runtime;Instruction sets","program debugging;software quality;synchronisation","synchronization verification;atomicity violation fixing;work unit isolation;concurrent threads;complex thread interactions;triggered bugs;bug-driven techniques;change-aware techniques;suspicious atomicity violations;to-be-isolated work units;verification algorithm;extensive evaluation;automatic fixing techniques;concurrent programs;quality assurance;bug databases;software development","","6","","48","","10 Sep 2015","","","IEEE","IEEE Journals"
"The Impact of Irrelevant and Misleading Information on Software Development Effort Estimates: A Randomized Controlled Field Experiment","M. Jorgensen; S. Grimstad","University of Oslo and Simula Research Laboratory, Lysaker; University of Oslo and Simula Research Laboratory, Lysaker","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","695","707","Studies in laboratory settings report that software development effort estimates can be strongly affected by effort-irrelevant and misleading information. To increase our knowledge about the importance of these effects in field settings, we paid 46 outsourcing companies from various countries to estimate the required effort of the same five software development projects. The companies were allocated randomly to either the original requirement specification or a manipulated version of the original requirement specification. The manipulations were as follows: 1) reduced length of requirement specification with no change of content, 2) information about the low effort spent on the development of the old system to be replaced, 3) information about the client's unrealistic expectations about low cost, and 4) a restriction of a short development period with start up a few months ahead. We found that the effect sizes in the field settings were much smaller than those found for similar manipulations in laboratory settings. Our findings suggest that we should be careful about generalizing to field settings the effect sizes found in laboratory settings. While laboratory settings can be useful to demonstrate the existence of an effect and better understand it, field studies may be needed to study the size and importance of these effects.","1939-3520","","10.1109/TSE.2010.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551161","Cost estimation;software psychology;requirements/specifications.","Estimation;Software;Companies;Laboratories;Programming;Materials;Project management","formal specification;software cost estimation","irrelevant information impact;misleading information impact;software development effort estimates;randomized controlled field experiment;software development projects;original requirement specification;laboratory settings;software psychology","","31","","31","","19 Aug 2010","","","IEEE","IEEE Journals"
"PerLa: A Language and Middleware Architecture for Data Management and Integration in Pervasive Information Systems","F. A. Schreiber; R. Camplani; M. Fortunato; M. Marelli; G. Rota","Politecnico di Milano, Milano; Politecnico di Milano, Milano; Politecnico di Milano, Milano; Politecnico di Milano, Milano; Politecnico di Milano, Milano","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","478","496","A declarative SQL-like language and a middleware infrastructure are presented for collecting data from different nodes of a pervasive system. Data management is performed by hiding the complexity due to the large underlying heterogeneity of devices, which can span from passive RFID(s) to ad hoc sensor boards to portable computers. An important feature of the presented middleware is to make the integration of new device types in the system easy through the use of device self-description. Two case studies are described for PerLa usage, and a survey is made for comparing our approach with other projects in the area.","1939-3520","","10.1109/TSE.2011.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5728831","Declarative language;device heterogeneity;functionality proxy;middleware infrastructure;pervasive system;SQL;wireless sensor networks.","Middleware;Monitoring;Software;Context;Wireless sensor networks;Databases;Hardware","data integration;information systems;middleware;software architecture;SQL;ubiquitous computing","PerLa;language architecture;middleware architecture;data management;data integration;pervasive information systems;declarative SQL-like language;data collection;passive RFID;ad hoc sensor boards;portable computers;device self-description","","31","2","53","","10 Mar 2011","","","IEEE","IEEE Journals"
"Embedding Polychrony into Synchrony","J. Brandt; M. Gemünde; K. Schneider; S. K. Shukla; J. Talpin","University of Kaiserslautern, Kaiserslautern; University of Kaiserslautern, Kaiserslautern; University of Kaiserslautern, Kaiserslautern; Virginia Polytechnic and State University, Blacksburg; INRIA Rennes-Bretagne-Atlantique, Rennes","IEEE Transactions on Software Engineering","26 Jun 2013","2013","39","7","917","929","This paper presents an embedding of polychronous programs into synchronous ones. Due to this embedding, it is not only possible to deepen the understanding of these different models of computation, but, more importantly, it is possible to transfer compilation techniques that were developed for synchronous programs to polychronous programs. This transfer is nontrivial because the underlying paradigms differ more than their names suggest: Since synchronous systems react deterministically to given inputs in discrete steps, they are typically used to describe reactive systems with a totally ordered notion of time. In contrast, polychronous system models entail a partially ordered notion of time, and are most suited to interface a system with an asynchronous environment by specifying input/output constraints from which a deterministic controller may eventually be refined and synthesized. As particular examples for the mentioned cross fertilization, we show how a simulator and a verification backend for synchronous programs can be made available to polychronous specifications, which is a first step toward integrating heterogeneous models of computation.","1939-3520","","10.1109/TSE.2012.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6381420","Model-driven embedded software;synchronous programming;polychronous programming;programming models;synchrony hypothesis;synchronous guarded commands","Clocks;Computational modeling;Synchronization;Embedded systems;Hardware;Unified modeling language","embedded systems;program compilers;program verification","polychronous program specification;compilation techniques;reactive systems;polychronous system model;asynchronous environment;input-output constraints;deterministic controller;synchronous program verification;heterogeneous model","","5","","42","","13 Dec 2012","","","IEEE","IEEE Journals"
"Automated Checking of Conformance to Requirements Templates Using Natural Language Processing","C. Arora; M. Sabetzadeh; L. Briand; F. Zimmer","SnT Centre for Security, Reliability, and Trust, Luxembourg; SnT Centre for Security, Reliability, and Trust, Luxembourg; SnT Centre for Security, Reliability, and Trust, Luxembourg; SES TechCom, Luxembourg","IEEE Transactions on Software Engineering","13 Oct 2015","2015","41","10","944","968","Templates are effective tools for increasing the precision of natural language requirements and for avoiding ambiguities that may arise from the use of unrestricted natural language. When templates are applied, it is important to verify that the requirements are indeed written according to the templates. If done manually, checking conformance to templates is laborious, presenting a particular challenge when the task has to be repeated multiple times in response to changes in the requirements. In this article, using techniques from natural language processing (NLP), we develop an automated approach for checking conformance to templates. Specifically, we present a generalizable method for casting templates into NLP pattern matchers and reflect on our practical experience implementing automated checkers for two well-known templates in the requirements engineering community. We report on the application of our approach to four case studies. Our results indicate that: (1) our approach provides a robust and accurate basis for checking conformance to templates; and (2) the effectiveness of our approach is not compromised even when the requirements glossary terms are unknown. This makes our work particularly relevant to practice, as many industrial requirements documents have incomplete glossaries.","1939-3520","","10.1109/TSE.2015.2428709","National Research Fund-Luxembourg; Validation Laboratory and AFR; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7100933","Requirements Templates;Natural Language Processing (NLP);Case Study Research;Requirements templates;natural language processing (NLP);case study research","Terminology;Natural language processing;Ear;Safety;Pipelines;Pattern matching","formal specification;natural language processing;pattern matching","conformance automated checking;requirements templates;natural language processing;generalizable method;NLP pattern matcher;requirements engineering community","","51","","71","","1 May 2015","","","IEEE","IEEE Journals"
"Formulating Cost-Effective Monitoring Strategies for Service-Based Systems","Q. He; J. Han; Y. Yang; H. Jin; J. Schneider; S. Versteeg","School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia 3122; School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia 3122; School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia 3122; Services Computing Technology and System Lab, Cluster and Grid Computing Lab, School of Computer Science and Technology, Huazhong University of Science and Technology, Wuhan 430074, China; School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia 3122; CA Technologies, Melbourne, Australia 3004","IEEE Transactions on Software Engineering","14 May 2014","2014","40","5","461","482","When operating in volatile environments, service-based systems (SBSs) that are dynamically composed from component services must be monitored in order to guarantee timely and successful delivery of outcomes in response to user requests. However, monitoring consumes resources and very often impacts on the quality of the SBSs being monitored. Such resource and system costs need to be considered in formulating monitoring strategies for SBSs. The critical path of a composite SBS, i.e., the execution path in the service composition with the maximum execution time, is of particular importance in cost-effective monitoring as it determines the response time of the entire SBS. In volatile operating environments, the critical path of an SBS is probabilistic, as every execution path can be critical with a certain probability, i.e., its criticality. As such, it is important to estimate the criticalities of different execution paths when deciding which parts of the SBS to monitor. Furthermore, cost-effective monitoring also requires management of the trade-off between the benefit and cost of monitoring. In this paper, we propose CriMon, a novel approach to formulating and evaluating monitoring strategies for SBSs. CriMon first calculates the criticalities of the execution paths and the component services of an SBS and then, based on those criticalities, generates the optimal monitoring strategy considering both the benefit and cost of monitoring. CriMon has two monitoring strategy formulation methods, namely local optimisation and global optimisation. In-lab experimental results demonstrate that the response time of an SBS can be managed cost-effectively through CriMon-based monitoring. The effectiveness and efficiency of the two monitoring strategy formulation methods are also evaluated and compared.","1939-3520","","10.1109/TSE.2013.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6642029","Service-based system;web service;QoS;response time;monitoring;criticality;cost of monitoring;value of monitoring","Monitoring;Scattering;Probability;Time factors;Runtime;Probabilistic logic;Quality of service","service-oriented architecture;system monitoring;Web services","cost-effective monitoring strategy;service-based systems;SBSs;component services;system costs;service composition;global optimisation;local optimisation;CriMon-based monitoring approach;monitoring strategy formulation methods;service-oriented computing;Web service","","21","","65","","21 Oct 2013","","","IEEE","IEEE Journals"
"Inner Source in Platform-Based Product Engineering","D. Riehle; M. Capraro; D. Kips; L. Horn","Computer Science Department, Friedrich-Alexander University Erlangen-Nürnberg, Erlangen, Germany; Computer Science Department, Friedrich-Alexander University Erlangen-Nürnberg, Erlangen, Germany; Develop Group, Erlangen, Germany; e-solutions, Erlangen, Germany","IEEE Transactions on Software Engineering","8 Dec 2016","2016","42","12","1162","1177","Inner source is an approach to collaboration across intra-organizational boundaries for the creation of shared reusable assets. Prior project reports on inner source suggest improved code reuse and better knowledge sharing. Using a multiple-case case study research approach, we analyze the problems that three major software development organizations were facing in their product line engineering efforts. We find that a root cause, the separation of product units as profit centers from a platform organization as a cost center, leads to delayed deliveries, increased defect rates, and redundant software components. All three organizations assume that inner source can help solve these problems. The article analyzes the expectations that these companies were having towards inner source and the problems they were experiencing in its adoption. Finally, the article presents our conclusions on how these organizations should adapt their existing engineering efforts.","1939-3520","","10.1109/TSE.2016.2554553","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7452676","Inner source;product line engineering;product families;platform-based product engineering;open source;open collaboration;case study research","Collaboration;Product design;Software product lines;Best practices;Open source software","asset management;public domain software;software product lines","inner source;platform-based product line engineering;shared reusable asset creation;software development organization;product unit separation;profit center","","3","","73","","14 Apr 2016","","","IEEE","IEEE Journals"
"A Risk Management Methodology for Project Risk Dependencies","T. W. Kwan; H. K. N. Leung","The Hong Kong Polytechnic University, Hong Kong; The Hong Kong Polytechnic University, Hong Kong","IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","635","648","Project risks are not always independent, yet current risk management practices do not clearly manage dependencies between risks. If dependencies can be explicitly identified and analyzed, project managers will be able to develop better risk management strategies and make more effective risk planning decisions. This paper proposes a management methodology to address risk dependency issues. Through the study of three IT projects, we confirm that risk dependencies do exist in projects and can be identified and systematically managed. We also observed that, as project teams needed to deal with risk dependency issues, communications between projects were improved, and there were synergetic effects in managing risks and risk dependencies among projects.","1939-3520","","10.1109/TSE.2010.108","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5696725","Project risk management;risk dependencies;risk assessment;metrics.","Risk management;Delta modulation;Analytical models;Monitoring;Measurement;Lead;Fault trees","project management;risk analysis","project risk management;risk planning decisions;IT projects;risk dependencies","","53","","33","","20 Jan 2011","","","IEEE","IEEE Journals"
"Bypassing the Combinatorial Explosion: Using Similarity to Generate and Prioritize T-Wise Test Configurations for Software Product Lines","C. Henard; M. Papadakis; G. Perrouin; J. Klein; P. Heymans; Y. Le Traon","Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg; Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg; Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg; Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg; Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg; Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, Luxembourg","IEEE Transactions on Software Engineering","8 Jul 2014","2014","40","7","650","670","Large Software Product Lines (SPLs) are common in industry, thus introducing the need of practical solutions to test them. To this end, t-wise can help to drastically reduce the number of product configurations to test. Current t-wise approaches for SPLs are restricted to small values of t. In addition, these techniques fail at providing means to finely control the configuration process. In view of this, means for automatically generating and prioritizing product configurations for large SPLs are required. This paper proposes (a) a search-based approach capable of generating product configurations for large SPLs, forming a scalable and flexible alternative to current techniques and (b) prioritization algorithms for any set of product configurations. Both these techniques employ a similarity heuristic. The ability of the proposed techniques is assessed in an empirical study through a comparison with state of the art tools. The comparison focuses on both the product configuration generation and the prioritization aspects. The results demonstrate that existing t-wise tools and prioritization techniques fail to handle large SPLs. On the contrary, the proposed techniques are both effective and scalable. Additionally, the experiments show that the similarity heuristic can be used as a viable alternative to t-wise.","1939-3520","","10.1109/TSE.2014.2327020","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6823132","Software product lines;testing;T-wise Interactions;search-based approaches;prioritization;similarity","Testing;Frequency modulation;Context;Scalability;Software;Linux;Arrays","combinatorial mathematics;program testing;software product lines","combinatorial explosion;test configurations;software product lines;SPL;product configurations;configuration process;search based approach;similarity heuristic;product configuration generation","","82","","64","","29 May 2014","","","IEEE","IEEE Journals"
"Static Analysis for Extracting Permission Checks of a Large Scale Framework: The Challenges and Solutions for Analyzing Android","A. Bartel; J. Klein; M. Monperrus; Y. Le Traon","Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, 4, rue Alphonse Weicker, Luxembourg, Kirchberg; Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, 4, rue Alphonse Weicker, Luxembourg, Kirchberg; University of Lille and Inria, Villeneuve d'Ascq, France; Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg, 4, rue Alphonse Weicker, Luxembourg, Kirchberg","IEEE Transactions on Software Engineering","16 Jun 2014","2014","40","6","617","632","A common security architecture is based on the protection of certain resources by permission checks (used e.g., in Android and Blackberry). It has some limitations, for instance, when applications are granted more permissions than they actually need, which facilitates all kinds of malicious usage (e.g., through code injection). The analysis of permission-based framework requires a precise mapping between API methods of the framework and the permissions they require. In this paper, we show that naive static analysis fails miserably when applied with off-the-shelf components on the Android framework. We then present an advanced class-hierarchy and field-sensitive set of analyses to extract this mapping. Those static analyses are capable of analyzing the Android framework. They use novel domain specific optimizations dedicated to Android.","1939-3520","","10.1109/TSE.2014.2322867","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6813664","Large scale framework;permissions;call-graph;Android;security;Soot;Java;static analysis","Androids;Humanoid robots;Sparks;Cameras;Java;Servers;Security","Android (operating system);optimisation;program diagnostics;security of data","static analysis;permission checks;large scale framework;common security architecture;permission-based framework;API methods;Android framework;novel domain specific optimizations;advanced class-hierarchy analysis;field-sensitive set analysis","","42","","32","","9 May 2014","","","IEEE","IEEE Journals"
"REPENT: Analyzing the Nature of Identifier Renamings","V. Arnaoudova; L. M. Eshkevari; M. D. Penta; R. Oliveto; G. Antoniol; Y. Guéhéneuc","Polytechnique Montréal, Québec, Canada; Polytechnique Montréal, Québec, Canada; University of Sannio, Benevento, Italy; University of Molise, Pesche (IS), Italy; Polytechnique Montréal, Québec, Canada; Polytechnique Montréal, Québec, Canada","IEEE Transactions on Software Engineering","14 May 2014","2014","40","5","502","532","Source code lexicon plays a paramount role in software quality: poor lexicon can lead to poor comprehensibility and even increase software fault-proneness. For this reason, renaming a program entity, i.e., altering the entity identifier, is an important activity during software evolution. Developers rename when they feel that the name of an entity is not (anymore) consistent with its functionality, or when such a name may be misleading. A survey that we performed with 71 developers suggests that 39 percent perform renaming from a few times per week to almost every day and that 92 percent of the participants consider that renaming is not straightforward. However, despite the cost that is associated with renaming, renamings are seldom if ever documented-for example, less than 1 percent of the renamings in the five programs that we studied. This explains why participants largely agree on the usefulness of automatically documenting renamings. In this paper we propose REanaming Program ENTities (REPENT), an approach to automatically document-detect and classify-identifier renamings in source code. REPENT detects renamings based on a combination of source code differencing and data flow analyses. Using a set of natural language tools, REPENT classifies renamings into the different dimensions of a taxonomy that we defined. Using the documented renamings, developers will be able to, for example, look up methods that are part of the public API (as they impact client applications), or look for inconsistencies between the name and the implementation of an entity that underwent a high risk renaming (e.g., towards the opposite meaning). We evaluate the accuracy and completeness of REPENT on the evolution history of five open-source Java programs. The study indicates a precision of 88 percent and a recall of 92 percent. In addition, we report an exploratory study investigating and discussing how identifiers are renamed in the five programs, according to our taxonomy.","1939-3520","","10.1109/TSE.2014.2312942","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6776542","Identifier renaming;refactoring;program comprehension;mining software repositories;empirical study","Taxonomy;Semantics;Java;Grammar;Software;History;Documentation","data flow analysis;pattern classification;software fault tolerance;software quality;source code (software)","identifier renaming analysis;REPENT;source code lexicon;software quality;software fault-proneness;program entity renaming;entity identifier;software evolution;reanaming program entities;data flow analysis;natural language tools;taxonomy dimensions;public API;open-source Java programs","","41","","58","","20 Mar 2014","","","IEEE","IEEE Journals"
"When and Why Your Code Starts to Smell Bad (and Whether the Smells Go Away)","M. Tufano; F. Palomba; G. Bavota; R. Oliveto; M. D. Penta; A. De Lucia; D. Poshyvanyk","College of William and Mary, Williamsburg, VA; University of Salerno, Fisciano, SA, Italy; Università della Svizzera italiana (USI), Lugano, Switzerland; University of Molise, Pesche, (IS), Italy; University of Sannio, Benevento, BN, Italy; University of Salerno, Fisciano, SA, Italy; College of William and Mary, Williamsburg, VA","IEEE Transactions on Software Engineering","10 Nov 2017","2017","43","11","1063","1088","Technical debt is a metaphor introduced by Cunningham to indicate “not quite right code which we postpone making it right”. One noticeable symptom of technical debt is represented by code smells, defined as symptoms of poor design and implementation choices. Previous studies showed the negative impact of code smells on the comprehensibility and maintainability of code. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced, what is their survivability, and how they are removed by developers. To empirically corroborate such anecdotal evidence, we conducted a large empirical study over the change history of 200 open source projects. This study required the development of a strategy to identify smell-introducing commits, the mining of over half a million of commits, and the manual analysis and classification of over 10K of them. Our findings mostly contradict common wisdom, showing that most of the smell instances are introduced when an artifact is created and not as a result of its evolution. At the same time, 80 percent of smells survive in the system. Also, among the 20 percent of removed instances, only 9 percent are removed as a direct consequence of refactoring operations.","1939-3520","","10.1109/TSE.2017.2653105","NSF; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7817894","Code smells;empirical study;mining software repositories","Ecosystems;History;Androids;Humanoid robots;Software systems;Maintenance engineering","data mining;public domain software;software maintenance;software quality;source code (software)","open source projects;code smells;code comprehensibility;code maintainability;commits mining;smell instances;smell-introducing commits;code quality;technical debt","","30","","91","Traditional","16 Jan 2017","","","IEEE","IEEE Journals"
"Development with Off-the-Shelf Components: 10 Facts","J. Li; R. Conradi; C. Bunse; M. Torchiano; O. P. N. Slyngstad; M. Morisio",Norwegian University of Science and Technology; Norwegian University of Science and Technology; International University; Politecnico di Torino; Norwegian University of Science and Technology; Politecnico di Torino,"IEEE Software","24 Feb 2009","2009","26","2","80","87","Empirical studies have revealed a discrepancy between academic theory and industrial practices regarding the selection and integration of commercial off-the-shelf and open source software components in software system development.","1937-4194","","10.1109/MS.2009.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786958","COTS-based development;OSS-based development;empirical studies","Open source software;Software quality;Risk management;Computer industry;Programming;Costs;Software systems;Electronic switching systems;Software libraries;Quality management","object-oriented programming;public domain software;software engineering","commercial off-the-shelf components;academic theory;industrial practices;open source software components;software system development","","58","","12","","24 Feb 2009","","","IEEE","IEEE Magazines"
"The 10-Minute Test Plan","J. A. Whittaker",Google,"IEEE Software","22 Oct 2012","2012","29","6","70","77","The lowly test plan is perhaps the least appreciated of all supporting (read: noncode) software development artifacts. All projects need one, but few engineers appreciate their existence. So it's important to spend no more time than is absolutely necessary in the creation, care, and feeding of the test plan. Ten minutes, to be precise.","1937-4194","","10.1109/MS.2012.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6148203","software testing","Software testing","program testing;software engineering","software testing;test plan;software development artifacts","","","","7","","7 Feb 2012","","","IEEE","IEEE Magazines"
"A More Agile Approach to Embedded System Development","M. Smith; J. Miller; L. Huang; A. Tran",University of Calgary; University of Alberta; NovATel; DirectVoxx,"IEEE Software","17 Apr 2009","2009","26","3","50","57","Given the plethora of advantages attributed to agile methodologies, why are there only infrequent reports of their application in the embedded systems world? We believe this has two principal causes. First, embedded applications go through a life cycle that differs from desktop life cycles, so that desktop application production processes must be significantly altered to meet the demands of this new domain. Second, without providing for full life-cycle tool support, no change to embedded production processes will ever succeed, and again desktop tools must be adapted to meet the new environment's constraints. Here, the authors discuss their thoughts on an XP-inspired embedded life cycle and their successes in developing, extending, and using embedded test-driven development frameworks for customers (Matlab-Fit and Embedded-FitNesse) and developers (MUnit and Embedded-Unit).","1937-4194","","10.1109/MS.2009.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814958","embedded systems;agile methods;test-driven development;tool support","Embedded system;System testing;Registers;Hardware;Life testing;Embedded software;Production;Silicon;Instruments;Health and safety","embedded systems;software engineering","embedded system development;agile methodologies;desktop application production process;full life-cycle tool support;XP-inspired embedded life cycle","","6","","14","","17 Apr 2009","","","IEEE","IEEE Magazines"
"Strategies Facilitating Software Product Transfers","D. Smite; C. Wohlin",Blekinge Institute of Technology; Blekinge Institute of Technology,"IEEE Software","18 Aug 2011","2011","28","5","60","66","Globalization of software work has become common in today's market. As part of cost-reduction strategies, many product-focused software companies started shipping their product development to insourcing and outsourcing offshore locations. Unfortunately, moving software products from one site to another isn't always a good business strategy for either the organization or the product. In this article, the authors discuss findings from studying software insourcing transfers at Ericsson, a large software product development company headquartered in Sweden. Their findings suggest that certain product, personnel, and process characteristics can facilitate the execution of an offshore insourcing transfer. On the basis of research conducted together with the company, they share a list of critical factors alleviating transfer difficulties and seven strategies facilitating transition of software work across sites.","1937-4194","","10.1109/MS.2010.112","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5499459","organizational management and coordination;planning;offshore software development","Globalization;Outsourcing;Product development;Process planning;Investments;Collaborative work;Software development","globalisation;outsourcing;software engineering","software product transfers;cost-reduction strategies;product-focused software companies;software product development company;offshore location insourcing;offshore location outsourcing;Ericsson;Sweden","","13","","10","","1 Jul 2010","","","IEEE","IEEE Magazines"
"Magic Potion: Incorporating New Development Paradigms through Metaprogramming","D. Djuric; V. Devedzic","University of Belgrade, Serbia; University of Belgrade, Belgrade","IEEE Software","19 Aug 2010","2010","27","5","38","44","Software environments are typically based on a single programming paradigm, such as ontologies, functions, objects, or concurrency. This can limit what developers can represent and how elegant their solutions can be, so today's applications usually involve mixing and matching languages, platforms, and paradigms. However, cross-mapping multiple paradigms and platforms generates an impedance mismatch that increases a solution's complexity. Metaprogramming supports a lightweight process to incorporate different programming paradigms in a single development environment that's suitable for small development teams.","1937-4194","","10.1109/MS.2010.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473201","programming paradigms;multiparadigm languages;ontology languages;metaprogramming;domain-specific languages;programming languages;domain engineering;programming techniques","Functional programming;Ontologies;Concurrent computing;Application software;Impedance","multiprogramming;object-oriented methods;software engineering","Magic Potion;metaprogramming;ontologies;software development","","3","","10","","27 May 2010","","","IEEE","IEEE Magazines"
"Tools for Continuously Evaluating Distributed System Qualities","J. Hill; D. Schmidt; J. Edmondson; A. Gokhale","Indiana University/Purdue University at Indianapolis, Indianapolis; Vanderbilt University, Nashville; Vanderbilt University, Nashville; Vanderbilt Univresity, Nashville","IEEE Software","14 Jun 2010","2010","27","4","65","71","Developers are increasingly using service-oriented middleware to develop distributed systems. This middleware raises the abstraction level for software so that distributed-system developers can focus more on application-level concerns (for instance, business logic) rather than wrestle with infrastructure-level concerns (such as software adaptation, context-awareness, and life-cycle management). Service-oriented middleware also promotes reuse of business logic and services across heterogeneous application domains, thus facilitating the development of larger, more complex systems.","1937-4194","","10.1109/MS.2009.197","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5306061","agile techniques;continuous system integration;distributed systems;domain-specific modeling languages;model-driven engineering;system execution modeling tools","System testing;Performance analysis;Life testing;Software testing;Databases;Automatic testing;World Wide Web;Computer languages;Operating systems;Middleware","middleware;software engineering","distributed-system qualities;service-oriented middleware;software development;application-level concern;business logic;heterogeneous application domain;complex system","","15","","11","","30 Oct 2009","","","IEEE","IEEE Magazines"
"Streamlining Development for Networked Embedded Systems Using Multiple Paradigms","C. Huygens; D. Hughes; B. Lagaisse; W. Joosen",Katholieke Universiteit Leuven; Xi'an Jiaotong-Liverpool University; Katholieke Universiteit Leuven; Katholieke Universiteit Leuven,"IEEE Software","19 Aug 2010","2010","27","5","45","52","In networked embedded systems, multiparadigm programming enables an integrated approach for developing complementary artifacts that are essential but can't be programmed using a single paradigm.","1937-4194","","10.1109/MS.2010.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473203","embedded systems;programming paradigms;system integration and implementation;wireless sensor networks;computing equipment management;software","Embedded system;Computer science;Application software;Hardware;Embedded software;Software maintenance;Logic programming;Runtime;Wireless sensor networks;Computer networks","embedded systems;multiprogramming;software engineering","streamlining development;networked embedded systems;multipαrαdigm programming","","10","","6","","27 May 2010","","","IEEE","IEEE Magazines"
"Agile Collaborative Research: Action Principles for Industry-Academia Collaboration","A. Sandberg; L. Pareto; T. Arts",Ericsson; Chalmers University of Technology; Chalmers University of Technology,"IEEE Software","23 Jun 2011","2011","28","4","74","83","Both the software industry and academia promote collaboration to solve challenges together that neither can solve alone. Collaboration brings opportunities to understand and improve in ways not possible when working apart, but it succeeds only if both parties are contributing. A collaboration model developed from eight years' experience setting up and managing a research center explicitly focused on industry needs is based on five success factors enabling research results (need orientation, industry goal alignment, deployment impact, industry benefit, and innovativeness), five success factors enabling research activities (management engagement, network access, collaborator match, communication ability, and continuity), and 10 action principles for industry-academia collaboration management.","1937-4194","","10.1109/MS.2011.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5733335","research and development management;collaborative practice research;industry–academia collaboration","Collaboration;Management;Product development;Business;Adaptation model;Modeling;Training","groupware;software engineering;software management;software prototyping","agile collaborative research;industry-academia collaboration;software industry;research center;management engagement;network access;collaborator match;communication ability;continuity","","34","","14","","17 Mar 2011","","","IEEE","IEEE Magazines"
"Analytics-Driven Dashboards Enable Leading Indicators for Requirements and Designs of Large-Scale Systems","R. W. Selby",Northrop Grumman Space Technology,"IEEE Software","22 Dec 2008","2009","26","1","41","49","Mining software repositories using analytics-driven dashboards provides a unifying mechanism for understanding, evaluating, and predicting the development, management, and economics of large-scale systems and processes. Dashboards enable measurement and interactive graphical displays of complex information and support flexible analytic capabilities for user customizability and extensibility. Dashboards commonly include system requirements and design metrics because they provide leading indicators for project size, growth, and volatility. This article focuses on dashboards that have been used on actual large-scale software projects as well as example empirical relationships revealed by the dashboards. The empirical results focus on leading indicators for requirements and designs of large-scale software systems based on insights from two sets of software projects containing 14 systems and 23 systems.","1937-4194","","10.1109/MS.2009.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721182","leading indicators;requirements;designs;defects;empirical analysis;metrics","Large-scale systems;Project management;Risk management;Displays;Technology management;Software development management;Large scale integration;Economic forecasting;Software performance;Information analysis","data mining;software engineering","analytics-driven dashboards;large-scale systems;software repositories mining;interactive graphical displays","","5","","16","","22 Dec 2008","","","IEEE","IEEE Magazines"
"What Next? Advances in Software-Driven Industries","C. Ebert; G. Hoefner; V. S. Mani",Vector Consulting Services; Siemens Technology and Services; Siemens Technology and Services,"IEEE Software","4 Feb 2015","2015","32","1","22","28","Software-driven industries are advancing in five dimensions: collaboration, comprehension, connectivity, cloud, and convergence. However, companies often can get stuck in an overly narrow technology focus. To avoid this, they should connect architecture and functionality, master the entire software development life cycle, strengthen globally distributed teams, and streamline development.","1937-4194","","10.1109/MS.2015.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030204","software complexity;software architecture;model-driven development;software development life cycle;distributed software development;software development","Software architecture;Complexity theory;Software development;Modeling;Computer architecture","cloud computing;DP industry;groupware;software engineering","software-driven industries;collaboration;comprehension;connectivity;cloud;convergence;software development life cycle;globally distributed teams;streamline development","","5","","3","","4 Feb 2015","","","IEEE","IEEE Magazines"
"A Refactoring Approach to Parallelism","D. Dig",University of Illinois at Urbana-Champaign,"IEEE Software","20 Dec 2010","2011","28","1","17","22","In the multicore era, a major programming task will be to make programs more parallel. This is tedious because it requires changing many lines of code; it's also error-prone and nontrivial because programmers need to ensure noninterference of parallel operations. Fortunately, interactive refactoring tools can help reduce the analysis and transformation burden. The author describes how refactoring tools can improve programmer productivity, program performance, and program portability. The article also describes a toolset that supports several refactorings for making programs thread-safe, threading sequential programs for throughput, and improving scalability of parallel programs.","1937-4194","","10.1109/MS.2011.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5672516","refactoring;parallelism;concurrency","Parallel processing;Instruction sets;Arrays;Computer threading","interactive systems;parallel programming;software engineering;software tools","refactoring approach;multicore era;major programming task;interactive refactoring tools;program performance;program portability;sequential programs threading;parallel programs","","41","","15","","20 Dec 2010","","","IEEE","IEEE Magazines"
"Social Networking Meets Software Development: Perspectives from GitHub, MSDN, Stack Exchange, and TopCoder","A. Begel; J. Bosch; M. Storey",Microsoft; Chalmers University of Technology; University of Victoria,"IEEE Software","3 Jan 2013","2013","30","1","52","66","Many successful software companies use social networking as a way to improve the services or products they provide. To gain an understanding of the role social networking plays in today's software development world, the guest editors of the January/February 2013 issue conducted semistructured interviews with leaders from four successful companies: Brian Doll, an engineer who manages GitHub's marketing; Doug Laundry, a principal group program manager at Microsoft; David Fullerton, vice president of engineering at Stack Exchange; and Robert Hughes, the president and chief operating officer of TopCoder. The first Web extra at http://try.github.com is a video of Joel Spolsky discussing the structure, software, technology, and culture of Stack Exchange. The second Web extra at http://blip.tv/play/gvUBgqLbRgI.html is a video of Matthew McCullough and Tim Berglund demonstrating how Git not only incorporates the best features of existing source control systems but also includes unique distributed capabilities that make version control commands available without connectivity, allowing you to choose when to interact with a network. The third Web extra at http://blip.tv/play/gvUBgqLbRgI.html is a video of Matthew McCullough and Tim Berglund demonstrating how to leverage Git's powerful yet underused advanced features. The last Web extra at http://youtu.be/SK6TBI1bNLI is a video of Thomas Baden, Chief Information Officer, State of Minnesota, Department of Human Services, describing the experience of working on the TopCoder Platform and with the members of the TopCoder Community.","1937-4194","","10.1109/MS.2013.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401114","social networking;software;community;Microsoft;Github;Stack Exchange;TopCoder","Social network services;Software development;Human factors","configuration management;Internet;marketing;social networking (online);software engineering","social networking;MSDN;stack exchange;software companies;today software development world;GitHub marketing;principal group program manager;Microsoft;second Web extra;source control systems;unique distributed capabilities;third Web extra;TopCoder platform;TopCoder community","","36","","","","3 Jan 2013","","","IEEE","IEEE Magazines"
"Financial Pricing of Software Development Risk Factors","M. Benaroch; A. Appari",Syracuse University; Dartmouth College,"IEEE Software","19 Aug 2010","2010","27","5","65","73","The ability to price (monetize) software development risks can benefit various aspects of software development. Cost estimators predict project cost by adjusting a project's nominal cost on the basis of risk factors' (cost drivers') expected values, but the predicted cost is often inaccurate because risk factors' actual values normally deviate from expectations. Because variability is a widely used risk measure in finance, this risk-pricing method relates risk factor variability to project cost variability. The method estimates two parameters for each risk factor: extra cost incurred per unit exposure and project sensitivity. Several areas can benefit from the benchmark risk-pricing parameters obtained when applying this method with a cost estimator such as Cocomo.","1937-4194","","10.1109/MS.2010.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5396317","risk management;economics;software development;risk factors;financial pricing;Cocomo;project sensitivity;extra cost per unit exposure","Pricing;Programming;Portfolios;Risk management;Finance;Project management;Cost function;Economic forecasting;Financial management;Software development management","pricing;project management;risk analysis;software engineering;software management","software development risk;cost estimation;project cost;risk factors;risk pricing;Cocomo","","4","","16","","22 Jan 2010","","","IEEE","IEEE Magazines"
"The State of Practice in Model-Driven Engineering","J. Whittle; J. Hutchinson; M. Rouncefield",Lancaster University; Lancaster University; Lancaster University,"IEEE Software","21 Apr 2014","2014","31","3","79","85","Despite lively debate over the past decade on the benefits and drawbacks of model-driven engineering (MDE), there have been few industry-wide studies of MDE in practice. A new study that surveyed 450 MDE practitioners and performed in-depth interviews with 22 more suggests that although MDE might be more widespread than commonly believed, developers rarely use it to generate whole systems. Rather, they apply MDE to develop key parts of a system.","1937-4194","","10.1109/MS.2013.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6507223","software design methodologies;model driven engineering practice;software design;MDE","Companies;Unified modeling language;Software;Interviews;Computer architecture;DSL;Industries","software engineering","MDE;model-driven engineering","","149","","11","","23 Apr 2013","","","IEEE","IEEE Magazines"
"Leveraging the Crowd: How 48,000 Users Helped Improve Lync Performance","R. Musson; J. Richards; D. Fisher; C. Bird; B. Bussone; S. Ganguly",Microsoft; Microsoft; Microsoft Research; Microsoft Research; Microsoft; Microsoft,"IEEE Software","26 Jun 2013","2013","30","4","38","45","Performance is a critical component of customer satisfaction with network-based applications. Unfortunately, accurately evaluating the performance of collaborative software that operates in extremely heterogeneous environments is difficult with traditional techniques such as modeling workloads or testing in controlled environments. To evaluate performance of an application in the wild during development, the authors deployed early versions of the software, collecting performance data from application users for key usage scenarios. The analysis package they used produces visualizations to help development teams identify and prioritize performance issues by focusing on performance early in the development cycle, evaluating progress, identifying defects, and estimating timelines.","1937-4194","","10.1109/MS.2013.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6509371","software performance;data collection;data analysis;performance monitoring;software analytics;software data visualization","Software development;Performance evaluation;Customer satisfaction;Software quality;Analytical models","groupware;software engineering","Lync performance;customer satisfaction;collaborative software;software development;data visualization","","25","","2","","26 Apr 2013","","","IEEE","IEEE Magazines"
"Introducing an Iterative Life-Cycle Model at Credit Suisse IT Switzerland","K. Sägesser; B. Joseph; R. Grau","Credit Suisse, Switzerland; Wipro Technologies; Zuhlke","IEEE Software","25 Feb 2013","2013","30","2","68","73","Credit Suisse IT Switzerland decided to introduce an iterative life-cycle model (ILCM) based on the Rational Unified Process (RUP), a de facto industry standard, in addition to the well-established waterfall life-cycle model (WLCM). Such a large-scale change management initiative involves risks, challenges, and an organizational mindset shift. The Credit Suisse project carefully considered issues such as the gap between RUP and CMMI, process vocabulary, best practices, development and maintenance effort, training, and company culture as a precursor to the change. The activities to deploy the model throughout the organization were coordinated in collaboration with actual practitioners toward creating awareness, managing knowledge, and managing resistance factors to effect the required mindset change.","1937-4194","","10.1109/MS.2012.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6216346","Rational Unified Process;RUP;iterative software development;software development life cycle;software development process management","Banking;Standards organizations;Training;Collaboration;Iterative methods;Product life cycle management;Software development;Process management","information technology;software engineering","iterative life cycle model;credit suisse IT Switzerland;ILCM;rational unified process;RUP;de facto industry standard;WLCM;waterfall life-cycle model;credit suisse project","","2","","12","","12 Jun 2012","","","IEEE","IEEE Magazines"
"Software Design for Empowering Scientists","D. De Roure; C. Goble",University of Southampton; University of Manchester,"IEEE Software","22 Dec 2008","2009","26","1","88","95","Scientific research is increasingly digital. Some activities, such as data analysis, search, and simulation, can be accelerated by letting scientists write workflows and scripts that automate routine activities. These capture pieces of the scientific method that scientists can share. The Taverna Workbench, a widely deployed scientific-workflow-management system, together with the myExperiment social Web site for sharing scientific experiments, follow six principles of designing software for adoption by scientists and six principles of user engagement.","1937-4194","","10.1109/MS.2009.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721191","scientific workflow management systems;Taverna workflow workbench;myExperiment social Web site;agile software development","Software design;Laboratories;Data analysis;Data processing;Software tools;Computational modeling;Analytical models;Application software;Proteins;Automation","scientific information systems;software engineering","software design;scientific research;scientific method;scientists;Taverna Workbench;scientific workflow management system;social Web site","","48","","9","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Technical Debt: Where Are the Shareholders' Interests?","P. Conroy",University of British Columbia,"IEEE Software","22 Oct 2012","2012","29","6","88","88","Technical debt is more than a metaphor: applying finance and accounting practices typical of other business obligations to technical debt can, in addition to meeting ethical and legal governance requirements, generate real, sustained financial benefits.","1937-4194","","10.1109/MS.2012.166","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6336729","technical debt;shareholder value;governance","Investments;Finance;Law;Ethics","DP industry;software process improvement","technical debt;ethical governance requirement;legal governance requirement;financial benefit;accounting;software engineering","","2","","","","22 Oct 2012","","","IEEE","IEEE Magazines"
"Refactoring-a Shot in the Dark?","M. Leppänen; S. Mäkinen; S. Lahtinen; O. Sievi-Korte; A. Tuovinen; T. Männistö",Tampere University of Technology; University of Helsinki; Tampere University of Technology; Tampere University of Technology; University of Helsinki; University of Helsinki,"IEEE Software","28 Oct 2015","2015","32","6","62","70","A study performed semistructured interviews of 12 seasoned software architects and developers at nine Finnish companies. Its main goals were to find out how the practitioners viewed the role and importance of refactoring, and how and when they refactored. Another goal was to see whether shortened cycle times and, especially, continuous-deployment practices affected how and when refactoring was done. The results paint a multifaceted picture with some common patterns. The respondents considered refactoring to be valuable but had difficulty explaining and justifying it to management and customers. Refactoring often occurred in conjunction with the development of new features because it seemed to require a clear business need. The respondents didn't use measurements to quantify the need for or impact of refactoring. This article is part of a special issue on Refactoring.","1937-4194","","10.1109/MS.2015.132","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310989","software architecture;refactoring;metrics;software development;software engineering","Code refractoring;Web services;Agile software development;Software development;Frequency-domain analysis;Software architecture","software architecture;software maintenance","software refactoring;semistructured interviews;software architecture;software development;Finnish companies;continuous-deployment practices","","11","","7","","28 Oct 2015","","","IEEE","IEEE Magazines"
"SCEPYLT: An Information System for Fighting Terrorism","J. Cano; R. Hernández",Universidad Nacional de Educacion a Distancia; Universidad Nacional de Educacion a Distancia,"IEEE Software","18 Apr 2013","2013","30","3","73","79","A safety-critical software system called SCEPYLT provides an information solution for a field traditionally not computerized: explosives and their associated risks in handling, storage, transport, and use. SCEPYLT is a model for cooperative distributed systems engineering projects, synchronized over multiple databases.","1937-4194","","10.1109/MS.2013.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6461871","eGovernment;public security;critical software engineering;explosives control;safety-critical;service-oriented architecture;distributed system;cooperative system;terrorism;SCEPYLT","Explosives;Security;Distributed databases;Computers;Mesh networks;Web services;Software reliability;Terrorism","","","","1","","15","","14 Feb 2013","","","IEEE","IEEE Magazines"
"Earned Business Value: See That You Deliver Value to Your Customer","J. E. Hannay; H. C. Benestad; K. Strand",Simula Research Laboratory; Expertware; PROMIS,"IEEE Software","11 Jul 2017","2017","34","4","58","70","The order in which you send your backlog items into construction determines when stakeholders can reap benefits from each piece of functionality. This can substantially impact market timing, enterprise earnings, and the project manager survival rate. There are several ways to order a backlog, and sophisticated methods and tools exist to do so-for example, during release planning. But no matter what backlog-ordering scheme you use, you ought to be explicit on the order in which you realize potential business value. To that end, researchers have developed methods to express business value relative to cost in your backlog. They also have devised methods to monitor how much potential business value you're realizing along the way-in addition to the cost expended.","1937-4194","","10.1109/MS.2017.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974676","earned business value;earned value management;benefit points;story points;agile management;software development;software engineering","Schedules;Monitoring;Stakeholders;Business;Cost benefit analysis;Project management","business data processing","backlog items;backlog-ordering scheme;release planning","","2","","21","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Adaptive Virtual Gestures for GUI Testing on Smartphones","C. Hsu; S. Lee; S. Winston Shieh",National Chiao Tung University; Chunghwa Telecom; National Chiao Tung University,"IEEE Software","22 Sep 2017","2017","34","5","22","29","Software testing is vital for software developers to launch mobile applications running on various software developer's kit versions and device models. Conventional in-depth testing isn't optimal for mobile apps because they're updated frequently in response to bugs and security concerns. Also, the wide variety of smartphones might diminish app quality owing to insufficient testing. To complement in-depth testing, a proposed breadth-first approach employs fast, automated GUI testing for adaptive virtual gestures on various mobile devices.","1937-4194","","10.1109/MS.2017.3641115","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048624","software testing;mobile application;GUI testing;software development;software engineering;automated GUI testing","Software testing;Graphical user interfaces;Smart phones;Androids;Humanoid robots","gesture recognition;graphical user interfaces;program testing;smart phones;software quality;tree searching","adaptive virtual gestures;smartphones;software testing;software development;mobile applications;software developer kit versions;device model;bugs;security concerns;application quality;breadth-first approach;automated GUI testing;mobile devices","","","","7","","22 Sep 2017","","","IEEE","IEEE Magazines"
"MobiGUITAR: Automated Model-Based Testing of Mobile Apps","D. Amalfitano; A. R. Fasolino; P. Tramontana; B. D. Ta; A. M. Memon","University of Naples Federico II; University of Naples Federico II; University of Naples Federico II; University of Maryland, College Park; University of Maryland, College Park","IEEE Software","21 Aug 2015","2015","32","5","53","59","As mobile devices become increasingly smarter and more powerful, so too must the engineering of their software. User-interface-driven system testing of these devices is gaining popularity, with each vendor releasing some automation tool. However, these tools are inappropriate for amateur programmers, an increasing portion of app developers. MobiGUITAR (Mobile GUI Testing Framework) provides automated GUI-driven testing of Android apps. It's based on observation, extraction, and abstraction of GUI widgets' run-time state. The abstraction is a scalable state machine model that, together with test coverage criteria, provides a way to automatically generate test cases. When applied to four open-source Android apps, MobiGUITAR automatically generated and executed 7,711 test cases and reported 10 new bugs. Some bugs were Android-specific, stemming from the event- and activity-driven nature of Android.","1937-4194","","10.1109/MS.2014.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6786194","software testing;GUI testing;android testing;software engineering;mobile apps;Android apps;MobiGUITAR","Software testing;Graphical user interfaces;Androids;Humanoid robots;Mobile communication;Computer bugs","Android (operating system);finite state machines;graphical user interfaces;mobile computing;program testing;public domain software","open-source Android apps;scalable state machine model;automated GUI-driven testing;mobile GUI testing framework;user-interface-driven system testing;mobile apps;automated model-based testing;MobiGUITAR","","129","2","14","","10 Apr 2014","","","IEEE","IEEE Magazines"
"Requirements-Driven Design of Service-Oriented Interactions","A. Mahfouz; L. Barroca; R. Laney; B. Nuseibeh","Webalo, Inc., Los Angeles; The Open University, Walton Hall; The Open University, Walton Hall; Lero, Limerick","IEEE Software","14 Oct 2010","2010","27","6","25","32","Service-oriented architecture (SOA) enables interenterprise service interactions. Services provide platform-independent abstractions around software systems, thereby enabling interoperability between heterogeneous systems. It is supported by a tool, Chreq(Choreograpy requirements) that automatically generates messaging protocols from requirements models. Chreq also generates comments, interleaved with the protocol, to indicate points at which physical activities should execute. Several languages are emerging as standards for describing interfaces and interaction protocols that specify service-oriented systems.","1937-4194","","10.1109/MS.2010.113","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5510236","software engineering","Protocols;Collaboration;Process design","business data processing;formal specification;formal verification;high level languages;open systems;software architecture;Web services","requirement driven design;service oriented architecture;interenterprise service interaction;platform independent abstraction;interoperability;heterogeneous system;interface protocol;interaction protocol;messaging protocol;choreography requirement;Web service description language","","1","","8","","15 Jul 2010","","","IEEE","IEEE Magazines"
"Coping with Quality Requirements in Large, Contract-Based Projects","M. Daneva; A. Herrmann; L. Buglione",University of Twente; Herrmann & Ehrlich; Engineering Ingegneria Informatica,"IEEE Software","28 Oct 2015","2015","32","6","84","91","A typical contract for delivering a large software system must address a variety of related issues such as system quality, timelines, delivery cost and effort, and service-level agreements. Interviews with 20 software architects revealed how they coped with quality requirements in this context.","1937-4194","","10.1109/MS.2014.134","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6915592","quality requirements;software architecture design;exploratory study;contract-based software development;software engineering;software development","Contracts;Project management;Software systems;Software architecture;Software quality;Software development","contracts;software architecture;software quality;systems analysis","quality requirements;contract-based projects;large software system;system quality;timelines;delivery cost;service-level agreements;software architecture","","4","","10","","2 Oct 2014","","","IEEE","IEEE Magazines"
"Toward Compositional Software Product Lines","J. Bosch","Intuit, Mountain View","IEEE Software","19 Apr 2010","2010","27","3","29","34","Software product lines (SPLs) were introduced over the last two decades as a mechanism for dealing with the complexities of software systems' ever-increasing size by exploiting the commonalities among the company's different products or systems. By standardizing the software components sourced from the outside and sharing domain specific software assets the company develops among different product teams, you can significantly reduce the per-product R&D cost, which improves the company's competitive position. This can be achieved through a richer product portfolio, a harmonized look-and-feel across the product portfolio, or a significantly higher degree of customer configurability. Companies that successfully deploy SPL technology can achieve order-of magnitude growth over a decade and reach major business milestones.","1937-4194","","10.1109/MS.2010.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406498","software product lines;software engineering;reuse;compositional software product lines","Companies;Portfolios;Software systems;Costs","business data processing;product development;software reusability","software product lines;software systems;domain specific software;R & D cost","","11","","7","","5 Feb 2010","","","IEEE","IEEE Magazines"
"Agile Architecture Interactions","J. Madison",NA,"IEEE Software","25 Feb 2010","2010","27","2","41","48","Agile development starts to build before the outcome is fully understood, adjusts designs and plans as empirical knowledge is gained while building, trusts the judgment of those closest to the problem, and encourages continual collaboration with the ultimate consumers. Architecture establishes a technology stack, creates design patterns, enhances quality attributes, and communicates to all interested parties. The combination of these two spaces is agile architecture-an approach that uses agile techniques to drive towards good architecture. Agility and architecture aren't at odds. Agile development gives the architect repeated opportunities to work closely with the business and technical teams to continually guide systems in the direction of good architecture.","1937-4194","","10.1109/MS.2010.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420794","agile development;enterprise architecture;software engineering;project management;team organization","Space technology;Buildings;Collaboration","software architecture;software prototyping","agile architecture;architectural priority;agile development;software architecture;software development","","35","","16","","25 Feb 2010","","","IEEE","IEEE Magazines"
"The Connected Car in the Cloud: A Platform for Prototyping Telematics Services","T. Häberle; L. Charissis; C. Fehling; J. Nahm; F. Leymann",Daimler TSS; Daimler TSS; University of Stuttgart; Daimler TSS; University of Stuttgart,"IEEE Software","28 Oct 2015","2015","32","6","11","17","The Connected-Car Prototyping Platform provides both a back end for applications interacting with connected cars and an abstraction of such connected devices for developers. It also provides services such as identity management and data storage. Its main purposes are experimentation, prototyping, evaluation of ideas, and reduction of time-to-market for successful applications.","1937-4194","","10.1109/MS.2015.137","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310999","Connected-Car Prototyping Platform;prototyping platform;application templates;Maven;connected cars;automotive software;telematics;cloud computing;software engineering;software development","Telematics;Intelligent vehicles;Automotive electronics;Computer architecture;Java;Cloud computing;User interfaces","automobiles;automotive engineering;cloud computing;software prototyping","connected-car prototyping platform;cloud platform;telematics service;identity management;data storage","","20","","12","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Up in the Air: Moving Your Applications to the Cloud","P. Louridas",consultant,"IEEE Software","14 Jun 2010","2010","27","4","6","11","An overview of cloud computing helps developers get beyond the hype by characterizing its unique requirements, the ways to implement cloud services, and the ways to operate the cloud infrastructure. A comparison of major products is included.","1937-4194","","10.1109/MS.2010.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484106","networking and communications;software engineering;systems engineering","Cloud computing","Internet;Web services","cloud computing;cloud infrastructure","","14","","","","14 Jun 2010","","","IEEE","IEEE Magazines"
"Software Adaptation: Classification and a Case Study with State Chart XML","F. Barbier; E. Cariou; O. L. Goaer; S. Pierre",University of Pau; University of Pau; University of Pau; University of Pau,"IEEE Software","21 Aug 2015","2015","32","5","68","76","Software adaptation has become prominent owing to the proliferation of software in everyday devices. In particular, computing with the Internet of Things requires adaptability. Traditional software maintenance, which involves long, energy-consuming cycles, is no longer satisfactory. Adaptation is a lightweight software evolution that provides more transparent maintenance for users. This article classifies types of adaptation and describes an implementation of it.","1937-4194","","10.1109/MS.2014.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6894482","software;model-driven development;model execution;software adaptation;software maintenance;software development;software engineering","Adaptation models;Unified modeling language;Java;Maintenance engineering;XML;Software maintenance","Internet of Things;software maintenance;XML","software adaptation;state chart XML;software proliferation;Internet of Things;software maintenance;energy-consuming cycles;lightweight software evolution","","3","","11","","9 Sep 2014","","","IEEE","IEEE Magazines"
"Impact of Ad Libraries on Ratings of Android Mobile Apps","I. J. Mojica Ruiz; M. Nagappan; B. Adams; T. Berger; S. Dienst; A. E. Hassan",McAfee; Rochester Institute of Technology; École Polytechnique de Montréal; University of Waterloo; University of Leipzig; Queen's University,"IEEE Software","7 Nov 2014","2014","31","6","86","92","One of the most popular ways to monetize a free app is by including advertisements in the app. Several advertising (ad) companies provide these ads to app developers through ad libraries that need to be integrated in the app. However, the demand for ads far exceeds the supply. This obstacle may lead app developers to integrate several ad libraries from different ad companies in their app to ensure they receive an ad with each request. However, no study has explored how many ad libraries are commonly integrated into apps. Additionally, no research to date has examined whether integrating many different ad libraries impacts an app's ratings. This article examines these two issues by empirically examining thousands of Android apps. The authors find that there are apps with as many as 28 ad libraries, but they find no evidence that the number of ad libraries in an app is related to its possible rating in the app store. However, integrating certain ad libraries can negatively impact an app's rating.","1937-4194","","10.1109/MS.2014.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6811104","software;mobile apps;ad libraries;Android;software economics;ad maintenance;software engineering","Advertisements;Companies;Androids;Humanoid robots;Mobile communication;Software development;Computer applications","advertising;Android (operating system);mobile computing;software libraries","ad libraries;Android mobile app ratings;free app monetization;advertisements;advertising companies;app store","","29","","13","","7 May 2014","","","IEEE","IEEE Magazines"
"Evaluating High-Performance Computing on Google App Engine","R. Prodan; M. Sperk; S. Ostermann",University of Innsbruck; University of Innsbruck; University of Innsbruck,"IEEE Software","20 Feb 2012","2012","29","2","52","58","An experimental approach employs the Google App Engine (GAE) for high-performance parallel computing. A generic master-slave framework enables fast prototyping and integration of parallel algorithms that are transparently scheduled and executed on the Google cloud infrastructure. Compared to Amazon Elastic Compute Cloud (EC2), GAE offers lower resource-provisioning overhead and is cheaper for jobs shorter than one hour. Experiments demonstrated good scalability of a Monte Carlo simulation algorithm. Although this approach produced important speedup, two main obstacles limited its performance: middleware overhead and resource quotas.","1937-4194","","10.1109/MS.2011.131","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6051415","cloud computing;high-performance computing;performance analysis;Google App Engine;GAE;Amazon Elastic Compute Cloud;Amazon EC2;software engineering","Google;Servers;Computer applications;Computational modeling;Parallel processing;Computer performance","cloud computing;middleware;Monte Carlo methods;parallel algorithms","Google App Engine;high-performance parallel computing;generic master-slave framework;parallel algorithm;Google cloud infrastructure;Amazon Elastic Compute Cloud;resource-provisioning overhead;Monte Carlo simulation algorithm;middleware overhead;resource quotas;GAE","","18","","12","","18 Oct 2011","","","IEEE","IEEE Magazines"
"The Risks of Agile Software Development: Learning from Adopters","A. Elbanna; S. Sarker","Royal Holloway, University of London; University of Virginia","IEEE Software","24 Aug 2016","2016","33","5","72","79","Agile software development (ASD) resulted from widespread professional discontent with traditional approaches; development projects' high failure rates; and, most important, the need for speedy, responsive delivery of software for Internet businesses. Many practitioners have embraced ASD, which commentators often extol as a faster, better, and cheaper development approach. However, a recent high-profile failure of an ASD project and the discontinued use of ASD in a software company have drawn attention to ASD's possible risks. Before we can manage such risks, we must identify them and understand why they arise. Researchers conducted interviews with 112 people in 28 organizations and with 25 ASD contractors and consultants. The interviews revealed key ASD risks that require careful management to achieve the desired project outcomes.","1937-4194","","10.1109/MS.2015.150","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7325176","agile software development;agile risks;software development risks;software risk management;software development;software engineering","Software development;Risk management;Agile software development;Software engineeirng","risk management;software prototyping","agile software development;development project high failure rates;ASD risk management;Internet business software","","10","","14","","11 Nov 2015","","","IEEE","IEEE Magazines"
"Multicore Desktop Programming with Intel Threading Building Blocks","W. Kim; M. Voss",Intel; Intel,"IEEE Software","20 Dec 2010","2011","28","1","23","31","The paper mentions that the Intel Threading Building Blocks is a key component of Intel Parallel Building Blocks. This widely used C++ template library helps developers achieve well-performing modular parallel programs in multiprogrammed environments.","1937-4194","","10.1109/MS.2011.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5672517","multicore programming;threading libraries;parallel-programming models;software engineering;programming;parallel programming","Computer threading;Instruction sets;Parallel processing;Arrays;Programming;Concurrent computing","C++ language;multiprocessing systems;parallel programming","multicore desktop programming;Intel threading building blocks;C++ template library;parallel programs;multiprogrammed environment","","26","","15","","20 Dec 2010","","","IEEE","IEEE Magazines"
"Community Collaboration for ERP Implementation","H. Wu; L. Cao",Old Dominion University; Old Dominion University,"IEEE Software","16 Oct 2009","2009","26","6","48","55","The paper discusses the enterprise resource planning (ERP).ERP implementation solves business problems by customizing and integrating off-the-shelf enterprise software packages. A successful ERP implementation involves extensive collaboration and communication among the customer, implementation consultancy, and software vendor. Collaboration allows implementation personnel from different organizations to utilize each other's experiences. An example of this is the Web 2.0. A Web 2.0 knowledge repository system can reduce costs, improve quality, and lower the risks of ERP implementations.Through the case study, the key desired features for Web 2.0 knowledge repository system to support ERP implementations were defined. Epics was designed to fulfill these requirements and developed a prototype. Epics can be used by software vendors, ERP consulting firms, and ERP users. Human aspects play a critical role in ERP implementation. ERP implementation quality depends largely on how the implementation personnel's knowledge and past experiences are reused and communicated. Although knowledge reuse, collaboration, and communication are important for all software projects, they're particularly critical in ERP implementation owing to its unique challenges.","1937-4194","","10.1109/MS.2009.171","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287009","Web 2.0;ERP implementation;software engineering;software implementation;packaged software;enterprise resource planning;ERP","Collaboration;Enterprise resource planning;Collaborative software;Personnel;Software packages;Costs;Software prototyping;Prototypes;Humans","data mining;enterprise resource planning;groupware;Internet;software reusability;software tools","ERP implementation;community collaboration;enterprise software packages;software vendor;Web 2.0 knowledge repository system;Epics software;ERP consulting firms;ERP users;knowledge reuse;communication","","12","1","12","","16 Oct 2009","","","IEEE","IEEE Magazines"
"PriView: Personalized Media Consumption Meets Privacy against Inference Attacks","S. Bhamidipati; N. Fawaz; B. Kveton; A. Zhang",Technicolor; Technicolor; Adobe Research; SET Media,"IEEE Software","30 Jun 2015","2015","32","4","53","59","PriView is an interactive personalized video consumption system that protects user privacy while recommending relevant content. It provides transparency of privacy risk, control of privacy risk, and personalized recommendations. It implements an information-theoretic framework to enable a utility-aware privacy mapping that distorts a user's video ratings to prevent attackers from inferring users' personal attributes (such as age, gender, or political views), while maintaining the distorted ratings' usefulness for recommendations. PriView uses convex optimization to create a probability mapping from actual ratings to distorted ratings that minimizes the distortion, subject to a privacy constraint. One practical challenge is scalability, when data comes from a large alphabet. Quantization combined with low-rank approximation of the rating matrix helps reduce the number of optimization variables. Evaluations showed that PriView can achieve perfect privacy with little change in recommendation quality. This article is part of a special issue on Security and Privacy on the Web.","1937-4194","","10.1109/MS.2015.100","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140690","inference attack;video personalization;privacy;privacy risk;privacy-utility tradeoff;video recommendations;transparency;video on demand;PriView;software engineering;software development","Computer security;Data privacy;TV;Distortion;Quantization (signal);Video on demand;Databases","convex programming;data protection;interactive video;quantisation (signal);recommender systems","PriView;personalized media consumption;inference attacks;interactive personalized video consumption system;user privacy protection;personalized content recommendation;privacy risk control;utility-aware privacy mapping;user video ratings;user personal attributes;user age;user gender;user political views;convex optimization;probability mapping;distortion minimization;quantization;low-rank approximation;rating matrix;optimization variables","","5","","6","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Software Security, Privacy, and Dependability: Metrics and Measurement","G. Hatzivasilis; I. Papaefstathiou; C. Manifavas",Technical University of Crete; Technical University of Crete; Rochester Institute of Technology Dubai,"IEEE Software","23 Jun 2016","2016","33","4","46","54","Measurement of software security is an ongoing research field. Privacy is also becoming an imperative target as social networking and ubiquitous computing evolve and users exchange high volumes of personal information. However, security and privacy alone don't guarantee proper data protection; software must also be dependable. Several standards typify the main concepts and protection mechanisms for these three properties, and measurement methodologies can quantify the provided protection level. However, security, privacy, and dependability are usually dealt with in isolation. To solve this problem, researchers have proposed a practical, easy-to-use methodology that measures a software system's overall security, privacy, and dependability (SPD) on the basis of the standards for each property. The nSHIELD (New Embedded Systems Architecture for Multi-layer Dependable Solutions) project is applying the SPD methodology to evaluate configurable embedded software in a social-mobility scenario.","1937-4194","","10.1109/MS.2016.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7436657","metrics;measurement;risk management;software quality assurance;verification and validation;security;privacy;software reliability;software dependability;nSHIELD;software engineering;software development","Privacy;Software security;Software measurement;Computer security;Process control","data privacy;security of data;software metrics;software quality","software security;privacy;dependability;metrics;social networking;ubiquitous computing;personal information;data protection;protection mechanisms;measurement methodologies;protection level;isolation;software system;nSHIELD project;SPD methodology;embedded software;social mobility scenario","","19","","11","","18 Mar 2016","","","IEEE","IEEE Magazines"
"Evolution of Software Systems with Extensible Languages and DSLs","S. Erdweg; S. Fehrenbach; K. Ostermann","Technische Universität Darmstadt, Germany; University of Marburg, Germany; University of Marburg, Germany","IEEE Software","15 Sep 2014","2014","31","5","68","75","Domain-specific languages (DSLs) provide various advantages regarding the maintainability of software systems. Unfortunately, existing software systems don't exploit DSLs and their maintenance benefits. Based on the extensible programming language SugarJ, the authors present a process for gradually integrating DSLs into existing software systems, report on their experience in integrating three DSLs into two existing software systems, and outline a roadmap for the development of tool support for the integration of DSLs.","1937-4194","","10.1109/MS.2014.99","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6840824","domain-specific languages;extensible programming languages;language embedding;software evolution;software maintenance;legacy applications;SugarJ;software engineering","DSL;Java;Software systems;Syntactics;Maintenance engineering;Programming;Domain specific languages;Embedded systems","high level languages;software maintenance","software system evolution;extensible languages;DSL;domain-specific languages;software system maintainability;SugarJ programming language","","","","16","","20 Jun 2014","","","IEEE","IEEE Magazines"
"Microservices Architecture Enables DevOps: Migration to a Cloud-Native Architecture","A. Balalaie; A. Heydarnoori; P. Jamshidi",Sharif University of Technology; Sharif University of Technology; Imperial College London,"IEEE Software","25 Apr 2016","2016","33","3","42","52","This article reports on experiences and lessons learned during incremental migration and architectural refactoring of a commercial mobile back end as a service to microservices architecture. It explains how the researchers adopted DevOps and how this facilitated a smooth migration.","1937-4194","","10.1109/MS.2016.64","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7436659","DevOps;microservices;cloud computing;migration pattern;architectural refactoring;software engineering;software development;mobile back end as a service","Computer architecture;Servers;Cloud computing;Microservices;Scalability;Mobile communication;Software architecture;Refractoring","cloud computing;software architecture;software maintenance","microservices architecture;DevOps;incremental migration;architectural refactoring;cloud-native architecture","","245","1","17","","18 Mar 2016","","","IEEE","IEEE Magazines"
"Using the Agile Unified Process in Banking","I. Christou; S. Ponis; E. Palaiologou","Athens Information Technology, Paiania; National Technical University of Athens, Athens; Athens Information Technology, Paiania","IEEE Software","19 Apr 2010","2010","27","3","72","79","The banking sector is well known for using large, sometimes monolithic, legacy systems. Now, banks find themselves having to catch up with rapid advancements in software development that call for new service-oriented computing paradigms. Unfortunately, this task is nontrivial and often requires huge projects that are costly, time consuming, and risky. The safe choice for a development methodology is a process framework such as the Rational Unified Process (RUP), which is customizable enough to fit any project. However, customizing RUP isn't trivial, so it's often used in its full-blown out-of-the-box form, which entails significant sacrifices of time, cost, and flexibility. The Agile Unified Process (AUP)-a hybrid approach designed by Scott Ambler combining RUP with agile methods to a successful project in the banking sector. The project achieved on-time delivery within budget, integrating heavy legacy back-end application systems with newly reengineered client user-interface applications on a modern service-oriented architecture (SOA) platform.","1937-4194","","10.1109/MS.2009.156","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5232801","software engineering;enterprise systems;systems design and analysis;methodologies;process;project management","Banking;Service oriented architecture;Programming;Costs","banking;software architecture;software maintenance;software prototyping;user interfaces","agile unified process;banking sector;software development;rational unified process;client user-interface application;service-oriented architecture;SOA;monolithic systems;legacy systems","","4","","12","","4 Sep 2009","","","IEEE","IEEE Magazines"
"Mining Task-Based Social Networks to Explore Collaboration in Software Teams","T. Wolf; A. Schröter; D. Damian; L. D. Panjer; T. H. D. Nguyen",University of Victoria; University of Victoria; University of Victoria; University of Victoria; University of Victoria,"IEEE Software","22 Dec 2008","2009","26","1","58","66","Suppose you're a software team manager who's responsible for delivering a software product by a specific date, and your team uses a code integration system (referred to as a build in IBM Rational Jazz and in this article) to integrate its work before delivery. When the build fails, your team needs to spend extra time diagnosing the integration issue and reworking code. As the manager, you suspect that your team failed to communicate about a code dependency, which broke the build. Your team needs to quickly disseminate information about its interdependent work to achieve a successful integration build. How can you understand your team's communication? Social-network analysis can give you insight into the team's communication patterns that might have caused the build's failure.","1937-4194","","10.1109/MS.2009.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721184","computer-supported collaborative work;organizational Impacts;software engineering;data mining","Social network services;Collaboration;Software;Graphical user interfaces;Data mining;Presses;Filtering","groupware;project management;social networking (online);software development management;team working","task-based social networks;collaboration;software teams;repository-independent approach;task-based communication","","58","","7","","22 Dec 2008","","","IEEE","IEEE Magazines"
"CodeBender: Remote Software Protection Using Orthogonal Replacement","M. Ceccato; P. Tonella",Fondazione Bruno Kessler; Fondazione Bruno Kessler,"IEEE Software","28 Feb 2011","2011","28","2","28","34","CodeBender implements a novel client replacement strategy to counter the malicious host problem and address the problem of guaranteeing client-code security. CodeBender is a tool that implements a novel client-replacement strategy to counter the malicious host problem. It works by limiting the client code's validity and, when the code expires, by having the server provide a new client that replaces the former one. The complexity of analyzing frequently changing, always different (orthogonal) program code deters an adversary's reverse engineering efforts. We've implemented CodeBender and tested its practicability in two case studies.","1937-4194","","10.1109/MS.2010.158","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5661761","hardware/software protection;development tools;software/software engineering;program transformation;security and protection","OFDM;Remote monitoring;Data structures;Encoding;Synchronization;Layout;Computer security","industrial property;program testing;reverse engineering","CodeBender;remote software protection;orthogonal replacement;client replacement strategy;malicious host problem;client code security;malicious host problem;client code validity;program code;reverse engineering","","6","","4","","10 Dec 2010","","","IEEE","IEEE Magazines"
"Developing a Scheduler with Difference-Bound Matrices and the Floyd-Warshall Algorithm","L. Ridi; J. Torrini; E. Vicario",Universita di Firenze; Universita di Firenze; Universita di Firenze,"IEEE Software","22 Dec 2011","2012","29","1","76","83","A study of difference-bound matrices and the Floyd-Warshall algorithm in the development of an online scheduler provides the backdrop for a comparison of software practice and algorithmic theory.","1937-4194","","10.1109/MS.2011.128","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111367","sequencing and scheduling;graph algorithms;Floyd-Warshall algorithm;difference-bound matrix;model checking;software engineering","Software algorithms;Scheduling;Difference equations;Algorithm design and analysis","graph theory;matrix algebra;scheduling","difference-bound matrices;Floyd-Warshall algorithm;online scheduler;software practice;algorithmic theory","","4","","12","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Feminine Expertise in Architecting Teams","M. Razavian; P. Lago",VU University Amsterdam; VU University Amsterdam,"IEEE Software","23 Jun 2016","2016","33","4","64","71","A well-known adage is ""diversity brings innovation."" Diversity can be in culture, thinking, discipline, gender, and many more aspects. The result is the same: the chances for creating innovation in a given context increase when diversity is involved. To some extent, this principle should also hold for gender diversity in software teams. Achieving gender diversity in IT-related fields has been a goal for decades, but still, too few women choose such a career. But what skills or traits assigned to the feminine role bring concrete advantages to software teams? Researchers addressed this important and, strangely enough, mostly unexplored problem, specifically for software-architecting teams. They interviewed male and female software architects at four major IT companies in the Netherlands and then interviewed a panel of experts. They identified seven feminine expertise ""flavors""--traits and skills linked to the feminine role in architecting teams. Much of such expertise relates to the skills required to successfully deal with software architecting's human aspects.","1937-4194","","10.1109/MS.2015.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7155435","software engineering;software development;software architecting;gender diversity;feminine expertise;gender studies;human factors","Interviews;Gender issues;Cultural differences;Technological innovation","gender issues;software architecture;team working","feminine expertise;innovation;gender diversity;software teams;IT-related fields;feminine role;software-architecting teams;female software architects;major IT companies","","6","","14","","13 Jul 2015","","","IEEE","IEEE Magazines"
"Software Architecture Design Reasoning: A Case for Improved Methodology Support","A. Tang; J. Han; R. Vasa",Swinburne University of Technology; Swinburne University of Technology; Swinburne University of Technology,"IEEE Software","24 Feb 2009","2009","26","2","43","49","This paper presents the capturing and recording of reasoning behind software architecture design to encourage architects to more carefully consider design decisions and better support future maintenance.","1937-4194","","10.1109/MS.2009.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786951","software architecture;design reasoning;software engineering;service interactions;speech acts","Software architecture;Software design;Process design;Design methodology;Computer architecture;Decision making;Context;Productivity","software architecture;software maintenance","software architecture design reasoning;improved methodology support;design decisions","","21","","12","","24 Feb 2009","","","IEEE","IEEE Magazines"
"Scrapheap Software Development: Lessons from an Experiment on Opportunistic Reuse","G. Kotonya; S. Lock; J. Mariani",Lancaster University; Lancaster University; Lancaster University,"IEEE Software","28 Feb 2011","2011","28","2","68","74","In this paper a set of 10 guidelines for opportunistic software reuse is discussed. These guidelines are based on observations of nine systems developed entirely with scraps of functionality scavenged from abandoned projects.","1937-4194","","10.1109/MS.2010.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5432144","Software engineering;opportunistic reuse;scrapheap development;component-based development","Programming;Software systems;Software reusability;Investments;Application software;Software tools;Software prototyping;Prototypes","project management;software development management;software reusability","scrapheap software development:;opportunistic software reuse;abandoned project","","2","","3","","18 Mar 2010","","","IEEE","IEEE Magazines"
"Database Refactoring: Lessons from the Trenches","G. Vial",HEC Montreal,"IEEE Software","28 Oct 2015","2015","32","6","71","79","Although database refactoring has been advocated as an important area of database development, little research has studied its implications. A small software development firm refactored a database related to an application that lets clients optimize their logistics processes. This project was based on the design of clear database development conventions and the need to package documentation in the database itself. The experience led to five key lessons learned: refactoring should be automated whenever possible, the database catalog is crucial, refactoring is easier when it's done progressively, refactoring can help optimize an application and streamline its code base, and refactoring related to application development requires a complex skill set and must be applied sensibly. This article is part of a special issue on Refactoring.","1937-4194","","10.1109/MS.2015.131","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310988","database management;database design;data manipulation languages;data description languages;relational databases;transaction processing;database evolution;database refactoring;software engineering;software development;refactoring","Software development;Data models;Code refractoring;Servers;Maintenance engineering","database management systems;software maintenance","database refactoring;database development;software development","","6","","12","","28 Oct 2015","","","IEEE","IEEE Magazines"
"A Comprehensive Evaluation of Common Python Implementations","J. M. Redondo; F. Ortin",University of Oviedo; University of Oviedo,"IEEE Software","30 Jun 2015","2015","32","4","76","84","Python is a widely used general-purpose dynamic language. Owing to its popularity, many implementations exist for the two distinct Python 2 and Python 3 language versions. Researchers evaluated seven implementations of both language versions to facilitate the selection of one of them. For this purpose, they carefully selected 523 programs to execute in each implementation. They evaluated run-time performance and memory consumption and investigated each implementation's important qualitative characteristics.","1937-4194","","10.1109/MS.2014.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6879048","dynamic languages;Python;run-time performance;memory consumption;benchmark suite;performance analysis;JIT compilation;just-in-time compilation;software engineering;software development","Runtime;Benchmark testing;Java;Memory management;Visual BASIC;Dynamic programming","high level languages;storage management","Python implementations;general-purpose dynamic language;Python 2 language versions;Python 3 language version;run-time performance;memory consumption","","12","","14","","15 Aug 2014","","","IEEE","IEEE Magazines"
"Open Collaboration within Corporations Using Software Forges","D. Riehle; J. Ellenberger; T. Menahem; B. Mikhailovski; Y. Natchetoi; B. Naveh; T. Odenwald",SAP Labs; SAP Research; SAP Labs; SAP Labs; SAP; Moblica; ICW Technology Labs,"IEEE Software","24 Feb 2009","2009","26","2","52","58","This article describes our experiences using open source software development practices at SAP. SAP is a major software developer and leader in business applications. We've found that open source practices can complement traditional top-down software development with bottom-up collective intelligence. Software forges offer a mechanism for advancing the adoption of open source best practices within corporations. We illustrate our experiences using SAP's own internal software forge, called SAP Forge, and compare our experiences with those from other large software companies.","1937-4194","","10.1109/MS.2009.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786953","Software Engineering;Programming Environments;Management;Information Interfaces and Presentations;User/Machine Systems;Group and Organization Interfaces;Management of Computing and Information Systems;Project and People Management;Software Management;software forge;collaborative software development;open source;open source best practices;open collaboration","Collaborative software;Open source software;Programming;Software tools;Software development management;Collaboration;Internet;Navigation;Project management;Switches","business data processing;DP industry;public domain software;software development management","SAP Forge;open source software development;business applications;collective intelligence;internal software forge;software companies","","28","","13","","24 Feb 2009","","","IEEE","IEEE Magazines"
"Characterizing Architecturally Significant Requirements","L. Chen; M. Ali Babar; B. Nuseibeh",University of Limerick and Paddy Power PLC; Lancaster University and IT University of Copenhagen; University of Limerick and The Open University,"IEEE Software","25 Feb 2013","2013","30","2","38","45","This article presents a framework for characterizing architecturally significant requirements (ASRs) on the basis of an empirical study using grounded theory. The study involved interviews with 90 practitioners with an accumulated 1,448 years of software development experiences in more than 500 organizations of various sizes and domains. These findings could provide researchers with a framework for discussing and conducting further research on ASRs and can inform researchers' development of technologies for dealing with ASRs. The findings also enrich understanding of requirements and architecture interactions, allowing the twin peaks to move from aspiration to reality.","1937-4194","","10.1109/MS.2012.174","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6365165","requirements;specifications;software engineering;software architectures;architecturally significant requirements;nonfunctional requirements;quality attributes;grounded theory;empirical study;ASR","Software devlopment;Computer architecture;Software architecture;Contracts","software architecture","architecturally significant requirements;ASR;empirical study;grounded theory;software development experiences;architecture interactions","","64","","10","","29 Nov 2012","","","IEEE","IEEE Magazines"
"Software Testing and Verification in Climate Model Development","T. Clune; R. Rood",NASA/Goddard Space Flight Center; University of Michigan,"IEEE Software","20 Oct 2011","2011","28","6","49","55","Over the past 30 years, most climate models have grown from relatively simple representations of a few atmospheric processes to complex multidisciplinary systems. Computer infrastructure over that period has gone from punchcard mainframes to modern parallel clusters. Model implementations have become complex, brittle, and increasingly difficult to extend and maintain. Verification processes for model implementations rely almost exclusively on some combination of detailed analyses of output from full climate simulations and system-level regression tests. Besides being costly in terms of developer time and computing resources, these testing methodologies are limited in the types of defects they can detect, isolate, and diagnose. Mitigating these weaknesses of coarse-grained testing with finer-grained unit tests has been perceived as cumbersome and counterproductive. Recent advances in commercial software tools and methodologies have led to a renaissance of systematic fine-grained testing. This opens new possibilities for testing climate-modeling-software methodologies.","1937-4194","","10.1109/MS.2011.117","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5999647","software engineering;program verification;testing strategies;testing and debugging","Atmospheric measurements;Meteorology;Software development;Computational modeling;Atmospheric modeling;Numerical models;Global warming","climatology;digital simulation;geophysics computing;program diagnostics;program testing;program verification","software testing;software verification;climate model development;atmospheric process;computer infrastructure;parallel clusters;verification process;climate simulation;system-level regression test;computing resources;defect detection;defect isolation;defect diagnosis","","21","","16","","25 Aug 2011","","","IEEE","IEEE Magazines"
"Capturing Compliance Requirements: A Pattern-Based Approach","O. Turetken; A. Elgammal; W. van den Heuvel; M. P. Papazoglou",Tilburg University; Tilburg University; Tilburg University; Tilburg University,"IEEE Software","20 Apr 2012","2012","29","3","28","36","In today's IT-centric business environment, managing compliance with regulations, laws, and other imperatives has become critical for success. Directives govern almost every aspect of running a business, requiring organizations to provide assurances to regulators, stakeholders, customers, and business partners. Assuring compliance across an enterprise necessitates a holistic, tractable, and disciplined approach for defining an integrated, consistent set of process and system-level internal controls. A new pattern-based framework captures and manages business process compliance requirements by acting as a springboard to fully automate and continuously audit business processes.","1937-4194","","10.1109/MS.2012.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6158632","business process management;representations;business process compliance;business process;software engineering","Process control;Monitoring;Optimization;Runtime;Risk management;Object recognition","auditing;business data processing;formal verification;legislation","pattern-based framework;business process compliance requirement management;business process auditing;assurance;organizational objective;business partners","","30","1","11","","27 Feb 2012","","","IEEE","IEEE Magazines"
"The Runtime Performance of invokedynamic: An Evaluation with a Java Library","F. Ortin; P. Conde; D. Fernandez-Lanvin; R. Izquierdo",University of Oviedo; University of Oviedo; University of Oviedo; University of Oviedo,"IEEE Software","13 Jun 2014","2014","31","4","82","90","The Java 7 platform includes the invokedynamic opcode in its virtual machine, a feature that lets programmers define-and dynamically change-the linkage of method call sites, thereby maintaining platform optimizations. A comprehensive evaluation of a new library's performance includes a description of how to optimize real Java applications.","1937-4194","","10.1109/MS.2013.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6493308","invokedynamic;Java Virtual Machine;runtime performance;dynamic languages;reflection;software engineering","Java;Runtime;Programming;Benchmark testing;Performance evaluation","Java;software libraries;source code (software);virtual machines","runtime performance;Java library performance;Java 7 platform;invokedynamic opcode;virtual machine;method call sites;platform optimizations;source code","","12","","9","","3 Apr 2013","","","IEEE","IEEE Magazines"
"The Architect's Role in Practice: From Decision Maker to Knowledge Manager?","R. Weinreich; I. Groher",Johannes Kepler University Linz; Johannes Kepler University Linz,"IEEE Software","28 Oct 2016","2016","33","6","63","69","Interviews with European and US software architects show not only a diverse practice of architecting but also the architect's transformation from primary decision maker to coordinator, advisor, and knowledge manager.","1937-4194","","10.1109/MS.2016.143","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725227","software architecture;architectural decision making;software architecture knowledge management;industrial interview study;software development;software engineering","Software architecture;Computer architecture;Interviews","personnel;software architecture;software development management","European software architects;US software architects;decision maker;knowledge manager;United States;coordinator;advisor","","3","","12","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Safety Analysis of Safety-Critical Systems Using State-Space Models","V. Kumar; L. K. Singh; A. K. Tripathi; P. Singh",Indian Institute of Technology (Banaras Hindu University); Indian Institute of Technology (Banaras Hindu University); Indian Institute of Technology (Banaras Hindu University); Indian Institute of Technology (Banaras Hindu University),"IEEE Software","11 Jul 2017","2017","34","4","38","47","State-space modeling is useful for prognostics of safety-critical systems. However, building such a model that embeds all the system requirements is a challenge. Furthermore, it requires expertise and hence isn't easily understood by all the stakeholders. UML can handle these challenges. A proposed approach converts a UML model into a state-space model. Researchers validated this approach on 13 safety-critical systems for nuclear power plants, focusing on the emergency core cooling system.","1937-4194","","10.1109/MS.2017.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974681","Petri nets;statecharts;state-space modeling;UML;software development;software engineering;nuclear power plants;emergency core cooling system;safety-critical systems","Unified modeling language;Reliability engineering;State-space methods;Safety;Mission critical systems","nuclear power stations;safety-critical software;Unified Modeling Language","safety-critical systems;state-space models;UML model;nuclear power plants;emergency core cooling system","","2","","15","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Microservices in Practice, Part 2: Service Integration and Sustainability","C. Pautasso; O. Zimmermann; M. Amundsen; J. Lewis; N. Josuttis",University of Lugano; University of Applied Sciences of Eastern Switzerland; API Academy; ThoughtWorks; NA,"IEEE Software","28 Mar 2017","2017","34","2","97","104","Service-oriented architecture (SOA) and microservices insiders Mike Amundsen, James Lewis, and Nicolai Josuttis share their experiences and predictions with department editors Cesare Pautasso and Olaf Zimmermann.","1937-4194","","10.1109/MS.2017.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888407","microservices;service-oriented architecture;SOA;domain-driven design;DDD;enterprise service bus;HTTP;Mike Amundsen;James Lewis;Nicolai Josuttis;software engineering;software development","Service-oriented architecture;Protocols;Data models;Semantics;Sustainable development","service-oriented architecture;sustainable development","microservices;service integration;sustainability;service-oriented architecture;SOA","","16","","24","","28 Mar 2017","","","IEEE","IEEE Magazines"
"Combining Service-Orientation with Product Line Engineering","J. Lee; G. Kotonya","Lancaster University, Lancaster; Lancaster University , Lancaster","IEEE Software","19 Apr 2010","2010","27","3","35","41","Software product line engineering (SPLE) is a paradigm of software reuse for developing a family of products with reduced time to market and improved quality. Most SPLE approaches, however, have focused on developing statically configured products using core assets. That is, all variations are instantiated before a product is delivered to the customers, making it difficult for them to make any changes to the product. However, various application areas are increasing the demand for dynamic product reconfiguration. A service-oriented product line (SOPL) is a DSPL application domain that's built on services and a service-oriented architecture. An example of an application area for an SOPL approach is a virtual office (VO). A VO includes many business peripherals with various services that interact with one another and that respond to their various environments to assist office workers.","1937-4194","","10.1109/MS.2010.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5406497","software;service-oriented product line;feature-oriented product line method;dynamic product line;service orientation;service-oriented architecture;QoS-aware framework;software engineering","Software quality;Time to market;Service oriented architecture;Teleworking","product development;software architecture;software reusability;virtual reality","service-orientation;software product line engineering;software reuse;core assets;dynamic product reconfiguration;service-oriented product line;service-oriented architecture;virtual office","","34","","15","","5 Feb 2010","","","IEEE","IEEE Magazines"
"Approximating Data with the Count-Min Sketch","G. Cormode; M. Muthukrishnan",AT&TLabs-Research; Rutgers University,"IEEE Software","22 Dec 2011","2012","29","1","64","69","Faced with handling multiple large data sets in modern data-processing settings, researchers have proposed sketch data structures that capture salient properties while occupying little memory and that update or probe quickly. In particular, the Count-Min sketch has proven effective for a variety of applications. It concurrently tracks many item counts with surprisingly strong accuracy.","1937-4194","","10.1109/MS.2011.127","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6042851","Count-Min sketch;massive data;streaming algorithms;software engineering","Software algorithms;Data processing;Data structures;Large-scale systems","data handling","Count-Min sketch;data approximation;data-processing setting;data set handling","","22","","8","","13 Oct 2011","","","IEEE","IEEE Magazines"
"Improving Domain-Specific Language Reuse with Software Product Line Techniques","J. White; J. H. Hill; J. Gray; S. Tambe; A. S. Gokhale; D. C. Schmidt",Vanderbilt University; Vanderbilt University; University of Alabama; Vanderbilt University; Vanderbilt University; Vanderbilt University,"IEEE Software","19 Jun 2009","2009","26","4","47","53","Complex software systems, such as traffic management systems and shipboard computing environments, raise several concerns (such as performance, reliability, and fault tolerance) that developers must manage throughout the software life cycle. Domain-specific languages (DSLs) have emerged as a powerful mechanism for capturing and reasoning about these diverse concerns. For each system concern, you can design a DSL to precisely capture key domain-level information while shielding developers and users from the technical solution's implementation-level details.","1937-4194","","10.1109/MS.2009.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5076458","feature models;domain-specific languages;reuse;software product lines;domain analysis;domain hierarchy;software engineering","Domain specific languages;DSL;Light scattering;Hardware;System testing;Context modeling;Embedded software;Application software;Programming;Traffic control","software reusability;specification languages","domain-specific language reuse;software product line techniques;complex software systems;software life cycle","","39","","4","","19 Jun 2009","","","IEEE","IEEE Magazines"
"Node.DPWS: Efficient Web Services for the Internet of Things","K. Fysarakis; D. Mylonakis; C. Manifavas; I. Papaefstathiou",Technical University of Crete; freelance software developer; Technological Educational Institute of Crete; Technical University of Crete,"IEEE Software","25 Apr 2016","2016","33","3","60","67","Node.DPWS is an implementation of the Devices Profile for Web Services (DPWS). It comprises the first set of DPWS libraries available to Node.js developers and can be used to deploy lightweight, efficient, and scalable Web services over heterogeneous nodes.","1937-4194","","10.1109/MS.2015.155","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7325198","Web services;development tools;software libraries;software development;standards;ubiquitous computing;software engineering;DPWS;Devices Profile for Web Services;Node.DPWS;Node.js","Libraries;Java;Performance evaluation;Context awareness;Interoperability;Service-oriented architecture;Internet of things;Web services;Software development;Ubiquitous computing","Internet of Things;Web services","Node.DPWS;devices profile for Web services;DPWS libraries;Internet of Things","","8","","16","","11 Nov 2015","","","IEEE","IEEE Magazines"
"Clear Climate Code: Rewriting Legacy Science Software for Clarity","N. Barnes; D. Jones",Climate Code Foundation; Climate Code Foundation,"IEEE Software","20 Oct 2011","2011","28","6","36","42","The Clear Climate Code project rewrote GISTEMP, a legacy software system used to produce an important global surface temperature dataset. The focus of the project is on clarity: making the source code as clear as possible to interested people, to improve public understanding. The result is a Python package that's easy to understand, run, and change, which allows any interested person to pose and answer novel research questions. In the process, the project's founders also discovered and fixed some inconsequential bugs and hopefully improved online discussion of global warming.","1937-4194","","10.1109/MS.2011.113","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5999649","Earth and atmospheric sciences;physical sciences and engineering;computer applications;software psychology;software engineering;software;climate change;restructuring;reverse engineering;reengineering distribution;maintenance;enhancement;documentation;portability","Software development;Meteorology;Temperature measurement;Computer bugs;Ocean temperature;Legacy systems;Atmospheric measurements;Global warming","climatology;environmental science computing;meteorology;software maintenance","legacy science software rewriting;clear climate code project;GISTEMP;legacy software system;global surface temperature dataset;Python package;global warming","","3","","9","","25 Aug 2011","","","IEEE","IEEE Magazines"
"Requirements Engineering for Safety-Critical Systems: Overview and Challenges","L. E. G. Martins; T. Gorschek",Federal University of São Paulo; Blekinge Institute of Technology,"IEEE Software","11 Jul 2017","2017","34","4","49","57","In a world that depends increasingly on complex, critical, and intertwined systems, requirements engineering is crucial to developing and maintaining safety-critical systems (SCSs). Researchers studied the state of the art (through the literature) and the state of the practice (through in-depth interviews with practitioners) to discover what approaches are available for capturing, specifying, and communicating safety requirements throughout the SCS lifecycle and to determine the remaining challenges.","1937-4194","","10.1109/MS.2017.94","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974683","requirements engineering;safety-critical systems;embedded systems;systems engineering;software engineering;software development","Safety;Reliability engineering;Mission critical systems;Industries;Aerospace control","formal specification;safety-critical software","requirements engineering;safety-critical systems;SCS","","6","","17","","11 Jul 2017","","","IEEE","IEEE Magazines"
"From Software Development to Software Assembly","H. M. Sneed; C. Verhoef",Technische Universität Dresden; Vrije Universiteit Amsterdam,"IEEE Software","24 Aug 2016","2016","33","5","80","85","The lack of skilled programming personnel and the growing burden of maintaining customized software are forcing organizations to quit producing their own software. It's high time they turned to ready-made, standard components to fulfill their business requirements. Cloud services might be one way to achieve that goal.","1937-4194","","10.1109/MS.2015.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7106411","IT labor shortage;maintenance costs;legacy systems;software reuse;Web services;software engineering;software development","Software development;Maintenance engineering;Personnel;Employments;Standards","cloud computing;software development management","software development;software assembly;cloud services","","1","","21","","13 May 2015","","","IEEE","IEEE Magazines"
"Stigmergy-Based Construction of Internetware Artifacts","W. Zhang; H. Zhao; Y. Jiang; Z. Jin",Peking University; Peking University; Nanjing University of Aeronautics and Astronautics; Peking University,"IEEE Software","4 Feb 2015","2015","32","1","58","66","A proposed approach supports the continual construction and evolution of model-based Internetware artifacts by a collective of Internet-connected stakeholders. The key mechanism is incremental graph superimposition (IGS), a refinement of stigmergy, the process that produces collective intelligence in social insects. Employing IGS, a collective of individuals collaboratively and continually construct a collective-level graph by incrementally aggregating the individuals' working results. Each individual can work independently without direct interaction with others, facilitating mass collaboration among a large number of individuals. A conceptual model illustrates the effects of IGS. A Web environment supports IGS-based conceptual-model construction and ongoing case studies.","1937-4194","","10.1109/MS.2014.133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6914466","software artifacts;stigmergy;incremental graph superimposition;evolution;software engineering","Software;Internet;Educational institutions;Market research;Buildings;Context;Insects","graph theory;groupware;Internet","stigmergy-based construction;model-based Internetware artifacts;Internet-connected stakeholders;incremental graph superimposition;collective intelligence;social insects;collective-level graph;mass collaboration;Web environment;IGS-based conceptual-model construction","","4","","14","","1 Oct 2014","","","IEEE","IEEE Magazines"
"Debugging the Internet of Things: The Case of Wireless Sensor Networks","P. Eugster; V. Sundaram; X. Zhang",SensorHound; SensorHound; Purdue University,"IEEE Software","4 Feb 2015","2015","32","1","38","49","The Internet of Things (IoT) has the strong potential to support a human society interacting more symbiotically with its physical environment. Indeed, the emergence of tiny devices that sense environmental cues and trigger actuators after consulting logic and human preferences promises a more environmentally aware and less wasteful society. However, the IoT inherently challenges software development processes, particularly techniques for ensuring software reliability. Researchers have developed debugging tools for wireless sensor networks (WSNs), which can be viewed as the enablers of perception in the IoT. These tools gather run-time information on individual sensor node executions and node interactions and then compress that information.","1937-4194","","10.1109/MS.2014.132","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6914470","Internet of Things;wireless sensor networks;debugging;tracing;replay;software engineering","Internet of things;Debugging;Wireless sensor networks;Computers;Wireless communication;Peer-to-peer computing;Runtime","Internet of Things;program debugging;software reliability;wireless sensor networks","Internet of Things;wireless sensor networks;software development process;debugging tools;IoT;sensor node executions;node interactions;software reliability","","16","","11","","1 Oct 2014","","","IEEE","IEEE Magazines"
"KLOVER: Automatic Test Generation for C and C++ Programs, Using Symbolic Execution","H. Yoshida; G. Li; T. Kamiya; I. Ghosh; S. Rajan; S. Tokumoto; K. Munakata; T. Uehara",Fujitsu Laboratories of America; Fujitsu Laboratories of America; Fujitsu Laboratories of America; Fujitsu Laboratories of America; Fujitsu Laboratories of America; Fujitsu Laboratories Limited; Fujitsu Laboratories Limited; Fujitsu Laboratories Limited,"IEEE Software","22 Sep 2017","2017","34","5","30","37","Fujitsu researchers have developed a methodology to automate testing of industrial-strength embedded software implemented in C or C++. The methodology's core is a program analysis technique called symbolic execution, which the researchers have customized to automate testing. The methodology generates unit-level tests, greatly reducing test generation time and cost while providing excellent test coverage.","1937-4194","","10.1109/MS.2017.3571576","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048666","automatic test generation;symbolic execution;embedded software;KLOVER;software engineering;software development","C++ languages;Embedded software;Payloads;Software testing;Automatic testing","C++ language;program diagnostics;program testing","KLOVER;automatic test generation;C programs;C++ programs;symbolic execution;software testing;program analysis technique","","3","","14","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Automated System-Level Regression Test Prioritization in a Nutshell","P. Erik Strandberg; W. Afzal; T. J. Ostrand; E. J. Weyuker; D. Sundmark",Westermo Research and Development; Mälardalen University; Mälardalen University; Mälardalen University; Mälardalen University,"IEEE Software","11 Jul 2017","2017","34","4","30","37","Westermo Research and Development has developed SuiteBuilder, an automated tool to determine an effective ordering of regression test cases. The ordering is based on factors such as fault detection success, the interval since the last execution, and code modifications. SuiteBuilder has enabled Westermo to overcome numerous regression-testing problems, including lack of time to run a complete regression suite, failure to detect bugs in a timely manner, and repeatedly omitted tests. In the tool's first two years of use, reordered test suites finished in the available time, most fault-detecting test cases were located in the first third of suites, no important test case was omitted, and the necessity for manual work on the suites decreased greatly.","1937-4194","","10.1109/MS.2017.92","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974685","regression testing;software testing;testing strategies;test execution;testing tools;test levels;validation;SuiteBuilder;Westermo;software engineering;software development","Software testing;Software development;Databases;Reliability engineering;Computer bugs;Regression analysis","program testing","automated system-level regression test prioritization;SuiteBuilder;complete regression suite;fault-detecting test cases","","1","","9","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Measuring Architecture Sustainability","H. Koziolek; D. Domis; T. Goldschmidt; P. Vorst",ABB Corporate Research Germany; ABB Corporate Research Germany; ABB Corporate Research Germany; ABB Corporate Research Germany,"IEEE Software","28 Oct 2013","2013","30","6","54","62","It's difficult to express a software architecture's sustainability in a single metric: relevant information is spread across requirements, architecture design documents, technology choices, source code, system context, and software architects' implicit knowledge. Many aspects influence economic sustainability, including design decisions facilitating evolutionary changes, adherence to good modularization practices, and technology choices. An approach that focuses on a single artifact or perspective is likely to neglect important factors. ABB Corporate Research is tracking the architecture sustainability of a large-scale industrial control system currently under development. A former version of the system grew to several million LOC and suffered from architecture erosion and high maintenance costs. A multiperspective approach called Morphosis will help avoid such a situation in the future by focusing on requirements, architecture design, and source code. It includes evolution scenario analysis, scoring of technology choices, architecture compliance checks, and tracking of architecture-level code metrics.","1937-4194","","10.1109/MS.2013.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6576748","software architecture;software engineering;maintenance measurement;product metrics;metrics;measurement;Morphosis;architecture sustainability","Computer architecture;Software architecture;Sustainable development;Software systems;Best practices","software architecture;software metrics;sustainable development","architecture sustainability measurment;software architecture sustainability;architecture design documents;source code;system context;economic sustainability;design decisions;ABB Corporate Research;large-scale industrial control system;architecture erosion;multiperspective approach;Morphosis;architecture compliance checks;architecture-level code metrics","","10","","13","","8 Aug 2013","","","IEEE","IEEE Magazines"
"Natural Language Requirements Processing: A 4D Vision","A. Ferrari; F. Dell’Orletta; A. Esuli; V. Gervasi; S. Gnesi",CNR-ISTI; CNR-ILC; CNR-ISTI; University of Pisa; CNR-ISTI,"IEEE Software","13 Nov 2017","2017","34","6","28","35","The future evolution of the application of natural language processing technologies in requirements engineering can be viewed from four dimensions: discipline, dynamism, domain knowledge, and datasets.","1937-4194","","10.1109/MS.2017.4121207","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106888","natural language processing;NLP;requirements engineering;RE;requirements specification;software engineering;software development","Natural language processing;Software development;Terminology;Requirements engineering","data analysis;formal specification;formal verification;natural language processing","datasets;domain knowledge;dynamism;discipline;natural language processing technologies;requirements engineering;4D vision;natural language requirements processing","","5","","21","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Developing Cloud Business Models: A Case Study on Cloud Gaming","A. Ojala; P. Tyrvainen",University of Jyväskylä; University of Jyväskylä,"IEEE Software","23 Jun 2011","2011","28","4","42","47","Cloud computing offers new ways for firms to operate in the global market so that even small firms can compete in markets traditionally dominated by multinational corporations. A case study considers how, over ten years, a small firm developed a successful business model to compete in computer gaming.","1937-4194","","10.1109/MS.2011.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5741005","cloud computing;business models;cloud gaming;value chain;platform;SaaS;software engineering","Cloud computing;Strategic planning;Business;Modeling;Competitive intelligence;Marketing and sales;Globalization","business data processing;cloud computing;computer games;small-to-medium enterprises","cloud business model;cloud gaming;cloud computing;small firm","","43","","12","","5 Apr 2011","","","IEEE","IEEE Magazines"
"People over Process: Key Challenges in Agile Development","K. Conboy; S. Coyle; X. Wang; M. Pikkarainen","National University of Ireland, Galway; National University of Ireland, Galway; Lero; VTT Technical Research Centre of Finland","IEEE Software","23 Jun 2011","2011","28","4","48","57","Case studies of 17 organizations that have used agile methods for more than three years uncovered many serious ""people"" challenges including recruitment, training, motivation, and performance evaluation.","1937-4194","","10.1109/MS.2010.132","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5560625","agile;agile software development;adoption;methodologies;people factors;developers;software development;software engineering","Agile manufacturing;Business;Object oriented modeling;Strategic planning;Business;Management","organisational aspects;recruitment;training","agile development;recruitment;training;motivation;performance evaluation;organisations","","80","","7","","2 Sep 2010","","","IEEE","IEEE Magazines"
"Scale and Responsiveness in Large-Scale Software Development","H. Olsson; A. Sandberg; J. Bosch; H. Alahyari","Malmö University; Ericsson AB , Gothenburg; Chalmers University of Technology, Gothenburg; Chalmers University of Technology, Gothenburg","IEEE Software","15 Sep 2014","2014","31","5","87","93","In large-scale software development, there is typically a conflict between being responsive to individual customers, while at the same time achieving scale in terms of delivering a high number of features to a large customer base. Most often, organizations focus on scale and individual customer requests are viewed as problematic since they add complexity to product variation and version control. Here, we explore the use of customer-specific teams as a means to address this conflict. First, we verify the use of customer-specific teams as successful for improving customer responsiveness, customer satisfaction and feature quality through a case study at Ericsson. Second, we identify three approaches for how to organize feature development, and recommendations on how software development companies can efficiently use these to improve their practices. Third, we observe new business opportunities that arise when using customer-specific teams.","1937-4194","","10.1109/MS.2013.139","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6656805","large-scale software development;customer-specific teams;customer responsiveness;software engineering","Software development;Companies;Feedback loop;Interviews;Customer satisfaction","customer satisfaction;software development management","large-scale software development;scale customer requests;individual customer requests;product variation;version control;customer-specific teams;customer responsiveness;customer satisfaction;feature quality;business opportunities","","8","","15","","6 Nov 2013","","","IEEE","IEEE Magazines"
"Visual Tools for Software Architecture Understanding: A Stakeholder Perspective","A. Telea; L. Voinea; H. Sassenburg","University of Groningen, Groningen; SolidSource BV, Eindhoven; SE-CURE, Lenk","IEEE Software","14 Oct 2010","2010","27","6","46","53","This paper is talking about visual tools for understanding software architecture.Software visualisation tool operates as a pipeline.They mine data from various sources and then analyse the data using various techniques like static analyzers, text miners, repository access clients, and database clients. A refined-fact database stores the analysis results, using an entity-relationship.","1937-4194","","10.1109/MS.2010.115","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5518754","software engineering;software tools;visualization","Software architecture","data analysis;data mining;software architecture;software tools","software architecture;software visualisation tool;data mining;refined fact database;entity relationship;data analysis","","9","","12","","23 Jul 2010","","","IEEE","IEEE Magazines"
"Handshaking with Implementation Proposals: Negotiating Requirements Understanding","S. Fricker; T. Gorschek; C. Byman; A. Schmidle",University of Zurich and Fuchs-Informatik AG; Blekinge Institute of Technology; ABB; ABB Switzerland,"IEEE Software","25 Feb 2010","2010","27","2","72","80","A bidirectional process for agreeing on product requirements proves effective in overcoming misunderstandings that arise in the traditional handoff of requirements specifications to development teams.","1937-4194","","10.1109/MS.2010.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420800","software engineering;requirements specification;software design;software methodologies","Proposals","formal specification;systems analysis","handshaking;implementation proposals;requirements understanding;bidirectional process;product requirements;requirements specifications","","43","","12","","25 Feb 2010","","","IEEE","IEEE Magazines"
"Model-Based Development and Formal Methods in the Railway Industry","A. Ferrari; A. Fantechi; S. Gnesi; G. Magnani","CNR-ISTI; Università di Firenze; CNR-ISTI; General Electric Transportation Systems, Florence","IEEE Software","18 Apr 2013","2013","30","3","28","34","The transition from a code-based process to a model-based process isn't easy. This is particularly true for a company that operates in a safety-critical sector, where the products must be developed according to international standards, with certified tools and controlled processes. The authors summarize the experience of a railway signaling manufacturer that decided to adopt general-purpose, model-based tools—namely, Simulink/Stateflow and SysML—for product development. The company faced challenges primarily concerning the verification of the software and the integration of the tools within the existing process. Structured development solutions and formal/semiformal approaches were adopted to tackle the challenges.","1937-4194","","10.1109/MS.2013.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6475930","software engineering process;formal methods;software and system safety;programming paradigms","Modeling;Software packages;Encoding;Rail transportation;Standards;System analysis and design;Safety","","","","18","","10","","7 Mar 2013","","","IEEE","IEEE Magazines"
"Scripting Multiple CPUs with Safe Data Sharing","A. Skyrme; N. Rodriguez; R. Ierusalimschy","Pontifical Catholic University of Rio de Janeiro, RJ; Pontifical Catholic University of Rio de Janeiro, Rio de Janeiro; Pontifical Catholic University of Rio de Janeiro, Rio de Janeiro","IEEE Software","15 Sep 2014","2014","31","5","44","51","Scripting languages are very popular and are being used to implement a wide range of applications. Meanwhile, multi-core processors are everywhere, from dektop computers to mobile devices, and concurrency has become the only means to improve performance. However, concurrent programming remains difficult and despite some interest in researching new concurrency models for compiled languages, the conventional concurrency support in scripting languages is still lacking. In this paper we are interested in \emph{safe data sharing for scripting languages}. We explore the landscape of conventional concurrency support in popular scripting languages and discuss some of its limitations. Then, we identify some emerging concurrency patterns in scripting languages, namely: no-default sharing, data ownership, futures and data immutability. Finally, we analyze some limitations in existing mechanisms and discuss how the patterns we identified can be used to provide safe data sharing in scripting languages.","1937-4194","","10.1109/MS.2014.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898741","software;software engineering;concurrent programming;scripting;languages programming languages;data sharing","Concurrent computing;Message systems;Multithreading;Synchronization;Programming;Software development;Information sharing","authoring languages;multiprocessing systems","scripting languages;multi-core processors;data sharing;dekstop computers;mobile devices;concurrent programming;concurrency models;no-default sharing pattern;data ownership pattern;futures pattern;data immutability pattern","","","","14","","15 Sep 2014","","","IEEE","IEEE Magazines"
"People as a Service: A Mobile-centric Model for Providing Collective Sociological Profiles","J. Guillén; J. Miranda; J. Berrocal; J. García-Alonso; J. M. Murillo; C. Canal",Gloin; Gloin; University of Extremadura; University of Extremadura; University of Extremadura; University of Málaga,"IEEE Software","17 Mar 2014","2014","31","2","48","53","Researchers from sociological disciplines could greatly benefit from collective information from the many people who use mobile devices to communicate via various social apps and services. However, processing that information is difficult because it's scattered among numerous social platforms. Furthermore, users are becoming increasingly concerned about how and by whom their information is being accessed. A new mobile-centric computing model allows sociological profiles of people to be generated, kept, and securely provided to third parties as a service. With this model, device owners can be fully aware and in control of how their information is accessed, while still contributing to collective sociological information.","1937-4194","","10.1109/MS.2013.140","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6662347","mobile applications;data sharing;nomadic computing;pervasive computing;human-centered computing;distributed systems;human information processing;privacy;people as a service;PeaaS;software engineering;mobile computing","Mobile handsets;Computational modeling;Computer architecture;Next generation networking;Mobile communication;Mobile computing;Sociology","mobile computing;social networking (online);social sciences computing","people as a service;collective sociological profiles;sociological disciplines;mobile devices;social apps;social platforms;mobile-centric computing model;collective sociological information","","48","","6","","12 Nov 2013","","","IEEE","IEEE Magazines"
"Reverse Engineering on the Mainframe: Lessons Learned from ""In Vivo"" Research","J. Van Geet; S. Demeyer","University of Antwerp, Antwerp; University of Antwerp University of Antwerp, Antwerp Antwerpen","IEEE Software","14 Jun 2010","2010","27","4","30","36","Despite growth in the popularity of desktop systems, Web applications, and mobile computing, mainframe systems remain the dominant force in large-scale enterprise computing. Although they're sometimes referred to as ""the dinosaurs of computing,"" even mainframe systems must adapt to changing circumstances to survive. Although reverse-engineering and reengineering techniques can help identify and achieve these adaptations, current techniques are mainly geared mainly toward more modern environments, languages, and platforms. It remains to be seen whether successful techniques can be easily transferred to a mainframe context. This article reports on the application of two proven reverse-engineering techniques (software visualization and feature location) in the context of mainframe systems. The authors conclude that these techniques remain viable but become very labor intensive when implemented on a per-project basis.","1937-4194","","10.1109/MS.2010.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5440167","feature location;software visualization;industrial experience;software engineering;software","Reverse engineering;In vivo;Mobile computing;Computer applications;Large-scale systems;Dinosaurs;Application software;Visualization","business data processing;program visualisation;reverse engineering","reverse engineering;mainframe systems;large-scale enterprise computing;software visualization;feature location","","8","","13","","29 Mar 2010","","","IEEE","IEEE Magazines"
"Requirements Engineering Tools","J. M. Carrillo de Gea; J. Nicolás; J. L. F. Alemán; A. Toval; C. Ebert; A. Vizcaíno","Software Eng. Res. Group, Univ. of Murcia, Murcia, Spain; Software Eng. Res. Group, Univ. of Murcia, Murcia, Spain; Software Eng. Res. Group, Univ. of Murcia, Murcia, Spain; Software Eng. Res. Group, Univ. of Murcia, Murcia, Spain; NA; Alarcos Res. Group, Univ. of Castilla-La Mancha, Ciudad Real, Spain","IEEE Software","23 Jun 2011","2011","28","4","86","91","Requirements engineering (RE) tools are increasingly used to ease the RE processes and allow for more systematic and formalized handling of requirements, change management and traceability. For developers and companies evaluating the use of RE tools it is thus essential to know which RE processes are supported by tools and how they fit to their own priorities. The answer isn't easy because many sales prospects highlight numerous features-yet leave out to which degree they're supported and whether all features really matter. To gain insight into how current RE tools adapt to RE activities, we ran a 146-item survey based on the features covered by the ISO/IEC TR 24766:2009, a new framework for assessing RE tool capabilities. We received responses from 37 participants, covering all relevant tools. In addition to the tools' score in each activity, we assessed their performance in three concrete use scenarios. Our findings can help practitioners select an RE tool as well as provide areas for improvement for RE tools developers.","1937-4194","","10.1109/MS.2011.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929527","requirements engineering tools;survey;ISO/IEC TR 24766:2009;software;software engineering","Design methodology;Software development management;Change detection algorithms;Business process re-engineering;System analysis and design","formal specification;formal verification;software tools;systems analysis","requirements engineering tools;RE processes;requirements handling;change management;change traceability;ISO-IEC TR 24766:2009 standard","","36","","2","","23 Jun 2011","","","IEEE","IEEE Magazines"
"Self-Adaptation Using Multiagent Systems","D. Weyns; M. Georgeff",Katholieke Universiteit Leuven; Monash University,"IEEE Software","31 Dec 2009","2010","27","1","86","91","Each decade has its key software technology to advance artificial intelligence, and each technology is highlighted in a novel that sells much better than the underlying technology. Who hasn't read Michael Crichton's Prey and wondered how far multiagent systems might evolve and how they might affect humankind? Our technology column digs into this topic in this issue. Danny Weyns and Michael Georgeff provide a short introduction and show how multiagent systems help master the complexity of self-adaptive systems. They contrast multiagent systems with other current technologies and provide links and hints for practitioners who want to get started with this emerging field.","1937-4194","","10.1109/MS.2010.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370765","software engineering;multiagent systems","Multiagent systems;Artificial intelligence","multi-agent systems;self-adjusting systems;systems analysis","systems self-adaptation;multiagent system;artificial intelligence","","12","","","","31 Dec 2009","","","IEEE","IEEE Magazines"
"Sharing Source Code with Clients: A Hybrid Business and Development Model","M. Riepula",Aalto University,"IEEE Software","23 Jun 2011","2011","28","4","36","41","Open innovation and the recent emphasis on client involvement imply the emergence of hybrid software licensing models combining the limited openness of source code with traditional value appropriation logic. A practical hybrid licensing model responds to the needs of both business-to-business software vendors in vertical domains and consultancies that must maintain separate quasi-products. The central idea is that the vendor of commoditized products also licenses source code to select clients, who become participants in and subscribers to an ongoing closed development community. The tools and techniques are readily available from open source development, but the motivations and relationship management work differently than in a pure open source context.","1937-4194","","10.1109/MS.2011.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5750002","client-shared source;shared source;gated source;open source;hybrid OSS;OSS 2.0;software licensing;client innovation;client coproduction;distributed development;inner source;corporate source;software business model;software commoditization;software commodification;software development;software engineering","Open source software;Licenses;Technological innovation;Business;Modeling;Marketing and sales;Strategic planning;Technological innovation","business data processing;consultancies;innovation management;public domain software;software development management","source code sharing;business-and-development model;open innovation;value appropriation logic;hybrid licensing model;business-to-business software vendors;commoditized products;open source development;consultancies","","3","","14","","15 Apr 2011","","","IEEE","IEEE Magazines"
"Object-Oriented Analysis: Is It Just Theory?","R. Gelbard; D. Te'eni; M. Sade","Bar-Ilan University , Ramat-Gan; Tel-Aviv Univ., Tel-Aviv, Israel; Tel-Aviv University, Tel-Aviv","IEEE Software","31 Dec 2009","2010","27","1","64","71","Research and commercial surveys suggest that the object-oriented (OO) approach strongly supports the technical design and coding phases of software development but poorly supports the functional analysis phase. In other words, ""the design is good, the analysis is poor."" The source of this weakness is often attributed to the fact that ""UML representations have not been effective in large-scale projects for context and communication.""","1937-4194","","10.1109/MS.2009.151","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5232797","object oriented analysis;uml;cost-benefit;software;software engineering","Programming;Functional analysis;Unified modeling language;Large-scale systems;Context","object-oriented methods;Unified Modeling Language","object-oriented analysis;software development technical design;software development coding phase;functional analysis phase;UML representation","","7","","19","","4 Sep 2009","","","IEEE","IEEE Magazines"
"Enabling IoT Ecosystems through Platform Interoperability","A. Bröring; S. Schmid; C. -K. Schindhelm; A. Khelil; S. Käbisch; D. Kramer; D. Le Phuoc; J. Mitic; D. Anicic; E. Teniente",Siemens; Bosch Corporate Research; Siemens; Landshut University of Applied Sciences; Siemens; Bosch Software Innovations; Technical University of Berlin; Siemens; Siemens; Universitat Politècnica de Catalunya,"IEEE Software","16 Jan 2017","2017","34","1","54","61","Today, the Internet of Things (IoT) comprises vertically oriented platforms for things. Developers who want to use them need to negotiate access individually and adapt to the platform-specific API and information models. Having to perform these actions for each platform often outweighs the possible gains from adapting applications to multiple platforms. This fragmentation of the IoT and the missing interoperability result in high entry barriers for developers and prevent the emergence of broadly accepted IoT ecosystems. The BIG IoT (Bridging the Interoperability Gap of the IoT) project aims to ignite an IoT ecosystem as part of the European Platforms Initiative. As part of the project, researchers have devised an IoT ecosystem architecture. It employs five interoperability patterns that enable cross-platform interoperability and can help establish successful IoT ecosystems.","1937-4194","","10.1109/MS.2017.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819420","interoperability;software architecture;software patterns;semantics;Internet of Things;IoT;BIG IoT;Bridging the Interoperability Gap of the IoT;software engineering;software development;IoT ecosystems","Internet of things;Software development;Ecosystems;Interoperability","application program interfaces;Internet of Things;open systems","Internet of Things;vertically oriented platforms;platform-specific API;information models;BIG IoT;IoT ecosystems;bridging the interoperability gap of the IoT","","135","","9","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Making Architecture Visible to Improve Flow Management in Lean Software Development","R. L. Nord; I. Ozkaya; R. S. Sangwan",Carnegie Mellon University; Carnegie Mellon University; Pennsylvania State University,"IEEE Software","21 Aug 2012","2012","29","5","33","39","Lean practices use the principle of Little's law to improve the flow of value to the end user by eliminating sources of waste from a software development process. Little's law defines throughput as a ratio of work in process and cycle time. Increasing throughput (or productivity) requires continuously improving (that is, decreasing) cycle time while ensuring that the work-in-process limit doesn't exceed the capacity available to process the work. This article shares experiences regarding the role architecture plays in lean software management practices. Release plans that give as much emphasis to architecturally significant tasks as to feature-based high-priority functionality can achieve better outcomes by avoiding conditions that lead to wasted time and effort. The application of lean software development practices can improve with better practical guidance on how to manage architecture flow as well as feature flow.","1937-4194","","10.1109/MS.2012.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6226344","software engineering management;lean software management;flow management;release planning;software architecture;waste","Computer architecture;Product life cycle management;Programming;Productivity;Agile manufacturing;Software management;Software architecture","software architecture;software development management;workflow management software","flow management;software development;software architecture;work in process;cycle time;lean software management;release plan;feature-based high priority functionality","","16","","12","","26 Jun 2012","","","IEEE","IEEE Magazines"
"Understanding How Companies Interact with Free Software Communities","J. M. Gonzalez-Barahona; D. Izquierdo-Cortazar; S. Maffulli; G. Robles",Universidad Rey Juan Carlos; Bitergia; OpenStack; Universidad Rey Juan Carlos,"IEEE Software","3 Sep 2013","2013","30","5","38","45","When free, open source software development communities work with companies that use their output, it's especially important for both parties to understand how this collaboration is performing. The use of data analytics techniques on software development repositories can improve factual knowledge about performance metrics.","1937-4194","","10.1109/MS.2013.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6560081","Software analytics;Software measurement;Electronic mail;Open source software;Statistics;computing milieu;software analytics;process metrics;measurement;software engineering;statistics","Software analytics;Software measurement;Electronic mail;Open source software;Statistics","data analysis;public domain software;software metrics","free software communities;open source software development communities;data analytics techniques;software development repositories;software performance metrics","","22","","9","","16 Jul 2013","","","IEEE","IEEE Magazines"
"Agile Practices: The Impact on Trust in Software Project Teams","O. McHugh; K. Conboy; M. Lang","National University of Ireland Galway; Australian School of Business, Sydney; National University of Ireland Galway","IEEE Software","20 Apr 2012","2012","29","3","71","76","Agile software development involves self-managing teams that are empowered and responsible for meeting project goals in whatever way they deem suitable. Managers must place more trust in such teams than they do in teams following more traditional development methodologies. The authors highlight how the use of agile practices can enhance trust amongst agile team members. They also present challenges that agile teams can face as a result of using agile practices. Their results are based on the findings from three case studies of agile software development teams.","1937-4194","","10.1109/MS.2011.118","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6007124","agile methodology;agile practice;daily stand-up;planning;retrospective;trust;culture;distributed software engineering","Planning;Software;Programming;Interviews;Business;Delay;Cultural differences","project management;software management;software prototyping;team working","agile software development;self-managing team;agile team member;software project team;agile practice;trust impact","","44","","13","","1 Sep 2011","","","IEEE","IEEE Magazines"
"SASSY: A Framework for Self-Architecting Service-Oriented Systems","D. Menasce; H. Gomaa; s. Malek; J. Sousa",George Mason University; George Mason University; George Mason University; George Mason University,"IEEE Software","20 Oct 2011","2011","28","6","78","85","Making architectural decisions manually in the presence of quality-of-service trade-offs can be complicated. The SASSY (Self-architecting Software Systems) framework automatically generates candidate software architectures and selects the one that best serves stakeholder-defined, scenario-based quality-of-service (QoS) goals. This lets domain experts concentrate on functional and QoS requirements. SASSY reduces the effort of composing service-oriented systems by automatically generating the QoS-optimized architecture and rapidly reconfiguring it at runtime. Self-architecting occurs during initial system deployment and at runtime, thus making systems self-adaptive, self-healing, self-managing, and self-optimizing.","1937-4194","","10.1109/MS.2011.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5696721","software architectures;QoS;quality of service;service-oriented systems;software engineering","Computer architecture;Quality of service;Service oriented architecture;Software systems;Adaptation model","quality of service;service-oriented architecture","SASSY;self-architecting software systems;self-architecting service-oriented systems;architectural decisions;quality-of-service trade-offs","","70","","13","","20 Jan 2011","","","IEEE","IEEE Magazines"
"Refactoring for Asynchronous Execution on Mobile Devices","D. Dig",Oregon State University,"IEEE Software","28 Oct 2015","2015","32","6","52","61","To improve responsiveness, developers often use asynchronous programming. In the post-PC era, asynchronous programming is even more in demand because mobile and wearable devices have limited resources and access the network excessively. One current development task is refactoring long-running, blocking synchronous code (for example, accessing the Web, a cloud, a database, or a file system) into nonblocking asynchronous code. This article describes the refactorings that improve responsiveness, along with the obstacles of using asynchrony. It also discusses the challenges of retrofitting asynchrony and presents program analyses and transformations and a growing, practical toolset and resources for retrofitting asynchrony. This article is part of a special issue on Refactoring.","1937-4194","","10.1109/MS.2015.133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310985","refactoring;asynchronous programming;program analysis and transformation;Asynchronizer;AsyncFixer;AsyncDroid;Asyncifier;software engineering;software development","Reactive power;Graphical user interfaces;Mobile communication;Programming profession;Androids;Humanoid robots;Code refractoring","mobile computing;wearable computers","asynchronous execution refactoring;mobile devices;asynchronous programming;post-PC era;wearable devices;synchronous code blocking;Web access;nonblocking asynchronous code;retrofitting asynchrony;program analyses","","6","1","14","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Improving Digital Game Development with Software Product Lines","A. W. B. Furtado; A. L. M. Santos; G. L. Ramalho; E. S. de Almeida",Federal University of Pernambuco; Federal University of Pernambuco; Federal University of Pernambuco; Federal University of Bahia,"IEEE Software","18 Aug 2011","2011","28","5","30","37","Introducing reuse and software product line (SPL) concepts into digital game-development processes isn't a straightforward task. This work presents a systematic process for bridging SPLs to game development, culminating with domain-specific languages and generators streamlined for game subdomains. The authors present a game SPL for arcade games as a case study to illustrate and evaluate their proposed guidelines. This article is part of a special issue on games.","1937-4194","","10.1109/MS.2011.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984795","digital games development;domain-specific languages;software product lines;software;software engineering","Software development;Product development;Software design;Computer architecture;Unified modeling language;Feature extraction;Games","computer games;software development management;software reusability;specification languages","digital game development;software product lines;software reusability;domain-specific languages;arcade games","","12","","13","","18 Aug 2011","","","IEEE","IEEE Magazines"
"The Architect's Role in Community Shepherding","D. A. Tamburri; R. Kazman; H. Fahimi",Politecnico di Milano; University of Hawaii; CGI,"IEEE Software","28 Oct 2016","2016","33","6","70","79","Software architects don't just design architecture components or champion architecture qualities; they often must guide and harmonize the entire community of project stakeholders. The community-shepherding aspects of the architect's role have been gaining attention, given the increasing importance of complex ""organizational rewiring"" scenarios such as DevOps, open source strategies, transitions to agile development, and corporate acquisitions. In these scenarios, architects would benefit by having effective models to align communities with architectures. This article discusses the ""smells"" indicating that a community isn't functioning efficiently, offers a set of mitigations for those smells, and provides an overview of community types.","1937-4194","","10.1109/MS.2016.144","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725222","software architecture shepherds;software organizational structure;software communities;software community smells;software social debt;social debt management;architectural social debt;software engineering;software development","Computer architecture;Software architecture;Cultural differences;Professional aspects","organisational aspects;software architecture;software quality","community shepherding;software architects;architecture component design;architecture qualities;project stakeholders;organizational rewiring","","23","","16","","28 Oct 2016","","","IEEE","IEEE Magazines"
"The rise and fall of the Chaos report figures","J. Eveleens; C. Verhoef","VU University, Amsterdam; VU University, Amsterdam","IEEE Software","31 Dec 2009","2010","27","1","30","36","This paper presents the chaos report figures that are often used to indicate problems in application software development project management, the reports contain major flaws.","1937-4194","","10.1109/MS.2009.154","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5232804","chaos report;standish group;forecasting;project success;software;software engineering","Chaos;Application software;Project management","chaos;project management;software management","chaos report figures;application software development management;project management","","117","","16","","4 Sep 2009","","","IEEE","IEEE Magazines"
"Is It Worth Responding to Reviews? Studying the Top Free Apps in Google Play","S. McIlroy; W. Shang; N. Ali; A. E. Hassan","Queen's University, Canada; Concordia University, Montreal; Queen's University, Canada; Queen's University, Canada","IEEE Software","15 May 2017","2017","34","3","64","71","Up to this point, researchers have not explored the value of responding to user reviews of mobile apps. An analysis of reviews and responses for 10,713 of the top apps in Google Play showed that few developers responded to reviews. However, responding can have positive effects. Users changed their ratings 38.7 percent of the time following a response, with a median rating increase of 20 percent.","1937-4194","","10.1109/MS.2015.149","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7325189","mobile apps;Google Play;software development;software engineering;user reviews","Google;Mobile communication;Crawlers;Data mining;Social network services;Computer crashes","information analysis;mobile computing;public domain software","free apps;Google Play;mobile apps;mobile app developer response;mobile app reviews","","10","","21","","11 Nov 2015","","","IEEE","IEEE Magazines"
"Mutation Testing Cost Reduction Techniques: A Survey","M. P. Usaola; P. R. Mateo",University of Castilla-La Mancha; University of Castilla-La Mancha,"IEEE Software","19 Apr 2010","2010","27","3","80","86","From the research perspective, mutation is a mature testing technique that has often shown its value for evaluating both software and software testing techniques. However, to the best of our knowledge, there's an important gap between its current research status and the possibilities of adopting it for the industrial world, owing to its high costs.","1937-4194","","10.1109/MS.2010.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452149","testing and debugging;testing strategies;testing tools;software engineering","Genetic mutations;Costs;Software testing","cost reduction;program testing","mutation testing cost reduction techniques;mature testing technique;testing techniques","","44","","30","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Environmental Modeling for Automated Cloud Application Testing","L. Zhang; X. Ma; J. Lu; T. Xie; N. Tillmann; P. de Halleux",Nanjing University; Nanjing University; Nanjing University; North Carolina State University; Microsoft Research; Microsoft Research,"IEEE Software","20 Feb 2012","2012","29","2","30","35","Platforms such as Windows Azure let applications conduct data-intensive cloud computing. Unit testing can help ensure high-quality development of such applications, but the results depend on test inputs and the cloud environment's state. Manually providing various test inputs and cloud states is laborious and time-consuming. However, automated test generation must simulate various cloud states to achieve effective testing. To address this challenge, a proposed approach models the cloud environment and applies dynamic symbolic execution to generate test inputs and cloud states. Applying this approach to open-source Azure cloud applications shows that it can achieve high structural coverage.","1937-4194","","10.1109/MS.2011.158","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095493","cloud computing;software testing;dynamic symbolic execution;cloud environment model;software engineering","Testing;Cloud computing;Open source software;Computational modeling;Computer applications","cloud computing;program testing","environmental modeling;automated cloud application testing;data-intensive cloud computing;automated test generation;dynamic symbolic execution;open-source Azure cloud application","","17","1","1","","6 Dec 2011","","","IEEE","IEEE Magazines"
"Examining the Relationship between FindBugs Warnings and App Ratings","H. Khalid; M. Nagappan; A. E. Hassan",Shopify; Rochester Institute of Technology; Queen's University,"IEEE Software","23 Jun 2016","2016","33","4","34","39","In the mobile-app ecosystem, user ratings of apps (a measure of user perception) are extremely important because they correlate strongly with downloads and hence revenue. A case study examined the relationship between ratings (and the associated review comments) and static-analysis warnings (collected using FindBugs) for 10,000 free-to-download Android apps. Three warning categories - bad practice, internationalization, and performance - were more frequent in low-rated apps and corresponded to the review comment complaints. Thus, these categories were closely related to the user experience. These results suggest that app developers could use static-analysis tools to identify the bugs behind the issues that users complain about, before releasing an app.","1937-4194","","10.1109/MS.2015.29","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7006337","mobile apps;static analysis;user ratings;software quality assurance;FindBugs;Android;software engineering;software development","Ecosystems;Androids;Humanoid robots;Computer bugs;Software development;Mobile communication;Computer applications","mobile computing;program diagnostics","FindBugs warnings;app ratings;mobile-app ecosystem;static-analysis warnings;free-to-download Android apps;warning categories;low-rated apps;user experience;static-analysis tools","","20","","10","","12 Jan 2015","","","IEEE","IEEE Magazines"
"Decision-Centric Architecture Reviews","U. van Heesch; V. Eloranta; P. Avgeriou; K. Koskimies; N. Harrison",University of Groningen; Tampere University of Technology; University of Groningen; Tampere University of Technology; Utah Valley University,"IEEE Software","28 Feb 2014","2014","31","1","69","76","Architecture evaluation is an important activity in the software engineering life cycle that ensures that the architecture satisfies stakeholders' expectations. Additionally, risks and issues can be uncovered before they cause tremendous costs later in the life cycle. Unfortunately, architecture evaluation isn't regularly practiced in industry. This article presents DCAR (decision-centric architecture review), an architecture evaluation method that uses architecture decisions as first-class entities. DCAR uncovers and evaluates the rationale behind the most important architecture decisions, considering the entire context in which the decisions were made. Furthermore, it's lightweight and can be performed during or after the design is finalized. Experiences in large industrial projects have shown that full-scale DCAR evaluations, including reporting, can be conducted in fewer than five person-days, while producing satisfying results for the stakeholders.","1937-4194","","10.1109/MS.2013.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6449237","software architecture;software quality;knowledge representation","Computer architecture;Software architecture;Context awareness;Documentation;Databases;Product life cycle management","software architecture","decision-centric architecture reviews;software engineering life cycle;architecture evaluation method;architecture decisions;industrial projects;full-scale DCAR evaluations","","23","","9","","4 Feb 2013","","","IEEE","IEEE Magazines"
"A Large-Scale Empirical Study on Software Reuse in Mobile Apps","I. J. Mojica; B. Adams; M. Nagappan; S. Dienst; T. Berger; A. E. Hassan",McAfee; École Polytechnique de Montréal; Queen's University; University of Leipzig; University of Waterloo; Queen's University,"IEEE Software","17 Mar 2014","2014","31","2","78","86","In less than five years, the number of mobile apps has grown exponentially, with more than 1 million available in the largest mobile app stores. One explanation for this growth could be the adoption of well-proven software engineering practices--in particular, software reuse despite the often conjectured lack of training among mobile app developers. A study of hundreds of thousands of Android apps across 30 different categories found substantial software reuse, indicating that while these apps benefit from increased productivity, they're also more dependent on the quality of the apps and libraries that they reuse.","1937-4194","","10.1109/MS.2013.142","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6663589","software reuse;mobile apps;Android","Mobile communication;Smart phones;Software reusability;Large-scale systems;Androids;Humanoid robots;Next generation networking;Mobile computing;Computer applications","Android (operating system);mobile computing;software libraries;software quality;software reusability","software reuse;mobile app stores;software engineering practices;mobile app developers;Android apps;app quality;library quality","","54","","17","","13 Nov 2013","","","IEEE","IEEE Magazines"
"Assisted Assignment of Automotive Safety Requirements","L. d. S. Azevedo; D. Parker; M. Walker; Y. Papadopoulos; R. E. Araújo",University of Hull; University of Hull; University of Hull; University of Hull; University of Porto,"IEEE Software","28 Feb 2014","2014","31","1","62","68","ISO 26262, a functional-safety standard, uses Automotive Safety Integrity Levels (ASILs) to assign safety requirements to automotive-system elements. System designers initially assign ASILs to system-level hazards and then allocate them to elements of the refined system architecture. Through ASIL decomposition, designers can divide a function's safety requirements among multiple components. However, in practice, manual ASIL decomposition is difficult and produces varying results. To overcome this problem, a new tool automates ASIL allocation and decomposition. It supports the system and software engineering life cycle by enabling users to efficiently allocate safety requirements regarding systematic failures in the design of critical embedded computer systems. The tool is applicable to industries with a similar concept of safety integrity levels.","1937-4194","","10.1109/MS.2013.118","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6594996","functional safety;ISO 26262;ASIL decomposition;ASIL automation;ASIL;Automotive Safety Integrity Levels;HiP-HOPS","Hazards;Resource management;ISO standards;Automotive engineering;Batteries;Software quality","automobiles;embedded systems;ISO standards;road safety;safety systems;safety-critical software;traffic engineering computing","automotive safety requirements;ISO 26262;functional-safety standard;automotive safety integrity levels;assisted assignment;automotive-system elements;system-level hazards;system architecture;manual ASIL decomposition;software engineering life cycle;critical embedded computer system design;safety integrity levels;systematic failures","","26","","11","","10 Sep 2013","","","IEEE","IEEE Magazines"
"Experiences in Improving Flight Software Development Processes","R. K. Kandt",Jet Propulsion Laboratory,"IEEE Software","17 Apr 2009","2009","26","3","58","64","In 2001, the Jet Propulsion Laboratory (JPL) initiated a software process improvement effort. In 2004, JPL began the Multimission System Architecture Platform (MSAP) project and designated it as part of this effort. In 2007, JPL's Engineering and Science Directorate, which controls the MSAP project's technical development, achieved CMMI Staged Maturity Level 3.1 This article describes the impacts of the CMMI rating and the JPL process improvement effort on the MSAP project's software engineering and assurance organizations.","1937-4194","","10.1109/MS.2009.66","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814959","software process improvement;software quality assurance","Programming;Software testing;System testing;Embedded software;Aerospace engineering;Systems engineering and theory;Design engineering;Hardware;Failure analysis;Documentation","aerospace computing;software process improvement","flight software development processes;Jet Propulsion Laboratory;software process improvement;software engineering","","7","","8","","17 Apr 2009","","","IEEE","IEEE Magazines"
"Sharing Satellite Observations with the Climate-Modeling Community: Software and Architecture","D. J. Crichton; C. A. Mattmann; L. Cinquini; A. Braverman; D. Waliser; M. Gunson; A. F. Hart; C. E. Goodale; P. Lean; J. Kim","NASA Jet Propulsion Laboratory; NASA Jet Propulsion Laboratory; NASA Jet Propulsion Laboratory; NASA Jet Propulsion Laboratory; NASA Jet Propulsion Laboratory; NASA Jet Propulsion Laboratory; NASA Jet Propulsion Laboratory; NASA Jet Propulsion Laboratory; University of Reading; University of California, Los Angeles","IEEE Software","21 Aug 2012","2012","29","5","73","81","The disparate communities of climate modeling and remote sensing are finding economic, political, and societal benefit from the direct comparisons of climate model outputs to satellite observations, using these comparisons to help tune models and to provide ground truth in understanding the Earth's climate processes. In the context of the Intergovernmental Panel on Climate Change (IPCC) and its upcoming 5th Assessment Report (AR5), the authors have been working with principals in both communities to build a software infrastructure that enables these comparisons. This infrastructure must overcome several software engineering challenges, including bridging heterogeneous data file formats and metadata formats, transforming swath-based remotely sensed data into globally gridded datasets, and navigating and aggregating information from the largely distributed ecosystem of organizations that house these climate model outputs and satellite data. The authors' focus in this article is on the description of software tools and services that meet these stringent challenges, and on informing the broader communities of climate modelers, remote sensing experts, and software engineers on the lessons learned from their experience so that future systems can benefit and improve upon their existing results.","1937-4194","","10.1109/MS.2012.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6133265","distributed applications;evolving Internet applications;domain-specific architectures","Meteorology;Distributed databases;Software development;Data models;Remote sensing;Computational modeling;Internet;Satellite communication","artificial satellites;climate mitigation;ecology;environmental science computing;meta data;remote sensing;satellite navigation;service-oriented architecture;software tools","satellite observations sharing;climate-modeling community;remote sensing experts;societal benefit;economic benefit;political benefit;Earth climate processes;intergovernmental panel on climate change;IPCC;5th assessment report;AR5;software infrastructure;software engineering challenges;heterogeneous data file formats;metadata formats;swath-based remotely sensed data;globally gridded datasets;information aggregation;information navigation;distributed ecosystem;climate model;satellite data;software tools;software services","","10","","9","","17 Jan 2012","","","IEEE","IEEE Magazines"
"The Dimension Architecture: A New Approach to Resource Access","W. Kern; C. Silberbauer; C. Wolff",Landesamt für Finanzen; Competence Center Software Engineering; University of Regensburg,"IEEE Software","19 Aug 2010","2010","27","5","74","81","An important task for almost every software application is I/O. For instance, database applications and even simple applications supporting configuration files-all use I/O. Consequently, accessing and manipulating resources is essential to most software systems. A new resource access approach separates various aspects such as address, content format, and location type to enable their flexible and configurable combination.","1937-4194","","10.1109/MS.2010.128","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551017","software architecture;I/O;resource acquisition;resource access;dimension architecture","Production facilities;Resource management;Software architecture;Cryptography","object-oriented methods;software architecture","dimension architecture;resource access;content format;software application;software systems","","","","14","","19 Aug 2010","","","IEEE","IEEE Magazines"
"The Business Goals Viewpoint","P. Clements; L. Bass","Carnegie Mellon University, Pittsburgh; Carnegie Mellon University, Pittsburgh","IEEE Software","14 Oct 2010","2010","27","6","38","45","A business goals viewpoint can help capture precise, unambiguous business goals, which in turn helps architects design systems that are more responsive to organizational needs. There are reasons other than cost reduction for improving business processes. A business goal expresses why a system is being developed at all, and what stakeholders in the developing organization, the customer organization, and beyond aspire to achieve through its production and use.","1937-4194","","10.1109/MS.2010.116","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5518755","business goals;business goals viewpoint;software architecture;business goals scenario","Databases;Computer architecture;Production systems;Software engineering;Feedback;Documentation;Costs;Remuneration;Thermostats","business data processing;cost reduction;organisational aspects;software architecture","business goal;system design;organizational need;cost reduction;business process;stakeholder;customer organization","","6","","10","","23 Jul 2010","","","IEEE","IEEE Magazines"
"How to Avoid Selecting Bids Based on Overoptimistic Cost Estimates","M. Jorgensen","Simula Res. Lab., Oslo","IEEE Software","17 Apr 2009","2009","26","3","79","84","This article documents important connections between cost overruns and bidding. It also recommends how clients should design their bidding process to avoid selecting bids based on overoptimistic cost estimates. The recommendations provided reduce the risk of initiating projects that have unrealistic plans, time overruns, low software quality, high maintenance costs, and inflexible providers. Although this article aims to improve the clients' bidding processes, the authos believes that it also has important implications for software providers. They could use the reported results to identify bidding rounds that they're likely to win only if they provide a bid based on strongly overoptimistic cost estimates. Software providers should consider carefully whether it's worthwhile to participate in bidding rounds in which this is the case.","1937-4194","","10.1109/MS.2009.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814964","cost estimation;bidding processes;provider selection;software acquisition","Uncertainty;Programming;Cost function;Context awareness;Writing;Proposals;Software engineering;Project management","software cost estimation;software maintenance","overoptimistic cost estimates;bidding;software quality;maintenance costs;software providers","","7","","15","","17 Apr 2009","","","IEEE","IEEE Magazines"
"Specification Inference Using Systematic Reverse-Engineering Methodologies: An Automotive Industry Application","M. Shahbaz; K. C. Shashidhar; R. Eschbach",University of Sheffield; Max Planck Institute for Software Systems; ITK Engineering AG,"IEEE Software","22 Oct 2012","2012","29","6","62","69","Lack of precise specification is a well-known problem in the software industry. This article covers some peculiar aspects of the problem and its causes in the automotive software industry. The authors describe how the situation motivates engineers to grasp reverse-engineering methodologies to comprehend third-party components. They developed a novel approach for reverse-engineering components, which they applied to a recent project on testing embedded systems of a modern vehicle.","1937-4194","","10.1109/MS.2011.159","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6112742","software reverse engineering;system analysis;model inference;system integration;system specification","Software engineering;Automotive engineering;Embedded systems;Reverse engineering;System analysis and design;Modeling","automobile industry;DP industry;formal specification;inference mechanisms;program testing;reverse engineering;road vehicles","specification inference;systematic reverse-engineering methodology;automotive software industry application;third-party components;modern vehicle embedded system testing","","2","","11","","27 Dec 2011","","","IEEE","IEEE Magazines"
"Contemporary Peer Review in Action: Lessons from Open Source Development","P. Rigby; B. Cleary; F. Painchaud; M. Storey; D. German","Concordia University, Montreal, Canada; University of Victoria, Canada; Department of National Defence, Canada; University of Victoria, Canada; University of Victoria, Canada","IEEE Software","22 Oct 2012","2012","29","6","56","61","Do you use software peer reviews? Are you happy with your current code review practices? Even though formal inspection is recognized as one of the most effective ways to improve software quality, many software organizations struggle to effectively implement a formal inspection regime. Open source projects use an agile peer review process-based on asynchronous, frequent, incremental reviews that are carried out by invested codevelopers-that contrasts with heavyweight inspection processes. The authors describe lessons from the OSS process that transfer to proprietary software development. They also present a selection of popular tools that support lightweight, collaborative, code review processes and nonintrusive metric collection.","1937-4194","","10.1109/MS.2012.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6148202","software quality;software peer review;inspection;agile development;open source software development","Software quality;Agile manufacturing;Programming;Electronic mail;Software engineering;Software development","DP industry;formal verification;inspection;public domain software;software quality;software reviews","contemporary peer review;open source development;software peer reviews;code review practices;software quality;software organizations;formal inspection regime;open source projects;agile peer review process;invested codevelopers;heavyweight inspection processes;OSS process;proprietary software development;lightweight review process;collaborative review process;code review process;nonintrusive metric collection","","57","","15","","7 Feb 2012","","","IEEE","IEEE Magazines"
"iUCP: Estimating Interactive-Software Project Size with Enhanced Use-Case Points","N. Nunes; L. Constantine; R. Kazman",University of Madeira; University of Madeira; University of Hawaii,"IEEE Software","23 Jun 2011","2011","28","4","64","73","An empirical study shows that estimations based on a modified use-case-point method exhibit less interestimator variance than those based on the original method.","1937-4194","","10.1109/MS.2010.111","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5499458","design tools and techniques. distribution;maintenance;enhancement. usability testing","Software engineering;Unified modeling language;Life estimation;Human computer interaction;User centered design;Interactive systems;Cost benefit analysis;Feedback;Data mining","project management;software development management;statistical analysis;user centred design;user interfaces","use-case-point method;interestimator variance;interactive-software project size;project size estimation;iUCP;interactive use-case point","","6","","12","","1 Jul 2010","","","IEEE","IEEE Magazines"
"Safety-Critical Software [Guest editors' introduction]","X. Larrucea; A. Combelles; J. Favaro",Tecnalia; inspearit Group; Intecs SpA,"IEEE Software","18 Apr 2013","2013","30","3","25","27","We live in a world in which our safety depends on software-intensive systems. This is the case for the aeronautic, automotive, medical, nuclear, and railway sectors as well as many more. Organizations everywhere are struggling to find cost-effective methods to deal with the enormous increase in size and complexity of these systems, while simultaneously respecting the need to ensure their safety. Consequently, we're witnessing the ad hoc emergence of a renewed discipline of safety-critical software systems development as a broad range of software engineering methods, tools, and frameworks are revisited from a safety-related perspective. The rise of these complex, critical systems has spawned several recent initiatives to promote reuse, both of the technical artifacts and the artifacts and procedures that certify their suitability for use in safety-related contexts. One unmistakable trend is a strong interest in applying model-driven engineering techniques to safety-critical systems development over the entire life cycle.","1937-4194","","10.1109/MS.2013.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6504883","safety critical;model based;certification;security","Special issues and sections;Software development;Certification;Computer security;Product life cycle management;Safety;Software reliabiilty","","","","6","","","","18 Apr 2013","","","IEEE","IEEE Magazines"
"You Are What You Read","P. Kruchten",University of British Columbia,"IEEE Software","24 Feb 2009","2009","26","2","10","11","Given that useful knowledge in software engineering has a half-life of about five years, reading remains an excellent way to replenish this vanishing resource for the diligent software engineer.","1937-4194","","10.1109/MS.2009.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786944","software literacy;reading;book;magazine;journal;fieldstone;dormouse","Books;Materials;Software;Probability density function;Feeds;Data mining;Unified modeling language","","","","","","1","","24 Feb 2009","","","IEEE","IEEE Magazines"
"The Business Rules Approach and Its Effect on Software Testing","T. O. Meservy; C. Zhang; E. T. Lee; J. Dhaliwal",University of Memphis; University of Memphis; University of Memphis; University of Memphis,"IEEE Software","10 Aug 2012","2012","29","4","60","66","Codification and testing of business rules in application programs has historically been a challenge in software engineering. Many organizations have adopted the business rules approach to formalize and compartmentalize business rules as a separate component from application code. This article investigates and presents the effects of the business rules approach on testing activities in the software development life cycle at a Fortune 500 corporation. The findings suggest that the business rules approach has the potential to engage testing personnel early in the development process and to improve the efficiency and effectiveness of testing activities.","1937-4194","","10.1109/MS.2011.120","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6030868","middleware/business logic;representations;rule-based processing;testing strategies","Programming;Software testing;Software development;Encoding;Testing;Best practices","","","","4","","11","","29 Sep 2011","","","IEEE","IEEE Magazines"
"Software is Driving Software Engineering?","G. Hurlburt; J. Voas",STEMCorp; National Institute of Standards and Technology,"IEEE Software","29 Dec 2015","2016","33","1","101","104","We're living in a physical world that's moving at the speed of software. This means that software's trajectory will drive software engineering, not vice versa. However, software engineering is also driven by visionary corporate leaders, backed by skilled software developers. This article is part of a special issue on the Future of Software Engineering.","1937-4194","","10.1109/MS.2016.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367983","software engineering;software development;SWEBOK;Software Engineering Body of Knowledge;SWEBOK Guide;Guide to the Software Engineering Body of Knowledge;software engineers","Software engineering;Professional aspects;Software development","professional aspects;software engineering","software engineering;physical world;software trajectory","","","","9","","29 Dec 2015","","","IEEE","IEEE Magazines"
"How Best to Teach Global Software Engineering? Educators Are Divided","S. Beecham; T. Clear; D. Damian; J. Barr; J. Noll; W. Scacchi","Lero; Auckland University of Technology; University of Victoria; Ithaca College; Lero; University of California, Irvine","IEEE Software","16 Jan 2017","2017","34","1","16","19","Pioneering educators discuss how they inject realism into global-software-engineering education.","1937-4194","","10.1109/MS.2017.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819407","global software engineering;GSE;global-software-engineering education;GSE-Ed;global software development;GSD;software education;software development;software engineering","Computer science education;Education courses;Software engineering","computer science education;software engineering","global-software-engineering education","","16","","3","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Brazil and the Emerging Future of Software Engineering","C. d. O. Melo; R. Ferraz; R. J. Parsons",ThoughtWorks Latin America; ThoughtWorks; ThoughtWorks,"IEEE Software","29 Dec 2015","2016","33","1","45","47","Claudia Melo, Ronaldo Ferraz, and Rebecca Parsons from ThoughtWorks share their views of software engineering's future from a Brazilian perspective. This invited essay is part of a special issue on the Future of Software Engineering.","1937-4194","","10.1109/MS.2016.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368013","software engineering;software development;ThoughtWorks;Brazil","Software engineering;Brazil;Software development;Market opportunties","software engineering","Brazil;ThoughtWorks;software engineering future","","2","","2","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Putting the Engineering into Software Engineering Education","J. Offutt",George Mason University,"IEEE Software","3 Jan 2013","2013","30","1","96","96","Based on over 20 years of teaching and research experience, the author provides his assessment of software engineering education. He then builds on the analysis to provide recommendations on how we need to diverge from computer science to increase our impact, gain credibility, and ultimately ensure the success and recognition of our young discipline. A key behind the author's message is that we need to become a true engineering discipline.","1937-4194","","10.1109/MS.2013.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401119","teaching paradigm;scientific discipline;software engineering education","Computer engineering education;Software engineering;Engineering education","computer science education;software engineering;teaching","software engineering education;teaching;research experience;computer science;gain credibility;engineering discipline","","7","","4","","3 Jan 2013","","","IEEE","IEEE Magazines"
"The Future of Software Engineering","F. Shull; A. Carleton; J. Carriere; R. Prikladnicki; D. Zhang",Software Engineering Institute; Software Engineering Institute; Google; Pontificia Universidade Catolica do Rio Grande do Sul; Microsoft Research,"IEEE Software","29 Dec 2015","2016","33","1","32","35","This special issue offers a range of perspectives on software engineering's future from professionals working around the world in diverse areas of software. The content ranges from detailed technical articles about the research areas behind today's trends to shorter essays and opinion pieces from folks working to sharpen the focus of their own visions of that future. The Web extra at https://youtu.be/LnSHGDl9O7U is an audio recording of st Shull and Anita Carleton of the Software Engineering Institute and Rafael Prikladnicki of Pontificia Universidade Catolica do Rio Grande do Sul talking about the authors, articles, and discussions that went into the IEEE Software January/February 2016 theme issue on the future of software engineering.","1937-4194","","10.1109/MS.2016.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367988","software engineering;software development;China;Brazil;requirements engineering;crowdsourcing;sustainability;technical debt;app stores;big data;massive systems","Special issues and sections;Software engineering;Software architecture;Software development","","","","1","","4","","29 Dec 2015","","","IEEE","IEEE Magazines"
"The Case for Context-Driven Software Engineering Research: Generalizability Is Overrated","L. Briand; D. Bianculli; S. Nejati; F. Pastore; M. Sabetzadeh",University of Luxembourg; University of Luxembourg; University of Luxembourg; University of Luxembourg; University of Luxembourg,"IEEE Software","22 Sep 2017","2017","34","5","72","75","For software engineering research to increase its impact and steer our community toward a more successful future, it must foster context-driven research. Such research focuses on problems defined in collaboration with industrial partners and is driven by concrete needs in specific domains and development projects.","1937-4194","","10.1109/MS.2017.3571562","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048656","context-driven software engineering;context-driven research;software engineering;software development","","groupware;software engineering","context-driven software engineering;industrial partner collaboration","","13","","1","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Software Engineering for Internet Computing: Internetware and Beyond [Guest editors' introduction]","A. Bertolino; M. B. Blake; P. Mehra; H. Mei; T. Xie",Italian National Research Council; University of Miami; SanDisk; Peking University; University of Illinois at Urbana-Champaign,"IEEE Software","4 Feb 2015","2015","32","1","35","37","Software engineering for Internet computing involves the architecting, development, deployment, management, and quality assurance of software supporting Internet-based systems. It also addresses global-development issues such as communication complexity, distributed control, governance policies, and cultural differences. This issue presents a selection of exciting and representative research on this topic. The Web extra at http://youtu.be/UA7rLAwFbwY is an audio recording in which author IEEE Software Multimedia Editor Davide Falessi interviews Antonia Bertolino, Hong Mei, and Tao Xie, guest editors of the magazine's January/February 2015 issue on Software Engineering for Internet Computing: Internetware and Beyond.","1937-4194","","10.1109/MS.2015.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030224","software engineering;Internet computing;Internetware;Internet of Things;wireless sensor networks;service choreographies;smartphone applications;cloud APIs;software diversification;cloud computing","Special issues and sections;Software engineering;Internet computing;Cloud computing;Smart phones;Software engineering;Wireless sensor networks;Computer applications","Internet;software architecture;software management;software quality","software engineering;Internet computing;Internetware;software architecture;software development;software deployment;software management;software quality assurance;Internet-based systems;global-development issues","","7","","11","","4 Feb 2015","","","IEEE","IEEE Magazines"
"Four Thought Leaders on Where the Industry Is Headed","A. Moore; T. O'Reilly; P. D. Nielsen; K. Fall",Carnegie Mellon University; O'Reilly Media; Software Engineering Institute (SEI); Carnegie Mellon University,"IEEE Software","29 Dec 2015","2016","33","1","36","39","Four software engineering thought leaders offer challenging, thought-provoking ideas about where our industry is headed. They discuss challenges for software engineers to keep their skill set current and tout the promise of new technologies to advance our field. These invited essays are part of a special issue on the Future of Software Engineering.","1937-4194","","10.1109/MS.2016.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368019","software development;software engineering;formal methods;new technologies;Code for America;e-government;agile development;autonomous systems","Interviews;Software development;Autonomous systems;Software engineering;Technological innovation","software engineering","software engineering","","4","","2","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Bringing the Human Factor to Software Engineering","L. Fernando Capretz",Western University,"IEEE Software","17 Mar 2014","2014","31","2","104","104","The human aspects involved in the software development process are vital to a successful completion of a software project. The author advocates for human factor topics to be part of mainstream software engineering education in order to elevate job satisfaction, improve performance, and increase productivity of software engineers. Emphasis should be on providing a practical overview of software engineering processes from a human perspective, offering alternative viewpoints within technically saturated curricula.","1937-4194","","10.1109/MS.2014.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774355","human factors;soft skills;software psychology","Software development;Human factors;Software engineering","computer science education;human factors;software engineering","human factor;software development process;software project completion;mainstream software engineering education;software engineers productivity;human perspective;job satisfaction;performance improvement","","6","","","","17 Mar 2014","","","IEEE","IEEE Magazines"
"Déjà Vu: The Life of Software Engineering Ideas","H. Erdogmus",Kalemun Research,"IEEE Software","31 Dec 2009","2010","27","1","2","5","The story of software engineering since the label came into use is thus a story of compromise among generality and specificity, heuristics and formalism, procedures and data, sequence and cycle. The practical response was combination and accommodation-covering all bases or splitting the difference, synthesizing complementary approaches or accommodating inescapable trade-offs. Pragmatists argued for mixed strategies of testing and proving, the use of tailored reliability models and development environments, the use of a full set of metrics, and the synthesis of life-cycle models. But while seizing the middle ground appeared to be a practical way to cope with difficulties, it seemed unlikely to produce a revolution. If software technologists are nowadays devoting more effort to engaging in a pragmatic fashion with the complexity of their problems, it is to their credit. That is symptomatic of maturity and of real engineering.","1937-4194","","10.1109/MS.2010.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370754","software engineering;maturation;innovation;adoption","Software engineering;Life testing","software metrics;software reliability","software engineering idea;tailored reliability model;software life-cycle model;software technologist;software metrics","","2","","","","31 Dec 2009","","","IEEE","IEEE Magazines"
"Software Engineering for the Internet of Things","X. Larrucea; A. Combelles; J. Favaro; K. Taneja",Tecnalia; inspearit; Intecs; Google,"IEEE Software","16 Jan 2017","2017","34","1","24","28","No consolidated set of software engineering best practices for the Internet of Things (IoT) has yet emerged. Too often, the landscape resembles the Wild West, with unprepared programmers putting together IoT systems in ad hoc fashion and throwing them out into the market, often poorly tested. In addition, the academic sector is in danger of fragmenting into specialized, often unrelated research areas. This IEEE Software theme issue aims to help provide the basis for a set of best practices that will guide the industry through the challenges of software engineering for the IoT","1937-4194","","10.1109/MS.2017.28","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819384","Internet of Things;IoT;cyber-physical systems;software engineering;software development;model-based software engineering;scalability","Special issues and sections;Software engineering;Internet of things;Best practices;Cyber-physical systems;Software development;Scalability","","","","20","","16","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Search Based Software Engineering: Introduction to the Special Issue of the IEEE Transactions on Software Engineering","M. Harman; A. Mansouri",NA; NA,"IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","737","741","","1939-3520","","10.1109/TSE.2010.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5644735","","Special issues and sections;Search engines;Search problems;Search methods","","","","21","","22","","29 Nov 2010","","","IEEE","IEEE Journals"
"The Tragedy of Defect Prediction, Prince of Empirical Software Engineering Research","M. Lanza; A. Mocci; L. Ponzanelli",Università della Svizzera italiana; Università della Svizzera italiana; Università della Svizzera italiana,"IEEE Software","28 Oct 2016","2016","33","6","102","105","If measured by the number of published papers, defect prediction has become an important research field over the past decade, with many researchers continuously proposing novel approaches to predict defects in software systems. However, most of these approaches have had a noticeable lack of impact on industrial practice. This lack of impact is because something is intrinsically wrong in how defect prediction approaches are evaluated.","1937-4194","","10.1109/MS.2016.156","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725218","defect prediction;empirical software engineering research;software engineering research;software engineering;software development;software defects;software bugs","","software fault tolerance","empirical software engineering research;software system defect prediction","","16","","5","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Guest Editor's Introduction: International Conference on Software Engineering","J. M. Atlee; P. Inverardi",NA; NA,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","3","4","The papers in this special section contain extended versions of selected papers from the 31st ACM/IEEE International Conference on Software Engineering (ICSE), held 20-22 May 2009 in Vancouver, British Columbia, Canada.","1939-3520","","10.1109/TSE.2012.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141071","","Special issues and sections;Meetings;Software engineering","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"Guest Editors' Introduction: 2008 Conference on the Foundations of Software Engineering","G. C. Murphy; W. Schafer",NA; NA,"IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","591","592","The four papers in this special section are extended versions of selected papers from the 16th ACM International Symposium on the Foundations of Software Engineering, held in Atlanta, Georgia, 11-13 November 2008.","1939-3520","","10.1109/TSE.2010.88","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5593044","","Special issues and sections;Meetings;Software engineering","","","","","","45","","30 Sep 2010","","","IEEE","IEEE Journals"
"Guest Editors' Introduction: Software Engineering for Compliance","U. Zdun; A. Bener; E. L. Olalia-Carin",University of Vienna; Ryerson University; KPMG Canada,"IEEE Software","20 Apr 2012","2012","29","3","24","27","This special issue of IEEE Software explores the challenges in developing compliant software systems. Typically, organizations face conflicting objectives, with compliance policies possibly hindering innovation, slowing down the product development process, or making the whole process most costly. The goal of software engineering for compliance is to bridge the gap between the software engineering community and the compliance community. The articles in this special issue explain the nature and extent of this domain from different viewpoints, the technical challenges it poses, novel software engineering methods for supporting compliance, and the current state of the art.","1937-4194","","10.1109/MS.2012.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188599","software engineering;compliance;regulations;laws;business","Special issues and sections;Software engineering","","","","3","","13","","20 Apr 2012","","","IEEE","IEEE Magazines"
"Embracing the Engineering Side of Software Engineering","L. Briand",University of Luxembourg,"IEEE Software","10 Aug 2012","2012","29","4","96","96","The author provides, based on 20 years of research and industrial experience, his assessment of software engineering research. He then builds on such analysis to provide recommendations on how we need to change as a research community to increase our impact, gain credibility, and ultimately ensure the success and recognition of our young discipline. The gist of the author's message is that we need to become a true engineering discipline.","1937-4194","","10.1109/MS.2012.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6265086","software engineering research;research paradigm;scientific discipline","Software engineering;Research and development","","","","22","","","","10 Aug 2012","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: End-User Software Engineering","A. J. Ko; R. Abraham; M. M. Burnett; B. A. Myers",University of Washington; Microsoft; Oregon State University; Carnegie Mellon University,"IEEE Software","25 Aug 2009","2009","26","5","16","17","Millions of people program to support their work but don't call themselves programmers. The field of end-user software engineering is concerned with helping these people create reliable, dependable, and reusable programs, without distracting them from their primary tasks. This special issue of IEEE Software presents a selection of research from this field, providing a glimpse of some of the exciting advances made in past 10 years of research and development.","1937-4194","","10.1109/MS.2009.129","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222788","software engineering;reliability;end-user programming","Software engineering;Enterprise resource planning;Computer science;Debugging;Software design;Computer languages;Contacts;Programming profession;Management training;Risk management","","","","6","","1","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Docker [Software engineering]","C. Anderson",NA,"IEEE Software","23 Apr 2015","2015","32","3","102","c3","In episode 217 of Software Engineering Radio, host Charles Anderson talks with James Turnbull, a software developer and security specialist who's vice president of services at Docker. Lightweight Docker containers are rapidly becoming a tool for deploying microservice-based architectures.","1937-4194","","10.1109/MS.2015.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093032","Docker;SE Radio;Software Engineering Radio;James Turnbull;microservices;Docker containers","Interviews;Virtual machining;Software engineering;Software development","","","","56","","","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Software Engineering for the Cloud","J. Grundy; G. Kaefer; J. Keung; A. Liu",Swinburne University of Technology; Siemens AG; Hong Kong Polytechnic University; National ICT Australia,"IEEE Software","20 Feb 2012","2012","29","2","26","29","Cloud computing is a new paradigm for software systems where applications are divided into sets of composite services hosted on leased, highly distributed platforms. There are many new software engineering challenges in building effective cloud-based software applications. This special issue provides a set of practical contributions to the engineering of cloud computing applications and includes software processes, architecture and design approaches, testing, scalability engineering, security engineering, and applications of highly parallel cloud-based systems.","1937-4194","","10.1109/MS.2012.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155142","software engineering for cloud computing;software testing;software architecture;scalability;parallel processing","Special issues and sections;Cloud computing;Software engineering;Computer architecture","","","","6","","","","20 Feb 2012","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Cooperative and Human Aspects of Software Engineering","C. R. B. de Souza; H. Sharp; J. Singer; L. Cheng; G. Venolia","Federal University of Pará, Brazil; The Open University, UK; National Research Council of Canada; IBM Center for Social Software; Microsoft Research","IEEE Software","16 Oct 2009","2009","26","6","17","19","Software is developed by people, used by people, and supports interaction among people. As such, human characteristics and cooperation are central to modern practical software construction. While human aspects were recognized as important over 30 years ago, recent changes in the software domain have made cooperative and human aspects of software engineering even more significant. This special issue of IEEE Software presents a sample of current research in this field illustrating the wide variety of approaches, software domains and activities in which human and cooperative aspects are being investigated.","1937-4194","","10.1109/MS.2009.176","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5287004","human aspects;cooperative aspects;social aspects;cooperation;coordination;collaborative software engineering.","Humans;Software engineering","","","","16","","5","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Responses to ""Software Engineering: An Idea Whose Time Has Come and Gone?""","",,"IEEE Software","25 Aug 2009","2009","26","5","5","5","The section features excerpts of letters responding to Tom DeMarco's article ""Software Engineering: An Idea Whose Time Has Come and Gone?"" (July/Aug., pp. 96, 95).","1937-4194","","10.1109/MS.2009.136","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222783","software engineering;Tom DeMarco;software metrics","Software engineering;Biomedical imaging;DICOM;Standardization;Medical diagnostic imaging;Computer industry;Open source software;Software tools;Surgery;Manufacturing","","","","","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Crowdsourcing for Software Engineering","K. Stol; T. D. LaToza; C. Bird",Lero-the Irish Software Research Centre; George Mason University; Microsoft Research,"IEEE Software","28 Mar 2017","2017","34","2","30","36","Crowdsourcing, which leverages the intelligence and contributions of a large group of people to achieve a specific goal, is disrupting business models and work practices. Because crowdsourcing approaches could have a far-reaching impact on future software development, this theme issue explores various ways developers and managers can benefit from these new opportunities. The Web Extra https://youtu.be/Z_8vWQjU7iY is an audio podcast of the introduction to the theme issue on crowdsourcing for software engineering.","1937-4194","","10.1109/MS.2017.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888402","crowdsourcing;software development;software engineering;requirements engineering;requirements elicitation;Stack Overflow;GitHub;crowdsourced software testing;CrowdSummarizer;code summaries;Java;App Store 2.0;mobile apps","Special issues and sections;Crowdsourcing;Software engineering;Business;Information analysis","crowdsourcing;software engineering","crowdsourcing;software engineering;business models;work practices;software development;audio podcast","","12","","19","","28 Mar 2017","","","IEEE","IEEE Magazines"
"How Abundance Changes Software Engineering","D. Spinellis",Athens University of Economics and Business,"IEEE Software","15 May 2017","2017","34","3","4","7","The abundance of processing power is changing the nature of software engineering. By reducing the cost of failure, abundance changes how developers use computing technologies. Also, abundance changes the developer's role by moving the focus from technology to management. This article also contains an erratum. In ""App Store 2.0: From Crowdsourced Information to Actionable Feedback in Mobile Ecosystems"" (DOI: 10.1109/MS.2017.46) from the Mar./Apr. 2017 issue, in the fifth line of the second column on p. 83, ""see sia"" should be ""see Figure 2a.""","1937-4194","","10.1109/MS.2017.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927929","processing power;software engineering;software development","","software development management;software reliability","software engineering;software failure;computing technologies;software management","","","","","","15 May 2017","","","IEEE","IEEE Magazines"
"Leaders of Tomorrow on the Future of Software Engineering: A Roundtable","F. Hermans; J. Siegmund; T. Fritz; G. Bavota; M. Nagappan; A. Hindle; Y. Kamei; A. Mesbah; B. Adams",Delft University of Technology; University of Passau; University of Zurich; Free University of Bozen-Bolzano; Rochester Institute of Technology; University of Alberta; Kyushu University; University of British Columbia; Polytechnique Montréal,"IEEE Software","26 Feb 2016","2016","33","2","99","104","Nine rising stars in software engineering describe how software engineering research will evolve, highlighting emerging opportunities and groundbreaking solutions. They predict the rise of end-user programming, the monitoring of developers through neuroimaging and biometrics sensors, analysis of data from unstructured documents, the mining of mobile marketplaces, and changes to how we create and release software.","1937-4194","","10.1109/MS.2016.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420475","end-user programming;neuroimaging;biometrics;unstructured documents;mobile marketplaces;software engineering;software development","","software engineering","software engineering;end-user programming;neuroimaging;biometrics sensors;data analysis;unstructured documents;mobile marketplace mining","","3","","9","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Improving Timeliness and Visibility in Publishing Software Engineering Research","M. B. Dwyer",NA,"IEEE Transactions on Software Engineering","13 Mar 2017","2017","43","3","205","206","Reports on initiatives to improve and enhance the IEEE Transactions on Software Engineering. ","1939-3520","","10.1109/TSE.2017.2663918","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7876880","","","","","","","","","","13 Mar 2017","","","IEEE","IEEE Journals"
"Getting an Intuition for Big Data","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","26 Jun 2013","2013","30","4","3","6","IEEE Software Editor-in-Chief Forrest Shull discusses the importance of building reliable systems to interpret big data. In addition, he discusses the IBM Impact 2013 Unconference; the Software Engineering Institute's SATURN 2013 conference in which the IEEE Software Architecture in Practice Award went to Simon Brown of Coding the Architecture, for his presentation titled ""The Conflict between Agile and Architecture: Myth or Reality"" and the IEEE Software New Directions Award went to Darryl Nelson of Raytheon for his presentation titled, ""Next-Gen Web Architecture for the Cloud Era."" He also welcomes Professor Rafael Prikladnicki of the Computer Science School at PUCRS, Brazil, and Chief Software Economist Walker Royce of IBM's Software Group to the IEEE Software Advisory Board. The first Web extra at http://youtu.be/JrQorWS5m6w is a video interview in which IEEE Software editor in chief Forrest Shull speaks with Paul Zikopoulos, Director--IBM Information Management Technical Professionals, Competitive Database, and Big Data at IBM, about the potentials of mining big data. Zikopoulos will deliver a keynote at Software Experts Summit 2013 on 17 July in Redmond, Washington. The second Web extra at http://youtu.be/NHHThAeONv8 is a video interview in which IEEE Software editor in chief Forrest Shull speaks with Catherine Plaisant and Megan Monroe of the University of Maryland Human-Computer Interaction Laboratory about big data information visualization and its applications to software development. The third Web extra at http://youtu.be/NqXE0ewoTKA is a video overview of the IBM Impact 2013 Unconference, sponsored by IEEE Software magazine, an event specifically designed for developers that featured Grady Booch and Tim O'Reilly as keynote speakers.","1937-4194","","10.1109/MS.2013.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547604","big data;smart data;reliability;software;interpret;interpretation;intuition;IBM;Impact;Unconference;Software Engineering Institute;SEI;Saturn;conference;Rafael Prikladnicki;Walker Royce;application;research;practice;practical;software engineering;software development","","data mining","big data interpretation;IEEE software;IBM Impact 2013 Unconference;IEEE Software Architecture in Practice Award;Software Engineering Institute;big data mining","","3","","","","26 Jun 2013","","","IEEE","IEEE Magazines"
"The Future of Chinese Software Development","Z. Tang; M. Yang; J. Xiang; J. Liu",Tuniu.com; Tujia.com; Secoo.com; Gridsum Technology,"IEEE Software","29 Dec 2015","2016","33","1","40","44","Four chief technology officers from Chinese software companies share their thoughts of their industry's fast growth and their experiences dealing with the technical challenges of software development for massive-scale systems and services. These invited essays are part of a special issue on the Future of Software Engineering.","1937-4194","","10.1109/MS.2016.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368024","China;software development;software engineering;Tunio.com;Tujia.com;Secoo.com;Gridsum Technology;massive-scale systems;big data;Internet;e-commerce","Interviews;China;Software development;Big data;E-commerce","software engineering","Chinese software development;Chinese software companies;massive-scale systems;massive-scale services;Future of Software Engineering","","","","4","","29 Dec 2015","","","IEEE","IEEE Magazines"
"The Only Constant Is Change","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","3 Sep 2013","2013","30","5","4","9","IEEE Software editor-in-chief Forrest Shull discusses the magazine's recent editorial board meeting and some of the discussions the group had about where software development is headed, including refactoring and reengineering, technical debt, measurement, cloud computing, user experiences, and effective project management. In addition, he describes the recent Software Experts Summit 2013, which focused on smart data science and the International Conference on Software Engineering's Software Engineering in Practice award, selected by IEEE Software. The first Web extra at http://youtu.be/BRioqQenavA is a video interview in which John Howie of the Cloud Security Alliance expands on his talk at Software Experts Summit 2013 ""Big Data: Answering Questions and Solving Society's Problems, but at What Cost?"" The second Web extra at http://youtu.be/6jm8mZTQsnw is a video interview in which Microsoft's James Whittaker expands on his talk at Software Experts Summit 2013 (SES13) about the future of the Web and search. The third Web extra at http://youtu.be/aCypdSuCDQs is a video interview in which IEEE Software editor in chief Forrest Shull speaks with Jane Cleland-Huang of DePaul University about the Software Engineering in Practice Award at the International Conference on Software Engineering 2013, presented by IEEE Software.","1937-4194","","10.1109/MS.2013.115","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6588533","refactoring;reengineering;technical debt;measurement;cloud computing;user experience;project management;software experts summit;ses;international conference on software engineering;ses;software engineering in practice award;ieee software;software;research;practice;practical;software engineering;software development","","","","","","","","","3 Sep 2013","","","IEEE","IEEE Magazines"
"Three Experts on Big Data Engineering","C. Szyperski; M. Petitclerc; R. Barga",Microsoft; IBM Canada; Amazon Web Services,"IEEE Software","26 Feb 2016","2016","33","2","68","72","Clemens Szyperski (Microsoft), Martin Petitclerc (IBM), and Roger Barga (Amazon Web Services) answer three questions: What major challenges do you face when building scalable, big data systems? How do you address these challenges? Where should the research community focus its efforts to create tools and approaches for building highly reliable, scalable, big data systems? This article is part of a special issue on Software Engineering for Big Data Systems.","1937-4194","","10.1109/MS.2016.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420462","big data;software engineering;software development;Clemens Szyperski;Martin Petitclerc;Roger Barga","","Big Data;software engineering","Big Data engineering;Microsoft;IBM;Amazon Web services;scalable Big Data systems;research community;software engineering","","2","","","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Editorial: Journal-First Publication for the Software Engineering Community","M. B. Dwyer; D. S. Rosenblum",NA; NA,"IEEE Transactions on Software Engineering","7 Jan 2016","2016","42","1","1","1","Presents the introductory editorial for this issue of the publication.","1939-3520","","10.1109/TSE.2015.2500318","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7374796","","","","","","","","","","7 Jan 2016","","","IEEE","IEEE Journals"
"Connecting and Serving the Software Engineering Community","M. B. Dwyer; E. Bodden; B. Fitzgerald; M. Kim; S. Kim; A. J. Ko; E. Mendes; R. Mirandola; A. Moreira; F. Shull; S. Siegel; T. Xie; C. Zhang",NA; NA; NA; NA; NA; NA; NA; NA; NA; NA; NA; NA; NA,"IEEE Transactions on Software Engineering","11 Mar 2016","2016","42","3","203","280","Presents an editorial discusses the current status and activities supported by this publication.","1939-3520","","10.1109/TSE.2016.2532379","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7432058","","","","","","","","","","11 Mar 2016","","","IEEE","IEEE Journals"
"When Software Crosses a Line","L. Hatton; M. van Genuchten",Oakwood Computing Associates; VitalHealth,"IEEE Software","29 Dec 2015","2016","33","1","29","31","The debacle with the VW ""defeat device"" raises some unsettling questions. Are any other companies doing this, or-if we take a more cynical standpoint-how many are doing this? If they aren't, are they still using software practices almost as dubious? How do we decide what's reasonable, given software's extraordinary ability to give hardware its character?","1937-4194","","10.1109/MS.2016.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368030","software engineering;software development;VW;defeat device;VW diesel engine","Software engineering;Software development;Companies;Design methodology;Automobile industry;Diesel engines;Maintenance engineering","software engineering","VW defeat device;software practices;software ability","","5","","7","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Then a Miracle Occurs","G. Booch",IBM,"IEEE Software","30 Jun 2015","2015","32","4","12","14","Developing software-intensive systems is like many other things, but it's also like no other thing. For the general public, how software is made remains a mystery. The Web extra at https://youtu.be/yVYDwatEpQc is an audio podcast of Grady Booch's On Computing column, in which he discusses how developing software-intensive systems is like many other things, but it's also like no other thing. And for the general public, how software is made remains a mystery.","1937-4194","","10.1109/MS.2015.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140683","software engineering;computing;history","Software development;Software engineering","Internet;software engineering","computing column;Web;software-intensive system","","","","7","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Software-Engineering the Internet of Things","D. Spinellis",NA,"IEEE Software","16 Jan 2017","2017","34","1","4","6","New wiring transformed ENIAC into a versatile stored-program computer. Rewiring Internet of Things infrastructures into a general-purpose computing fabric can similarly change how modern computation interfaces with our environment.","1937-4194","","10.1109/MS.2017.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819398","Internet of Things;IoT;ENIAC;software engineering;software development","","","","","4","","","","16 Jan 2017","","","IEEE","IEEE Magazines"
"The Practice and Future of Release Engineering: A Roundtable with Three Release Engineers","B. Adams; S. Bellomo; C. Bird; T. Marshall-Keim; F. Khomh; K. Moir",Polytechnique Montréal; Software Engineering Institute; Microsoft Research; Software Engineering Institute; Polytechnique Montréal; Mozilla,"IEEE Software","10 Mar 2015","2015","32","2","42","49","Three release engineers share their perspectives on quality metrics for releases and on continuous delivery's benefits and limitations. They also discuss release-engineering job skills, the required mind-set, the role of education, and cultural change, and they recommend future research areas. The Web extra at http://youtu.be/O3cJQTZXAI8 is an audio recording of Davide Falessi speaking with Guest Editors Bram Adams and Foutse Khomh about release engineering and its value to the software industry.","1937-4194","","10.1109/MS.2015.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057611","release engineering;software engineering;continuous delivery;software development","Special issues and sections;Interviews;Software development;Continuous production;Software engineering","","","","9","","","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Jürgen Laartz and Alexander Budzier on Why Large IT Projects Fail","R. Blumen",SalesForce Desk.com,"IEEE Software","23 Jun 2016","2016","33","4","117","120","Software Engineering Radio host Robert Blumen speaks to Jürgen Laartz and Alexander Budzier about their joint research on large-IT-project failures.","1937-4194","","10.1109/MS.2016.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498545","Software Engineering Radio;IT;project failures;black swan;software engineering;software development","Interviews;Software engineering;Software development;Information technology;Project management;Failure analysis","","","","","","","","23 Jun 2016","","","IEEE","IEEE Magazines"
"Technical Debt","E. Wolff; S. Johann",innoQ; Trifork Amsterdam,"IEEE Software","30 Jun 2015","2015","32","4","94","c3","In Episode 224 of Software Engineering Radio, Eberhard Wolff and Sven Johann discuss technical debt and how to handle it.","1937-4194","","10.1109/MS.2015.95","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140698","SE radio;Software Engineering Radio;Eberhard Wolff;Sven Johann;technical debt;software engineering","Software development;Software engineering;Software reliability","","","","","","","","30 Jun 2015","","","IEEE","IEEE Magazines"
"The Modern Cloud-Based Platform","S. Tilkov",innoQ,"IEEE Software","10 Mar 2015","2015","32","2","116","116","In this excerpt from Software Engineering Radio, Stefan Tilkov talks with Adrian Cockcroft about architecture, development, and operations that make the most out of cloud-based offerings, with Cockcroft sharing his experience at Netflix.","1937-4194","","10.1109/MS.2015.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057614","continuous delivery;DevOps;cloud;PaaS;platform as a service;infrastructure;windows;software engineering;SE Radio;Software Engineering Radio;Adrian Cockcroft","Software engineering;Continuous production;Software development","","","","4","","","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Software Quality, Energy Awareness, and More","J. C. Carver; A. Yamashita; L. Minku; M. Habayeb; S. A. Kocak",University of Alabama; Yamashita Research; University of Leicester; Ryerson University; Ryerson University,"IEEE Software","28 Oct 2015","2015","32","6","98","100","This article discusses six papers presented at events connected with the 2015 International Conference on Software Engineering. The papers cover organizational factors and software quality, microclones, big data platforms, energy-aware commits, open source software architecture, and requirements engineering.","1937-4194","","10.1109/MS.2015.127","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7311003","software engineering;ICSE;2015 International Conference on Software Engineering;organizational factors;software quality;microclones;big data;energy-aware commits;open source software architecture;requirements engineering;last-line effect;PVS-Studio;Requirements Engineering for Sustainability;RE4S;software development","Software quality;Software engineering;Organizational aspects;Software architecture","","","","","","","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Software Engineering for the Internet of Things","",,"IEEE Software","26 Feb 2016","2016","33","2","c3","c3","Advertisement. IEEE.","1937-4194","","10.1109/MS.2016.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420463","","","","","","","","","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Lightweight and Flexible: Emerging Trends in Software Architecture from the SATURN Conferences","M. Keeling",IBM,"IEEE Software","23 Apr 2015","2015","32","3","7","11","Over its 10-year history, the annual Software Engineering Institute (SEI) Architecture Technology User Network (SATURN) conference has become a barometer for the ever-evolving software architecture climate. This article summarizes some software architecture trends that emerged during SATURN 2014 and gives a glimpse of the future based on the current SATURN 2015 technical program.","1937-4194","","10.1109/MS.2015.65","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093052","SATURN;Software Engineering Institute (SEI) Architecture Technology User Network Conference;software architecture;software development;software engineering","","software architecture","SATURN conferences;Software Engineering Institute Architecture Technology User Network;software architecture climate;SATURN 2014;SATURN 2015 technical program","","3","","8","","23 Apr 2015","","","IEEE","IEEE Magazines"
"The Clock Is Ticking","F. Shull",Software Engineering Institute of Carnegie Mellon University,"IEEE Software","21 Apr 2014","2014","31","3","4","8","IEEE Software Editor-in-Chief Forrest Shull discusses his tenure and looks at the initiatives during this time. He also welcomes Robert Blumen as department editor for Software Engineering Radio and puts out a call for more hosts to contribute to the Software Engineering Radio podcast interviews.","1937-4194","","10.1109/MS.2014.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6802990","editor in chief;IEEE software;podcast;new media;digital edition;initiatives;mission;experience reports;comments;volunteer;objective;software;development;software engineering;radio;se radio","","","","","","","1","","21 Apr 2014","","","IEEE","IEEE Magazines"
"Keeping Ahead of Our Adversaries","J. Cleland-Huang; T. Denning; T. Kohno; F. Shull; S. Weber",DePaul University; University of Utah; University of Washington; Software Engineering Institute; Software Engineering Institute,"IEEE Software","25 Apr 2016","2016","33","3","24","28","Every software system is potentially vulnerable in ways that aren't always imagined during development. White-collar crime involving data breaches are rampant, and governments are investigating the potential for terrorist attacks on power grids, airplanes, and other public services. Technology is a double-edged blade: although computers let us pursue ever-more-impressive innovations, we're likewise subjected to growing possibilities for abuse. So, how do we build secure products that are hardened against adversarial attacks? The article provides a look at this topic.","1937-4194","","10.1109/MS.2016.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458755","threat analysis;software requirements;software security;Security Cards;implantable cardioverter-defibrillator;ICD;software development;software engineering","","security of data","software security;software development;white-collar crime;adversarial attacks","","3","","7","","25 Apr 2016","","","IEEE","IEEE Magazines"
"The True Cost of Mobility?","F. Shull",Software Engineering Institute of Carnegie Mellon University,"IEEE Software","17 Mar 2014","2014","31","2","5","9","IEEE Software Editor-in-Chief Forrest Shull discusses privacy implications for mobile and cloud computing with the John Howie, chief operating officer of the Cloud Security Alliance. He also looks at the upcoming Software Experts Summit scheduled for 30 May 2014 in Bangalore, India, and discusses the 200th episode of Software Engineering Radio. The Web extra at http://youtu.be/12w2q6BirV8 is an audio interview in which IEEE Software editor-in-chief Forrest Shull discusses the privacy implications of mobile and cloud computing with John Howie, chief operating officer of the Cloud Security Alliance.","1937-4194","","10.1109/MS.2014.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774335","smart phones;mobile computing;privacy;cloud;cloud computing;software experts summit;ses;software engineering;radio;se radio","","","","","1","","","","17 Mar 2014","","","IEEE","IEEE Magazines"
"Engineering Values: From Architecture Games to Agile Requirements","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","25 Feb 2013","2013","30","2","2","6","IEEE Software Editor-in-Chief Forrest Shull discusses the importance of having and applying professional principles in all facets of software development while also keeping them in perspective. He cites work by Philippe Kruchten, Ellen Gottesdiener and Mary Gorman to support his position. In addition, he welcomes Dr. Adam Welc to the IEEE Software Editorial Board and discusses the 2012 African Conference on Software Engineering and Applied Computing. The first Web extra at http://youtu.be/R5zUHUFEB7k is an audio interview of IEEE Software editor-in-chief Forrest Shull speaking with Ellen Gottesdiener and Mary Gorman about requirements management in an agile context. The second Web extra at http://youtu.be/SSO6td0xzkI is an audio interview of IEEE Software editor-in-chief Forrest Shull speaking with Philippe Kruchten about how software engineers can be misled by their own cognitive biases, falacial reasoning, and the games architects and requirements managers play.","1937-4194","","10.1109/MS.2013.27","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6470583","engineering values;principles;values;bias;Philippe Kruchten;Ellen Gottesdiener;Mary Gorman;Adam Welc;ASEAC;African Conference on Software Engineering and Applied Computing","","game theory;professional aspects;software architecture;software prototyping","engineering values;architecture games;agile requirements;professional principles;software development;cognitive biases;falacial reasoning","","","","","","25 Feb 2013","","","IEEE","IEEE Magazines"
"I Believe!","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","22 Dec 2011","2012","29","1","4","7","Many studies have shown that important factors and key relationships often don't hold up well when transferred from one project to another. To deal with this seeming lack of global truisms in software engineering, it helps to develop a healthy skepticism and find ways to test our beliefs in key development practices against measures collected within the project context.","1937-4194","","10.1109/MS.2012.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111358","effort prediction;defect prediction;empirical software engineering","","","","","1","","4","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Perspectives [The changing nature of software evolution; The inevitability of evolution]","B. Boehm; K. Beck",University of Southern California; Three Rivers Institute,"IEEE Software","14 Jun 2010","2010","27","4","26","29","Summary form only given. Traditionally, software evolution took place after software development put a system in place. However, the pace of change in technology and competition has changed the nature of software evolution to a continuous process, in which there's no neat boundary between development and evolution. Many traditional software development assumptions and practices haven't recognized this changing nature and increasingly find themselves in deep trouble as a result. Minimizing development costs by adopting numerous off-the-shelf products often leads to unaffordable evolution costs as vendors ship new releases and stop supporting the old ones. Assuming that a single form of evolutionary development covers all situations often leads to unrealistic commitments and dead-end systems as situations change.","1937-4194","","10.1109/MS.2010.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5484112","software evolution;software engineering;software change;development","Programming;Costs;Lead;Marine vehicles","software engineering","software evolution;software development;off-the-shelf software products;evolutionary development","","8","","14","","14 Jun 2010","","","IEEE","IEEE Magazines"
"Looking into the Future","C. Ebert",Vector Consulting Services,"IEEE Software","28 Oct 2015","2015","32","6","92","97","Surveys of and interviews with software business leaders around the world point to success factors that will advance the software business over the next 30 years. However, the responses left unaddressed whether we evolve to Humanity 2.0-or a posthuman society.","1937-4194","","10.1109/MS.2015.142","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310986","software engineering;software development;software business","Software development;Market opportunities;Market research","social aspects of automation;software engineering","software business leaders;success factors;humanity 2.0;posthuman society","","7","","5","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Lifelong Learning for Lifelong Employment","P. Kruchten",University of British Columbia,"IEEE Software","30 Jun 2015","2015","32","4","85","87","Software engineers today must be lifelong learners or risk finding themselves out of a job, with totally obsolete skills to sell. Here are a few hints on how to tackle continuous professional development in our field.","1937-4194","","10.1109/MS.2015.97","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140693","software development;software engineering;lifelong learning;professional development","Career development;Employment;Training;Engineering education","computer science education;continuing professional development;software engineering","lifelong learning;lifelong employment;software engineers;continuous professional development in our field","","5","","3","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Barry O'Reilly on Lean Enterprises","J. Thönes",ThoughtWorks,"IEEE Software","28 Oct 2015","2015","32","6","101","104","Software Engineering Radio host Johannes Thönes and Barry O'Reilly, coauthor of Lean Enterprise: How High Performance Organizations Innovate at Scale, discuss lean enterprises. A lean enterprise is a large organization that manages to innovate while keeping its existing products in the market. The Web extra at http://www.se-radio.net/2015/08/se-radio-episode-234-barry-oreilly-on-lean-enterprise is an audio recording of Johannes Thönes talking to Barry O'Reilly, principal consultant at ThoughtWorks, about his recent book Lean Enterprise. A lean enterprise is a large organization that manages to keep innovating while keeping its existing products in the market.","1937-4194","","10.1109/MS.2015.140","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310997","lean enterprise;lean startups;three-horizons model;software development;software engineering","Interviews;Software engineering","","","","","","","","28 Oct 2015","","","IEEE","IEEE Magazines"
"The Mobile Software App Takeover","J. Voas; J. B. Michael; M. van Genuchten",NA; Naval Postgraduate School; Open Digital Dentistry,"IEEE Software","10 Aug 2012","2012","29","4","25","27","Smartphones aren't very “smart” without the software apps that give them their usability and versatility. Apps, like all software, need some degree of guidance, regulation, and measurement to ensure a user is receiving proper functionality and quality of service. This problem has existed in software engineering and software development from Day 1, and apps are no different. The void has led to a recent clamor for some way to vet apps and the app stores in which they will reside and be licensed. The guest editors of this special issue contend that this will be a huge problem for the mobile app market as it continues to grow; the articles they feature here attempt to address the challenges to come.","1937-4194","","10.1109/MS.2012.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6265078","software engineering;mobile devices;mobile apps","Special issues and sections;Mobile communication;Computer applications;Smart phones;Handheld devices;Cloud computing;Software engineering","","","","6","","2","","10 Aug 2012","","","IEEE","IEEE Magazines"
"Ben Hindman on Apache Mesos","J. Meyerson",NA,"IEEE Software","29 Dec 2015","2016","33","1","117","120","Software Engineering Radio host Jeff Meyerson talks to Ben Hindman about Apache Mesos, a kernel that abstracts away many of the hassles of managing a distributed system.","1937-4194","","10.1109/MS.2016.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367989","distributed system;abstraction;Apache Mesos;software engineering;software development","Software engineering;Distributed processing;Software development","","","","2","","","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Microservices","J. Thönes",NA,"IEEE Software","4 Feb 2015","2015","32","1","116","116","In this excerpt from Software Engineering Radio, Johannes Thönes talks with James Lewis, principal consultant at ThoughtWorks, about microservices. They discuss microservices' recent popularity, architectural styles, deployment, size, technical decisions, and consumer-driven contracts. They also compare microservices to service-oriented architecture and wrap up the episode by talking about key figures in the microservice community and standing on the shoulders of giants. The Web extra at http://www.se-radio.net/2014/10/episode-213-james-lewis-on-microservices is an audio recording of Tobias Kaatz speaking with James Lewis, principal consultant at ThoughtWorks, about microservices. They discuss microservices' recent popularity, architectural styles, deployment, size, technical decisions, and consumer-driven contracts. They also compare microservices to service-oriented architecture and wrap up the episode by talking about key figures in the microservice community and standing on the shoulders of giants.","1937-4194","","10.1109/MS.2015.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030212","architecture;enterprise service bus;http;microservice;service-oriented architecture;software engineering;SE Radio","Interviews;Software architecture;Service oriented architecture;Software engineering","","","","95","2","","","4 Feb 2015","","","IEEE","IEEE Magazines"
"Signing Off: The State of the Journal","B. Nuseibeh","Open University, UK","IEEE Transactions on Software Engineering","5 Mar 2014","2014","40","1","1","3","","1939-3520","","10.1109/TSE.2014.2298171","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6757048","","Editorials;Software engineering;Communities;Educational institutions;Software;Bibliometrics;Production","","","","","","4","","5 Mar 2014","","","IEEE","IEEE Journals"
"The Wonder Years","G. Booch",IBM,"IEEE Software","26 Jun 2013","2013","30","4","16","17","For those on the outside of the curtain of computing, there is much mystery behind the matter of software-intensive systems. To some, it looks like magic; to most, its inner workings are irrelevant in so far that it simply works. To those of us behind the curtain, however, we know that such systems are filled with chaos, regularity, and beauty. The first Web extra at http://youtu.be/HfGVE3kt8Og is an audio podcast of author Grady Booch reading his On Computing column, in which he peers behind the curtain of computing into the mystery behind software-intensive systems. To some, such systems look like magic; to most, the inner workings are irrelevant insofar that they simply work. To those of us behind the curtain, however, we know that such systems are filled with chaos, regularity, and beauty. The second Web extra at http://youtu.be/52ztwEAcmAA is a video in which Tim O'Reilly, CEO and founder of O'Reilly Media, and Grady Booch, IBM Fellow, IBM Chief Scientist for Software Engineering, and author of On Computing in IEEE Software magazine, speak with James Governor about the next stage of development of mobile apps and the focus on development practitioners prior to the IBM Impact 2013 Unconference, sponsored by IEEE Software magazine.","1937-4194","","10.1109/MS.2013.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547632","software-intensive system;mystery;education;discovery;fundamentals","","mobile computing;software engineering","software-intensive systems;software engineering;IEEE Software magazine;mobile apps development;IBM Impact 2013 Unconference","","","","","","26 Jun 2013","","","IEEE","IEEE Magazines"
"Bridging Software Communities through Social Networking","A. Begel; J. Bosch; M. Storey",Microsoft Research; Chalmers University of Technology; University of Victoria,"IEEE Software","3 Jan 2013","2013","30","1","26","28","Over the past decade, the advent of social networking has fundamentally altered the landscape of how software is used, designed, and developed. It has expanded how communities of software stakeholders communicate, collaborate, learn from, and coordinate with one another. The guest editors of this special issue describe both the field and the articles they selected for it.","1937-4194","","10.1109/MS.2013.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401112","social networking;software;communities;stakeholders;communication","Special issues and sections;Software engineering;Social network services;Software development","social networking (online);software engineering","software communities;social networking;software stakeholders","","9","","5","","3 Jan 2013","","","IEEE","IEEE Magazines"
"Hiring in the Software Industry","T. Kaatz","CSC, Germany","IEEE Software","7 Nov 2014","2014","31","6","96","96","With this episode, Software Engineering Radio begins a series of interviews on the social or nontechnical aspects of working as a software engineer. Tobias Kaatz talks to Randy Shoup, who is the former CTO at Kixeye and before that served as Google's director of engineering for its Cloud Computing Group, about hiring in the software industry. The Web extra at http://www.se-radio.net/2014/08/episode-208-randy-shoup-on-hiring-in-the-software-industry is an audio recording of Tobias Kaatz speaking with Randy Shoup, former CTO at KIXEYE, about hiring in the software industry.","1937-4194","","10.1109/MS.2014.140","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949527","Google;hiring;job interviews;Kixeye;Randy Shoup;software engineering;SE Radio","Employment;Career development;Engineering profession","DP industry;employment;software radio","hiring;software industry;software engineering radio;social aspects;nontechnical aspects;Randy Shoup;CTO;Kixeye;Cloud Computing Group;Tobias Kaatz","","","","","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Sustainability and Requirements: A Manifesto","B. Penzenstadler","California State University, Long Beach","IEEE Software","21 Aug 2015","2015","32","5","90","92","""The Karlskrona Manifesto on Sustainability Design"" is a call for discussion and action on the challenge of sustainability and its relation to software engineering. The manifesto aims to create common ground and develop a reference point for the global community of research and practice in software and sustainability. The Web extra at http://youtu.be/PXhFgswJPco is an audio podcast in which author Birgit Penzenstadler provides an audio recording of this column.","1937-4194","","10.1109/MS.2015.114","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217768","sustainability;software requirements;Karlskrona Manifesto;software design;software engineering;software development","","formal specification;sustainable development","requirements;Karlskrona Manifesto;sustainability design;software engineering","","2","","5","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Our Best Hope","F. Shull",Software Engineering Institute of Carnegie Mellon University,"IEEE Software","13 Jun 2014","2014","31","4","4","8","IEEE Software editor in chief Forrest Shull talks with author and consultant Linda Rising about the power of retrospectives for software teams. The Web extra at http://youtu.be/2Tgui-qr2AQ is an audio recording of IEEE Software editor in chief Forrest Shull talking with author and consultant Linda Rising about the power of retrospectives for software teams. The second Web extra at http://www.se-radio.net/2014/01/episode-200-markus-volter-on-language-design-and-domain-specific-languages/ is an audio recording of Markus Voelter talking to Linda Rising about retrospectives and the logistics of making them work for software projects.","1937-4194","","10.1109/MS.2014.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834710","software engineering;Linda Rising;retrospective;agile;practices;change;projects;Norman Keith","","","","","","","","","13 Jun 2014","","","IEEE","IEEE Magazines"
"The Human Element in Social Networking","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","3 Jan 2013","2013","30","1","2","6","IEEE Software Editor in Chief Forrest Shull discusses his interviews with Ben Schneiderman on the social networking site the Nation of Neighbors and with Anne Rose on the International Children's Digital Library and lessons learned from both websites on how developers can best design social networks to award volunteer appreciation, thus ensuring continued success. The first Web extra at http://youtu.be/yFG3lL6HJ38 is an audio interview of IEEE Software editor-in-chief Forrest Shull speaking with Ben Shneiderman about the Nation of Neighbors Project and lessons learned about software that supports effective social networks. The Nation of Neighbors is an ambitious program that facilitates real-time collaboration in more than 400 neighborhood communities across the United States. The second Web extra at http://youtu.be/M3R4-XLBRyE is an audio interview of IEEE Software editor-in-chief Forrest Shull speaking with Anne Rose about the International Childrens Digital Library and lessons learned about supporting effective social networks. The ICDL is visited by up to 130,000 unique users per month and relies on the efforts of an impassioned network of more than 4,000 volunteers worldwide.","1937-4194","","10.1109/MS.2013.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401105","social networks;development;software;nation of neighbors;international children's digital library;software engineering","","digital libraries;social networking (online)","human element;social networking;Nation of Neighbors;digital library;Web sites","","","","2","","3 Jan 2013","","","IEEE","IEEE Magazines"
"Looking Forward","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","21 Aug 2012","2012","29","5","2","5","Editor in chief Forrest Shull describes the decisions made at the magazine's most recent editorial board meeting and the exciting changes to come for this publication's digital edition. He also highlights winners of recent IEEE Software-sponsored awards.","1937-4194","","10.1109/MS.2012.117","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6276290","software engineering;editorial board;awards;digital publication","","","","","","","","","21 Aug 2012","","","IEEE","IEEE Magazines"
"Designing a World at Your Fingertips: A Look at Mobile User Interfaces","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","10 Aug 2012","2012","29","4","4","7","Smart mobile devices have had a huge impact on the world today with new apps being produced at a prodigious rate. How we got to this point has a lot to do with the ease of use that manufacturers and app developers have achieved, which includes aspects such as quick response time, intuitive interfaces, and well-designed functionality. To explore how this came about, IEEE Software Editor-in-Chief Forrest Shull recently spoke with Ben Shneiderman and Ben Bederson, both of whom are former directors of the University of Maryland's Human-Computer Interaction Lab (HCIL), the oldest center in the US focusing on research in HCI.","1937-4194","","10.1109/MS.2012.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6265071","software;engineering;smart phones;mobile devices;apps;functionality;interfaces;hci;human-computer interaction;lab;HCIL","","","","","1","","","","10 Aug 2012","","","IEEE","IEEE Magazines"
"A Lifetime Guarantee","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","28 Oct 2013","2013","30","6","4","8","IEEE Software editor-in-chief Forrest Shull discusses the software sustainability and his interview with Girish Seshagiri, the CEO of AIS, an organization that offers ""firm fixed-price contracting with performance guarantees, including a lifetime warranty on software defects"" in government contracts. In addition, he discusses the best paper award at the 21st Annual IEEE International Requirements Engineering Conference and the best research paper award at the Agile Conference. The first Web extra at http://youtu.be/L1XN0R4koRk is an audio interview highlighting IEEE Software editor in chief Forrest Shull's discussion with Girish Seshagiri, the CEO of AIS, about the organization's philosophy of offering ""firm fixed-price contracting with performance guarantees, including a lifetime warranty on software defects"" in government contracts. The second Web extra at http://youtu.be/iFsZlrhSM9E is the complete audio interview in which IEEE Software editor in chief Forrest Shull's speaks with Girish Seshagiri, the CEO of AIS, about the organization's philosophy of offering ""firm fixed-price contracting with performance guarantees, including a lifetime warranty on software defects"" in government contracts.","1937-4194","","10.1109/MS.2013.119","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648577","sustainability;ais;Girish Seshagiri;software quality;defects;government contracts;requirements engineering;agile;best paper ieee software;software;research;practice;practical;software engineering;software development","","","","","1","","","","28 Oct 2013","","","IEEE","IEEE Magazines"
"The Road Ahead","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","20 Dec 2010","2011","28","1","2","4","The new editor in chief of IEEE Software magazine briefly outlines his vision for the future, including items regarding new digital content and possibilities for reader-author interaction. This EIC message also contains an erratum to the Nov./Dec. 2010 article, ""Visual Tools for Software Architecture Understanding: A Stakeholder Perspective,"" by Alexandru Telea, Lucian Voinea, SolidSource BV, and Hans Sassenburg. The erratum corrects a URL in Figure 1.","1937-4194","","10.1109/MS.2011.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5672510","software;software engineering;EIC;editorial","","","","","","","","","20 Dec 2010","","","IEEE","IEEE Magazines"
"Refactoring Tools are Trustworthy Enough and Trust Must be Earned","J. Brant; F. Steimann","FernUniv. in Hagen, Hagen, Germany; Fernuniversität in Hagen","IEEE Software","28 Oct 2015","2015","32","6","80","83","In his Point essay, ""Refactoring Tools Are Trustworthy Enough,"" John Brant argues that refactoring tools that help developers work more efficiently is more important than tools that preserve behavior. In his Counterpoint essay, ""Trust Must Be Earned,"" Friedrich Steimann argues that current refactoring tools are unreliable and that developers should give their best to create refactoring tools that are correct. This article is part of a special issue on Refactoring.","1937-4194","","10.1109/MS.2015.145","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310993","refactoring;software development;software engineering","Code refractoring;Software development;Software engineering","software tools","refactoring tools;imperfect tools","","2","","","","28 Oct 2015","","","IEEE","IEEE Magazines"
"The Persistence of Memory","G. Booch",IBM,"IEEE Software","7 Nov 2014","2014","31","6","38","40","Each generation remakes itself. In the context of the historical, economic, technological, and cultural forces around it, each generation must confront, adapt, and evolve--or die; this is the nature of humankind. Still, some common threads exist that shape that evolution--threads that define our very humanity. Even in the face of the tumultuous changes brought about by computing, these threads persist and bring a poignant texture to a fully digital life. The Web extra at http://youtu.be/nsInmRVIlv0 is an audio podcast of author Grady Booch reading his On Computing column, in which he discusses how even in the face of the tumultuous changes brought about by computing, the threads that define our very humanity still persist and bring a poignant texture to a fully digital life.","1937-4194","","10.1109/MS.2014.148","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949575","software engineering;computing;commerce;architecture;history","Software engineering;Software architecture;History;Technology forecasting","","","","","","","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Remembrance of Things Past","G. Booch",NA,"IEEE Software","29 Dec 2015","2016","33","1","10","12","We live in a world of unprecedented complexity and astonishing possibility. We should never forget our past, for those who came before us in computing enabled those possibilities. The Web extra at https://youtu.be/-ovLxiHmbr0 is an audio podcast of this column.","1937-4194","","10.1109/MS.2016.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7367979","history;Alan Turing;Bletchley Park;Tommy Flowers;Grace Hopper;history of computing;women in computing;software engineering;software development","History;Computer industry;Software engineering;Turing, Alan;Codes","","","","","","7","","29 Dec 2015","","","IEEE","IEEE Magazines"
"All Watched Over by Machines of Loving Grace","G. Booch",IBM,"IEEE Software","10 Mar 2015","2015","32","2","19","21","There was a time we could only dream of machines that served as companions, as helpmates, as servants. Now, we build them. As we slowly and inevitably and irreversibly surrender to these machines of our own creation, we must come to grips with a number of practical, ethical conundrums. The Web extra at http://youtu.be/17MsuJY4Xmo is an audio podcast of author Grady Booch reading his On Computing column, in which he discusses how we must come to grips with a number of practical and ethical conundrums as machines of our own creation become our companions, helpmates, and servants.","1937-4194","","10.1109/MS.2015.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057613","software engineering;computing;ethics of computing;morality","Software engineering;Ethics","ethical aspects","ethical conundrums;Web extra;audio podcast;On Computing column;practical conundrums","","3","","7","","10 Mar 2015","","","IEEE","IEEE Magazines"
"The Top 10 Burning Research Questions from Practitioners","S. Freudenberg; H. Sharp","independent agile coach; Open University, Milton Keynes, UK","IEEE Software","19 Aug 2010","2010","27","5","8","9","A common and frequent complaint from software practitioners is that academic research doesn't meet their requirements or expectations. During XP 2010 in Trondheim this year, practitioners were asked to suggest research topics that they'd like to see addressed. Around 60 different suggestions were made. They were collected and displayed so that attendees at the conference could vote for their favorite topic, and from this we developed a prioritized backlog of research issues. This article presents the top ten issues according to the voting, discusses the range of themes across the complete set of suggestions, and poses several questions that need answering for this backlog to be processed. The Web extra is an erratum to the acknowledgments.","1937-4194","","10.1109/MS.2010.129","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551011","agile;XP 2010;research;distributed;scaling agile;software engineering;general interest and relevance","Research and development;Software engineering;Distributed processing;Technological innovation;Technology","","","","14","","","","19 Aug 2010","","","IEEE","IEEE Magazines"
"Harnessing UML for Architectural Description--the Context View","E. Woods",Artechra,"IEEE Software","7 Nov 2014","2014","31","6","30","33","This column discusses architectural descriptions and the process of representing and communicating designs and how UML is useful when creating architectural descriptions.","1937-4194","","10.1109/MS.2014.139","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949558","software engineering;UML;architecture;modeling","Unified modeling language;Context modeling;Software architecture;Software engineering;Modeling","software architecture;Unified Modeling Language","UML;architectural descriptions","","4","","3","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Code Ownership Perspectives","S. Eldh; B. Murphy",Ericsson; Microsoft Research,"IEEE Software","28 Oct 2015","2015","32","6","18","19","In the essay ""Code Ownership-a Quality Issue,"" Sigrid Eldh argues for adapting code ownership to specific situations, focusing on quality, and taking into account ownership of the test code. In the essay ""Code Ownership-More Complex to Understand Than Research Implies,"" Brendan Murphy argues for a broader and deeper analysis of code ownership.","1937-4194","","10.1109/MS.2015.141","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310992","code ownership;code quality;software quality;software development;software engineering","Code refractoring;Encoding;Software engineering;Software development","computer software;copyright","code ownership perspectives","","","","","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Developer, Debug Thyself","D. Spinellis",NA,"IEEE Software","29 Dec 2015","2016","33","1","3","5","The risks of misbehaving software have been with us for decades but are now becoming too ubiquitous to casually brush under the carpet. We must act now; otherwise, the next software scandal might take down software development as we know it.","1937-4194","","10.1109/MS.2016.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368033","Volkswagen;VW;software development;software engineering;open source;government regulation;professional ethics;diesel engines;VW diesel engine;defeat device","Software development;Companies;Software engineering;Automobile industry;Diesel engines;Maintenance engineering","","","","1","","1","","29 Dec 2015","","","IEEE","IEEE Magazines"
"New Transactions Issue Alerts","",,"IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","879","879","","1939-3520","","10.1109/TSE.2011.118","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095283","","","","","","","","","","5 Dec 2011","","","IEEE","IEEE Journals"
"Editorial","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","28 Aug 2013","2013","39","9","1187","1189","IT is my pleasure to introduce a number of distinguished researchers to the Editorial Board of IEEE Transactions on Software Engineering (TSE) this month. Their expertise covers a range of of areas that have seen consistently large numbers of submissions in recent times, and each new associate editor (AE) brings a track record of significant contributions to their field. Their short biographies are provided. Additionally, I am happy to report in the meantime that the latest journal Impact Factors have recently been published, and TSE's has risen to 2.6. It continues to be the highest of all software engineering and related journals.","1939-3520","","10.1109/TSE.2013.41","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6587460","","","","","","","","","","28 Aug 2013","","","IEEE","IEEE Journals"
"Editorial [new associate editors]","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","29 Apr 2013","2013","39","5","588","590","It is the Editor-in-Chief's (EiC's) pleasure to welcome a number of new associate editors to the editorial board of the IEEE Transactions on Software Engineering. They are: Luciano Baresi, Daniela Damian, Robert DeLine, Audris Mockus, Gail Murphy, Mauro Pezze, Gian Pietro Pico, Helen Sharp, and Paolo Tonella. They bring a wealth of expertise in a broad range of research areas within software engineering, consolidating traditional strengths in areas such as software testing, and strengthening areas such as empirical studies of software development, mobile computing, and adaptive systems. Short professional biographies are included. At the same time, the EiC would like to bid farewell to those associate editors whose terms of service have ended: Martin Robillard, Peggy Storey, and Tetsuo Tamai. He thanks them for their distinguished contributions over a number of years, and for continuing to handle submitted manuscripts already on their editorial stack.","1939-3520","","10.1109/TSE.2013.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6509892","","","","","","","","","","29 Apr 2013","","","IEEE","IEEE Journals"
"Collaborations and Code Reviews","J. C. Carver; B. Caglayan; M. Habayeb; B. Penzenstadler; A. Yamashita","University of Alabama; Ryerson University; Ryerson University; California State University, Long Beach; Yamashita Research","IEEE Software","21 Aug 2015","2015","32","5","27","29","This article discusses five papers presented at events connected with the 2015 International Conference on Software Engineering. The papers cover topics related to industry-academic collaborations and modern code review.","1937-4194","","10.1109/MS.2015.113","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217781","software engineering;industry-academic collaboration;code review;ICSE;2015 International Conference on Software Engineering;feedback cycles;changesets;ClusterChanges;software bugs","","","","","","","","","21 Aug 2015","","","IEEE","IEEE Magazines"
"James Phillips on Service Discovery","C. Anderson",NA,"IEEE Software","28 Oct 2016","2016","33","6","117","120","In this excerpt from a Software Engineering Radio podcast, James Phillips, who works on the open source service discovery tool Consul at HashiCorp, explains what service discovery is, provides use cases, and discusses available tools. You can listen to the entire interview at <url>www.se-radio.net</url>.","1937-4194","","10.1109/MS.2016.150","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725237","James Phillips;service discovery;Consul;software engineering;software development;Software Engineering Radio","Servers;IP networks;Databases;Interviews;Computer architecture;Internet","","","","","","","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Software Architecture for Developers","S. Johann",Trifork Amsterdam,"IEEE Software","21 Aug 2015","2015","32","5","93","96","In Episode 228 of Software Engineering Radio, Sven Johann and Simon Brown discuss using sketches to create and communicate software architecture.","1937-4194","","10.1109/MS.2015.125","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217764","SE radio;Software Engineering Radio;Simon Brown;Sven Johann;software architecture;C4;Software Architecture for Developers;UML;software engineering;software development","","","","","","","","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Requirements, Human Values, and the Development Technology Landscape","J. C. Carver; L. L. Minku; B. Penzenstadler","University of Alabama; University of Leicester; California State University, Long Beach","IEEE Software","16 Jan 2017","2017","34","1","13","15","This issue's column reports on papers from the 24th International Requirements Engineering Conference, 38th International Conference on Software Engineering, and the 10th International Symposium on Empirical Software Engineering and Measurement. Topics include performance and security requirements, injecting human values into software engineering, and mapping the software development technology landscape.","1937-4194","","10.1109/MS.2017.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819412","software requirements;security requirements;social engineering;sentence patterns;serious games;human values;software engineering;software development;Stack Overflow;association rule mining;natural-language processing","","","","","","","","","16 Jan 2017","","","IEEE","IEEE Magazines"
"In Memoriam: Robin Milner and Amir Pnueli","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","305","305","Provides the biographies for two members of the computing community, Robin Milner and Amir Pnueli, who recently passed away. Both were Turing Award winners and both contributed in fundamental ways to the foundations of software engineering.","1939-3520","","10.1109/TSE.2010.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473899","","Obituary;Robin Milner and Amir Pnueli","","","","","","","","27 May 2010","","","IEEE","IEEE Journals"
"elytS edoC detisiveR","",,"IEEE Software","23 Jun 2011","2011","28","4","7","8","Phillip G. Armour responds to a Tools of the Trade column by Diomidis Spinellis called ""elytS edoC"" in the March/April 2011 issue of IEEE Software, discussing the coding styles of software engineering. In another letter, Stefan Braun responds to a Letter from the Editor column by Forrest Shull called ""Perfectionists in a World of Finite Resources,"" in the March/April 2011 issue of IEEE Software, discussing the concept of technical debt in the world of software engineering.","1937-4194","","10.1109/MS.2011.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929520","software engineering;coding;technical debt;letters;IEEE Software","","","","","","","","","23 Jun 2011","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction to the Special Section on Software Language Engineering","J. Favre; D. Gasević; R. Lammel; A. Winter",NA; NA; NA; NA,"IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","737","741","The six articles in this special section are devoted to software language engineering.","1939-3520","","10.1109/TSE.2009.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353438","","History;Natural languages;Writing;Humans;Production;Food technology;Information technology;Systems engineering and theory;Software engineering;Domain specific languages","","","","3","","8","","15 Dec 2009","","","IEEE","IEEE Journals"
"Stakeholders on the Prowl","J. Cleland-Huang",DePaul University,"IEEE Software","26 Feb 2016","2016","33","2","29","31","Working with diverse stakeholders is a fact of life for any requirements engineer. And learning to bring out the best in each of them is an art acquired over time. This article shares effective stakeholder interaction techniques for solving three common problems. The Web extra at https://youtu.be/1df3HmRTbBk is an audio podcast in which author Jane Cleland-Huang provides an audio recording of the Requirements column.","1937-4194","","10.1109/MS.2016.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420494","software requirements;software engineering;agile software engineering;software development;requirements engineering;requirements elicitation","","formal specification","stakeholder interaction techniques;Web extra;requirements column","","4","","7","","26 Feb 2016","","","IEEE","IEEE Magazines"
"On Target","",,"IEEE Software","15 Sep 2014","2014","31","5","8","8","Ivan Sanchez, a student from Guayaquil, Ecuador, writes a letter thanking the editor for the continued publication of Grady Booch's columns, first On Architecture and now On Computing.","1937-4194","","10.1109/MS.2014.117","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898683","software engineering;grady booch;computing;architecture","","","","","","","","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Vaughn Vernon on Reactive Programming with the Actor Model","S. Tilkov",innoQ,"IEEE Software","25 Apr 2016","2016","33","3","109","112","Host Stefan Tilkov speaks with Vaughn Vernon, a consultant and mentor with more than 25 years' experience in software design, development, and architecture, about reactive programming and the actor model.","1937-4194","","10.1109/MS.2016.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458769","Vaughn Vernon;software development;software engineering;reactive programming;actor model;Software Engineering Radio","","","","","1","","","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Software Analytics: So What?","T. Menzies; T. Zimmermann",West Virginia University; Microsoft Research,"IEEE Software","26 Jun 2013","2013","30","4","31","37","The guest editors of this special issue of IEEE Software invited submissions that reflected the benefits (and drawbacks) of software analytics, an area of explosive growth. They had so many excellent submissions that they had to split this special issue into two volumes--you'll see even more content in the September/October issue. They divided the articles on conceptual grounds, so both volumes will feature equally excellent work. The Web extra at http://youtu.be/nO6X0azR0nw is a video interview in which IEEE Software editor in chief Forrest Shull speaks with Tim Menzies about the growing importance of software analytics.","1937-4194","","10.1109/MS.2013.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547619","software analytics;big data;analysis;metrics;measurement","Special issues and sections;Data analysis;Decision making;Data models;Software development;Software algorithms;Software engineering","program diagnostics;software engineering","software analytics;IEEE Software;explosive software growth","","68","","10","","26 Jun 2013","","","IEEE","IEEE Magazines"
"Diversity and Software Development","H. Erdogmus",National Research Council Canada,"IEEE Software","17 Apr 2009","2009","26","3","2","4","Scott E. Page's diversity framework provides useful insights regarding software engineering research, practice, and education. This editorial discusses the concepts and implications of diversity in this context.","1937-4194","","10.1109/MS.2009.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4814948","diversity;software engineering;problem solving;software estimation;regression models","Programming;Problem-solving;Predictive models;Software safety;Decision making;Economic forecasting","","","","","","","","17 Apr 2009","","","IEEE","IEEE Magazines"
"The Elusiveness of Smart Healthcare","D. Spinellis",Athens University of Economics and Business,"IEEE Software","13 Nov 2017","2017","34","6","4","6","To realize smart healthcare’s many benefits, researchers and practitioners must overcome significant hurdles. The problems they face mirror the challenges of the field of software engineering in a world gradually eaten up by software.","1937-4194","","10.1109/MS.2017.4121206","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106889","smart healthcare;software development;software engineering;From the Editor","","","","","","","","","13 Nov 2017","","","IEEE","IEEE Magazines"
"IEEE Software and Professional Development","I. Sommerville",NA,"IEEE Software","26 Feb 2016","2016","33","2","90","92","To become more relevant to both researchers and practitioners, IEEE Software should refocus and become the first place software engineers turn to for professional development in software engineering and related areas.","1937-4194","","10.1109/MS.2016.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420501","IEEE Software;software development;software engineering;professional development","","","","","","","4","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Reliability Engineering","X. Larrucea; F. Belmonte; A. Welc; T. Xie",Tecnalia; Alstom Transport; Huawei; University of Illinois at Urbana-Champaign,"IEEE Software","11 Jul 2017","2017","34","4","26","29","Reliability engineering dates back to reliability studies in the 20th century; since then, various models have been defined and used. Software engineering plays a key role from several viewpoints, but the main concern is that we're moving toward a more connected world, including enterprises and mobile devices. The three articles in this special issue illustrate current trends in this domain.","1937-4194","","10.1109/MS.2017.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974694","reliability engineering;software reliability;software reliability growth models;regression testing;safety-critical systems;state-space models;requirements engineering;fault tree analysis;failure mode and effects analysis;software engineering;software development","Special issues and sections;Reliability engineering;Safety;Mission critical systems","","","","2","","17","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Managing Montezuma: Handling All the Usual Challenges of Software Development, and Making It Fun: An Interview with Ed Beach","F. Shull",Fraunhofer Center for Experimental Software,"IEEE Software","18 Aug 2011","2011","28","5","4","7","EIC Forrest Shull interviews AI lead programmer Ed Beach to investigate the software engineering practices employed to create computer gaming software that is both high quality and fun. This interview focuses on the context of the best-selling Civilization series of games created by Firaxis Inc.","1937-4194","","10.1109/MS.2011.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984786","software engineering;artificial intelligence;computer gaming","","","","","","","","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Did 32% Waterfall Surprise You?","",,"IEEE Software","16 Jan 2017","2017","34","1","7","7","This issue's letter discusses the proper use of sampling in software engineering research surveys.","1937-4194","","10.1109/MS.2017.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819417","waterfall model;software development;software engineering;convenience sampling","","","","","","","","","16 Jan 2017","","","IEEE","IEEE Magazines"
"How Do You Keep Up to Date?","F. Shull",Fraunhofer Center for Experimental Software,"IEEE Software","25 Apr 2011","2011","28","3","2","5","Keeping up to date with new software engineering methods, practices, and tools is challenging in the best of times, and made even more urgent by today's tough economic climate. This article discusses a survey of software developers and describes high-level themes related to the types of media that were deemed useful for staying up to date. Based on these themes, some important thrusts for IEEE Software digital content are described.","1937-4194","","10.1109/MS.2011.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5756287","software engineering;survey;professional development","","","","","","","","","25 Apr 2011","","","IEEE","IEEE Magazines"
"Trends in Systems and Software Variability [Guest editors' introduction]","J. Bosch; R. Capilla; R. Hilliard",Chalmers University of Technology; Rey Juan Carlos University; consulting software systems architect,"IEEE Software","23 Apr 2015","2015","32","3","44","51","The two articles in this special section address the topic of systems and software vaiability. Variability management involves two key challenges. First, industrial reality shows that for successful platforms, the number of variation points, variants (alternatives that can be selected for a variation point), and dependencies between variation points and variants easily reaches staggering levels.","1937-4194","","10.1109/MS.2015.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093024","software variability;systems variability;software engineering;software development;software product lines;FODA;Feature-Oriented Domain Analysis;binding time;software requirements;software architecture","Special issues and sections;Software architecture;Software engineering;Software development;Analytical models;Software variability","","","","23","","28","","23 Apr 2015","","","IEEE","IEEE Magazines"
"A Decade of Enterprise Integration Patterns: A Conversation with the Authors","O. Zimmermann; C. Pautasso; G. Hohpe; B. Woolf","University of Applied Sciences of Eastern Switzerland, Rapperswil; University of Lugano; Allianz; IBM","IEEE Software","29 Dec 2015","2016","33","1","13","19","Department editors Olaf Zimmerman and Cesare Pautasso interview Gregor Hohpe and Bobby Woolf, authors of Enterprise Integration Patterns. They discuss the book's impact, pattern language design, message-oriented middleware, integration technology's evolution, and the authors' future plans.","1937-4194","","10.1109/MS.2016.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368007","Enterprise Integration Patterns;software patterns;Gregor Hohpe;Bobby Woolf;Martin Fowler;pattern languages;message-oriented middleware;integration technology;software engineering;software development","Software engineering;Software development;Middleware;Message systems;Pattern recognition","","","","4","","12","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction to the Special Section on Evaluation and Improvement of Software Dependability","K. Goseva-Popstojanova; K. Kanoun","Lane Department of Computer Science and Electrical Engineering, West Virginia University, Morgantown, WV; LAAS-CNRS, 31077 Toulouse, France","IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","306","308","The four papers in this special section present new findings on different aspects of software dependability.","1939-3520","","10.1109/TSE.2010.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473900","","Software systems;Information security;Safety;Software testing;Medical control systems;Control systems;Humans;Software quality;Availability;Airplanes","","","","1","","51","","27 May 2010","","","IEEE","IEEE Journals"
"State of the Journal","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","1","2","","1939-3520","","10.1109/TSE.2012.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141070","","","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"Guest Editors' Introduction: Special Section on the Socio-Technical Environment of Software Development Projects","M. Cataldo; K. Ehrlich; A. Mockus",NA; NA; NA,"IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","305","306","","1939-3520","","10.1109/TSE.2011.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5779016","","Special issues and sections;Software development;Social factors;Software architecture;Collaboration","","","","1","","4","","27 May 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","c4","c4","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2012.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363460","","","","","","","","","","29 Nov 2012","","","IEEE","IEEE Journals"
"Editorial: New Associate Editors Introduction","J. Kramer",NA,"IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","449","449","","1939-3520","","10.1109/TSE.2009.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5186361","","","","","","","","","","31 Jul 2009","","","IEEE","IEEE Journals"
"Editorial: What Makes a Publication Archival?","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","145","145","","1939-3520","","10.1109/TSE.2011.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5739157","","","","","","1","","","","24 Mar 2011","","","IEEE","IEEE Journals"
"E-ditorial: State of the Journal","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","24 Jan 2013","2013","39","2","145","146","","1939-3520","","10.1109/TSE.2013.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6419732","","","","","","","","","","24 Jan 2013","","","IEEE","IEEE Journals"
"Editorial: State of the Journal","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","1","3","","1939-3520","","10.1109/TSE.2011.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704236","","","","","","","","","","28 Jan 2011","","","IEEE","IEEE Journals"
"Introduction: The Best Papers of ISSTA","B. G. Ryder; A. Zeller",NA; NA,"IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","451","452","We present the best papers of the International Symposium on Software Testing and Analysis (ISSTA) 2008.","1939-3520","","10.1109/TSE.2010.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5532338","","Software testing;System testing;Sections;Electronic equipment testing;Electronic voting;Humans;Computer science;Computer industry;Security;Electronic voting systems","","","","","","","","29 Jul 2010","","","IEEE","IEEE Journals"
"Editorial","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","735","736","","1939-3520","","10.1109/TSE.2010.104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5644734","","","","","","","","","","29 Nov 2010","","","IEEE","IEEE Journals"
"State of the Journal Editorial","M. B. Dwyer",NA,"IEEE Transactions on Software Engineering","7 Jan 2015","2015","41","1","1","2","Reports on the state of the journal.","1939-3520","","10.1109/TSE.2014.2380479","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7004121","","","","","","","","","","7 Jan 2015","","","IEEE","IEEE Journals"
"Guest Editors' Introduction to the Special Issue on Quantitative Evaluation of Computer Systems","J. Hillston; M. Kwiatkowska; M. Telek",NA; NA; NA,"IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","145","147","The 10 items in this special issue focus on quantitative evaluation of computer systems.","1939-3520","","10.1109/TSE.2009.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4809711","","Stochastic processes;Performance analysis;Petri nets;Queueing analysis;Stochastic systems;Discrete event simulation;Protocols;Performance evaluation;Air traffic control;Computational modeling","","","","","","","","3 Apr 2009","","","IEEE","IEEE Journals"
"[Front inside cover]","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","c2","c2","Provides a listing of current society officers.","1939-3520","","10.1109/TSE.2012.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141069","","","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","c4","c4","Provides a listing of current society officers.","1939-3520","","10.1109/TSE.2012.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141077","","","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"Guest Editors' Introduction to the Special Section from the International Conference on Software Maintenance","G. Canfora; L. Tahvildari; H. A. Muller",NA; NA; NA,"IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","450","451","The two papers in this special section are extended and enhanced versions of ones presented at the International Conference on Software Maintenance (ICSM), held in Paris, France, on 2-5 October 2007.","1939-3520","","10.1109/TSE.2009.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5186362","","Software maintenance;Computer Society;Conferences;Computer science;Software testing;Tagging;Programming profession;Navigation;Cities and towns;Sections","","","","","","","","31 Jul 2009","","","IEEE","IEEE Journals"
"Editorial: How Special Should Issues Be?","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","449","450","","1939-3520","","10.1109/TSE.2010.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5532337","","","","","","1","","","","29 Jul 2010","","","IEEE","IEEE Journals"
"Editorial: State of the Journal Address","J. Kramer",NA,"IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","1","1","","1939-3520","","10.1109/TSE.2009.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4771848","","","","","","","","","","2 Feb 2009","","","IEEE","IEEE Journals"
"Guest Editorial: Special Section on the International Symposium on Software Testing and Analysis 2010","A. Orso; P. Tonella","Georgia Institute of Technology, 266 Ferst Drive, Atlanta, GA 30332-0765; Fondazione Bruno Kessler, Via Sommarive, 18, 38123 Povo, Trento, Italy","IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","241","242","The articles in this special section contain selected papers from the International Symposium on Software Testing and Analysis 2010.","1939-3520","","10.1109/TSE.2012.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6173077","","Special issues and section;Meetings;Software testing","","","","","","","","3 Apr 2012","","","IEEE","IEEE Journals"
"Guest Editors' Introduction: Algorithms and Today's Practitioner","G. Prencipe; C. Zavattari; A. Tommasi; J. Favaro","University of Pisa; CrowdEngineering, Pisa; CrowdEngineering, Pisa; Intecs SpA","IEEE Software","22 Dec 2011","2012","29","1","61","63","Enormous advances in computing power and programming environments have obscured the importance of algorithms, one of the foundational pillars of software engineering. Today, even university curricula too often pay only lip service to the teaching of algorithmic fundamentals, reinforcing the popular belief that their place at the core of a software engineer's education is past. Yet even today, the importance of algorithms in software engineering has not diminished, and the effects of neglect are evident everywhere in needlessly inefficient industrial applications. The study of algorithms must regain its rightful place of central importance in the everyday work of today's practitioner.","1937-4194","","10.1109/MS.2012.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6111366","algorithm;software;efficiency;complexity","Special issues and sections;Software algorithms;Internet;Software engineering;Data structures","","","","","","","","22 Dec 2011","","","IEEE","IEEE Magazines"
"Code Inflation","G. J. Holzmann",NASA/JPL,"IEEE Software","10 Mar 2015","2015","32","2","10","13","Much of the increase in the size of software applications is unnecessary. The history of the tiny Unix /bin/true command illustrates this growth.","1937-4194","","10.1109/MS.2015.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057573","software development;true command;code size;Unix","Encoding;Software development;Unix;Codes","software engineering;Unix","code inflation;software applications;Unix /bin/true command","","1","","","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Guest Editor's Introduction: How Open Source Tools Can Benefit Industry","C. Ebert",Vector Consulting Services,"IEEE Software","24 Feb 2009","2009","26","2","50","51","The software industry has evolved toward complex supplier-user networks that cooperate and collaborate in many ways. We hardly see any longer the traditional way of software development in which one company handles design, production, sales, delivery, and service. Business models, engineering life cycles, distribution channels, and services have changed dramatically. A key driver in these new value networks is open source software (OSS). Open source refers to software that we may freely use, modify, or distribute, provided we observe certain restrictions with respect to copyright and protection of its open source status. OSS is not freeware and generally has a copyright. IEEE Software, through this paper, has assembled this minitheme to provide a glimpse of where OSS is heading.","1937-4194","","10.1109/MS.2009.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4786952","open source;open source software;software forge;community source;OSS project management tools;CMMI;dotProject","Open source software;Project management;Collaborative software;Software tools;Software quality;Employment;Engineering management;Computer industry;Ecosystems;Open source hardware","public domain software;software engineering","software industry;complex supplier-user networks;software development;open source software","","5","","6","","24 Feb 2009","","","IEEE","IEEE Magazines"
"Looking for the Holy Grail of Software Development","P. Ghazi; A. M. Moreno; L. Peters",Universidad Politécnica de Madrid; Universidad Politécnica de Madrid; NA,"IEEE Software","28 Feb 2014","2014","31","1","96","96","The history of software engineering has been marked by many famous project failures documented in papers, articles, and books. This pattern of lack of success has prompted the creation of dozens of software analysis, requirements definition, design methods, programming languages, software development environments, and software development processes all promoted as solving ""the software problem."" What we hear less about are software projects that were successful. This article reports on the findings of an extensive analysis of successful software projects that have been reported in the literature. It discusses the different interpretations of success and extracts the characteristics that successful projects have in common. These characteristics provide software project managers with an agenda of topics to be addressed that will help ensure, not guarantee, that their software project will be successful.","1937-4194","","10.1109/MS.2014.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6750443","successful project;success factors;software project management","Software development;Software engineering;Software reliability","","","","7","","14","","28 Feb 2014","","","IEEE","IEEE Magazines"
"The Strategic Importance of Release Engineering","D. Spinellis",Athens University of Economics and Business,"IEEE Software","10 Mar 2015","2015","32","2","3","5","Release engineering affects the software we build, how we build it, and how we can make money out of it. It also presents many challenges that will take time to overcome.","1937-4194","","10.1109/MS.2015.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057563","release engineering;software engineering;agile methods","","","","","1","","","","10 Mar 2015","","","IEEE","IEEE Magazines"
"The Gender Gap","",,"IEEE Software","10 Aug 2012","2012","29","4","8","8","Linda Rising responds to an article by Robert Glass in the Sounding Board column (“The Gender Gap: Is It a Computing Problem or Simply a Computer Science Problem?”) in the March/April 2012 issue of IEEE Software.","1937-4194","","10.1109/MS.2012.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6265072","software;engineering;computer;gender gap;computer science;affirmative action;competitiveness;competition;gap","","","","","","","","","10 Aug 2012","","","IEEE","IEEE Magazines"
"Automotive Software","C. Ebert; J. Favaro",Vector Consulting Services; Intecs,"IEEE Software","15 May 2017","2017","34","3","33","39","This theme issue addresses automotive IT and software development. What technologies and principles deliver value, and how can you introduce them at a fast pace?","1937-4194","","10.1109/MS.2017.82","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927926","automotive software;IT;safety;cybersecurity;software engineering;software development","Special issues and sections;Automotive engineering;Software development","","","","28","","4","","15 May 2017","","","IEEE","IEEE Magazines"
"Disseminating the Best Material to Practitioners","P. Laplante; S. Counsell; G. Antoniol",Pennsylvania State University; Brunel University; Polytechnique Montréal,"IEEE Software","15 May 2017","2017","34","3","111","113","As this department celebrates its second year, its editors restate its mission and scope of interest, invite appropriate articles, and look at some previous contributions.","1937-4194","","10.1109/MS.2017.72","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927894","software practitioners;software development;software engineering;IEEE CS 2022 Report","","","","","","","6","","15 May 2017","","","IEEE","IEEE Magazines"
"Virtual Teams [Guest editors' introduction]","D. Smite; M. Kuhrmann; P. Keil",Blekinge Institute of Technology; University of Southern Denmark; Keil KTM GmbH,"IEEE Software","7 Nov 2014","2014","31","6","41","46","Over the past decades, today, and in the future, business contexts in software organizations and the common ways of developing software are changing dramatically. Formation of teams in distributed environments, virtual or not, calls for new ways of working across geographic, temporal, and cultural boundaries. This, however, also requires effective leadership approaches enabled through systems, processes, technology, and people. The authors pulled together this special issue to provide some ideas and strategies for practitioners and open questions for researchers. The Web extra at http://youtu.be/YxE6S6MM3Ws is an audio recording in which author IEEE Software Multimedia Editor Davide Falessi interviews Laurence Tratt and Adam Welc, guest editors of the magazine's September/October 2014 issue, about the field of programming languages.","1937-4194","","10.1109/MS.2014.149","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949534","virtual teams;distributed teams;outsourcing;insourcing;software engineering","Special issues and sections;Software development;Virtual groups;Research and development;Project management;Computer languages;Programming","human resource management;software development management;team working","software development;virtual teams;team formation;leadership approach","","2","","10","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Recent Advances in Healthcare Software: Toward Context-Aware and Smart Solutions","A. Solanas; J. H. Weber; A. B. Bener; F. van der Linden; R. Capilla",Rovira i Virgili University; University of Victoria; Ryerson University; Philips; Rey Juan Carlos University,"IEEE Software","13 Nov 2017","2017","34","6","36","40","This theme issue presents some of the most recent advances in and applications of software for context-aware and smart healthcare, so as to provide a view of the state of the technology.","1937-4194","","10.1109/MS.2017.4121202","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106887","smart health;s-health;electronic health;e-health;mobile health;m-health;contextaware computing;healthcare;healthcare software;recommender systems;hygge;SafeNeighborhood;software development;software engineering;context-aware and smart healthcare","Special issues and sections;Contect awareness;Medical services;Smart devices","","","","4","","7","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Architecture Meets Agility","H. Erdogmus",National Research Council Canada,"IEEE Software","25 Aug 2009","2009","26","5","2","4","The concept of architecture has a major role to play in expanding the traditional scope of agile software development.","1937-4194","","10.1109/MS.2009.121","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222782","software engineering;agile software development;software architecture","Computer architecture;Software architecture;Documentation;Programming;Vehicles;Risk management;Costs;Communication system control;Stability","","","","7","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Recruiting a Star Team","D. Spinellis",Athens University of Economics and Business,"IEEE Software","23 Apr 2015","2015","32","3","3","5","Editor in chief Diomidis Spinellis explains how IEEE Software recruited volunteers for the magazine.","1937-4194","","10.1109/MS.2015.68","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7093014","IEEE Software;editorial board;advisory board;volunteer recruitment;software engineering","","human resource management;personnel","star team recruiting;Diomidis Spinellis;IEEE software;volunteer recruit;magazine","","2","","1","","23 Apr 2015","","","IEEE","IEEE Magazines"
"Kudos to Bob Glass and Rebecca Wirfs-Brock","",,"IEEE Software","31 Dec 2009","2010","27","1","7","9","These letters deal with the retirement of Rebecca Wirfs-Brock and Bob Glass, systems architecture, domain-specific languages, the certification of requirements analysts, measurement, and reading classics.","1937-4194","","10.1109/MS.2010.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370756","General interest;software engineering;standards and best practices","Glass;Retirement;Domain specific languages;Certification","","","","","","","","31 Dec 2009","","","IEEE","IEEE Magazines"
"Twenty Years of Patterns' Impact","G. Hohpe; R. Wirfs-Brock; J. W. Yoder; O. Zimmermann","Allianz SE; Wirfs-Brock Associates; The Refactory, Inc.; Institute for Software at the University of Applied Sciences of Eastern Switzerland, Rapperswil (HSR FHO)","IEEE Software","28 Oct 2013","2013","30","6","88","88","This column celebrates 20 years of software patterns. IEEE Software advisory board members teamed up with members of the Hillside Group, a nonprofit organization that promotes the use of patterns and pattern languages, to reflect on the state of the practice and impact of patterns.","1937-4194","","10.1109/MS.2013.135","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648592","impact;patterns;pattern writing;software engineering enterprise service bus;enterprise application integration;messaging;architectural knowledge","","","","","4","","15","","28 Oct 2013","","","IEEE","IEEE Magazines"
"The Social Responsibility of Software Development","D. Spinellis",NA,"IEEE Software","28 Mar 2017","2017","34","2","4","6","For better or worse, software developers are building the fabric of tomorrow's world. So, they need to realize that many of the things they do have ethical, social, and political implications.","1937-4194","","10.1109/MS.2017.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888390","software engineering;ethics;software development;social responsibility","","","","","4","","1","","28 Mar 2017","","","IEEE","IEEE Magazines"
"My Must-Reads","",,"IEEE Software","22 Dec 2008","2009","26","1","8","8","Two readers offer high praise for IEEE Software 's contributions to their careers.","1937-4194","","10.1109/MS.2009.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721172","software engineering;professional development","Engineering profession","","","","","","","","22 Dec 2008","","","IEEE","IEEE Magazines"
"State-of-the-Art Software Testing","D. Spinellis",Athens University of Economics and Business,"IEEE Software","22 Sep 2017","2017","34","5","4","6","Best practices for software testing include unit testing, test-driven development, using a test pyramid, test automation, continuous integration, test coverage analysis, A/B testing, and employing the appropriate metrics.","1937-4194","","10.1109/MS.2017.3571564","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048644","software testing;unit testing;test-driven development;test pyramids;test automation;continuous integration;test coverage analysis;A/B testing;software development;software engineering;Mik Kersten;DevOps","","program testing;software metrics","software testing;unit testing;test-driven development;test pyramid;test automation;continuous integration;test coverage analysis;A/B testing","","2","","4","","22 Sep 2017","","","IEEE","IEEE Magazines"
"The Changing Role of the Software Architect","D. Spinellis",NA,"IEEE Software","28 Oct 2016","2016","33","6","4","6","Being a good software architect has never been easy. Changes in the software industry are making the job even more challenging. The key drivers are the rising role of software in systems and their operation; more emphasis on reuse, agility, and testability during software development; and several quality elements increasingly affected by architectural choices.","1937-4194","","10.1109/MS.2016.133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725213","software architecture;software architect;software development;software engineering","","software architecture;software quality;software reusability","software architect;software industry;software development;quality elements;software reuse;software agility;software testability","","3","","1","","28 Oct 2016","","","IEEE","IEEE Magazines"
"Of Boilers, Bit, and Bots","G. Booch",IBM,"IEEE Software","4 Feb 2015","2015","32","1","11","13","Parallels exist between the Industrial Revolution and our current computing revolution regarding risk, transparency, and responsibility. This article examines some of these parallels, the implications for society, and the individual developer's responsibility. The Web extra at http://youtu.be/9qfm9DDzLCc is an audio podcast of author Grady Booch reading his On Computing column, in which he discusses how parallels exist between the Industrial Revolution and our current computing revolution regarding risk, transparency, and responsibility. Grady then examines some of these parallels, their implications for society, and individual developer's responsibilities.","1937-4194","","10.1109/MS.2015.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030158","software engineering;computing;history;society;professional development","Social factors;Technology social factors;Social implications of technology;Philosophical considerations","","","","","","","","4 Feb 2015","","","IEEE","IEEE Magazines"
"A Brave New World of Testing? An Interview with Google's James Whittaker","F. Shull",NA,"IEEE Software","20 Feb 2012","2012","29","2","4","7","The increasing pervasiveness of cloud computing is changing the state of the practice in software testing. In an interview with James Whittaker, an engineering director at Google, editor in chief Forrest Shull explores some of the important trends in cloud computing and their implications. The conversation covers key technology changes, such as more pervasive access to monitoring frameworks, the ability to aggregate and act on feedback directly from massive user communities (the ""crowdsourcing"" of quality assurance), and the ability to know the exact machine configuration when bugs are discovered. All of these changes are having concrete impacts on which skills are important—and which no longer so—for software testers. An accompanying audio interview provides a complete recording of the conversation and more details on points such as privacy testing.","1937-4194","","10.1109/MS.2012.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6155134","cloud computing;software testing;quality assurance;functional testing;software engineering training;privacy","","","","","1","1","","","20 Feb 2012","","","IEEE","IEEE Magazines"
"Seeking Your Insights","C. Pautasso; O. Zimmermann","University of Lugano; University of Applied Sciences of Eastern Switzerland in Rapperswil, Switzerland","IEEE Software","10 Mar 2015","2015","32","2","7","9","The column's new editors ask readers to participate, and they give guidelines for the type of articles they seek.","1937-4194","","10.1109/MS.2015.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7057623","IEEE Software;Insights column;software engineering;software development;software development lifecycle;software architectures","","","","","","","6","","10 Mar 2015","","","IEEE","IEEE Magazines"
"Point/Counterpoint","R. Kolb; F. van der Linden",Honeywell; Philips Healthcare,"IEEE Software","19 Apr 2010","2010","27","3","56","59","Ronny Kolb and Frank van der Linden discuss the pros and cons of software product lines. Kolb writes about the competitive advantages software product lines can deliver in reducing time-to-market in his article, ""The Need for Speed: Releasing Products Earlier Using Software Product Lines."" Whereas, in ""Why Do We Do Product Lines?"" van der Linden cautions that different stakeholders and organizations have different goals that might or might not fit with software product lines.","1937-4194","","10.1109/MS.2010.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452146","software product lines;software engineering;product line engineering","Time to market","","","","1","","3","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Extending Our Field's Reach","D. Spinellis",Athens University of Economics and Business,"IEEE Software","28 Oct 2015","2015","32","6","4","6","The techniques and processes software engineers have perfected to manage complex projects, version control, and international collaboration could benefit other fields and industries.","1937-4194","","10.1109/MS.2015.138","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7311002","software engineering;change management;Git;GitHub;version control;configuration management","","","","","","","","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Sigil, BlueGriffon, and the Evolving Software Market","T. DeMarco",NA,"IEEE Software","13 Jun 2014","2014","31","4","100","100","Changes in the applications software market promise increased opportunities for individual players.","1937-4194","","10.1109/MS.2014.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834686","software market;freelance development;software brokerage;niche software;software engineering","","","","","","","","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Refactoring [Guest editors' introduction]","E. Murphy-Hill; D. Roberts; P. Sommerlad; W. F. Opdyke",North Carolina State University; University of Evansville; FHO/Hochschule für Technik Rapperswil; JPMorgan Chase,"IEEE Software","28 Oct 2015","2015","32","6","27","29","Refactoring changes a program's source code without changing its external behavior, typically to improve the software's design The articles selected for this issue range from historical, exploring refactoring research's origins, to practical, exploring software developers' experiences with refactoring, to theoretical, exploring new refactoring techniques that haven't yet appeared in the wild. The Web extra at https://youtu.be/f2IK3V9wwa8 is an audio recording of Davide Falessi speaking with guest editors Emerson Murphy-Hill of North Carolina State University, Don Roberts of the University of Evansville, and Peter Sommerlad of Fachhochschule Ostschweiz / Hochschule für Technik Rapperswil about past, present, and future approaches to refactoring.","1937-4194","","10.1109/MS.2015.136","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310990","refactoring;software engineering;software development;mobile computing","Special issues and sections;Code refractoring;Software architecture;Programming;Software development","","","","1","","1","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Fewer Dead Trees, More Engagement","D. Spinellis",Athens University of Economics and Business,"IEEE Software","4 Feb 2015","2015","32","1","4","6","New IEEE Software editor in chief Diomidis Spinellis discusses the IEEE Computer Society's switch to digital as the primary delivery option for its publication. He also outlines his vision for Software's future and calls for volunteer help.","1937-4194","","10.1109/MS.2015.5","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030241","software engineering;digital edition;IEEE Computer Society;publications","","","","","1","","","","4 Feb 2015","","","IEEE","IEEE Magazines"
"RE@40: Midlife Crisis or Graceful Maturity?","S. Gregory",Intel Corporation,"IEEE Software","13 Nov 2017","2017","34","6","14","17","The RE@40 seminar offered a diagnosis of the state of RE as it enters its 40s. At 40, RE has grown up a bit and should have a clear sense of who it is as it moves deeper into its most productive years. Of course, many 40-somethings also begin to experience a midlife crisis and suddenly change direction, perhaps not attending well to their current responsibilities. Where does RE sit at this juncture?","1937-4194","","10.1109/MS.2017.4121215","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106880","RE@40;requirements engineering;software requirements;software development;software engineering;Requirements","","","","","1","","2","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Data, Data Everywhere...","F. Shull",Carnegie Mellon University,"IEEE Software","15 Sep 2014","2014","31","5","4","7","Editor-in-chief Forrest Shull talks about the practical application of software analytics.","1937-4194","","10.1109/MS.2014.110","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898721","software engineering;software analytics;software measurement;software management","","","","","","","4","","15 Sep 2014","","","IEEE","IEEE Magazines"
"How Well Do You Know Your Personae Non Gratae?","J. Cleland-Huang",DePaul University,"IEEE Software","13 Jun 2014","2014","31","4","28","31","Imagine that you're building a software system that collects healthcare data and financial information from its users. It might seem obvious that this personal information should be protected from prying eyes through access control mechanisms, audit trails, transaction controls, transmission encryption, and so on--in fact, perhaps so obvious that in many cases people perform only a cursory security analysis and produce rather generic security requirements. But is this the right way to build secure software? Are security requirements so similar across projects that we simply don't need to invest the time to explore product-level needs or to document requirements at an individual level for each project? The Web extra at http://youtu.be/qoocRI-7yRQ is an audio podcast in which author Jane Cleland-Huang discusses the importance of making informed decisions about how much time and effort to invest in analyzing security needs and specifying product-level security requirements.","1937-4194","","10.1109/MS.2014.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834694","requirements;software engineering;cybersecurity;attackers;security","Network security;Software development;Productivity;Medical services;Information services","","","","3","","4","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Architecture from a Developer's Perspective","D. Spinellis",Athens University of Economics,"IEEE Software","21 Aug 2015","2015","32","5","4","7","Editor in Chief Diomidis Spinellis discusses the importance of architectural considerations for developers.","1937-4194","","10.1109/MS.2015.110","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217777","IEEE Software;software engineering;architecture","","","","","","","","","21 Aug 2015","","","IEEE","IEEE Magazines"
"Being a DevOps Developer","D. Spinellis",NA,"IEEE Software","25 Apr 2016","2016","33","3","4","5","In many IT sectors, DevOps is here to stay, helping deliver higher-quality services more efficiently. Thinking like a DevOps developer is an essential trait of an enlightened software professional. This article is part of a theme issue on DevOps.","1937-4194","","10.1109/MS.2016.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458759","DevOps;software development;software engineering;agile development;software developers;IT operations","","","","","2","","","","25 Apr 2016","","","IEEE","IEEE Magazines"
"To Code or Not to Code, That Is the Question","G. Booch",IBM,"IEEE Software","15 Sep 2014","2014","31","5","9","11","There have been many periods in the unfolding of human history when we have asserted that it was possible to catalog all that was known or that could be known. Ignoring the pragmatic reality of trying to catalog an ever-expanding corpus, one must understand that such a task is further complicated by cultural and situational bias: what is important to know at one place and time is not necessary important in another. So it is with our present day; this raises the question, what must a functioning member of society know about computing? The Web extra at http://youtu.be/PjR6GqobTBo is an audio podcast of author Grady Booch reading his On Computing column, in which he discusses how much a functioning member of society today should know about computing.","1937-4194","","10.1109/MS.2014.128","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898799","computational thinking;programming;knowledge;information;history;software engineering","","computer science education;encoding;programming","code;computing;Internet;programming;coding teaching","","","","","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Introductions","D. Spinellis",Athens University of Economics and Business,"IEEE Software","30 Jun 2015","2015","32","4","3","5","Editor in Chief Diomidis Spinellis introduces 12 editorial board members, four advisory board members, the initiatives team, and two magazine departments.","1937-4194","","10.1109/MS.2015.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140675","IEEE Software;software engineering","","","","","1","","1","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Differential Debugging","",,"IEEE Software","28 Oct 2013","2013","30","6","9","10","Phillip G. Armour responds to ""Differential Debugging"" in the Tools of the Trade column September/October issue of IEEE Software to discuss the process of predicting defects.","1937-4194","","10.1109/MS.2013.123","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648591","defects;debugging;bugs;software;engineering;development;testing;tools;defect masking;existential defects","","","","","","","","","28 Oct 2013","","","IEEE","IEEE Magazines"
"Protection from Wishful Thinking","F. Shull",NA,"IEEE Software","23 Jun 2011","2011","28","4","3","6","One of the problems of software development is accurately assessing progress and the cost remaining to completion. Without a good sense of where the project is and how far it still has to go, it's just not possible to consistently manage people and resources well. And miscommunicating progress to stakeholders is among the surest ways to lose trust and buy-in. Even with the best of intentions and good processes in place, it's possible for projects to end up in serious trouble as a result of misassessing or miscomunicating progress. The paper mentions that optimism is a virtue in many cases, but there is a fine distinction between optimism and wishful thinking.","1937-4194","","10.1109/MS.2011.80","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929519","Software engineering;survey;professional development","","project management;software development management","project sense;people management;resource management;software development management","","","","","","23 Jun 2011","","","IEEE","IEEE Magazines"
"Passing the Baton","F. Shull",Carnegie Mellon University,"IEEE Software","7 Nov 2014","2014","31","6","4","8","Forrest Shull writes his final column as IEEE Software editor in chief; outlining the magazine's accomplishments during his four-year tenure; introducing his successor, Diomidis Spinellis; and discussing the success of Software Experts Summit 2014 in Bangalore, India. The Web extra at http://youtu.be/yhBsX8OHqhY is a video overview of the multimedia content from past issues of IEEE Software and Computer magazines showing the endless possibilites that IEEE Computer Society multimedia affords.","1937-4194","","10.1109/MS.2014.143","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6949506","software engineering;computing;Forrest Shull;Diomidis Spinellis;SES14;Software Experts Summit","","","","","","","","","7 Nov 2014","","","IEEE","IEEE Magazines"
"Security and Privacy on the Web [Guest editors' introduction]","T. Grandison; L. Koved",Proficiency Labs; IBM Research,"IEEE Software","30 Jun 2015","2015","32","4","36","39","Software enables every aspect of the Web. Everything from device communication to online social networks is achievable only because of multiple lines of code. For various reasons, designing and building security and privacy into Web software is often an afterthought for most developers. This results in easily compromised systems that pose significant privacy and security risks to users. The Web extra at https://youtu.be/juxM-mJERxc is an audio recording of Davide Falessi speaking with Guest Editors Tyrone Grandison, CEO of Proficiency Labs, and Larry Koved, Principal Research Staff Member at IBM Research, about why, at a bare minimum, Web software developers must ensure that their code is sufficiently hardened to protect against URL interpretation attacks, input validation attacks, SQL injection attacks, impersonation attacks, basic inference attacks, buffer overflow attacks, and inadvertent data disclosure attacks.","1937-4194","","10.1109/MS.2015.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140679","software development;security;privacy;Web;software engineering;Web software","Special issues and sections;Social network services;Computer security;Privacy;Software development","","","","1","","","","30 Jun 2015","","","IEEE","IEEE Magazines"
"The Computational Human","G. Booch",IBM,"IEEE Software","26 Feb 2016","2016","33","2","8","10","Different ages of humanity have required different modes of thinking. These modes aren't only reflections of the particular circumstances of life in each age; they're also projections of the forces that propel us to the next. The Web extra at https://youtu.be/0_kwid5kUAU is an audio podcast of Grady Booch's On Computing column, in which he discusses how we have progressed from the Cognitive Revolution to the Agricultural Revolution to the Industrial Revolution and now find ourselves in the Computational Revolution.","1937-4194","","10.1109/MS.2016.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420499","computational thinking;history;science;software engineering","","social aspects of automation","cognitive revolution;agricultural revolution;industrial revolution;computational revolution;computational human","","1","","4","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Architecting in the Gaps: A Metaphor for Architecture Work","E. Woods",Endava,"IEEE Software","30 Jun 2015","2015","32","4","33","35","The metaphor ""architecting in the gaps"" can help software development teams clearly understand the software architect's role and how architecture contributes to a system's overall efficiency.","1937-4194","","10.1109/MS.2015.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140650","software architecture;software engineering;software development;software design","Software development;Software architecture","software architecture","software development teams;software architect role;system overall efficiency","","2","","2","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Time Pressure","F. Dzerzhinskiy","Promsvyazbank, Moscow, Russia","IEEE Software","25 Apr 2016","2016","33","3","6","6","The article is a letter discussing the aspect of time in software development. It states that time pressure has its positive aspects but can also hinder software developers.","1937-4194","","10.1109/MS.2016.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458773","time pressure;software development;software engineering;human factors","","software development management","time pressure;software development","","","","","","25 Apr 2016","","","IEEE","IEEE Magazines"
"Dave Thomas on Innovating Legacy Systems","S. Johann",innoQ,"IEEE Software","26 Feb 2016","2016","33","2","105","108","Host Sven Johann speaks with Dave Thomas, ACM Distinguished Member, entrepreneur, and researcher, about the tradeoffs and constraints facing developers as they work with legacy systems.","1937-4194","","10.1109/MS.2016.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420466","Dave Thomas;legacy systems;software development;software engineering","","software maintenance","legacy system innovation","","2","","","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Playing Nice","",,"IEEE Software","3 Jan 2013","2013","30","1","7","8","Dale Gaumer responds to Linda Rising's column in the September/October 2012 issue of IEEE Software titled ""Why Can't We All Play Nice?"" and gives examples of how the competence and talent of one's management and coworkers can impact the success of a project. Chris Morris responds to Rising's column to clarify her statements on human genetics.","1937-4194","","10.1109/MS.2013.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6401106","software;engineering;projects;management;competition;genes;genetics","","","","","","","","","3 Jan 2013","","","IEEE","IEEE Magazines"
"Reflecting on Quality","D. Spinellis",Athens University of Economics and Business,"IEEE Software","23 Jun 2016","2016","33","4","4","5","The production of quality software requires data-driven quality management. Fortunately, developers can use a plethora of tools and techniques for this.","1937-4194","","10.1109/MS.2016.90","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7498538","software quality;data-driven management;software engineering","","","","","","","","","23 Jun 2016","","","IEEE","IEEE Magazines"
"I Believe","",,"IEEE Software","20 Apr 2012","2012","29","3","7","7","Magdin Stoica discusses the difference between beliefs, intuition and principles in a letter responding to Forrest Shull's From the Editor column ""I Believe"" in the January/February 2012 issue of IEEE Software.","1937-4194","","10.1109/MS.2012.64","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188593","software;engineering;belief;intuition;principles;test-driven development;tdd","","","","","2","","","","20 Apr 2012","","","IEEE","IEEE Magazines"
"Software Process versus Design Quality: Tug of War?","G. Suryanarayana; T. Sharma; G. Samarthyam","Corporate Research and Technologies Center, Siemens Technology and Services Private Ltd., India; Corporate Research and Technologies Center, Siemens Technology and Services Private Ltd., India; Corp. Res. & Technol. Center, Siemens Technol. & Services Private Ltd., India","IEEE Software","30 Jun 2015","2015","32","4","7","11","Software processes and design quality are inextricably intertwined. So, developers must consider their impact on each other to ensure a high-quality design.","1937-4194","","10.1109/MS.2015.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7140652","software design smells;refactoring;software process;software engineering;software development;software design;software quality;duplicate abstraction;insufficient modularization;multipath hierarchy","Software development;Product life cycle management","software quality","software process;software design quality;high-quality design","","6","","10","","30 Jun 2015","","","IEEE","IEEE Magazines"
"Perfectionists in a World of Finite Resources","F. Shull",Fraunhofer Center for Experimental Software,"IEEE Software","28 Feb 2011","2011","28","2","4","6","The metaphor of technical debt, originally coined by Ward Cunninghamhas helped me recently get a handle on this type of issue. Almost invariably in software projects, developers can be so focused on accomplishing the needed functionality that the software itself grows less understandable, more complex, and harder to modify. Since this system deterioration usually reflects a lack of activity spent in refactoring, documentation, and other aspects of the project infrastructure, we can view it as a kind of debt that developers owe the system. Ward Cunningham's metaphor helps make clear an important trade-off: although a little debt can speed up software development in the short run, this benefit is achieved at the cost of extra work in the future, as if paying interest on the debt. Technical debt gives us a frame work for thinking about the fact that not doing some good things today, no matter how valuable they seem on their own merits, allows us to invest in other good things. In short, there are always trade-offs in life.","1937-4194","","10.1109/MS.2011.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5720703","technical debt;code decay;code smells;software maintainability;software engineering","","software maintenance","technical debt;software projects;system deterioration;software development;software refactoring","","2","","","","28 Feb 2011","","","IEEE","IEEE Magazines"
"Software Reliability Redux","D. Spinellis",Athens University of Economics and Business,"IEEE Software","11 Jul 2017","2017","34","4","4","7","The requirement for high reliability is no longer restricted to a few specialized and proven domains. Instead, ever more functions whose failure can hurt humans and damage property are cropping up in new areas. Avoiding problems and catastrophes in the new software reliability landscape is possible but won't be easy.","1937-4194","","10.1109/MS.2017.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974699","software reliability;software development;software engineering","","","","","","","3","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Sweet Spot for User Involvement","",,"IEEE Software","21 Apr 2014","2014","31","3","9","9","Chris Morris writes a letter to the editor in response to the Voice of Evidence column ""Does Involving Users in Software Development Really Influence System Success?"" from the Nov./Dec. 2013 issue of IEEE Software in which he discusses the correlation between user and involvement and project success.","1937-4194","","10.1109/MS.2014.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6802988","letter to the editor;Chris Morris;user involvement;voice of evidence;software;engineering;development;IEEE","","","","","","","","","21 Apr 2014","","","IEEE","IEEE Magazines"
"View from the Bridge","",,"IEEE Software","17 Mar 2014","2014","31","2","10","13","Stuart Jobbins writes a letter to the editor in response to the column ""Progression, Regression, or Stasis?"" from the Jan./Feb. 2014 issue of IEEE Software in which he states that software engineers need to inspire youngsters enter our intellectually stimulating and challenging career world, where technology evolution means constant learning and growth in an industry that now pervades nearly every product. Stan Rifkin also writes a letter regarding the same column in which he states that a commitment to software quality is of utmost importance.","1937-4194","","10.1109/MS.2014.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774317","letter to the editor;letters;Stuart Jobbins;careers;software;engineering;Stan Rifkin;quality;development;IEEE","","","","","","","","","17 Mar 2014","","","IEEE","IEEE Magazines"
"I, for One, Welcome Our New Computer Overlords","G. Booch",NA,"IEEE Software","28 Oct 2015","2015","32","6","8","10","Many fear the rise of superintelligent AIs. Such fears are at best unfounded and at worst misleading. The Web extra at https://youtu.be/geSb5Zp4qbM is an audio podcast of Grady Booch's On Computing column, in which he discusses why he rejects fears that machines with superintelligent computing powers will eventually spell the end of humanity.","1937-4194","","10.1109/MS.2015.134","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7310991","software engineering;computing;artificial intelligence;future;singularity","","artificial intelligence;Internet","computer overlords;superintelligent AIs;Web extra;audio podcast;Grady Booch On Computing column;superintelligent computing powers","","3","","13","","28 Oct 2015","","","IEEE","IEEE Magazines"
"Serving Professionals","D. Spinellis",Athens University of Economics and Business,"IEEE Software","26 Feb 2016","2016","33","2","4","6","Editor in Chief Diomidis Spinellis discusses what IEEE Software is doing to provide more practitioner-focused material.","1937-4194","","10.1109/MS.2016.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420484","IEEE Software;software engineering;software development","","","","","","","","","26 Feb 2016","","","IEEE","IEEE Magazines"
"Next-Generation Mobile Computing","J. Edmondson; W. Anderson; J. Gray; J. P. Loyall; K. Schmid; J. White",Carnegie Mellon University; Carnegie Mellon University; University of Alabama; Raytheon BBN Technologies; University of Hildesheim; Vanderbilt University,"IEEE Software","17 Mar 2014","2014","31","2","44","47","This issue of IEEE Software discusses where the mobile computing has brought us today and where it could be taking us in the future. It provides a glimpse into the near future of mobile computing by focusing on proximate software challenges coupled with promising techniques, infrastructure, and research from academia, government, and industry. The first Web extra at http://youtu.be/iLnNHwp-H8E is a video demonstration of the Group Autonomy for Mobile Systems (GAMS) project, which is an extension of a research project called Self-governing Mobile Adhocs with Sensors and Handhelds (SMASH) that investigated human-in-the-loop autonomy at Carnegie Mellon University. The project created Android interfaces to a drone swarm that tried to autonomously search for survivors in a disaster scenario using the Parrot AR.Drone and custom GPS and thermal sensors. The second Web extra at http://youtu.be/lW1dqsrdRHU is a video demonstration of HD4AR mobile augmented reality technology that was commercialized through PAR Works. The third Web extra at http://youtu.be/M4w5oPqrMRo is an audio interview in which James Edmondson talks with Suzanne Miller about autonomous systems, specifically as they relate to robotic systems. In particular, Edmondson's research focuses on partial autonomy with an aim of complementing human users and extending their reach and capabilities in mission-critical environments. From the SEI Podcast Series ""Conversations in Software Engineering.""","1937-4194","","10.1109/MS.2014.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774331","mobile computing;mobile;smartphones","Special issues and sections;Next generation networking;Mobile computing;Mobile communication;Computer applications;Software development","augmented reality;disasters;Global Positioning System;mobile computing;robots;user interfaces","next-generation mobile computing;IEEE software;Group Autonomy for Mobile Systems;GAMS;Self-governing Mobile Adhocs with Sensors and Handhelds;SMASH;human-in-the-loop autonomy;Carnegie Mellon University;Android interfaces;disaster scenario;Parrot AR.Drone;custom GPS;thermal sensors;HD4AR mobile augmented reality technology;PAR Works;autonomous systems;robotic systems;mission-critical environments;SEI Podcast Series Conversations in Software Engineering","","7","","6","","17 Mar 2014","","","IEEE","IEEE Magazines"
"Progression, Regression, or Stasis?","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","28 Feb 2014","2014","31","1","4","8","IEEE Software Editor in Chief Forrest Shull discusses the challenges of delivering quality software systems on time and on schedule, while considering the many challenges faced by the Health Insurance Marketplace system. He also introduces new Editorial Board and Advisory Board members Jeromy Carriere, Davide Falessi, Evelyn Tian, and Grigori Melnik.","1937-4194","","10.1109/MS.2014.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6750467","healthcare.gov;health insurance marketplace;Jeromy Carriere;Davide Falessi;Evelyn Tian;Grigori Melnik","","","","","","","11","","28 Feb 2014","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Developing Scientific Software, Part 2","J. Segal; C. Morris",Open University; Daresbury Lab,"IEEE Software","22 Dec 2008","2009","26","1","79","79","This guest editors' introduction introduces a special issue on scientific software development. This issue is a sequel to the July/August 2008 issue, whose 6 articles provided some flavor of the variety of such software. Part 2 of this theme focuses on practices for improving the relationships between users, developers, and software.","1937-4194","","10.1109/MS.2009.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4721189","scientific computing;high-performance computing;simulation;data visualization","Programming;Councils;Risk management;Software development management;Software testing;Software engineering;Usability;User centered design;Microscopy;Publishing","","","","3","","1","","22 Dec 2008","","","IEEE","IEEE Magazines"
"Requirements That Reflect Social Responsibility","J. Cleland-Huang",DePaul University,"IEEE Software","29 Dec 2015","2016","33","1","109","111","A few simple steps can help app developers think through potential harm, identify mitigating requirements, and ensure that the products they develop maximize good and minimize harm. The Web extra at https://youtu.be/UI-itpTr6Jw is an audio podcast of this column.","1937-4194","","10.1109/MS.2016.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368038","software requirements;software development;social responsibility;social networking;Peeple;SketchFactor;software design","Software engineering;Requirements engineering;Social network services;Software design","formal specification","software requirements;social responsibility","","","","4","","29 Dec 2015","","","IEEE","IEEE Magazines"
"Lean Software Development","C. Ebert; P. Abrahamsson; N. Oza",Vector Consulting Services; Free University of Bozen-Bolzano; University of Helsinki,"IEEE Software","21 Aug 2012","2012","29","5","22","25","This special issue addresses lean software development. What principles deliver value, and how are they introduced to best manage change?","1937-4194","","10.1109/MS.2012.116","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6276296","lean software development;agile;life cycle","Special issues and sections;Software engineering;Product life cycle management;Software development;Agile manufacturing","","","","33","","5","","21 Aug 2012","","","IEEE","IEEE Magazines"
"The Many Faces of Software Analytics","T. Menzies; T. Zimmermann",West Virginia University; Microsoft Research,"IEEE Software","3 Sep 2013","2013","30","5","28","29","Articles regarding the many faces of software analytics highlight the power of analytics for different types of organizations: large organizations and open source projects, as well as small- to medium-sized projects.","1937-4194","","10.1109/MS.2013.114","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6588525","software analytics;analytics;analysis","Special issues and sections;Software analytics;Software engineering","","","","2","","","","3 Sep 2013","","","IEEE","IEEE Magazines"
"Don't Fire the Architect! Where Were the Requirements?","J. Cleland-Huang",DePaul University,"IEEE Software","17 Mar 2014","2014","31","2","27","29","The Healthcare.gov debacle of 2013 leads many to wonder if a better understanding of the project's requirements could have lessened the impact of the failed launch. The Web extra at http://youtu.be/qyQldlPz1ws is an audio podcast of author Jane Cleland-Huang reading her Requirements column, in which she discusses the Healthcare.gov debacle of 2013 and how it led many to wonder if a better understanding of the projec's requirements could have lessened the impact of the failed launch.","1937-4194","","10.1109/MS.2014.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6774318","requirements;architecture;Healthcare.gov","Software engineering;Medical services;Insurance;Performance evaluation;Computer architecture","medical information systems;social aspects of automation;Web sites","healthcare.gov debacle;project requirements;failed launch;Web extra;audio podcast","","2","","5","","17 Mar 2014","","","IEEE","IEEE Magazines"
"A Balancing Act: What Software Practitioners Have to Say about Technical Debt","E. Lim; N. Taksande; C. Seaman","Aquatic Informatics; Novasom; University of Maryland, Baltimore County","IEEE Software","22 Oct 2012","2012","29","6","22","27","An interview study involving 35 practitioners from a variety of domains aimed to characterize technical debt at the ground level to find out how software practitioners perceive it. The study also aimed to understand the context in which technical debt occurs, including its causes, symptoms, and effects. In addition, the study focused on how practitioners currently deal with technical debt. This analysis paints a picture of a large, complex balancing act of various short- and long-term concerns. The Web Extra gives the interview questions used by Erin Lim, Nitin Taksande, and Carolyn Seaman.","1937-4194","","10.1109/MS.2012.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6280547","maintenance management;software maintenance;technical debt;software engineering","Interviews;Risk management;Investments;Software testing;Documentation;Software quality","DP industry;project management;software development management;software quality","software practitioner;technical debt;software quality;project management","","83","","10","","23 Aug 2012","","","IEEE","IEEE Magazines"
"New Perspectives on Software Quality [Guest editors' introduction]","R. Breu; A. Kuntzmann-Combelles; M. Felderer",University of Innsbruck; inspearit; University of Innsbruck,"IEEE Software","28 Feb 2014","2014","31","1","32","38","This special issue, owing to its fundamental software quality focus, comprises a collection of diverse articles that address the challenges and directions for software quality research. The Web extra at http://youtu.be/T7V4RSr1KEE is an audio interview in which Davide Falessi speaks with guest editors Annie Kuntzmann-Combelles, Michael Felderer, and Ruth Breu about methods for improving software quality management, testing, and security on intelligent and interconnected devices.","1937-4194","","10.1109/MS.2014.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6750444","software quality;quality engineering;software","Special issues and sections;Software testing;Collaboration;Quality management;Software engineering;Data analysis;Software quality","","","","9","","15","","28 Feb 2014","","","IEEE","IEEE Magazines"
"Mars Rover","",,"IEEE Software","26 Jun 2013","2013","30","4","8","8","Iowa State University Lanh & Oanh Nguyen Professor of Software Engineering David Weiss compliments the ""Landing a Spacecraft on Mars"" article in the Impact column from the March/April 2013 issue of IEEE Software.","1937-4194","","10.1109/MS.2013.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547628","engineering;Curiosity;rover;Mars;spacecraft;software;development;process critical systems","","","","","1","","","","26 Jun 2013","","","IEEE","IEEE Magazines"
"The Go Programming Language","J. Meyerson",NA,"IEEE Software","15 Sep 2014","2014","31","5","104","104","Andrew Gerrand, who works on the Go programming language at Google, speaks with Jeff Meyerson in this excerpt from Software Engineering Radio. His conversation with Jeff begins with a history of the language, including the details behind how Go was conceived and how the open source community contributes to it. Andrew explains how Go intends to simplify problems which have been motifs as Google has scaled. The Web extra at http://www.se-radio.net/2014/03/episode-202-andrew-gerrand/ is an audio recording of Jeff Meyerson speaking with Andrew Gerrand about the Go programming language.","1937-4194","","10.1109/MS.2014.127","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898707","Andrew Gerrand;arrays;build times;C;compilers;garbage collection;Go;golang;Google;imports;interfaces;open source;readability;scalability;slices;standard library;syntax","","","","","3","","","","15 Sep 2014","","","IEEE","IEEE Magazines"
"Assuring the Future? A Look at Validating Climate Model Software","F. Shull",NA,"IEEE Software","20 Oct 2011","2011","28","6","4","8","The scientific community studying climate change uses a variety of strategies to assess the correctness of their models. These software systems represent large, sophisticated, fine-grained scientific tools. The validation practices described are thus tailored to a domain in which software and software engineering practices are useful but cannot be allowed to get in the way of the science. In audio interviews, two scientists--Robert Jacob, a computational climate scientist at Argonne National Laboratory, and Gavin Schmidt, a climatologist and climate modeler at the NASA Goddard Institute for Space Studies--discuss what it means to develop and communicate ground-breaking results.","1937-4194","","10.1109/MS.2011.135","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6055655","Software validation;modeling and simulation;climate studies;Robert Jacob;Gavin Schmidt;Argonne National Laboratory and NASA Goddard Institute for Space Studies","Special issues and sections;Software development;Metrology;Global warming;Atmospheric modeling;Atmosphere measurements","","","","1","","1","","20 Oct 2011","","","IEEE","IEEE Magazines"
"Sharing Your Story","F. Shull",Fraunhofer Center for Experimental Software,"IEEE Software","18 Apr 2013","2013","30","3","4","7","IEEE Software Editor-in-Chief Forrest Shull discusses the value of experience reports and how they can bring practical advice and perspective that simple metrics are not always able to provide. In addition, he discusses Software Experts Summit 2013 and announces that the magazine is seeking a new multimedia editor. The first Web extra at http://youtu.be/KTUHr-1S_wo is a video preview of Software Experts Summit 2013, which will focus on Smart Data Science: Harnessing Data for Intelligent Decision Making. Scheduled for 17 July at the Microsoft Campus in Redmond, Washington, speakers include James Whittaker of Microsoft, Paul Zikopoulos of IBM, Wolfram Schulte of Microsoft Research, Ayse Bener of Ryerson University, and Forrest Shull of the Fraunhofer Center for Experimental Software Engineering.","1937-4194","","10.1109/MS.2013.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6504876","experience report;software;technology;engineering;multimedia;edit;editing;author;guidelines;application;research;practice;practical","","","","","1","","3","","18 Apr 2013","","","IEEE","IEEE Magazines"
"Roundtable: The Future of Software Engineering for Internet Computing","J. Lü; D. S. Rosenblum; T. Bultan; V. Issarny; S. Dustdar; M. Storey; D. Zhang","Nanjing University; National University of Singapore; University of California, Santa Barbara; Inria Paris-Rocquencourt; Vienna University of Technology; University of Victoria; Microsoft Research, China","IEEE Software","4 Feb 2015","2015","32","1","91","97","Seven research leaders in software engineering for Internet computing present their viewpoints on important issues that will shape this field's future. They discuss opportunities and challenges for the shifting software paradigm; stepping outside the comfort zone to revisit issues such as software correctness; improving Internet software dependability and programmability; addressing software engineering issues for the Internet of Things; exploring relationships among the Internet of Things, people, and software services; supporting a participatory culture of software development; and rethinking logging in online services.","1937-4194","","10.1109/MS.2015.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030178","software engineering;Internetware;Internet computing;Internet of Things","Interviews;Software engineering;Internet computing;Internet of things","","","","4","","18","","4 Feb 2015","","","IEEE","IEEE Magazines"
"2014 Index IEEE Transactions on Software Engineering Vol. 40","",,"IEEE Transactions on Software Engineering","19 Jan 2015","2015","41","1","104","112","This index covers all technical items - papers, correspondence, reviews, etc. - that appeared in this periodical during the year, and items from previous years that were commented upon or corrected in this year. Departments and other items may also be covered if they have been judged to have archival value. The Author Index contains the primary entry for each item, listed under the first author's name. The primary entry includes the co-authors' names, the title of the paper or other item, and its location, specified by the publication abbreviation, year, month, and inclusive pagination. The Subject Index contains entries describing the item under all appropriate subject headings, plus the first author's name, the publication abbreviation, month, and year, and inclusive pages. Note that the item title is found only under the primary entry in the Author Index.","1939-3520","","10.1109/TSE.2014.2382474","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7014339","","Indexes","","","","","","","","19 Jan 2015","","","IEEE","IEEE Journals"
"2016 Index IEEE Transactions on Software Engineering Vol. 42","",,"IEEE Transactions on Software Engineering","9 Jan 2017","2017","43","1","1","8","This index covers all technical items - papers, correspondence, reviews, etc. - that appeared in this periodical during the year, and items from previous years that were commented upon or corrected in this year. Departments and other items may also be covered if they have been judged to have archival value. The Author Index contains the primary entry for each item, listed under the first author's name. The primary entry includes the co-authors' names, the title of the paper or other item, and its location, specified by the publication abbreviation, year, month, and inclusive pagination. The Subject Index contains entries describing the item under all appropriate subject headings, plus the first author's name, the publication abbreviation, month, and year, and inclusive pages. Note that the item title is found only under the primary entry in the Author Index.","1939-3520","","10.1109/TSE.2016.2638761","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7809252","","","","","","","","","","9 Jan 2017","","","IEEE","IEEE Journals"
"Kief Morris on Infrastructure as Code","S. Johann",NA,"IEEE Software","16 Jan 2017","2017","34","1","117","120","Cloud specialist Kief Morris joins Software Engineering Radio host Sven Johann to discuss the benefits of infrastructure as code, including security, auditability, testing, documentation, and traceability.","1937-4194","","10.1109/MS.2017.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7819402","Kief Morris;infrastructure as code;infrastructure automation;Software Engineering Radio;software engineering;software development","Servers;Software engineering;Automation;Software testing;Computer security","","","","2","","","","16 Jan 2017","","","IEEE","IEEE Magazines"
"Jay Fields on Working with Unit Tests","S. Tilkov",innoQ,"IEEE Software","24 Aug 2016","2016","33","5","117","120","Host Stefan Tilkov explores issues surrounding unit testing with software engineer Jay Fields, author of Working Effectively with Unit Tests.","1937-4194","","10.1109/MS.2016.121","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7548912","Software Engineering Radio;unit tests;software engineering;Jay Fields;software testing;software development","Testing;Writing;Databases;Software engineering;Navigation;Interviews;Production","","","","1","","","","24 Aug 2016","","","IEEE","IEEE Magazines"
"Software Engineering for Big Data Systems","I. Gorton; A. B. Bener; A. Mockus","Northeastern University; Ryerson University; University of Tennessee, Knoxville","IEEE Software","26 Feb 2016","2016","33","2","32","35","Software engineering for big data systems is complex and faces challenges including pervasive distribution, write-heavy workloads, variable request loads, computation-intensive analytics, and high availability. The articles in this theme issue examine several facets of this complicated puzzle. The Web extra at https://youtu.be/YKBGf9EOBUo is an audio recording of Davide Falessi speaking with Ayse Basar Bener and Audris Mockus about the authors, articles, and discussions that went into the IEEE Software March/April 2016 theme issue on software engineering for big data systems.","1937-4194","","10.1109/MS.2016.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7420514","strategic prototyping;online video processing;operational-log analysis;data analytics;big data;software engineering;software development","","","","","15","","5","","26 Feb 2016","","","IEEE","IEEE Magazines"
"How Important Is Evidence, Really?","H. Erdogmus",Kalemun Research,"IEEE Software","19 Apr 2010","2010","27","3","2","5","The utility of evidence in the adoption of software engineering ideas depends on several factors. The type of evidence, the adoption context, the attitudes of decision makers, and the size of the idea and its bundle all play a role in the adoption decision. Feasibility check might suffice for small, viral ideas, whereas systematic evidence might be warranted for medium-scale ideas considered for limited-scale but rapid adoption.","1937-4194","","10.1109/MS.2010.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452140","software engineering;empirical software engineering;evidence-based software engineering","Software engineering","","","","5","","18","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Josh Doody on Salary Negotiation for Software Engineers","M. Blankenship",NA,"IEEE Software","28 Mar 2017","2017","34","2","117","120","Host Marcus Blankenship talks about the importance of salary negotiation for software engineers with Josh Doody, author of Fearless Salary Negotiation.","1937-4194","","10.1109/MS.2017.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7888381","Josh Doody;software engineering;salary negotiation;SE Radio;software development","Remuneration;Companies;Software engineering;Software;Interviews;Digital audio broadcasting;Blogs","","","","","","","","28 Mar 2017","","","IEEE","IEEE Magazines"
"The Future of Software Engineering","",,"IEEE Software","21 Aug 2015","2015","32","5","c2","c2","Describes the above-named upcoming special issue or section. May include topics to be covered or calls for papers.","1937-4194","","10.1109/MS.2015.123","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7217778","","","","","","","","","","21 Aug 2015","","","IEEE","IEEE Magazines"
"International Conference on Software Engineering","",,"IEEE Software","22 Sep 2017","2017","34","5","c3","c3","Describes the above-named upcoming conference event. May include topics to be covered or calls for papers.","1937-4194","","10.1109/MS.2017.3571566","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048632","","","","","","","","","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Software Engineering for the 21st Century [Advertisement]","",,"IEEE Software","21 Apr 2014","2014","31","3","c2","c2","Advertisement.","1937-4194","","10.1109/MS.2014.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6802983","","","","","","","","","","21 Apr 2014","","","IEEE","IEEE Magazines"
"40th International Conference on Software Engineering","",,"IEEE Software","11 Jul 2017","2017","34","4","c2","c2","Describes the above-named upcoming conference event. May include topics to be covered or calls for papers.","1937-4194","","10.1109/MS.2017.106","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974704","","","","","","","","","","11 Jul 2017","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction to the Special Section on Exception Handling: From Requirements to Software Maintenance","A. Garcia; A. Romanovsky; V. Issarny",NA; NA; NA,"IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","147","149","The four papers in this special section focus on topics related to exception handling.","1939-3520","","10.1109/TSE.2010.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5439569","","Software maintenance;Application software;Software systems;Computer languages;Programming;Software quality;Software engineering;Protection;Pressing;Reflection","","","","","","70","","29 Mar 2010","","","IEEE","IEEE Journals"
"The Software Architect's Role in the Digital Age","G. Hohpe; I. Ozkaya; U. Zdun; O. Zimmermann","Allianz SE; Carnegie Mellon Software Engineering Institute; University of Vienna; University of Applied Sciences of Eastern Switzerland, Rapperswil","IEEE Software","28 Oct 2016","2016","33","6","30","39","Internet scale, the increasing rate of technology evolution, and the broad adoption of lean and agile methods have triggered a profound change in not only application and infrastructure architectures but also the software architect's roles and responsibilities. This article reviews the field's state of the art, identifies the skills of the connected architect, and gives an overview of related education programs and knowledge sources.","1937-4194","","10.1109/MS.2016.137","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7725214","software architect;software architecture;software development;software engineering;software engineering education;architecture as a service;connected vehicles;Ericsson;embedded software;decision making","","","","","13","","21","","28 Oct 2016","","","IEEE","IEEE Magazines"
"2011 Reviewers List","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","236","238","Lists the reviewers who contributed to IEEE Transactions on Software Engineering in 2011.","1939-3520","","10.1109/TSE.2012.3","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141072","","IEEE publishing","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"2010 Reviewers List","",,"IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","142","144","Lists the reviewers who contributed to IEEE Transactions on Software Engineering in 2010.","1939-3520","","10.1109/TSE.2011.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704238","","IEEE publishing","","","","","","","","28 Jan 2011","","","IEEE","IEEE Journals"
"2008 Reviewers List","",,"IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","138","141","Lists the reviewers who contributed to the IEEE Transactions on Software Engineering from 09 January 2008 through 13 January 2009.","1939-3520","","10.1109/TSE.2009.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4771849","","IEEE","","","","","","","","2 Feb 2009","","","IEEE","IEEE Journals"
"2009 Reviewers List","",,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","141","143","Lists the reviewers who contributed to the IEEE Transactions on Software Engineering from 14 January 09 through 07 January 2010.","1939-3520","","10.1109/TSE.2010.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401366","","IEEE publications","","","","","","","","29 Jan 2010","","","IEEE","IEEE Journals"
"Toward Meaningful Industrial--Academic Partnerships","J. Cleland-Huang",DePaul University,"IEEE Software","4 Feb 2015","2015","32","1","18","21","At the Ready-Set-Transfer panel at the 2014 IEEE International Requirements Engineering Conference, researchers presented their projects to a team of industrial judges, explaining the industrial motivation and describing how they had evaluated their idea's adoption readiness. The projects included FlexiSketch, a collaborative-whiteboard sketching tool; the Collaborative Creativity Canvas, which replaces requirements negotiation with a lively cocreation process; and Archie, which detects and visualizes architectural decisions in code. The Web extra at http://youtu.be/6RNYVVWrJAQ is an audio podcast in which author Jane Cleland-Huang provides an audio recording of the Requirements column,in which she discusses the Ready-Set-Transfer panel at the 2014 IEEE International Requirements Engineering Conference.","1937-4194","","10.1109/MS.2015.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7030230","technology transfer;requirements engineering;software engineering;Ready-Set-Transfer;FlexiSketch;Collaborative Creativity Canvas;Archie","Technology transfer;Requirements engineering;Software engineering;Interviews","","","","1","","4","","4 Feb 2015","","","IEEE","IEEE Magazines"
"Front Cover","",,"IEEE Software","25 Aug 2009","2009","26","5","c1","c1","September/October 2009 IEEE Software: End-User Software Engineering","1937-4194","","10.1109/MS.2009.128","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222780","IEEE Software;End-User Software Engineering","","","","","","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Front Cover","",,"IEEE Software","16 Oct 2009","2009","26","6","c1","c1","November/December 2009 IEEE Software: Human Aspects of Software Engineering","1937-4194","","10.1109/MS.2009.174","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5286994","IEEE Software;End-User Software Engineering","","","","","","","","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Front Cover","",,"IEEE Software","20 Apr 2012","2012","29","3","c1","c1","May/June 2012 IEEE Software: Software Engineering for Compliance","1937-4194","","10.1109/MS.2012.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188589","Software Engineering for Compliance","","","","","","","","","20 Apr 2012","","","IEEE","IEEE Magazines"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2011.114","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095281","","","","","","","","","","5 Dec 2011","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2010.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473897","","","","","","","","","","27 May 2010","","","IEEE","IEEE Journals"
"TSE information for authors [inside back cover]","",,"IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2012.59","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311393","","","","","","","","","","24 Sep 2012","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2011.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5779014","","","","","","","","","","27 May 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2012.24","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6173079","","","","","","","","","","3 Apr 2012","","","IEEE","IEEE Journals"
"7 Great Reasons for Joining the IEEE Computer Society [advertisement]","",,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","144","144","Advertisement: 7 Great Reasons for Joining the IEEE Computer Society.","1939-3520","","10.1109/TSE.2010.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401367","","","","","","","","","","29 Jan 2010","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2009.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353436","","","","","","","","","","15 Dec 2009","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2010.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5439566","","","","","","","","","","29 Mar 2010","","","IEEE","IEEE Journals"
"Call for Papers for New IEEE Transactions on Affective Computing","",,"IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","879","879","The new IEEE Transactions on Affective Computing seeks original manuscripts for publication. This new online only journal will publish cross disciplinary and international archival results of research on the design of systems that can recognize, interpret, and simulate human emotions and related affective phenomena. The journal will publish original research on the principles and theories explaining why and how affective factors condition interaction between humans and technology, on how affective sensing and simulation techniques can inform our understanding of human affective processes, and on the design, implementation and evaluation of systems that carefully consider affect among the factors that influence their usability. Surveys of existing work will be considered for publication when they propose a new viewpoint on the history and the perspective on this domain.","1939-3520","","10.1109/TSE.2009.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353440","","","","","","","","","","15 Dec 2009","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2010.42","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5439570","","","","","","","","","","29 Mar 2010","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2010.55","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473902","","","","","","","","","","27 May 2010","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2010.85","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5593043","","","","","","","","","","30 Sep 2010","","","IEEE","IEEE Journals"
"[Table of contents - Front cover]","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2012.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141068","","","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"[Inside back cover]","",,"IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2011.115","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095285","","","","","","","","","","5 Dec 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2010.19","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401369","","","","","","","","","","29 Jan 2010","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2009.76","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353442","","","","","","","","","","15 Dec 2009","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2011.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5779018","","","","","","","","","","27 May 2011","","","IEEE","IEEE Journals"
"2013 Reviewers List","",,"IEEE Transactions on Software Engineering","4 Mar 2014","2014","40","1","103","106","The publication offers a note of thanks and lists its reviewers. Reviewers' comments are an essential part of the process of creating a well written article capable of expressing theoretical content well with effective illustrations, tables and graphs.","1939-3520","","10.1109/TSE.2014.2298173","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6755631","","IEEE publishing","","","","","","","","4 Mar 2014","","","IEEE","IEEE Journals"
"Introduction to OnlinePlus Video [advertisement]","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","239","239","Advertisement: Now available: A video introducing the IEEE Computer Society's new OnlinePius publication model for Transactions. Viewers will see an overview of the great features and benefits included with an OnlinePlus subscription and will take a tour of the user-friendly interface included on the accompanying disc. Go to www.computer.org/onlineplus to view the video and learn all about it today.","1939-3520","","10.1109/TSE.2012.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141074","","","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"[Front inside cover]","",,"IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","c2","c2","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2012.78","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363458","","","","","","","","","","29 Nov 2012","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2010.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5593047","","","","","","","","","","30 Sep 2010","","","IEEE","IEEE Journals"
"[Cover3]","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2012.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141076","","","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2011.30","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5739155","","","","","","","","","","24 Mar 2011","","","IEEE","IEEE Journals"
"2015 reviewers list","",,"IEEE Transactions on Software Engineering","7 Jan 2016","2016","42","1","100","102","The conference offers a note of thanks and lists its reviewers.","1939-3520","","10.1109/TSE.2015.2507218","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7374786","","IEEE publishing","","","","","","","","7 Jan 2016","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2009.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5275151","","","","","","","","","","2 Oct 2009","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2009.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5186359","","","","","","","","","","31 Jul 2009","","","IEEE","IEEE Journals"
"Call for Papers for Special Issue on Software Services and Service-Based Systems","",,"IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","592","592","Prospective authors are requested to submit new, unpublished manuscripts for inclusion in the upcoming event described in this call for papers.","1939-3520","","10.1109/TSE.2009.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5186363","","","","","","","","","","31 Jul 2009","","","IEEE","IEEE Journals"
"[Inside back cover]","",,"IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2012.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6205671","","","","","","","","","","29 May 2012","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2011.72","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5966993","","","","","","","","","","28 Jul 2011","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2009.63","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5275153","","","","","","","","","","2 Oct 2009","","","IEEE","IEEE Journals"
"[Table of contents - Front cover]","",,"IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","c1","c1","Presents the cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2012.57","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311484","","","","","","","","","","24 Sep 2012","","","IEEE","IEEE Journals"
"[Inside back cover]","",,"IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2012.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6249693","","","","","","","","","","26 Jul 2012","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2009.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5186365","","","","","","","","","","31 Jul 2009","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2011.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704234","","","","","","","","","","28 Jan 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2011.33","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5739159","","","","","","","","","","24 Mar 2011","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2012.35","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6205669","","","","","","","","","","29 May 2012","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2010.72","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5532336","","","","","","","","","","29 Jul 2010","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2011.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5966995","","","","","","","","","","28 Jul 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2010.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5532340","","","","","","","","","","29 Jul 2010","","","IEEE","IEEE Journals"
"New Transactions Newsletter [advertisement]","",,"IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","992","992","Advertisement: Stay connected with the IEEE Computer Society Transactions by signing up for our new Transactions Connection newsletter. It is free and contains valuable information.","1939-3520","","10.1109/TSE.2012.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6249695","","","","","","","","","","26 Jul 2012","","","IEEE","IEEE Journals"
"2012 Reviewers List","",,"IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","141","144","The publication offers a note of thanks and lists its reviewers.","1939-3520","","10.1109/TSE.2013.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6397559","","IEEE publishing","","","","","","","","28 Dec 2012","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2011.15","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704240","","","","","","","","","","28 Jan 2011","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2010.100","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5644732","","","","","","","","","","29 Nov 2010","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2011.97","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6030115","","","","","","","","","","29 Sep 2011","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2009.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4771847","","","","","","","","","","2 Feb 2009","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2009.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4771851","","","","","","","","","","2 Feb 2009","","","IEEE","IEEE Journals"
"2016 Reviewers List*","",,"IEEE Transactions on Software Engineering","9 Jan 2017","2017","43","1","100","103","The publication offers a note of thanks and lists its reviewers.","1939-3520","","10.1109/TSE.2016.2636498","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7809238","","IEEE publishing","","","","","","","","9 Jan 2017","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2009.39","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5061641","","","","","","","","","","2 Jun 2009","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2010.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401362","","","","","","","","","","29 Jan 2010","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2011.98","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6030117","","","","","","","","","","29 Sep 2011","","","IEEE","IEEE Journals"
"[Cover2]","",,"IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","c2","c2","Provides a listing of current society officers.","1939-3520","","10.1109/TSE.2012.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6173076","","","","","","","","","","3 Apr 2012","","","IEEE","IEEE Journals"
"IEEE Computer Society CSDP [advertisement]","",,"IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","878","878","Advertisement: The IEEE Computer Society Certified Software Development Professional (CSDP) credential.","1939-3520","","10.1109/TSE.2010.105","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5644736","","","","","","","","","","29 Nov 2010","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2009.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5061639","","","","","","","","","","2 Jun 2009","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2011.113","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095280","","","","","","","","","","5 Dec 2011","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","c2","c2","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2012.58","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311392","","","","","","","","","","24 Sep 2012","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","c1","c1","Presents the table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2009.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4809709","","","","","","","","","","3 Apr 2009","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2009.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4809713","","","","","","","","","","3 Apr 2009","","","IEEE","IEEE Journals"
"[Inside back cover]","",,"IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2012.23","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6173078","","","","","","","","","","3 Apr 2012","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2010.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5644738","","","","","","","","","","29 Nov 2010","","","IEEE","IEEE Journals"
"IEEE Computer Society Magazines and Transactions available in ePUB format [advertisement]","",,"IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","878","878","Advertisement: IEEE Computer Society Magazines and Transactions in ePUB format.","1939-3520","","10.1109/TSE.2011.117","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095282","","","","","","","","","","5 Dec 2011","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2010.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473898","","","","","","","","","","27 May 2010","","","IEEE","IEEE Journals"
"IEEE Computer Society [Back cover]","",,"IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2012.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311394","","","","","","","","","","24 Sep 2012","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2011.49","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5779015","","","","","","","","","","27 May 2011","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","27 May 2010","2010","36","3","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2010.54","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5473901","","","","","","","","","","27 May 2010","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2010.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5593042","","","","","","","","","","30 Sep 2010","","","IEEE","IEEE Journals"
"What's new in Transactions [advertisement]","",,"IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","880","880","Advertisement: IEEE periodicals.","1939-3520","","10.1109/TSE.2011.119","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095284","","","","","","","","","","5 Dec 2011","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2010.18","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401368","","","","","","","","","","29 Jan 2010","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2009.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353437","","","","","","","","","","15 Dec 2009","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2010.41","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5439567","","","","","","","","","","29 Mar 2010","","","IEEE","IEEE Journals"
"7 Great Reasons for Joining the IEEE Computer Society [advertisement]","",,"IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","880","880","Advertisement: 7 Great Reasons for Joining the IEEE Computer Society.","1939-3520","","10.1109/TSE.2009.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353441","","","","","","","","","","15 Dec 2009","","","IEEE","IEEE Journals"
"IEEE Open Access Publishing [advertisement]","",,"IEEE Transactions on Software Engineering","24 Sep 2012","2012","38","5","1232","1232","Advertisement: What does IEEE Open Access mean to an author? Top quality publishing with established impact factors; Increased exposure and recognition as a thought leader; A consistent IEEE peer-review standard of excellence; Unrestricted access for readers to discover your publications; and Great way to fulfill a requirement to publish open access.","1939-3520","","10.1109/TSE.2012.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6311396","","","","","","","","","","24 Sep 2012","","","IEEE","IEEE Journals"
"Distinguish yourself with the CSDP [advertisement]","",,"IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","448","448","Advertisement: The IEEE Computer Society Certified Software Development Professional (CSDP) credential.","1939-3520","","10.1109/TSE.2011.52","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5779017","","","","","","","","","","27 May 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2010.43","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5439571","","","","","","","","","","29 Mar 2010","","","IEEE","IEEE Journals"
"2011 Annual Index","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","Online Only","","This index covers all technical items - papers, correspondence, reviews, etc. - that appeared in this periodical during the year, and items from previous years that were commented upon or corrected in this year. Departments and other items may also be covered if they have been judged to have archival value. The Author Index contains the primary entry for each item, listed under the first author's name. The primary entry includes the coauthors' names, the title of the paper or other item, and its location, specified by the publication abbreviation, year, month, and inclusive pagination. The Subject Index contains entries describing the item under all appropriate subject headings, plus the first author's name, the publication abbreviation, month, and year, and inclusive pages. Note that the item title is found only under he primary entry in the Author Index.","1939-3520","","10.1109/TSE.2012.2","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141073","","Indexes","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","5 Dec 2011","2011","37","6","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2011.116","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6095286","","","","","","","","","","5 Dec 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","15 Dec 2009","2009","35","6","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2009.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5353443","","","","","","","","","","15 Dec 2009","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","27 May 2011","2011","37","3","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2011.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5779019","","","","","","","","","","27 May 2011","","","IEEE","IEEE Journals"
"[Table of contents - Front cover]","",,"IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","c1","c1","Presents the cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2012.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363457","","","","","","","","","","29 Nov 2012","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","30 Sep 2010","2010","36","5","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2010.86","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5593046","","","","","","","","","","30 Sep 2010","","","IEEE","IEEE Journals"
"What's new in Transactions [advertisement]","",,"IEEE Transactions on Software Engineering","30 Jan 2012","2012","38","1","240","240","Advertisement: Our new ""What's New in Transactions"" webpage provides an overview of our 14 peer-reviewed scholarly journals. Visit http://www.computer.org/whats-new today.","1939-3520","","10.1109/TSE.2012.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6141075","","","","","","","","","","30 Jan 2012","","","IEEE","IEEE Journals"
"2014 Reviewers List*","",,"IEEE Transactions on Software Engineering","7 Jan 2015","2015","41","1","100","103","The publication offers a note of thanks and lists its reviewers.","1939-3520","","10.1109/TSE.2014.2376651","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7004099","","IEEE publishing","","","","","","","","7 Jan 2015","","","IEEE","IEEE Journals"
"[Back inside cover]","",,"IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2012.79","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363459","","","","","","","","","","29 Nov 2012","","","IEEE","IEEE Journals"
"OnlinePlus Coming Soon to TSE [advertisement]","",,"IEEE Transactions on Software Engineering","29 Nov 2012","2012","38","6","1488","1488","Advertisement: Recognizing the need for quicker access to research, TSE will transition to the new OnlinePlus publication model beginning in 2013.","1939-3520","","10.1109/TSE.2012.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6363463","","","","","","","","","","29 Nov 2012","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2009.45","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5186360","","","","","","","","","","31 Jul 2009","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2009.61","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5275150","","","","","","","","","","2 Oct 2009","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2011.31","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5739156","","","","","","","","","","24 Mar 2011","","","IEEE","IEEE Journals"
"IEEE Computer Society OnlinePlus Coming Soon to TSE","",,"IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","736","736","Advertisement: Recognizing the need for quicker access to research, TSE will transition to the new OnlinePlus publication model beginning in 2013.","1939-3520","","10.1109/TSE.2012.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6205670","","","","","","","","","","29 May 2012","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2011.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5966992","","","","","","","","","","28 Jul 2011","","","IEEE","IEEE Journals"
"Call for Papers: Special Issue on Software Services and Service-Based Systems","",,"IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","736","736","Prospective authors are requested to submit new, unpublished manuscripts for inclusion in the upcoming event described in this call for papers.","1939-3520","","10.1109/TSE.2009.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5275152","","","","","","","","","","2 Oct 2009","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","c2","c2","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2012.48","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6249692","","","","","","","","","","26 Jul 2012","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","31 Jul 2009","2009","35","4","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2009.46","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5186364","","","","","","","","","","31 Jul 2009","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","24 Mar 2011","2011","37","2","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2011.32","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5739158","","","","","","","","","","24 Mar 2011","","","IEEE","IEEE Journals"
"[Table of contents - Front cover]","",,"IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2012.34","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6205668","","","","","","","","","","29 May 2012","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2010.71","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5532335","","","","","","","","","","29 Jul 2010","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","29 May 2012","2012","38","3","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2012.37","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6205672","","","","","","","","","","29 May 2012","","","IEEE","IEEE Journals"
"Distinguish yourself with the CSDP [advertisement]","",,"IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","592","592","Advertisement: The IEEE Computer Society Certified Software Development Professional (CSDP) credential.","1939-3520","","10.1109/TSE.2011.75","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5966994","","","","","","","","","","28 Jul 2011","","","IEEE","IEEE Journals"
"[Table of contents - Front cover]","",,"IEEE Transactions on Software Engineering","27 Jul 2012","2012","38","4","c1","c1","Presents the cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2012.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6249798","","","","","","","","","","27 Jul 2012","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","2 Oct 2009","2009","35","5","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2009.64","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5275154","","","","","","","","","","2 Oct 2009","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","26 Jul 2012","2012","38","4","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2012.50","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6249694","","","","","","","","","","26 Jul 2012","","","IEEE","IEEE Journals"
"2012 Annual Index","",,"IEEE Transactions on Software Engineering","28 Dec 2012","2013","39","1","Online-only content","","This index covers all technical items - papers, correspondence, reviews, etc. - that appeared in this periodical during the year, and items from previous years that were commented upon or corrected in this year. Departments and other items may also be covered if they have been judged to have archival value. The Author Index contains the primary entry for each item, listed under the first author's name. The primary entry includes the co-authors' names, the title of the paper or other item, and its location, specified by the publication abbreviation, year, month, and inclusive pagination. The Subject Index contains entries describing the item under all appropriate subject headings, plus the first author's name, the publication abbreviation, month, and year, and inclusive pages. Note that the item title is found only under the primary entry in the Author Index.","1939-3520","","10.1109/TSE.2013.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6397558","","Indexes","","","","","","","","28 Dec 2012","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2011.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704235","","","","","","","","","","28 Jan 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","28 Jul 2011","2011","37","4","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2011.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5966996","","","","","","","","","","28 Jul 2011","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2011.16","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704241","","","","","","","","","","28 Jan 2011","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2011.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6030114","","","","","","","","","","29 Sep 2011","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","29 Jul 2010","2010","36","4","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2010.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5532339","","","","","","","","","","29 Jul 2010","","","IEEE","IEEE Journals"
"[Front cover]","",,"IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","c1","c1","Presents the table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2009.7","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4771846","","","","","","","","","","2 Feb 2009","","","IEEE","IEEE Journals"
"IEEE Computer Society 2009 Membership Application","",,"IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","142","144","Advertisement: IEEE Computer Society 2009 Membership Application.","1939-3520","","10.1109/TSE.2009.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4771850","","","","","","","","","","2 Feb 2009","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2010.101","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5644733","","","","","","","","","","29 Nov 2010","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2009.38","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5061640","","","","","","","","","","2 Jun 2009","","","IEEE","IEEE Journals"
"2010 Annual Index","",,"IEEE Transactions on Software Engineering","28 Jan 2011","2011","37","1","Online-only content","","This index covers all technical items - papers, correspondence, reviews, etc. - that appeared in this periodical during the year, and items from previous years that were commented upon or corrected in this year. Departments and other items may also be covered if they have been judged to have archival value. The Author Index contains the primary entry for each item, listed under the first author's name. The primary entry includes the coauthors' names, the title of the paper or other item, and its location, specified by the publication abbreviation, year, month, and inclusive pagination. The Subject Index contains entries describing the item under all appropriate subject headings, plus the first author's name, the publication abbreviation, month, and year, and inclusive pages. Note that the item title is found only under the primary entry in the Author Index.","1939-3520","","10.1109/TSE.2011.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5704239","","","","","","","","","","28 Jan 2011","","","IEEE","IEEE Journals"
"IEEE Computer Society Magazines and Transactions available in ePUB format [advertisement]","",,"IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","736","736","Advertisement: IEEE Computer Society Magazines and Transactions in ePUB format.","1939-3520","","10.1109/TSE.2011.100","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6030116","","","","","","","","","","29 Sep 2011","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2009.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4809710","","","","","","","","","","3 Apr 2009","","","IEEE","IEEE Journals"
"[Table of contents - Front cover]","",,"IEEE Transactions on Software Engineering","3 Apr 2012","2012","38","2","c1","c1","Presents the front cover/table of contents for this issue of the periodical.","1939-3520","","10.1109/TSE.2012.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6173075","","","","","","","","","","3 Apr 2012","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","2 Feb 2009","2009","35","1","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2009.10","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4771852","","","","","","","","","","2 Feb 2009","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","2 Jun 2009","2009","35","3","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2009.40","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5061642","","","","","","","","","","2 Jun 2009","","","IEEE","IEEE Journals"
"[Inside front cover]","",,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","c2","c2","Provides a listing of current committee members and society officers.","1939-3520","","10.1109/TSE.2010.17","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401363","","","","","","","","","","29 Jan 2010","","","IEEE","IEEE Journals"
"[Back cover]","",,"IEEE Transactions on Software Engineering","29 Sep 2011","2011","37","5","c4","c4","Provides a listing of current staff, committee members and society officers.","1939-3520","","10.1109/TSE.2011.99","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6030118","","","","","","","","","","29 Sep 2011","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","3 Apr 2009","2009","35","2","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2009.22","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4809712","","","","","","","","","","3 Apr 2009","","","IEEE","IEEE Journals"
"TSE Information for authors","",,"IEEE Transactions on Software Engineering","29 Nov 2010","2010","36","6","c3","c3","Provides instructions and guidelines to prospective authors who wish to submit manuscripts.","1939-3520","","10.1109/TSE.2010.102","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5644737","","","","","","","","","","29 Nov 2010","","","IEEE","IEEE Journals"
"In Memoriam - David Notkin (1953-2013)","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","23 May 2013","2013","39","6","742","743","David Samuel Notkin, whose technical, educational, and social contributions to computer science and software engineering research made him a major figure in the field, died on 22 April 2013, at his home in Seattle, Washington. He was 58 years old. The cause of his death was cancer. David is best known for his research, with his many graduate students, on software evolution. He asked why software is often so hard and expensive to change, and he worked to reduce the difficulty of software evolution to an essential minimum. This focus came from his belief that the ability to change software - its softness - is where its true but under-realized potential resides. He asked questions such as whether we can identify and close the gap between Brooks' notions of accidental and essential software complexity? How much should rather than does it cost to develop, test, and evolve software? Can we make the cost of change proportionate rather than disproportionate to the apparent complexity of changes to be made? Can we design software analysis methods that realize the best properties of both static and dynamic analysis techniques? Beyond technical contributions, David is widely recognized and admired for his exceptional skill as a research mentor for graduate students and as a powerful and unwavering advocate for improving gender diversity in computer science. A brief biography is given highlighting Notkin's professional achievements.","1939-3520","","10.1109/TSE.2013.25","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6519247","","Obituaries;Notkin, David","","","","","","","","23 May 2013","","","IEEE","IEEE Journals"
"Front Cover","",,"IEEE Software","11 Jul 2017","2017","34","4","c1","c1","The theme articles in this issue address reliability engineering. Other topics in the issue include agile development, requirements engineering, and technical debt.","1937-4194","","10.1109/MS.2017.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7974714","IEEE Software;July/Aug. 2017;reliability engineering;agile development;requirements engineering;technical debt;software engineering;software development","","","","","","","","","11 Jul 2017","","","IEEE","IEEE Magazines"
"An Interview with Gilad Bracha","L. Tratt; A. Welc",King's College London; Oracle Labs,"IEEE Software","15 Sep 2014","2014","31","5","76","79","The guest editors of IEEE Software's special issue on programming languages recently met with Gilad Bracha to talk about his experiences in the field.","1937-4194","","10.1109/MS.2014.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898742","software engineering;programming languages","Programming;Software;Security;Java;Interviews;Educational institutions","","","","","","","","15 Sep 2014","","","IEEE","IEEE Magazines"
"2015 Reviewers","",,"IEEE Software","29 Dec 2015","2016","33","1","6","8","The articles in IEEE Software are the result of hard work by many people. We deeply appreciate the efforts of everyone who reviewed the many articles submitted to Software last year. The peer review process helps maintain the magazine's revered quality. All of us in the software development community owe gratitude to people who participate in this crucial service.","1937-4194","","10.1109/MS.2016.4","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7368003","IEEE Software;peer review;reviewers;software engineering;software development","IEEE publishing","","","","","","","","29 Dec 2015","","","IEEE","IEEE Magazines"
"2009 Reviewers","",,"IEEE Software","31 Dec 2009","2010","27","1","92","94","The editorial board and staff of IEEE Software thanks the 337 reviewers who contributed to the continuous excellence of the magazine in 2009 through the peer review process.","1937-4194","","10.1109/MS.2010.1","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5370766","peer review;reviewers;software;software engineering","IEEE publications","","","","","","","","31 Dec 2009","","","IEEE","IEEE Magazines"
"Front Cover","",,"IEEE Software","22 Sep 2017","2017","34","5","c1","c1","Presents the front cover for this issue of the publication.","1937-4194","","10.1109/MS.2017.3571579","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8048654","IEEE Software;Sept./Oct. 2017;software testing;DevOps;DevSecOps;gamification;requirements;software engineering;software development","","","","","","","","","22 Sep 2017","","","IEEE","IEEE Magazines"
"Front Cover","",,"IEEE Software","15 May 2017","2017","34","3","c1","c1","The theme articles in this issue address automotive IT and software development. Other topics in the issue include software for inland shipping, software startups, and energy-aware software.","1937-4194","","10.1109/MS.2017.73","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7927927","IEEE Software;May/June 2017;automotive software;software engineering;software development;inland shipping;software startups;energy-aware software","","","","","","","","","15 May 2017","","","IEEE","IEEE Magazines"
"Table of Contents","",,"IEEE Software","20 Apr 2012","2012","29","3","1","2","IEEE Software May/June 2012 Table of Contents","1937-4194","","10.1109/MS.2012.67","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6188591","IEEE Software;software engineering for compliance","","","","","","","","","20 Apr 2012","","","IEEE","IEEE Magazines"
"Table of Contents","",,"IEEE Software","18 Aug 2011","2011","28","5","2","3","IEEE Software September/October Table of Contents","1937-4194","","10.1109/MS.2011.109","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984785","IEEE Software;Engineering Fun","","","","","","","","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Certified Software Architects","P. Clements",Carnegie Mellon University,"IEEE Software","14 Oct 2010","2010","27","6","6","8","Are software architecture certifications worthwhile? At a recent Software Engineering Institute architecture conference, certification programs from Boeing, Raytheon, Siemens, the International Association of Software Architects, and the SEI were presented and compared. This article captures the comparison, and offers some advice about engaging in certification activities and (if you're an organizational manager) setting up your own program.","1937-4194","","10.1109/MS.2010.137","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5604355","software architecture;software architect;architecture certification;software architecture training;software engineering","Software architecture;Certification;Training;Career development","","","","1","","","","14 Oct 2010","","","IEEE","IEEE Magazines"
"Editorial: A New Decade of TSE","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","3","6","","1939-3520","","10.1109/TSE.2010.20","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401365","","","","","","1","","1","","29 Jan 2010","","","IEEE","IEEE Journals"
"Editorial: Readers, Writers, Reviewers, and Editors","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","29 Mar 2010","2010","36","2","145","156","","1939-3520","","10.1109/TSE.2010.44","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5439568","","","","","","1","","","","29 Mar 2010","","","IEEE","IEEE Journals"
"In Memoriam: Mary Jean Harrold (1947-2013)","B. Nuseibeh",NA,"IEEE Transactions on Software Engineering","28 Oct 2013","2013","39","11","1466","1466","Recounts the career and contributions of Mary Jean Harrold.","1939-3520","","10.1109/TSE.2013.51","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6648565","","Obituaries;Harrold,  Mary Jean","","","","","","","","28 Oct 2013","","","IEEE","IEEE Journals"
"Editorial: A New Editor in Chief and the State of the Journal","J. Kramer",NA,"IEEE Transactions on Software Engineering","29 Jan 2010","2010","36","1","1","2","","1939-3520","","10.1109/TSE.2010.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5401364","","","","","","","","","","29 Jan 2010","","","IEEE","IEEE Journals"
"Watts Humphrey: 4 July 1927 - 28 October 2010","F. Shull",Fraunhofer Center for Experimental Software Engineering,"IEEE Software","20 Dec 2010","2011","28","1","5","5","Watts Humphrey, one of the true pioneers of the software engineering discipline, passed away this past October. Watts Humphrey had a truly remarkable career, during which he developed or contributed to the Personal Software Process, Team Software Process, and Capability Maturity Model Integration (CMMI) framework, among many other contributions. Many colleagues (including IEEE Software board members and authors) who knew Watts have documented some of their memories here and on our website (www.computer.org/software/watts). Readers are invited to reminisce with them and contribute your own thoughts on the website.","1937-4194","","10.1109/MS.2011.21","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5672511","software engineeringWatts Humphreyhistory of computingsoftware development processPersonal Software ProcessTeam Software ProcessCapability Maturity Model IntegrationCMMI","Obituaries;Humphrey, Watts","","","","","","","","20 Dec 2010","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Software as a Business","J. Favaro; S. L. Pfleeger",Intecs; Dartmouth University,"IEEE Software","23 Jun 2011","2011","28","4","22","25","Software plays an increasingly important role in most aspects of business. Many new business models for software-intensive enterprises have arisen in the last decade, ranging from selling software as a service to off shoring and crowd sourcing. Governments and standards bodies have also intervened to influence business models for stimulating growth in the industry. The software business has also had ancillary effects including the creation of new sectors such as innovation management. The management of intellectual property rights has become a more critical issue as software is embedded in more and more products. The debate about whether the software business is fundamentally different from others will continue, even as the software business continues to transform itself.","1937-4194","","10.1109/MS.2011.77","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5929525","software;business model;open source;service;embedded systems","Special issues and sections;Software;Business;Marketing and sales;Strategic planning;Enterprise resource planning;Modeling;Product development;Productivity","business data processing;cloud computing;industrial property;innovation management;software engineering","software business;business model;software intensive enterprise;innovation management;intellectual property right;software as a service","","1","","5","","23 Jun 2011","","","IEEE","IEEE Magazines"
"Programming Languages","L. Tratt; A. Welc",King's College London; Oracle Labs,"IEEE Software","15 Sep 2014","2014","31","5","33","34","The guest editors of IEEE Software magazine's September/October issue describe the field of programming languages and why they selected the articles highlighted here. The Web extra at http://youtu.be/SmIc0Chc9Y0 is an audio recording in which author IEEE Software Multimedia Editor Davide Falessi interviews Laurence Tratt and Adam Welc, guest editors of IEEE Software magazine's September/October 2014 issue, about the field of programming languages.","1937-4194","","10.1109/MS.2014.119","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6898781","programming languages;software engineering","","","","","","","","","15 Sep 2014","","","IEEE","IEEE Magazines"
"John D. Musa","W. Everett; J. Cusick; L. Williams",SPRE (Software Process and Reliability Engineering); Walters Kluwer; North Carolina State University,"IEEE Software","25 Aug 2009","2009","26","5","102","102","This article looks back at the life of John Musa, known for his work in software reliability engineering.","1937-4194","","10.1109/MS.2009.132","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222805","John Musa;software engineering;software reliability engineering;software reliability","Software reliability;Reliability engineering","","","","","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"DevOps and Its Practices","L. Zhu; L. Bass; G. Champlin-Scharff",Data61 | CSIRO; Professional Education Consortium; IBM,"IEEE Software","25 Apr 2016","2016","33","3","32","34","DevOps aims to reduce the time between committing a system change and placing the change into normal production, while ensuring high quality. The article topics in this theme issue include using DevOps to migrate to microservices, adopting DevOps, and DevOps tools. The Web extra at https://youtu.be/NzX6JmwDS0s is an audio recording of Davide Falessi speaking with Len Bass and George Champlin-Scharff about the IEEE Software May/June 2016 theme issue on DevOps and its practices.","1937-4194","","10.1109/MS.2016.81","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7458765","DevOps;microservices;continuous deployment;continuous delivery;software development;software engineering","","","","","40","","4","","25 Apr 2016","","","IEEE","IEEE Magazines"
"The Reflective Software Engineer: Reflective Practice","T. Dybå; N. Maiden; R. Glass",SINTEF; City University London; Computing Trends,"IEEE Software","13 Jun 2014","2014","31","4","32","36","The capacity to reflect on past practice is important for continuous learning in software development. Reflection often takes place in cycles of experience followed by conscious application of learning from that experience, during which a software developer might explore comparisons, ponder alternatives, take diverse perspectives, and draw inferences, especially in new and/or complex situations. Such reflective practice has been shown in different disciplines to be an effective developmental practice for organizations, for teams, and for individuals. The guest editors of this special issue on reflection describe the concept in general and the selected articles in particular.","1937-4194","","10.1109/MS.2014.97","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6834681","reflection;software development;software engineering;practitioners","","","","","11","","12","","13 Jun 2014","","","IEEE","IEEE Magazines"
"Tracking Progress through Earned Value","H. Erdogmus",Kalemun Research,"IEEE Software","19 Aug 2010","2010","27","5","2","7","Considered a gross misnomer by some, earned value for progress tracking in software development projects is still little known in the software industry. But the concept shouldn't be so unfamiliar: tracking progress by earned value is similar to tracking progress through burndown charts-the ubiquitous, simple and powerful visuals that are so popular in agile software development. The two techniques, although developed independently in very different contexts, are similar in terms of their information content. This isn't a new discovery: Alistair Cockburn talked about the relationship between earned value and burndown charts as early as 2004 in Chapter 3 of his book Crystal Clear (Addison-Wesley, 2004). Section 7.3 of Gngori Melnik's and Gerard Meszaros' volume 1 of Acceptance Test Engineering Guide also discusses the same relationship.","1937-4194","","10.1109/MS.2010.130","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5551010","software engineering;project management;performance measurement;earned value;earned value management;burndown charts;schedule variance;cost variance","","DP industry;project management;software development management;software prototyping","progress tracking;software development projects;software industry;agile software development;burndown charts;earned value","","","","","","19 Aug 2010","","","IEEE","IEEE Magazines"
"Modeling and Managing Context-Aware Systems’ Variability","K. Mens; R. Capilla; H. Hartmann; T. Kropf",Université catholique de Louvain; Rey Juan Carlos University; NXP Semiconductors; Robert Bosch GmbH,"IEEE Software","13 Nov 2017","2017","34","6","58","63","This theme issue provides an updated perspective on techniques to manage software system variability at runtime, to make software systems smarter and less dependent on human intervention.","1937-4194","","10.1109/MS.2017.4121225","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8106877","context awareness;context-aware systems;system variability;runtime variability;connected cars;context analysis;context-oriented programming;feature-oriented programming;object-oriented systems;software engineering;software development;contextual-variability modeling","","","","","2","","16","","13 Nov 2017","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Successful Software Product Line Practices","J. D. McGregor; D. Muthig; K. Yoshimura; P. Jensen",Clemson University; Lufthansa Systems; Hitachi; OverWatch Textron,"IEEE Software","19 Apr 2010","2010","27","3","16","21","A software product line is a set of software-intensive systems sharing a common, managed set of features that satisfy the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way in place. Organizations adopting product development strategies that include a software product line have achieved impressive results, reducing product cycle time and increasing productivity by an order of magnitude. The software product line strategy is a blend of business and technical actions that lets an organization satisfy a wide range of customers, gain leverage with suppliers, meet the threats of substitute products, and deter other companies seeking to enter the market. The strategy is robust over a wide range of technologies, domains, and organizations of different structures, cultures, and goals. Service-oriented architectures, agile development methods, and open source business models have all played roles in successful product line organizations.","1937-4194","","10.1109/MS.2010.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5452144","software architecture;software product lines;software engineering","Asset management;Software development management;Product development;Productivity;Companies;Robustness;Service oriented architecture","business data processing;product development;software architecture;software reusability","software product line strategy;software-intensive systems;market segment;product development strategies;product cycle time reduction;service-oriented architectures;agile development methods;open source business models","","22","","18","","19 Apr 2010","","","IEEE","IEEE Magazines"
"Agility and Architecture: Can They Coexist?","P. Abrahamsson; M. A. Babar; P. Kruchten",University of Helsinki; IT University of Copenhagen; University of British Columbia,"IEEE Software","25 Feb 2010","2010","27","2","16","22","Agile development has significantly impacted industrial software development practices. However, despite its wide popularity, there's an increasing perplexity about software architecture's role and importance in agile approaches. Advocates of architecture's vital role in achieving quality goals for large software-intensive systems doubt the scalability of any development approach that doesn't pay sufficient attention to architecture. This article talks about software architecture being relevant to the basis of aspects such as communication among team members, inputs to subsequent design decisions, documenting design assumptions, and evaluating design alternatives. In a large software organization, implementing agile approaches isn't a straightforward adoption problem. Most likely, it will take several years to shorten the feedback cycles to benefit from the adaptability and earlier value-creation opportunities. Failure is a natural part of process improvement.","1937-4194","","10.1109/MS.2010.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5420791","software architecture;agile development methods;software engineering","Computer architecture;Software architecture;Computer industry;Programming;Scalability;Feedback","software architecture;software development management","agile development;industrial software development practices;software intensive systems;software architecture;design decisions;design assumptions","","79","","32","","25 Feb 2010","","","IEEE","IEEE Magazines"
"Front Cover","",,"IEEE Software","18 Aug 2011","2011","28","5","c1","c1","September/October IEEE Software: Engineering Fun cover","1937-4194","","10.1109/MS.2011.96","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5984782","Engineering Fun;IEEE Software","","","","","","","","","18 Aug 2011","","","IEEE","IEEE Magazines"
"Table of Contents","",,"IEEE Software","16 Oct 2009","2009","26","6","2","3","November/December 2009 IEEE Software Table of Contents. Theme: Human Aspects of Software Engineering","1937-4194","","10.1109/MS.2009.189","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5286997","","","","","","","","","","16 Oct 2009","","","IEEE","IEEE Magazines"
"Software Experts Summit Advertisement","",,"IEEE Software","26 Jun 2013","2013","30","4","c4","c4","Software Experts Summit Advertisement. The first Web extra at http://youtu.be/KTUHr-1S_wo is a video preview of Software Experts Summit 2013, which wiwill focus on Smart Data Science: Harnessing Data for Intelligent Decision Making. Scheduled for 17 July at the Microsoft Campus in Redmond, Washington, speakers include James Whittaker of Microsoft, Paul Zikopoulos of IBM, Wolfram Schulte of Microsoft Research, Jeromy Carriere of Google, John Howie of Cloud Security Alliance, Ayse Bener of Ryerson University, and Forrest Shull of the Fraunhofer Center for Experimental Software Engineering.","1937-4194","","10.1109/MS.2013.87","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547635","Software Experts Summit Advertisement","","","","","","","","","26 Jun 2013","","","IEEE","IEEE Magazines"
"Table of Contents","",,"IEEE Software","25 Aug 2009","2009","26","5","c2","1","IEEE Software September/October 2009 issue on End-User Software Engineering.","1937-4194","","10.1109/MS.2009.142","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5222781","","","","","","","","","","25 Aug 2009","","","IEEE","IEEE Magazines"
"Green Software","A. B. Bener; M. Morisio; A. Miranskyy",Ryerson University; Politecnico di Torino; Ryerson University,"IEEE Software","21 Apr 2014","2014","31","3","36","39","Most studies and regulatory controls focus on hardware-related measurement, analysis, and control for energy consumption. However, all forms of hardware include significant software components. Although software systems don't consume energy directly, they affect hardware utilization, leading to indirect energy consumption. Therefore, it's important to engineer software to optimize its energy consumption. The software engineering research domain has recently been paying attention to sustainability, as the increased number of publications, empirical studies, and conferences on the topic demonstrate. The guest editors of this special issue explain the articles they selected to highlight this important research area. The Web extra at http://youtu.be/h0tQoOH9_aM is an audio interview in which IEEE Software multimedia editor Davide Falessi interviews guest editor Ayse Basar Bener about how green software can help minimize the negative effects of software products and their development.","1937-4194","","10.1109/MS.2014.62","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6802987","green software;green IT;energy efficiency;power usage;datacenter;cloud","","","","","3","","1","","21 Apr 2014","","","IEEE","IEEE Magazines"
"David Notkin: 1955-2013","",,"IEEE Software","26 Jun 2013","2013","30","4","7","7","Members of the software research community, including IEEE Software Editor in Chief Forrest Shull, IEEE Software Advisory Board Chair Emerita Frances Paulisch, IEEE Software Editor in Chief Emeritus Hakan Erdogmus, and IEEE Transactions on Software Engineering Editor in Chief Bashar Nuseibeh remember David Notkin, who recently passed away.","1937-4194","","10.1109/MS.2013.74","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6547599","David Notkin","Obituaries;Notkin, David","","","","","","","","26 Jun 2013","","","IEEE","IEEE Magazines"
"Guest Editors' Introduction: Software Architecture: Framing Stakeholders' Concerns","P. Lago; P. Avgeriou; R. Hilliard",VU University Amsterdam; University of Groningen; Freelance Software Architect,"IEEE Software","14 Oct 2010","2010","27","6","20","24","As noted earlier, some stakeholder concerns are well-served today by available architecture viewpoints, frameworks, or ADLs, while others aren't expressible with available, off-the-shelf approaches. Hence the theme of this special issue: exploring the space of architecting in the face of multiple stakeholder concerns and looking for solutions that help the architect in that space. The articles in this issue all demonstrate techniques for framing one or more stakeholder concerns. Some have confronted the topic within software architecture; others are included because they offer insights on concerns and viewpoints from other branches of software engineering.","1937-4194","","10.1109/MS.2010.142","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5604359","stakeholder concerns;architecture;framework;viewpoints;software development;software life cycle","Special issues and sections;Software development;Product life cycle management;Investments;Software architecture","","","","13","","5","","14 Oct 2010","","","IEEE","IEEE Magazines"
